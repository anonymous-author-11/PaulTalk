; ModuleID = 'C:\Users\PaulK\OneDrive\Documents\PL\PyPL\build\build\out_optimized.dbg.ll'
source_filename = "llvm-link"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "aarch64-windows-msvc"

%struct._CONTEXT = type { i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i16, i16, i16, i16, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %union.anon, [26 x %struct._M128A], i64, i64, i64, i64, i64, i64 }
%union.anon = type { %struct._XSAVE_FORMAT }
%struct._XSAVE_FORMAT = type { i16, i16, i8, i8, i16, i32, i16, i16, i32, i16, i16, i32, i32, [8 x %struct._M128A], [16 x %struct._M128A], [96 x i8] }
%struct._M128A = type { i64, i64 }

@string_string = internal constant [4 x i8] c"%s\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local local_unnamed_addr global ptr null
@always_one = linkonce thread_local local_unnamed_addr global i1 true
@current_ptr = thread_local global ptr null
@backtrace_string = constant [16 x i8] c"%i: %s - 0x%0X\0A\00"
@_parameterization_Pairi32._Bool = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_Bool, ptr null]
@_parameterization_Pairi32._i32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedi32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedi32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@tuple_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @tuple_typ]
@tuple_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@_parameterization_Bool = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 0]
@Container_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @any_typ, ptr @Container, ptr @Object]
@Iterator_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 13, i32 13]
@Iterable_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 35, i32 35]
@ConstantTimeIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @ConstantTimeIterator, ptr null]
@ConstantTimeIterator_offset_tbl = constant [8 x i32] [i32 16, i32 10, i32 0, i32 16, i32 0, i32 13, i32 10, i32 0]
@Enumeration_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @Enumeration, ptr @Object]
@Enumeration_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 0, i32 64, i32 0, i32 10, i32 64]
@Enumeration = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2805197119131967777, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumeration_hashtbl, ptr @Enumeration_offset_tbl, ptr @_data_size_Enumeration, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Enumeration_field_Enumeration_0, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_field_iterable, ptr @Enumeration_B_init_iterableIterableT, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_init_iterableIterableT, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Enumerator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @Enumerator]
@Enumerator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@MapIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@MapIterable_offset_tbl = constant [8 x i32] [i32 0, i32 65, i32 10, i32 40, i32 65, i32 0, i32 0, i32 10]
@MapIterable = constant { [3 x i64], [7 x ptr], [55 x ptr] } { [3 x i64] [i64 -7488770571603291722, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterable_hashtbl, ptr @MapIterable_offset_tbl, ptr @_data_size_MapIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [55 x ptr] [ptr @MapIterable_field_MapIterable_0, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_field_iterable, ptr @MapIterable_field_f, ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterator, ptr @Container, ptr null, ptr @Iterator, ptr null, ptr null]
@MapIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 10, i32 21, i32 0, i32 18, i32 0, i32 0]
@FilterIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @FilterIterable, ptr null, ptr @Container, ptr @Iterable, ptr null]
@FilterIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 10, i32 0, i32 64, i32 39, i32 0]
@FilterIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 8498466713076104350, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterable_hashtbl, ptr @FilterIterable_offset_tbl, ptr @_data_size_FilterIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_field_iterable, ptr @FilterIterable_field_f, ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@FilterIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @FilterIterator, ptr null]
@FilterIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@FilterIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -1221365496900303883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterator_hashtbl, ptr @FilterIterator_offset_tbl, ptr @_data_size_FilterIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_field_iterator, ptr @FilterIterator_field_f, ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_B_next_, ptr @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_next_, ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_B_next_, ptr @FilterIterator_next_] }
@ChainIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ChainIterable, ptr @Container, ptr null, ptr null, ptr @Object]
@ChainIterable_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 10, i32 64, i32 0, i32 0, i32 64]
@ChainIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2370247058431047815, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterable_hashtbl, ptr @ChainIterable_offset_tbl, ptr @_data_size_ChainIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_field_first, ptr @ChainIterable_field_second, ptr @ChainIterable_B_init_firstIterableT_secondIterableT, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_init_firstIterableT_secondIterableT, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ChainIterator]
@ChainIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@InterleaveIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @InterleaveIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@InterleaveIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 39, i32 64, i32 0, i32 0, i32 10]
@InterleaveIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 4936782714255954462, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterable_hashtbl, ptr @InterleaveIterable_offset_tbl, ptr @_data_size_InterleaveIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_field_first, ptr @InterleaveIterable_field_second, ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleaveIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleaveIterator, ptr @Iterator, ptr null, ptr null]
@InterleaveIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 0, i32 21, i32 10, i32 18, i32 0, i32 0]
@ZipIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @ZipIterable, ptr @Object]
@ZipIterable_offset_tbl = constant [8 x i32] [i32 10, i32 41, i32 0, i32 0, i32 66, i32 0, i32 10, i32 66]
@ZipIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 35232740166152944, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterable_hashtbl, ptr @ZipIterable_offset_tbl, ptr @_data_size_ZipIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ZipIterable_field_ZipIterable_0, ptr @ZipIterable_field_ZipIterable_1, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_field_first, ptr @ZipIterable_field_second, ptr @ZipIterable_B_init_firstIterableT_secondIterableU, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_init_firstIterableT_secondIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZipIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ZipIterator]
@ZipIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 22, i32 19, i32 22, i32 0, i32 10, i32 10]
@ProductIterable_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ProductIterable, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr null]
@ProductIterable_offset_tbl = constant [8 x i32] [i32 66, i32 10, i32 10, i32 66, i32 0, i32 41, i32 0, i32 0]
@ProductIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 4128338911757318636, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterable_hashtbl, ptr @ProductIterable_offset_tbl, ptr @_data_size_ProductIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ProductIterable_field_ProductIterable_0, ptr @ProductIterable_field_ProductIterable_1, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_field_first, ptr @ProductIterable_field_second, ptr @ProductIterable_B_init_firstIterableT_secondIterableU, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_init_firstIterableT_secondIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr null, ptr @Container, ptr @Object, ptr null, ptr @ProductIterator]
@ProductIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 21, i32 0, i32 24, i32 24, i32 0, i32 10]
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Enumeration_field_iterable = internal constant { ptr, ptr } { ptr @Enumeration_getter_iterable, ptr @Enumeration_setter_iterable }
@Enumerator_field_iterator = internal constant { ptr, ptr } { ptr @Enumerator_getter_iterator, ptr @Enumerator_setter_iterator }
@Enumerator_field_index = internal constant { ptr, ptr } { ptr @Enumerator_getter_index, ptr @Enumerator_setter_index }
@MapIterable_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable_getter_iterable, ptr @MapIterable_setter_iterable }
@MapIterable_field_f = internal constant { ptr, ptr } { ptr @MapIterable_getter_f, ptr @MapIterable_setter_f }
@MapIterator_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator_getter_iterator, ptr @MapIterator_setter_iterator }
@MapIterator_field_f = internal constant { ptr, ptr } { ptr @MapIterator_getter_f, ptr @MapIterator_setter_f }
@FilterIterable_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable_getter_iterable, ptr @FilterIterable_setter_iterable }
@FilterIterable_field_f = internal constant { ptr, ptr } { ptr @FilterIterable_getter_f, ptr @FilterIterable_setter_f }
@FilterIterator_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator_getter_iterator, ptr @FilterIterator_setter_iterator }
@FilterIterator_field_f = internal constant { ptr, ptr } { ptr @FilterIterator_getter_f, ptr @FilterIterator_setter_f }
@ChainIterable_field_first = internal constant { ptr, ptr } { ptr @ChainIterable_getter_first, ptr @ChainIterable_setter_first }
@ChainIterable_field_second = internal constant { ptr, ptr } { ptr @ChainIterable_getter_second, ptr @ChainIterable_setter_second }
@ChainIterator_field_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_first, ptr @ChainIterator_setter_first }
@ChainIterator_field_second = internal constant { ptr, ptr } { ptr @ChainIterator_getter_second, ptr @ChainIterator_setter_second }
@ChainIterator_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_on_first, ptr @ChainIterator_setter_on_first }
@InterleaveIterable_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_first, ptr @InterleaveIterable_setter_first }
@InterleaveIterable_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_second, ptr @InterleaveIterable_setter_second }
@InterleaveIterator_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_first, ptr @InterleaveIterator_setter_first }
@InterleaveIterator_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_second, ptr @InterleaveIterator_setter_second }
@InterleaveIterator_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_on_first, ptr @InterleaveIterator_setter_on_first }
@ZipIterable_field_first = internal constant { ptr, ptr } { ptr @ZipIterable_getter_first, ptr @ZipIterable_setter_first }
@ZipIterable_field_second = internal constant { ptr, ptr } { ptr @ZipIterable_getter_second, ptr @ZipIterable_setter_second }
@ZipIterator_field_first = internal constant { ptr, ptr } { ptr @ZipIterator_getter_first, ptr @ZipIterator_setter_first }
@ZipIterator_field_second = internal constant { ptr, ptr } { ptr @ZipIterator_getter_second, ptr @ZipIterator_setter_second }
@ProductIterable_field_first = internal constant { ptr, ptr } { ptr @ProductIterable_getter_first, ptr @ProductIterable_setter_first }
@ProductIterable_field_second = internal constant { ptr, ptr } { ptr @ProductIterable_getter_second, ptr @ProductIterable_setter_second }
@ProductIterator_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_first_iterator, ptr @ProductIterator_setter_first_iterator }
@ProductIterator_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterator, ptr @ProductIterator_setter_second_iterator }
@ProductIterator_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterable, ptr @ProductIterator_setter_second_iterable }
@ProductIterator_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator_getter_current_first, ptr @ProductIterator_setter_current_first }
@Enumerator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3435222131909153872, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumerator_hashtbl, ptr @Enumerator_offset_tbl, ptr @_data_size_Enumerator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Enumerator_field_Enumerator_0, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_field_iterator, ptr @Enumerator_field_index, ptr @Enumerator_B_init_iteratorIteratorT, ptr @Enumerator_B_next_, ptr @Enumerator_init_iteratorIteratorT, ptr @Enumerator_next_, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_B_next_, ptr @Enumerator_next_] }
@MapIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -146553482626734782, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterator_hashtbl, ptr @MapIterator_offset_tbl, ptr @_data_size_MapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @MapIterator_field_MapIterator_0, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_field_iterator, ptr @MapIterator_field_f, ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_B_next_, ptr @MapIterator_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_next_, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_B_next_, ptr @MapIterator_next_] }
@ChainIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6043157723929225452, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterator_hashtbl, ptr @ChainIterator_offset_tbl, ptr @_data_size_ChainIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_field_first, ptr @ChainIterator_field_second, ptr @ChainIterator_field_on_first, ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_B_next_, ptr @ChainIterator_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_next_, ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_B_next_, ptr @ChainIterator_next_] }
@InterleaveIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3924664358248524505, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterator_hashtbl, ptr @InterleaveIterator_offset_tbl, ptr @_data_size_InterleaveIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_field_first, ptr @InterleaveIterator_field_second, ptr @InterleaveIterator_field_on_first, ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_next_, ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_next_] }
@ZipIterator = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 -2141114445739585318, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterator_hashtbl, ptr @ZipIterator_offset_tbl, ptr @_data_size_ZipIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @ZipIterator_field_ZipIterator_0, ptr @ZipIterator_field_ZipIterator_1, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_field_first, ptr @ZipIterator_field_second, ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_B_next_, ptr @ZipIterator_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_next_, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_B_next_, ptr @ZipIterator_next_] }
@ProductIterator = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 1697250377212095568, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterator_hashtbl, ptr @ProductIterator_offset_tbl, ptr @_data_size_ProductIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @ProductIterator_field_ProductIterator_0, ptr @ProductIterator_field_ProductIterator_1, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_field_first_iterator, ptr @ProductIterator_field_second_iterator, ptr @ProductIterator_field_second_iterable, ptr @ProductIterator_field_current_first, ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_B_next_, ptr @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_next_, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_B_next_, ptr @ProductIterator_next_] }
@Collection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr @Collection]
@Collection_offset_tbl = constant [8 x i32] [i32 69, i32 10, i32 0, i32 69, i32 0, i32 44, i32 0, i32 10]
@EnumeratedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr @EnumeratedCollection, ptr null, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@EnumeratedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 107, i32 10, i32 0, i32 132, i32 0, i32 48, i32 132]
@EnumeratedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 7081690788784801875, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @EnumeratedCollection_hashtbl, ptr @EnumeratedCollection_offset_tbl, ptr @_data_size_EnumeratedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @EnumeratedCollection_field_EnumeratedCollection_0, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_field_collection, ptr @EnumeratedCollection_B_init_collectionCollectionT, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_init_collectionCollectionT, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MappedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr @MappedCollection, ptr @Collection]
@MappedCollection_offset_tbl = constant [8 x i32] [i32 133, i32 10, i32 0, i32 133, i32 0, i32 108, i32 10, i32 49]
@MappedCollection = constant { [3 x i64], [7 x ptr], [123 x ptr] } { [3 x i64] [i64 5460697656559120915, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MappedCollection_hashtbl, ptr @MappedCollection_offset_tbl, ptr @_data_size_MappedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [123 x ptr] [ptr @MappedCollection_field_MappedCollection_0, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_field_collection, ptr @MappedCollection_field_f, ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainedCollection_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr @ChainedCollection, ptr @Container, ptr @Iterable, ptr null]
@ChainedCollection_offset_tbl = constant [8 x i32] [i32 0, i32 132, i32 10, i32 48, i32 10, i32 132, i32 107, i32 0]
@ChainedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 -4136536984535342799, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainedCollection_hashtbl, ptr @ChainedCollection_offset_tbl, ptr @_data_size_ChainedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_field_first, ptr @ChainedCollection_field_second, ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleavedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleavedCollection, ptr @Iterable, ptr null, ptr @Collection]
@InterleavedCollection_offset_tbl = constant [8 x i32] [i32 132, i32 10, i32 0, i32 132, i32 10, i32 107, i32 0, i32 48]
@InterleavedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 8589355597059143861, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleavedCollection_hashtbl, ptr @InterleavedCollection_offset_tbl, ptr @_data_size_InterleavedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_field_first, ptr @InterleavedCollection_field_second, ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZippedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Collection, ptr @Object, ptr @Container, ptr @ZippedCollection, ptr @Iterable, ptr null, ptr null]
@ZippedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 50, i32 134, i32 134, i32 10, i32 109, i32 0, i32 0]
@ZippedCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 880335312586431241, i64 4611686018427388513, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZippedCollection_hashtbl, ptr @ZippedCollection_offset_tbl, ptr @_data_size_ZippedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ZippedCollection_field_ZippedCollection_0, ptr @ZippedCollection_field_ZippedCollection_1, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_field_first, ptr @ZippedCollection_field_second, ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ProductCollection, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@ProductCollection_offset_tbl = constant [8 x i32] [i32 10, i32 109, i32 0, i32 10, i32 134, i32 0, i32 50, i32 134]
@ProductCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 -310975631771072937, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductCollection_hashtbl, ptr @ProductCollection_offset_tbl, ptr @_data_size_ProductCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ProductCollection_field_ProductCollection_0, ptr @ProductCollection_field_ProductCollection_1, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_field_first, ptr @ProductCollection_field_second, ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@EnumeratedCollection_field_collection = internal constant { ptr, ptr } { ptr @EnumeratedCollection_getter_collection, ptr @EnumeratedCollection_setter_collection }
@MappedCollection_field_collection = internal constant { ptr, ptr } { ptr @MappedCollection_getter_collection, ptr @MappedCollection_setter_collection }
@MappedCollection_field_f = internal constant { ptr, ptr } { ptr @MappedCollection_getter_f, ptr @MappedCollection_setter_f }
@ChainedCollection_field_first = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_first, ptr @ChainedCollection_setter_first }
@ChainedCollection_field_second = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_second, ptr @ChainedCollection_setter_second }
@InterleavedCollection_field_first = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_first, ptr @InterleavedCollection_setter_first }
@InterleavedCollection_field_second = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_second, ptr @InterleavedCollection_setter_second }
@ZippedCollection_field_first = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_first, ptr @ZippedCollection_setter_first }
@ZippedCollection_field_second = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_second, ptr @ZippedCollection_setter_second }
@ProductCollection_field_first = internal constant { ptr, ptr } { ptr @ProductCollection_getter_first, ptr @ProductCollection_setter_first }
@ProductCollection_field_second = internal constant { ptr, ptr } { ptr @ProductCollection_getter_second, ptr @ProductCollection_setter_second }
@Range_hashtbl = constant [16 x ptr] [ptr null, ptr @Object, ptr null, ptr @Range, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @Container, ptr null, ptr @Collection, ptr null, ptr @Iterable, ptr @any_typ, ptr null]
@Range_offset_tbl = constant [16 x i32] [i32 0, i32 137, i32 0, i32 10, i32 0, i32 0, i32 0, i32 0, i32 0, i32 137, i32 0, i32 53, i32 0, i32 112, i32 10, i32 0]
@RangeIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr @RangeIterator, ptr @Container, ptr @Object, ptr null, ptr null]
@RangeIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 18, i32 10, i32 21, i32 21, i32 0, i32 0]
@Range_field_start = internal constant { ptr, ptr } { ptr @Range_getter_start, ptr @Range_setter_start }
@Range_field_end = internal constant { ptr, ptr } { ptr @Range_getter_end, ptr @Range_setter_end }
@Range_field_step = internal constant { ptr, ptr } { ptr @Range_getter_step, ptr @Range_setter_step }
@RangeIterator_field_counter = internal constant { ptr, ptr } { ptr @RangeIterator_getter_counter, ptr @RangeIterator_setter_counter }
@RangeIterator_field_end = internal constant { ptr, ptr } { ptr @RangeIterator_getter_end, ptr @RangeIterator_setter_end }
@RangeIterator_field_step = internal constant { ptr, ptr } { ptr @RangeIterator_getter_step, ptr @RangeIterator_setter_step }
@Indexable_hashtbl = constant [4 x ptr] [ptr @Object, ptr @Indexable, ptr @any_typ, ptr null]
@Indexable_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 10, i32 0]
@IndexableCollection_hashtbl = constant [8 x ptr] [ptr @Indexable, ptr null, ptr @IndexableCollection, ptr @Container, ptr @Collection, ptr @Iterable, ptr @any_typ, ptr @Object]
@IndexableCollection_offset_tbl = constant [8 x i32] [i32 54, i32 0, i32 10, i32 144, i32 60, i32 119, i32 10, i32 60]
@List_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr @List, ptr @Collection]
@List_offset_tbl = constant [8 x i32] [i32 146, i32 10, i32 0, i32 146, i32 0, i32 121, i32 10, i32 62]
@_parameterization_Character = linkonce_odr constant [2 x ptr] [ptr @Character, ptr null]
@_parameterization_i8 = linkonce_odr constant [2 x ptr] [ptr @i8_typ, ptr null]
@_parameterization_IterableCharacter = linkonce_odr constant [3 x ptr] [ptr @Iterable, ptr @_parameterization_Character, ptr null]
@tuple_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3422634369532007740, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @tuple_typ_hashtbl, ptr @tuple_typ_offset_tbl, ptr @_data_size_tuple_typ, ptr @_box_tuple_typ, ptr @_unbox_tuple_typ, ptr @_data_size_tuple_typ], [0 x ptr] undef }
@RangeIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -913562485944406675, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @RangeIterator_hashtbl, ptr @RangeIterator_offset_tbl, ptr @_data_size_RangeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @RangeIterator_field_counter, ptr @RangeIterator_field_end, ptr @RangeIterator_field_step, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_init_counteri32_endi32_stepi32, ptr @RangeIterator_B_next_, ptr @RangeIterator_init_counteri32_endi32_stepi32, ptr @RangeIterator_next_, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_next_, ptr @RangeIterator_next_] }
@Unicode_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Unicode]
@Unicode_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 0, i32 10]
@Unicode = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -7454226071548845319, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Unicode_hashtbl, ptr @Unicode_offset_tbl, ptr @_data_size_Unicode, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Unicode_B__Self_replacement_codepoint_, ptr @Unicode_B__Self_replacement_str_, ptr @Unicode_B__Self_replacement_buf_, ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode_B__Self_encode_one_cpi32, ptr @Unicode__Self_replacement_codepoint_, ptr @Unicode__Self_replacement_str_, ptr @Unicode__Self_replacement_buf_, ptr @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode__Self_encode_one_cpi32] }
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [16 x ptr] [ptr @Iterable, ptr @List, ptr null, ptr null, ptr null, ptr null, ptr @Object, ptr @Collection, ptr @any_typ, ptr null, ptr null, ptr null, ptr @String, ptr null, ptr @Container, ptr @Representable]
@String_offset_tbl = constant [16 x i32] [i32 297, i32 102, i32 0, i32 0, i32 0, i32 0, i32 322, i32 238, i32 10, i32 0, i32 0, i32 0, i32 10, i32 0, i32 322, i32 322]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 21, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [8 x ptr] [ptr @StringIterator, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr @ConstantTimeIterator, ptr @any_typ, ptr null]
@StringIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 26, i32 23, i32 26, i32 17, i32 10, i32 0]
@StringIterator = constant { [3 x i64], [7 x ptr], [16 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [16 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_byte_index, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_] }
@Stacktrace_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Stacktrace]
@Stacktrace_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 0, i32 10]
@Stacktrace = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 -59384212523717097, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Stacktrace_hashtbl, ptr @Stacktrace_offset_tbl, ptr @_data_size_Stacktrace, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @Stacktrace_field_stacktrace, ptr @Stacktrace_field_n_frames, ptr @Stacktrace_B_init_, ptr @Stacktrace_B_print_, ptr @Stacktrace_init_, ptr @Stacktrace_print_] }
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 24, i32 0, i32 10, i32 10]
@InvalidUTF8Error_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @InvalidUTF8Error, ptr @Object]
@InvalidUTF8Error_offset_tbl = constant [4 x i32] [i32 10, i32 24, i32 10, i32 38]
@InvalidUTF8Error = constant { [3 x i64], [7 x ptr], [28 x ptr] } { [3 x i64] [i64 4104693287331019315, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @InvalidUTF8Error_hashtbl, ptr @InvalidUTF8Error_offset_tbl, ptr @_data_size_InvalidUTF8Error, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [28 x ptr] [ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@OutOfBounds_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @OutOfBounds, ptr @Object]
@OutOfBounds_offset_tbl = constant [4 x i32] [i32 10, i32 27, i32 10, i32 41]
@OutOfBoundsDetails_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @OutOfBoundsDetails]
@OutOfBoundsDetails_offset_tbl = constant [4 x i32] [i32 16, i32 0, i32 10, i32 10]
@OutOfBoundsDetails = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 4650630525701360429, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBoundsDetails_hashtbl, ptr @OutOfBoundsDetails_offset_tbl, ptr @_data_size_OutOfBoundsDetails, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @OutOfBoundsDetails_field_bounds, ptr @OutOfBoundsDetails_field_index, ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_B_report_, ptr @OutOfBoundsDetails_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_report_] }
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_byte_length = internal constant { ptr, ptr } { ptr @String_getter_byte_length, ptr @String_setter_byte_length }
@String_field_char_length = internal constant { ptr, ptr } { ptr @String_getter_char_length, ptr @String_setter_char_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_codepoint = internal constant { ptr, ptr } { ptr @Character_getter_codepoint, ptr @Character_setter_codepoint }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_byte_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_byte_index, ptr @StringIterator_setter_byte_index }
@Stacktrace_field_stacktrace = internal constant { ptr, ptr } { ptr @Stacktrace_getter_stacktrace, ptr @Stacktrace_setter_stacktrace }
@Stacktrace_field_n_frames = internal constant { ptr, ptr } { ptr @Stacktrace_getter_n_frames, ptr @Stacktrace_setter_n_frames }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@Exception_field_stacktrace = internal constant { ptr, ptr } { ptr @Exception_getter_stacktrace, ptr @Exception_setter_stacktrace }
@InvalidUTF8Error_field_line_number = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_line_number, ptr @InvalidUTF8Error_setter_line_number }
@InvalidUTF8Error_field_file_name = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_file_name, ptr @InvalidUTF8Error_setter_file_name }
@InvalidUTF8Error_field_message = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_message, ptr @InvalidUTF8Error_setter_message }
@InvalidUTF8Error_field_stacktrace = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_stacktrace, ptr @InvalidUTF8Error_setter_stacktrace }
@OutOfBounds_field_details = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_details, ptr @OutOfBounds_setter_details }
@OutOfBounds_field_line_number = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_line_number, ptr @OutOfBounds_setter_line_number }
@OutOfBounds_field_file_name = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_file_name, ptr @OutOfBounds_setter_file_name }
@OutOfBounds_field_message = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_message, ptr @OutOfBounds_setter_message }
@OutOfBounds_field_stacktrace = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_stacktrace, ptr @OutOfBounds_setter_stacktrace }
@OutOfBoundsDetails_field_bounds = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_bounds, ptr @OutOfBoundsDetails_setter_bounds }
@OutOfBoundsDetails_field_index = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_index, ptr @OutOfBoundsDetails_setter_index }
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64, ptr @IO__Self_print_xBool, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xi8, ptr @IO__Self_print_xString, ptr @IO__Self_print_xi32, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xi64, ptr @IO__Self_print_xf64] }
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@List = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -83120161364696977, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @List_hashtbl, ptr @List_offset_tbl, ptr @_data_size_List, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Range = constant { [3 x i64], [7 x ptr], [127 x ptr] } { [3 x i64] [i64 5490049236840671069, i64 4611686018427389989, i64 15], [7 x ptr] [ptr @subtype_test, ptr @Range_hashtbl, ptr @Range_offset_tbl, ptr @_data_size_Range, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [127 x ptr] [ptr @Range_field_start, ptr @Range_field_end, ptr @Range_field_step, ptr @Range_field_Range_0, ptr @Range_B_init_endi32, ptr @Range_B_init_starti32_endi32, ptr @Range_B_step_stepi32, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_init_endi32, ptr @Range_init_starti32_endi32, ptr @Range_step_stepi32, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Range_field_Range_0, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@OutOfBounds = constant { [3 x i64], [7 x ptr], [31 x ptr] } { [3 x i64] [i64 5348403617834207535, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBounds_hashtbl, ptr @OutOfBounds_offset_tbl, ptr @_data_size_OutOfBounds, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [31 x ptr] [ptr @OutOfBounds_field_details, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_boundsi32_indexi32, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @OutOfBounds_init_boundsi32_indexi32, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_] }
@Array_hashtbl = constant [32 x ptr] [ptr null, ptr @Representable, ptr @List, ptr null, ptr null, ptr @Container, ptr @Array, ptr null, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @IndexableCollection, ptr null, ptr @Collection, ptr @any_typ, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @Indexable, ptr null, ptr null, ptr null, ptr null]
@Array_offset_tbl = constant [32 x i32] [i32 0, i32 537, i32 93, i32 0, i32 0, i32 313, i32 10, i32 0, i32 0, i32 288, i32 313, i32 0, i32 0, i32 0, i32 0, i32 0, i32 313, i32 0, i32 229, i32 10, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 447, i32 0, i32 0, i32 0, i32 0]
@Array = constant { [3 x i64], [7 x ptr], [529 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427389773, i64 31], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [529 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_field_Array_2, ptr @Array_B_init_, ptr @Array_B_init_capacityi32, ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_B_capacity_, ptr @Array_B_reserve_new_capacityi32, ptr @Array_B_bounds_check_indexi32, ptr @Array_B_unchecked_index_indexi32, ptr @Array_B_unchecked_insert_indexi32_valueT, ptr @Array_B__Self_empty_, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_append_xT, ptr @Array_B_length_, ptr @Array_B_first_, ptr @Array_B_last_, ptr @Array_B_extend_otherIterableT_extend_otherCollectionT, ptr @Array_B_get_indexi32, ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_B_indices_, ptr @Array_B_values_, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_B_repr_, ptr @Array_init_, ptr @Array_init_capacityi32, ptr @Array_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_capacity_, ptr @Array_reserve_new_capacityi32, ptr @Array_bounds_check_indexi32, ptr @Array_unchecked_index_indexi32, ptr @Array_unchecked_insert_indexi32_valueT, ptr @Array__Self_empty_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_append_xT, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @Array_extend_otherCollectionT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_indices_, ptr @Array_values_, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_repr_, ptr @Array_field_Array_0, ptr @Array_B__Self_empty_, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_append_xT, ptr @Array_B_length_, ptr @Array_B_first_, ptr @Array_B_last_, ptr @Array_B_extend_otherIterableT_extend_otherCollectionT, ptr @Array_B_get_indexi32, ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array__Self_empty_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_append_xT, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_field_Array_0, ptr @Array_B_indices_, ptr @Array_B_values_, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_indices_, ptr @Array_values_, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_repr_] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr @Iterator, ptr @ConstantTimeIterator, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 26, i32 10, i32 0, i32 26, i32 10, i32 23, i32 17, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [16 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [16 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@_parameterization_Bufferi8 = linkonce_odr constant [2 x ptr] [ptr @buffer_typ, ptr null]
@ConstantTimeIterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7049076106841707882, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ConstantTimeIterator_hashtbl, ptr @ConstantTimeIterator_offset_tbl, ptr @_data_size_ConstantTimeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@String = constant { [3 x i64], [7 x ptr], [314 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427390361, i64 15], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [314 x ptr] [ptr @String_field_bytes, ptr @String_field_byte_length, ptr @String_field_char_length, ptr @String_field_capacity, ptr @String_field_String_0, ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_c_string_c_stringBufferi8, ptr @String_B_init_, ptr @String_B_init_capacityi32, ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_B_byte_length_, ptr @String_B_capacity_, ptr @String_B_c_string_, ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_B_reserve_new_capacityi32, ptr @String_B__EQ_otherString, ptr @String_B_decode_at_byte_indexi32, ptr @String_B_unchecked_index_xi32, ptr @String_B_unchecked_insert_xi32_valuei8, ptr @String_B_copy_, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherIterableT_extend_otherString_extend_otherCollectionCharacter, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_B_repr_, ptr @String__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String__Self_from_c_string_c_stringBufferi8, ptr @String_init_, ptr @String_init_capacityi32, ptr @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_byte_length_, ptr @String_capacity_, ptr @String_c_string_, ptr @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_reserve_new_capacityi32, ptr @String__EQ_otherString, ptr @String_decode_at_byte_indexi32, ptr @String_unchecked_index_xi32, ptr @String_unchecked_insert_xi32_valuei8, ptr @String_copy_, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @String_extend_otherString, ptr @String_extend_otherCollectionCharacter, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_repr_, ptr @String_field_String_0, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherIterableT_extend_otherString_extend_otherCollectionCharacter, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_B_repr_, ptr @String_repr_] }
@Character = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Character_field_codepoint, ptr @Character_B_init_codepointi32, ptr @Character_B_codepoint_, ptr @Character_B_to_string_, ptr @Character_B__EQ_otherCharacter, ptr @Character_B_n_bytes_, ptr @Character_init_codepointi32, ptr @Character_codepoint_, ptr @Character_to_string_, ptr @Character__EQ_otherCharacter, ptr @Character_n_bytes_] }
@Exception = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_field_stacktrace, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberi32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@KeyNotFound_hashtbl = constant [4 x ptr] [ptr @Object, ptr @KeyNotFound, ptr @any_typ, ptr @Exception]
@KeyNotFound_offset_tbl = constant [4 x i32] [i32 38, i32 10, i32 10, i32 24]
@KeyNotFound = constant { [3 x i64], [7 x ptr], [28 x ptr] } { [3 x i64] [i64 2946564862774055400, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @KeyNotFound_hashtbl, ptr @KeyNotFound_offset_tbl, ptr @_data_size_KeyNotFound, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [28 x ptr] [ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@Map_hashtbl = constant [8 x ptr] [ptr @Indexable, ptr @Map, ptr @IndexableCollection, ptr @Container, ptr @Collection, ptr @Iterable, ptr @any_typ, ptr @Object]
@Map_offset_tbl = constant [8 x i32] [i32 198, i32 10, i32 64, i32 288, i32 204, i32 263, i32 10, i32 204]
@MapKeys_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr @MapKeys, ptr @Container, ptr @Iterable, ptr null]
@MapKeys_offset_tbl = constant [8 x i32] [i32 0, i32 132, i32 10, i32 48, i32 10, i32 132, i32 107, i32 0]
@MapKeys = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 -6755415596079746205, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapKeys_hashtbl, ptr @MapKeys_offset_tbl, ptr @_data_size_MapKeys, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @MapKeys_field_MapKeys_1, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_field_map, ptr @MapKeys_B_init_mapMapK._V, ptr @MapKeys_B_size_, ptr @MapKeys_B_is_empty_, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherIterableU_product_otherCollectionU, ptr @MapKeys_init_mapMapK._V, ptr @MapKeys_size_, ptr @Collection_is_empty_, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_size_, ptr @MapKeys_B_is_empty_, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherIterableU_product_otherCollectionU, ptr @MapKeys_size_, ptr @Collection_is_empty_, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherIterableU_product_otherCollectionU, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherIterableU_product_otherCollectionU, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapValues_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @MapValues, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@MapValues_offset_tbl = constant [8 x i32] [i32 10, i32 107, i32 0, i32 10, i32 132, i32 0, i32 48, i32 132]
@MapValues = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 2074062704914054732, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapValues_hashtbl, ptr @MapValues_offset_tbl, ptr @_data_size_MapValues, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @MapValues_field_MapValues_0, ptr @MapValues_field_MapValues_1, ptr @MapValues_field_map, ptr @MapValues_B_init_mapMapK._V, ptr @MapValues_B_size_, ptr @MapValues_B_is_empty_, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherIterableU_product_otherCollectionU, ptr @MapValues_init_mapMapK._V, ptr @MapValues_size_, ptr @Collection_is_empty_, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_size_, ptr @MapValues_B_is_empty_, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherIterableU_product_otherCollectionU, ptr @MapValues_size_, ptr @Collection_is_empty_, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherIterableU_product_otherCollectionU, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherIterableU_product_otherCollectionU, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapKeyIterator_hashtbl = constant [8 x ptr] [ptr null, ptr @MapKeyIterator, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr null]
@MapKeyIterator_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 20, i32 17, i32 20, i32 0, i32 10, i32 0]
@MapKeyIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 7211362081012783701, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapKeyIterator_hashtbl, ptr @MapKeyIterator_offset_tbl, ptr @_data_size_MapKeyIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @MapKeyIterator_field_MapKeyIterator_1, ptr @MapKeyIterator_field_MapKeyIterator_0, ptr @MapKeyIterator_field_map_iterator, ptr @MapKeyIterator_B_init_map_iteratorIteratorPairK._V, ptr @MapKeyIterator_B_next_, ptr @MapKeyIterator_init_map_iteratorIteratorPairK._V, ptr @MapKeyIterator_next_, ptr @MapKeyIterator_field_MapKeyIterator_0, ptr @MapKeyIterator_B_next_, ptr @MapKeyIterator_next_] }
@MapValueIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @MapValueIterator, ptr @Iterator, ptr null, ptr @Container, ptr @Object, ptr null, ptr null]
@MapValueIterator_offset_tbl = constant [8 x i32] [i32 10, i32 10, i32 17, i32 0, i32 20, i32 20, i32 0, i32 0]
@MapValueIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -4981803053484113385, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapValueIterator_hashtbl, ptr @MapValueIterator_offset_tbl, ptr @_data_size_MapValueIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @MapValueIterator_field_MapValueIterator_0, ptr @MapValueIterator_field_MapValueIterator_1, ptr @MapValueIterator_field_map_iterator, ptr @MapValueIterator_B_init_map_iteratorIteratorPairK._V, ptr @MapValueIterator_B_next_, ptr @MapValueIterator_init_map_iteratorIteratorPairK._V, ptr @MapValueIterator_next_, ptr @MapValueIterator_field_MapValueIterator_1, ptr @MapValueIterator_B_next_, ptr @MapValueIterator_next_] }
@HashMap_hashtbl = constant [16 x ptr] [ptr null, ptr @Container, ptr null, ptr null, ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr null, ptr @Map, ptr @IndexableCollection, ptr null, ptr null, ptr @Indexable, ptr @Iterable, ptr @HashMap]
@HashMap_offset_tbl = constant [16 x i32] [i32 0, i32 568, i32 0, i32 0, i32 0, i32 484, i32 10, i32 484, i32 0, i32 66, i32 344, i32 0, i32 0, i32 478, i32 543, i32 10]
@KeyNotFound_field_line_number = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_line_number, ptr @KeyNotFound_setter_line_number }
@KeyNotFound_field_file_name = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_file_name, ptr @KeyNotFound_setter_file_name }
@KeyNotFound_field_message = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_message, ptr @KeyNotFound_setter_message }
@KeyNotFound_field_stacktrace = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_stacktrace, ptr @KeyNotFound_setter_stacktrace }
@MapKeys_field_map = internal constant { ptr, ptr } { ptr @MapKeys_getter_map, ptr @MapKeys_setter_map }
@MapValues_field_map = internal constant { ptr, ptr } { ptr @MapValues_getter_map, ptr @MapValues_setter_map }
@MapKeyIterator_field_map_iterator = internal constant { ptr, ptr } { ptr @MapKeyIterator_getter_map_iterator, ptr @MapKeyIterator_setter_map_iterator }
@MapValueIterator_field_map_iterator = internal constant { ptr, ptr } { ptr @MapValueIterator_getter_map_iterator, ptr @MapValueIterator_setter_map_iterator }
@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Pair = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_init_firstT_secondU, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_] }
@Container = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_data_size_Container, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388349, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388477, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Collection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 1375598993350293883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Collection_hashtbl, ptr @Collection_offset_tbl, ptr @_data_size_Collection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Indexable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8246772220324864030, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Indexable_hashtbl, ptr @Indexable_offset_tbl, ptr @_data_size_Indexable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@IndexableCollection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -307435881317861917, i64 4611686018427389201, i64 7], [7 x ptr] [ptr @subtype_test, ptr @IndexableCollection_hashtbl, ptr @IndexableCollection_offset_tbl, ptr @_data_size_IndexableCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Map = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5249855671126779970, i64 4611686018427389201, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Map_hashtbl, ptr @Map_offset_tbl, ptr @_data_size_Map, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@HashMap = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388447, i64 15], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 25, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [15 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [15 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_primary_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueV_primary_hashi32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_primary_hash_, ptr @Entry_B_to_pair_, ptr @Entry_init_keyK_valueV_primary_hashi32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_primary_hash_, ptr @Entry_to_pair_] }
@CuckooMap_hashtbl = constant [16 x ptr] [ptr null, ptr @Container, ptr null, ptr null, ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr null, ptr @Map, ptr @IndexableCollection, ptr @CuckooMap, ptr null, ptr @Indexable, ptr @Iterable, ptr @HashMap]
@CuckooMap_offset_tbl = constant [16 x i32] [i32 0, i32 1154, i32 0, i32 0, i32 0, i32 1070, i32 10, i32 1070, i32 0, i32 652, i32 930, i32 10, i32 0, i32 1064, i32 1129, i32 94]
@CuckooMap = constant { [3 x i64], [7 x ptr], [1144 x ptr] } { [3 x i64] [i64 3547150501766965522, i64 4611686018427388447, i64 15], [7 x ptr] [ptr @subtype_test, ptr @CuckooMap_hashtbl, ptr @CuckooMap_offset_tbl, ptr @_data_size_CuckooMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [1144 x ptr] [ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_field_table1, ptr @CuckooMap_field_table2, ptr @CuckooMap_field_table_len, ptr @CuckooMap_field_size, ptr @CuckooMap_field_hasher, ptr @CuckooMap_field_eq, ptr @CuckooMap_B__Self_max_displacements_, ptr @CuckooMap_B_hash1_keyK, ptr @CuckooMap_B_hash2_from_primary_primary_hashi32, ptr @CuckooMap_B_index1_primary_hashi32, ptr @CuckooMap_B_index2_primary_hashi32, ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_B_resize_, ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap__Self_max_displacements_, ptr @CuckooMap_hash1_keyK, ptr @CuckooMap_hash2_from_primary_primary_hashi32, ptr @CuckooMap_index1_primary_hashi32, ptr @CuckooMap_index2_primary_hashi32, ptr @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_resize_, ptr @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU, ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@CuckooMapIterator_hashtbl = constant [8 x ptr] [ptr @CuckooMapIterator, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr null]
@CuckooMapIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 27, i32 24, i32 27, i32 0, i32 10, i32 0]
@CuckooMapIterator = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 -1975748647346050920, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMapIterator_hashtbl, ptr @CuckooMapIterator_offset_tbl, ptr @_data_size_CuckooMapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @CuckooMapIterator_field_CuckooMapIterator_0, ptr @CuckooMapIterator_field_CuckooMapIterator_1, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_field_map_table1, ptr @CuckooMapIterator_field_map_table2, ptr @CuckooMapIterator_field_table_len, ptr @CuckooMapIterator_field_index, ptr @CuckooMapIterator_field_on_second, ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_next_, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_next_] }
@Entry_field_primary_hash = internal constant { ptr, ptr } { ptr @Entry_getter_primary_hash, ptr @Entry_setter_primary_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@CuckooMap_field_table1 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table1, ptr @CuckooMap_setter_table1 }
@CuckooMap_field_table2 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table2, ptr @CuckooMap_setter_table2 }
@CuckooMap_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table_len, ptr @CuckooMap_setter_table_len }
@CuckooMap_field_size = internal constant { ptr, ptr } { ptr @CuckooMap_getter_size, ptr @CuckooMap_setter_size }
@CuckooMap_field_hasher = internal constant { ptr, ptr } { ptr @CuckooMap_getter_hasher, ptr @CuckooMap_setter_hasher }
@CuckooMap_field_eq = internal constant { ptr, ptr } { ptr @CuckooMap_getter_eq, ptr @CuckooMap_setter_eq }
@CuckooMapIterator_field_map_table1 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table1, ptr @CuckooMapIterator_setter_map_table1 }
@CuckooMapIterator_field_map_table2 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table2, ptr @CuckooMapIterator_setter_map_table2 }
@CuckooMapIterator_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_table_len, ptr @CuckooMapIterator_setter_table_len }
@CuckooMapIterator_field_index = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_index, ptr @CuckooMapIterator_setter_index }
@CuckooMapIterator_field_on_second = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_on_second, ptr @CuckooMapIterator_setter_on_second }

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nocapture nofree readonly %supertype_tbl) #0 {
  %product.i = mul i64 %cand_id, %hash_coef
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash.i
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_Default(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %fat_ptr, ptr nocapture nofree readnone %parameterization) #2 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr inbounds i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr nocapture nofree readnone %parameterization, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %destination) #3 {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr inbounds i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Default(ptr nocapture nofree readnone %parameterization) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @PRNG_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4401938362882229211
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %. = call i32 @llvm.smax.i32(i32 %3, i32 noundef 1) #41
  call void %10(ptr %.fca.1.extract, i32 %.) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4401938362882229211
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #43
  %10 = mul i32 %9, 1103515245
  %11 = add i32 %10, 12345
  %12 = and i32 %11, 2147483647
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 %12) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %17 = load ptr, ptr %6, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #43
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define i32 @get_offset(ptr nocapture nofree readonly align 8 %vptr, ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(8) %id_ptr) local_unnamed_addr #7 {
  %id = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr = getelementptr i8, ptr %vptr, i64 40
  %hash_coef = load i64, ptr %hash_coef_ptr, align 8
  %tbl_size = load i64, ptr %tbl_size_ptr, align 8
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %product.i = mul i64 %hash_coef, %id
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %hash.i
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) local_unnamed_addr #1 {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %shifted, %product
  %hash = and i64 %xored, %tbl_size
  ret i64 %hash
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #9

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #10 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #45
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0) local_unnamed_addr #10 {
  %result = call { i64, i64 } %f(ptr nocapture nofree readonly %0) #45
  ret { i64, i64 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) local_unnamed_addr #10 {
  %result = call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #45
  ret { ptr, i160 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @unbox_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) local_unnamed_addr #11 {
  call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #46
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull readonly %1) local_unnamed_addr #12 {
  %result = call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #47
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #12 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull %0) #47
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @adjust_trampoline(ptr nofree readonly %tramp) local_unnamed_addr #13 {
  %ret = call ptr @llvm.adjust.trampoline(ptr nofree readonly %tramp) #48
  ret ptr %ret
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #14

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, inaccessiblemem: none)
define noalias ptr @bump_malloc(i64 noundef %size) local_unnamed_addr #15 {
  %result = call noalias ptr @bump_malloc_wrapper(i64 noundef %size) #49
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none)
define noalias ptr @bump_malloc_wrapper(i64 noundef %size) local_unnamed_addr #16 {
  %result = call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #49
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %current_ptr) local_unnamed_addr #17 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_data_size_tuple_typ(ptr nocapture nofree readonly align 4 %0) #18 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull align 8 %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add nuw i64 %11, %.reg2mem22.011
  %19 = add nuw i64 %18, %17
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem20.0.lcssa = phi i64 [ 1, %1 ], [ %13, %.lr.ph ]
  %.reg2mem22.0.lcssa = phi i64 [ 0, %1 ], [ %19, %.lr.ph ]
  %24 = urem i64 %.reg2mem22.0.lcssa, %.reg2mem20.0.lcssa
  %25 = icmp eq i64 %24, 0
  %26 = sub nuw i64 %.reg2mem20.0.lcssa, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add nuw i64 %27, %.reg2mem22.0.lcssa
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa, 1
  ret { i64, i64 } %30
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #9

define { i64, i64 } @_data_size_union_typ(ptr nocapture nofree readonly align 4 %0) local_unnamed_addr #18 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge.thread, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull align 8 %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 noundef %12, i64 noundef %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = call i64 @llvm.umax.i64(i64 noundef %11, i64 noundef %.reg2mem22.011)
  %19 = call i64 @llvm.umax.i64(i64 noundef %18, i64 noundef %17)
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph
  %right_size = icmp eq i64 %19, 32
  %spec.select6 = select i1 %right_size, i64 0, i64 8
  %24 = add i64 %spec.select6, %19
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %1
  %.reg2mem20.0.lcssa4 = phi i64 [ 1, %1 ], [ %13, %._crit_edge ]
  %final_size = phi i64 [ 8, %1 ], [ %24, %._crit_edge ]
  %25 = urem i64 %final_size, %.reg2mem20.0.lcssa4
  %26 = icmp eq i64 %25, 0
  %27 = sub nuw i64 %.reg2mem20.0.lcssa4, %25
  %28 = select i1 %26, i64 0, i64 %27
  %29 = add nuw i64 %28, %final_size
  %30 = insertvalue { i64, i64 } undef, i64 %29, 0
  %31 = insertvalue { i64, i64 } %30, i64 %.reg2mem20.0.lcssa4, 1
  ret { i64, i64 } %31
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %dest) local_unnamed_addr #18 {
  %3 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %3, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %4 = getelementptr i8, ptr %1, i64 8
  %5 = load i64, ptr %4, align 4
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %.lr.ph.i, %2
  %.in.i = phi i64 [ %24, %.lr.ph.i ], [ %5, %2 ]
  %7 = phi i64 [ %22, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem20.010.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %2 ]
  %8 = inttoptr i64 %.in.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = call { i64, i64 } %11(ptr nonnull align 8 %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = call i64 @llvm.umax.i64(i64 noundef %14, i64 noundef %.reg2mem20.010.i)
  %16 = urem i64 %.reg2mem22.011.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub nuw i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = call i64 @llvm.umax.i64(i64 noundef %13, i64 noundef %.reg2mem22.011.i)
  %21 = call i64 @llvm.umax.i64(i64 noundef %20, i64 noundef %19)
  %22 = add nuw i64 %7, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %21, 32
  %spec.select6.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select6.i, %21
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %._crit_edge.i, %2
  %.reg2mem20.0.lcssa4.i = phi i64 [ 1, %2 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %2 ], [ %26, %._crit_edge.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %final_size.i, %.reg2mem20.0.lcssa4.i
  %30 = icmp eq i64 %29, 0
  %31 = sub nuw i64 %.reg2mem20.0.lcssa4.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add nuw i64 %32, %final_size.i
  %34 = icmp slt i64 %33, 17
  %35 = icmp eq i64 %33, 32
  %36 = select i1 %34, ptr %.fca.1.gep, ptr %28
  %source = select i1 %35, ptr %3, ptr %36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %dest, ptr nocapture nofree readonly align 1 %source, i64 %33, i1 noundef false)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #19

define noundef nonnull ptr @coroutine_create(ptr nofree %func, ptr nofree %arg_passer) local_unnamed_addr #18 {
  %result.i = call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #50
  store ptr %func, ptr %result.i, align 8
  %stack_top = getelementptr inbounds i8, ptr %result.i, i64 8388512
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr inbounds i8, ptr %result.i, i64 8
  %arg_passer_slot = getelementptr inbounds i8, ptr %result.i, i64 32
  %into_callee_second_word = getelementptr inbounds i8, ptr %result.i, i64 16
  %into_callee_third_word = getelementptr inbounds i8, ptr %result.i, i64 24
  store i64 %stack_top_aligned, ptr %into_callee_buf, align 8
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 8
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr inbounds i8, ptr %result.i, i64 40
  store i1 false, ptr %is_finished, align 8
  call void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8388592) %into_callee_second_word)
  ret ptr %result.i
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @virtual_reserve(i64 %size) local_unnamed_addr #20 {
  %result = call noalias ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 %size, i32 noundef 12288, i32 noundef 4) #50
  ret ptr %result
}

define void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %into_callee_second_word) #18 {
  store ptr blockaddress(@coroutine_trampoline, %trampoline), ptr %into_callee_second_word, align 8
  %result = call i1 @returns_one() #51
  br i1 %result, label %exit, label %trampoline

trampoline:                                       ; preds = %0
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  %arg_passer_ptr = getelementptr i8, ptr %current_coroutine, i64 32
  %arg_passer = load ptr, ptr %arg_passer_ptr, align 8
  call void %arg_passer(ptr %current_coroutine)
  %current_coroutine2 = load ptr, ptr @current_coroutine, align 8
  %is_finished_ptr = getelementptr i8, ptr %current_coroutine2, i64 40
  store i1 true, ptr %is_finished_ptr, align 1
  call void @llvm.eh.sjlj.longjmp(ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #22
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define i1 @returns_one() local_unnamed_addr #21 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #22

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) local_unnamed_addr #23

define void @setup_landing_pad() #18 {
  %result.i = call noalias dereferenceable_or_null(5368709120) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 5368709120, i32 noundef 12288, i32 noundef 4) #50
  store ptr %result.i, ptr @current_ptr, align 8
  %sp = call ptr @llvm.stacksave.p0() #52
  store ptr %sp, ptr @into_caller_buf, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %sp, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %result.i.i = call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #50
  store ptr @setup_landing_pad, ptr %result.i.i, align 8
  %stack_top.i = getelementptr inbounds i8, ptr %result.i.i, i64 8388512
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr inbounds i8, ptr %result.i.i, i64 8
  %arg_passer_slot.i = getelementptr inbounds i8, ptr %result.i.i, i64 32
  %into_callee_second_word.i = getelementptr inbounds i8, ptr %result.i.i, i64 16
  %into_callee_third_word.i = getelementptr inbounds i8, ptr %result.i.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 8
  store ptr @arg_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr inbounds i8, ptr %result.i.i, i64 40
  store i1 false, ptr %is_finished.i, align 8
  call void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8388592) %into_callee_second_word.i)
  store ptr %result.i.i, ptr @current_coroutine, align 8
  %result = call i1 @returns_one() #53
  br i1 %result, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = call i32 @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @string_string, ptr nofree noundef nonnull align 16 dereferenceable(45) @exception_message) #54
  %cc.unpack = load ptr, ptr @current_coroutine, align 8
  %cc1 = insertvalue { ptr } poison, ptr %cc.unpack, 0
  call void @report_exception({ ptr } %cc1)
  call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #24

define void @arg_passer(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %current_coroutine) #18 {
  %func = load ptr, ptr %current_coroutine, align 8
  call void %func()
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #25

declare void @exit() local_unnamed_addr #18

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @assume_offset(ptr nocapture nofree noundef nonnull readnone align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readnone align 4 %id_ptr) local_unnamed_addr #1 {
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr nocapture nofree noundef nonnull readonly %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nofree readonly %supertype_tbl) local_unnamed_addr #10 {
  %result = call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #45
  ret i1 %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @arg_buffer_filler(ptr nocapture nofree readnone %coroutine) local_unnamed_addr #1 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define ptr @get_current_coroutine() local_unnamed_addr #26 {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %from_buf, ptr %to_buf) #27 {
  %from_buf_second_word = getelementptr inbounds i8, ptr %from_buf, i64 8
  %from_buf_third_word = getelementptr inbounds i8, ptr %from_buf, i64 16
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = call ptr @llvm.stacksave.p0() #52
  store ptr %sp, ptr %from_buf, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %is_first_time = call i1 @returns_one() #51
  br i1 %is_first_time, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #22
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

; Function Attrs: nounwind
define void @coroutine_yield(ptr nocapture nofree nonnull writeonly align 8 dereferenceable(24) %current_coroutine) local_unnamed_addr #28 {
  %into_callee_buf = getelementptr inbounds i8, ptr %current_coroutine, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %into_callee_buf, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #55
  ret void
}

; Function Attrs: cold minsize noinline nounwind
define void @coroutine_yield_cold(ptr nocapture nofree nonnull writeonly align 8 dereferenceable(24) %current_coroutine) local_unnamed_addr #29 {
  %into_callee_buf.i = getelementptr inbounds i8, ptr %current_coroutine, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #55
  ret void
}

; Function Attrs: nounwind
define void @coroutine_call(ptr %coroutine) local_unnamed_addr #28 {
  %old_into_caller.unpack2 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr i8, ptr %coroutine, i64 8
  %1 = load <2 x ptr>, ptr @into_caller_buf, align 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr %into_callee_buf) #55
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store <2 x ptr> %1, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack2, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr nofree %tramp) local_unnamed_addr #30 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr nofree %tramp, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect) #54
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) local_unnamed_addr #30

define void @print_backtrace(ptr nocapture nofree readonly %backtrace, i64 %n_frames) local_unnamed_addr #18 {
  %handle = tail call ptr @GetCurrentProcess()
  %1 = tail call i32 @SymInitialize(ptr noundef %handle, ptr noundef align 4294967296 null, i32 noundef 1)
  %2 = alloca [344 x i8], align 1
  %3 = getelementptr inbounds i8, ptr %2, i64 4
  call void @llvm.memset.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(344) %3, i8 noundef 0, i64 noundef 340, i1 noundef false)
  %4 = getelementptr inbounds i8, ptr %2, i64 80
  store i32 255, ptr %4, align 4
  store i32 88, ptr %2, align 4
  %.not = icmp eq i64 %n_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %0
  %5 = getelementptr inbounds i8, ptr %2, i64 56
  %6 = getelementptr inbounds i8, ptr %2, i64 84
  br label %7

7:                                                ; preds = %7, %.lr.ph
  %indvars.iv.in = phi i64 [ %n_frames, %.lr.ph ], [ %indvars.iv, %7 ]
  %indvars.iv = add i64 %indvars.iv.in, -1
  %8 = getelementptr inbounds [100 x ptr], ptr %backtrace, i64 0, i64 %indvars.iv
  %9 = load ptr, ptr %8, align 8
  %10 = ptrtoint ptr %9 to i64
  %11 = call i32 @SymFromAddr(ptr noundef %handle, i64 noundef %10, ptr noundef align 4294967296 null, ptr noundef nonnull align 4 dereferenceable(344) %2)
  %12 = load i64, ptr %5, align 8
  %13 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(16) @backtrace_string, i64 noundef %indvars.iv, ptr nofree nonnull dereferenceable(260) %6, i64 %12) #54
  %exitcond.not = icmp slt i64 %indvars.iv, 1
  br i1 %exitcond.not, label %._crit_edge, label %7

._crit_edge:                                      ; preds = %7, %0
  %14 = call i32 @SymCleanup(ptr noundef %handle)
  ret void
}

declare ptr @GetCurrentProcess() local_unnamed_addr #18

declare i32 @SymInitialize(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #18

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #31

declare i32 @SymFromAddr(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #18

declare i32 @SymCleanup(ptr) local_unnamed_addr #18

define i64 @capture_backtrace(i64 %max_frames, ptr nocapture nofree writeonly %backtrace) local_unnamed_addr #18 {
entry:
  %context = alloca %struct._CONTEXT, align 16
  call void @RtlCaptureContext(ptr noundef nonnull align 16 dereferenceable(1232) %context)
  %rip = getelementptr inbounds i8, ptr %context, i64 248
  %img_base_ptr = alloca i64, align 8
  %0 = alloca ptr, align 8
  %1 = alloca i64, align 8
  %.not = icmp eq i64 %max_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %entry
  %.pre = load i64, ptr %rip, align 8
  br label %.lr.ph

.lr.ph:                                           ; preds = %3, %.lr.ph.preheader
  %2 = phi i64 [ %.pre, %.lr.ph.preheader ], [ %6, %3 ]
  %indvars.iv = phi i64 [ 0, %.lr.ph.preheader ], [ %indvars.iv.next, %3 ]
  %fentry = call ptr @RtlLookupFunctionEntry(i64 %2, ptr noundef nonnull align 8 dereferenceable(8) %img_base_ptr, ptr noundef align 4294967296 null)
  %img_base = load i64, ptr %img_base_ptr, align 8
  %fentry_null = icmp eq ptr %fentry, null
  %img_base_null = icmp eq i64 %img_base, 0
  %either = or i1 %fentry_null, %img_base_null
  br i1 %either, label %._crit_edge.loopexit.split.loop.exit, label %3

3:                                                ; preds = %.lr.ph
  %4 = load i64, ptr %rip, align 8
  %5 = call ptr @RtlVirtualUnwind(i32 noundef 0, i64 %img_base, i64 %4, ptr nonnull %fentry, ptr noundef nonnull align 16 dereferenceable(1232) %context, ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1, ptr noundef align 4294967296 null)
  %6 = load i64, ptr %rip, align 8
  %7 = inttoptr i64 %6 to ptr
  %8 = getelementptr inbounds ptr, ptr %backtrace, i64 %indvars.iv
  store ptr %7, ptr %8, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %max_frames
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge.loopexit.split.loop.exit:             ; preds = %.lr.ph
  %n_captured.le = add nsw i64 %indvars.iv, -4
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit.split.loop.exit, %3, %entry
  %.0.lcssa = phi i64 [ 0, %entry ], [ %n_captured.le, %._crit_edge.loopexit.split.loop.exit ], [ %max_frames, %3 ]
  ret i64 %.0.lcssa
}

declare void @RtlCaptureContext(ptr) local_unnamed_addr #18

declare ptr @RtlLookupFunctionEntry(i64, ptr, ptr) local_unnamed_addr #18

declare ptr @RtlVirtualUnwind(i32, i64, i64, ptr, ptr, ptr, ptr, ptr) local_unnamed_addr #18

define i1 @cniklhvjbm(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @nbugdksdmt(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @vyzyclalfc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ybmjkqijeh(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @cckwdxkqty(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ahgwqksoob(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @llfzdiimhe(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @lsrvbzeimc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ztufuhgpns(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @goxxgxvwti(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ppinaaxjdc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @eltauzrbyc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @eejnmacokr(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ihchcttgxk(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @aslhbjemhr(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @mzrpmlixaa(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @xzhnfrekfk(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @qbiggiwwnd(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @euxizdanlq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @yvdngfjhuo(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #18 {
  %result.i5.i309.h2s330 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i5.i309.h2s330, align 4
  %result.i5.i289.h2s332 = alloca [16 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(16) %result.i5.i289.h2s332, i8 0, i64 16, i1 false)
  %result.i5.i269.h2s334 = alloca [4 x i8], align 4
  store i32 7564576, ptr %result.i5.i269.h2s334, align 4
  %result.i5.i249.h2s336 = alloca [15 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i5.i249.h2s336, i8 0, i64 15, i1 false)
  %result.i5.i.h2s338 = alloca [15 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i5.i.h2s338, i8 0, i64 15, i1 false)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %5 = ptrtoint ptr %.fca.1.extract to i64
  %6 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.667.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.667.8.insert.shift = shl nuw i160 %.sroa.667.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %6 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.667.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.366.8.insert.ext = zext i64 %5 to i160
  %.sroa.366.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.366.8.insert.ext
  %7 = insertvalue { ptr, i160 } %4, i160 %.sroa.366.8.insert.insert, 1
  %8 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8) #41
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #41
  %11 = icmp eq ptr %.fca.0.extract, @nil_typ
  %12 = icmp eq ptr %.fca.0.extract, null
  %13 = or i1 %11, %12
  br i1 %13, label %RangeIterator_next_.exit52.i.preheader, label %14

14:                                               ; preds = %3
  %15 = icmp eq ptr %.fca.0.extract, @i32_typ
  br i1 %15, label %RangeIterator_next_.exit52.i.preheader, label %16

16:                                               ; preds = %14
  %17 = icmp eq ptr %.fca.0.extract, @bool_typ
  br i1 %17, label %RangeIterator_next_.exit52.i.preheader, label %18

18:                                               ; preds = %16
  %19 = icmp eq ptr %.fca.0.extract, @i64_typ
  br i1 %19, label %RangeIterator_next_.exit52.i.preheader, label %20

20:                                               ; preds = %18
  %21 = icmp eq ptr %.fca.0.extract, @f64_typ
  br i1 %21, label %RangeIterator_next_.exit52.i.preheader, label %22

22:                                               ; preds = %20
  %23 = icmp eq ptr %.fca.0.extract, @i8_typ
  br i1 %23, label %RangeIterator_next_.exit52.i.preheader, label %24

24:                                               ; preds = %22
  %25 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %26 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %27 = load i64, ptr %hash_coef_ptr.i, align 4
  %28 = load i64, ptr %tbl_size_ptr.i, align 4
  %29 = load ptr, ptr %25, align 8
  %30 = load ptr, ptr %26, align 8
  %result.i4.i = call i1 %29(i64 %28, i64 %27, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %30) #45
  br i1 %result.i4.i, label %31, label %.critedge.i

31:                                               ; preds = %24
  %result.i3.i = call i1 %29(i64 %28, i64 %27, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %30) #45
  br i1 %result.i3.i, label %.critedge.i, label %32

32:                                               ; preds = %31
  %result.i2.i = call i1 %29(i64 %28, i64 %27, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %30) #45
  br i1 %result.i2.i, label %.critedge.i, label %RangeIterator_next_.exit52.i.preheader

.critedge.i:                                      ; preds = %32, %31, %24
  %result.i1.i = call i1 %29(i64 %28, i64 %27, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %30) #45
  br i1 %result.i1.i, label %33, label %.critedge14.i

33:                                               ; preds = %.critedge.i
  %result.i.i = call i1 %29(i64 %28, i64 %27, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %30) #45
  br i1 %result.i.i, label %.critedge14.i, label %RangeIterator_next_.exit52.i.preheader

.critedge14.i:                                    ; preds = %33, %.critedge.i
  br label %RangeIterator_next_.exit52.i.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %.critedge14.i, %33, %32, %22, %20, %18, %16, %14, %3
  %.reg2mem25.0.i = phi i64 [ 7, %3 ], [ 6, %14 ], [ 1, %16 ], [ 8, %18 ], [ 9, %20 ], [ 4, %22 ], [ 2, %33 ], [ 3, %32 ], [ 5, %.critedge14.i ]
  %34 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %.reg2mem25.0.i
  %35 = getelementptr i8, ptr %34, i64 80
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %7)
  store i8 32, ptr %result.i5.i.h2s338, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s338, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep, align 1
  %37 = getelementptr inbounds i8, ptr %result.i5.i.h2s338, i64 14
  store i8 0, ptr %37, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338) #56
  %38 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1) #56
  store i8 32, ptr %result.i5.i249.h2s336, align 1
  %scevgep318 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318, align 1
  %39 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336, i64 14
  store i8 0, ptr %39, align 1
  %puts.i174 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336) #56
  %40 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2) #56
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %puts.i194 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334) #56
  %45 = icmp sgt i32 %1, 0
  br i1 %45, label %RangeIterator_next_.exit52.i292.preheader, label %._crit_edge

RangeIterator_next_.exit52.i292.preheader:        ; preds = %RangeIterator_next_.exit52.i.preheader
  %46 = zext nneg i32 %1 to i64
  store i8 32, ptr %result.i5.i289.h2s332, align 1
  %scevgep324 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324, align 1
  %47 = mul i64 %2, 1000000
  %48 = sdiv i64 %47, %46
  %49 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332, i64 15
  store i8 0, ptr %49, align 1
  %puts.i214 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332) #56
  %50 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %48) #56
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  store i8 32, ptr %result.i5.i309.h2s330, align 4
  %scevgep327 = getelementptr inbounds i8, ptr %result.i5.i309.h2s330, i64 1
  store i16 29550, ptr %scevgep327, align 1
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %55 = getelementptr inbounds i8, ptr %result.i5.i309.h2s330, i64 3
  store i8 0, ptr %55, align 1
  %puts.i234 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330) #56
  br label %._crit_edge

._crit_edge:                                      ; preds = %RangeIterator_next_.exit52.i292.preheader, %RangeIterator_next_.exit52.i.preheader
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr #18 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i287.h2s300 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i287.h2s300, i8 0, i64 5, i1 false)
  %result.i5.i.h2s302 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i.h2s302, i8 0, i64 19, i1 false)
  %oldProtect.i26 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %3 = alloca [4 x ptr], align 8
  %4 = alloca { ptr, ptr, ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %result.i24 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i24, align 8
  %11 = getelementptr inbounds i8, ptr %result.i24, i64 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i24, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i24) #41
  %result.i23 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  %result.i25 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i23, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i23, ptr noalias nofree noundef nonnull readnone @yvdngfjhuo, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i15 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i23) #48
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i23) #41
  %result.i22 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i26) #41
  %result.i27 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i22, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i26) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i26) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i22, ptr noalias nofree noundef nonnull readnone @euxizdanlq, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i22) #48
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i22) #41
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i24, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 10, 3
  %19 = getelementptr inbounds i8, ptr %result.i24, i64 48
  store ptr %ret.i15, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i24, i64 56
  store ptr %ret.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i24, i64 40
  store i32 8, ptr %21, align 8
  %result.i1.i61 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %22 = getelementptr inbounds i8, ptr %result.i24, i64 24
  store ptr %result.i1.i61, ptr %22, align 8
  %result.i.i62 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %23 = getelementptr inbounds i8, ptr %result.i24, i64 32
  store ptr %result.i.i62, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %25 = getelementptr inbounds i8, ptr %result.i24, i64 44
  store i32 0, ptr %25, align 4
  %26 = call i64 @clock()
  %.sroa.gep = getelementptr inbounds i8, ptr %8, i64 8
  %.sroa.gep308 = getelementptr inbounds i8, ptr %8, i64 16
  %.sroa.gep311 = getelementptr inbounds i8, ptr %8, i64 24
  %.sroa.gep314 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep317 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep320 = getelementptr inbounds i8, ptr %7, i64 24
  %27 = icmp sgt i32 %0, 0
  br i1 %27, label %._crit_edge.preheader, label %151

._crit_edge.preheader:                            ; preds = %1
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.preheader
  %.042 = phi i32 [ %29, %._crit_edge ], [ 0, %._crit_edge.preheader ]
  %29 = add nuw nsw i32 %.042, 1
  %.sroa.0283.0.insert.ext = zext nneg i32 %.042 to i160
  %30 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0283.0.insert.ext, 1
  %.sroa.0280.0.insert.ext = zext nneg i32 %29 to i160
  %31 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0280.0.insert.ext, 1
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %30, { ptr, i160 } %31)
  %exitcond.not = icmp eq i32 %29, %0
  br i1 %exitcond.not, label %._crit_edge2, label %._crit_edge

._crit_edge2:                                     ; preds = %._crit_edge
  %.sroa.gep306 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep309 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep312 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep315 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep318 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep321 = getelementptr inbounds i8, ptr %3, i64 24
  %32 = call i64 @clock()
  %33 = add nsw i32 %0, -1
  %.sroa.0269.0.insert.ext = zext nneg i32 %33 to i160
  %34 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0269.0.insert.ext, 1
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %36 = load ptr, ptr %19, align 8
  %37 = call i32 %36({ ptr, i160 } %34)
  %38 = load i32, ptr %21, align 8
  %39 = add i32 %38, -1
  %40 = and i32 %39, %37
  %41 = load ptr, ptr %22, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %43 = sext i32 %40 to i64
  %44 = shl nsw i64 %43, 5
  %45 = getelementptr i8, ptr %41, i64 %44
  %46 = load ptr, ptr %45, align 8
  %47 = icmp ne ptr %46, @nil_typ
  %48 = icmp ne ptr %46, null
  %.not48.i = and i1 %47, %48
  br i1 %.not48.i, label %49, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

49:                                               ; preds = %._crit_edge2
  %50 = getelementptr i8, ptr %45, i64 8
  %51 = load i64, ptr %50, align 4
  %.sroa_idx.i = getelementptr i8, ptr %45, i64 16
  %52 = load i64, ptr %.sroa_idx.i, align 4
  %53 = inttoptr i64 %51 to ptr
  %54 = inttoptr i64 %52 to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %46, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %46, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %46, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %46, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %53, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %54, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %offset.i14.i, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %46) #41
  %61 = sext i32 %offset.i14.i to i64
  %62 = getelementptr ptr, ptr %46, i64 %61
  %63 = getelementptr i8, ptr %62, i64 64
  %64 = load ptr, ptr %63, align 8
  %result.i2.i = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %65 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %2)
  %66 = icmp eq i32 %65, %37
  br i1 %66, label %._crit_edge.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i:                                    ; preds = %49
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %46)
  %69 = getelementptr i8, ptr %62, i64 48
  %70 = load ptr, ptr %69, align 8
  %result.i1.i = call ptr %70({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %71 = call { ptr, i160 } %result.i1.i({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %2)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %73 = load ptr, ptr %20, align 8
  %74 = call i1 %73({ ptr, i160 } %71, { ptr, i160 } %34)
  br i1 %74, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i, %49, %._crit_edge2
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %82

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %46)
  %77 = getelementptr i8, ptr %62, i64 56
  %78 = load ptr, ptr %77, align 8
  %result.i.i206 = call ptr %78({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %79 = call { ptr, i160 } %result.i.i206({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %2)
  %.fca.0.extract26.i = extractvalue { ptr, i160 } %79, 0
  %.fca.1.extract27.i = extractvalue { ptr, i160 } %79, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %80 = icmp ne ptr %.fca.0.extract26.i, @nil_typ
  %81 = icmp ne ptr %.fca.0.extract26.i, null
  %.not99.i = and i1 %80, %81
  %extract.t273 = trunc i160 %.fca.1.extract27.i to i32
  br i1 %.not99.i, label %CuckooMap_get_keyK.exit, label %82

82:                                               ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %83 = add i32 %37, 2127912214
  %84 = shl i32 %37, 12
  %85 = add i32 %83, %84
  %86 = ashr i32 %85, 19
  %87 = xor i32 %85, %86
  %88 = xor i32 %87, -949894596
  %89 = add i32 %88, 374761393
  %90 = shl i32 %88, 5
  %91 = add i32 %89, %90
  %92 = add i32 %91, -744332180
  %93 = shl i32 %91, 9
  %94 = xor i32 %92, %93
  %95 = add i32 %94, -42973499
  %96 = shl i32 %94, 3
  %97 = add i32 %95, %96
  %98 = ashr i32 %97, 16
  %99 = xor i32 %97, %98
  %100 = xor i32 %99, -1252372727
  %101 = load i32, ptr %21, align 8
  %102 = add i32 %101, -1
  %103 = and i32 %102, %100
  %104 = load ptr, ptr %23, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %106 = sext i32 %103 to i64
  %107 = shl nsw i64 %106, 5
  %108 = getelementptr i8, ptr %104, i64 %107
  %109 = load ptr, ptr %108, align 8
  %110 = icmp ne ptr %109, @nil_typ
  %111 = icmp ne ptr %109, null
  %.not48.i236 = and i1 %110, %111
  br i1 %.not48.i236, label %112, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261

112:                                              ; preds = %82
  %113 = getelementptr i8, ptr %108, i64 8
  %114 = load i64, ptr %113, align 4
  %.sroa_idx.i241 = getelementptr i8, ptr %108, i64 16
  %115 = load i64, ptr %.sroa_idx.i241, align 4
  %116 = inttoptr i64 %114 to ptr
  %117 = inttoptr i64 %115 to ptr
  %hash_coef_ptr.i3.i242 = getelementptr i8, ptr %109, i64 8
  %tbl_size_ptr.i4.i243 = getelementptr i8, ptr %109, i64 16
  %offset_tbl_ptr.i5.i244 = getelementptr i8, ptr %109, i64 40
  %hash_coef.i6.i245 = load i64, ptr %hash_coef_ptr.i3.i242, align 4
  %tbl_size.i7.i246 = load i64, ptr %tbl_size_ptr.i4.i243, align 4
  %offset_tbl.i8.i247 = load ptr, ptr %offset_tbl_ptr.i5.i244, align 8
  %product.i.i9.i248 = mul i64 %hash_coef.i6.i245, 4015701072841558310
  %shifted.i.i10.i249 = lshr i64 %product.i.i9.i248, 32
  %xored.i.i11.i250 = xor i64 %shifted.i.i10.i249, %product.i.i9.i248
  %hash.i.i12.i251 = and i64 %xored.i.i11.i250, %tbl_size.i7.i246
  %offset_ptr.i13.i252 = getelementptr i32, ptr %offset_tbl.i8.i247, i64 %hash.i.i12.i251
  %offset.i14.i253 = load i32, ptr %offset_ptr.i13.i252, align 4
  %118 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %109, 0
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %116, 1
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr %117, 2
  %121 = insertvalue { ptr, ptr, ptr, i32 } %120, i32 %offset.i14.i253, 3
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %109) #41
  %124 = sext i32 %offset.i14.i253 to i64
  %125 = getelementptr ptr, ptr %109, i64 %124
  %126 = getelementptr i8, ptr %125, i64 64
  %127 = load ptr, ptr %126, align 8
  %result.i2.i254 = call ptr %127({ ptr, ptr, ptr, i32 } %121, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %128 = call i32 %result.i2.i254({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull align 8 %2)
  %129 = icmp eq i32 %128, %37
  br i1 %129, label %._crit_edge.i255, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261

._crit_edge.i255:                                 ; preds = %112
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %109)
  %132 = getelementptr i8, ptr %125, i64 48
  %133 = load ptr, ptr %132, align 8
  %result.i1.i256 = call ptr %133({ ptr, ptr, ptr, i32 } %121, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %134 = call { ptr, i160 } %result.i1.i256({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull align 8 %2)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %136 = load ptr, ptr %20, align 8
  %137 = call i1 %136({ ptr, i160 } %134, { ptr, i160 } %34)
  br i1 %137, label %138, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261

138:                                              ; preds = %._crit_edge.i255
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %109)
  %141 = getelementptr i8, ptr %125, i64 56
  %142 = load ptr, ptr %141, align 8
  %result.i.i258 = call ptr %142({ ptr, ptr, ptr, i32 } %121, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %143 = call { ptr, i160 } %result.i.i258({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull align 8 %2)
  %.fca.0.extract26.i259 = extractvalue { ptr, i160 } %143, 0
  %.fca.1.extract27.i260 = extractvalue { ptr, i160 } %143, 1
  %144 = trunc i160 %.fca.1.extract27.i260 to i32
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261: ; preds = %138, %._crit_edge.i255, %112, %82
  %.reg2mem38.sroa.3.0.i237 = phi i32 [ %144, %138 ], [ poison, %._crit_edge.i255 ], [ poison, %82 ], [ poison, %112 ]
  %.reg2mem36.0.i238 = phi ptr [ %.fca.0.extract26.i259, %138 ], [ @nil_typ, %._crit_edge.i255 ], [ @nil_typ, %82 ], [ @nil_typ, %112 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.not.i = icmp eq ptr %.reg2mem36.0.i238, null
  %145 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem36.0.i238
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not99.i272.off0 = phi i32 [ %.reg2mem38.sroa.3.0.i237, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261 ], [ %extract.t273, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem17.0.i = phi ptr [ %145, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit261 ], [ %.fca.0.extract26.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %146 = icmp ne ptr %.reg2mem17.0.i, @nil_typ
  %147 = icmp ne ptr %.reg2mem17.0.i, null
  %.not299 = and i1 %146, %147
  br i1 %.not299, label %._crit_edge4, label %._crit_edge3

._crit_edge4:                                     ; preds = %CuckooMap_get_keyK.exit
  %.not303 = icmp eq i32 %0, %.not99.i272.off0
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge4, %CuckooMap_get_keyK.exit
  %.2 = phi i1 [ %.not303, %._crit_edge4 ], [ false, %CuckooMap_get_keyK.exit ]
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %149 = load i32, ptr %25, align 4
  %.not304 = icmp eq i32 %149, %0
  %150 = select i1 %.not304, i1 %.2, i1 false
  br label %RangeIterator_next_.exit52.i.preheader

151:                                              ; preds = %1
  %.sroa.gep30643 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep30944 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep31245 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep31546 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep31847 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep32148 = getelementptr inbounds i8, ptr %3, i64 24
  %152 = call i64 @clock()
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %154 = load i32, ptr %25, align 4
  %.not = icmp eq i32 %154, 0
  br label %RangeIterator_next_.exit52.i.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %151, %._crit_edge3
  %155 = phi i64 [ %32, %._crit_edge3 ], [ %152, %151 ]
  %.sroa.gep32159 = phi ptr [ %.sroa.gep321, %._crit_edge3 ], [ %.sroa.gep32148, %151 ]
  %.sroa.gep31857 = phi ptr [ %.sroa.gep318, %._crit_edge3 ], [ %.sroa.gep31847, %151 ]
  %.sroa.gep31555 = phi ptr [ %.sroa.gep315, %._crit_edge3 ], [ %.sroa.gep31546, %151 ]
  %.sroa.gep31253 = phi ptr [ %.sroa.gep312, %._crit_edge3 ], [ %.sroa.gep31245, %151 ]
  %.sroa.gep30951 = phi ptr [ %.sroa.gep309, %._crit_edge3 ], [ %.sroa.gep30944, %151 ]
  %.sroa.gep30649 = phi ptr [ %.sroa.gep306, %._crit_edge3 ], [ %.sroa.gep30643, %151 ]
  %.reg2mem15.0.in = phi i1 [ %150, %._crit_edge3 ], [ %.not, %151 ]
  %result.i21 = call noalias dereferenceable_or_null(18) ptr @bump_malloc_wrapper(i64 noundef 18) #49
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i21, align 1
  %156 = sub i64 %155, %26
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #41
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #41
  %result.i5.i = call noalias dereferenceable_or_null(18) ptr @bump_malloc_wrapper(i64 noundef 18) #49
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %162 = load i8, ptr %result.i21, align 1
  store i8 %162, ptr %result.i5.i, align 1
  %163 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %164 = getelementptr i8, ptr %result.i21, i64 1
  %wide.load = load <16 x i8>, ptr %164, align 1
  %165 = getelementptr i8, ptr %result.i5.i, i64 1
  store <16 x i8> %wide.load, ptr %165, align 1
  %166 = getelementptr i8, ptr %result.i5.i, i64 17
  store i8 0, ptr %166, align 1
  %puts.i305 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #54
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %167 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %167, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #56
  %168 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #56
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %169 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %169, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #56
  %170 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %156) #56
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #56
  br i1 %27, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader
  %171 = zext nneg i32 %0 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %172 = mul i64 %156, 1000000
  %173 = sdiv i64 %172, %171
  %174 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %174, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #56
  %175 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %173) #56
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %177 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #56
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i.h2s302, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s302, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep, align 1
  %182 = getelementptr inbounds i8, ptr %result.i5.i.h2s302, i64 18
  store i8 0, ptr %182, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i.h2s302) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.0.extract = select i1 %.reg2mem15.0.in, i8 80, i8 70
  %.sroa.0197.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0197.3 = select i1 %.reg2mem15.0.in, <4 x i8> %.sroa.0197.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0197.1.vec.insert = insertelement <4 x i8> %.sroa.0197.3, i8 65, i64 1
  %.fca.2.extract = select i1 %.reg2mem15.0.in, i8 83, i8 73
  %.sroa.0197.2 = select i1 %.reg2mem15.0.in, <4 x i8> %.sroa.0197.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0197.2.vec.insert = insertelement <4 x i8> %.sroa.0197.2, i8 %.fca.2.extract, i64 2
  %.fca.3.extract = select i1 %.reg2mem15.0.in, i8 83, i8 76
  %.sroa.0197.1 = select i1 %.reg2mem15.0.in, <4 x i8> %.sroa.0197.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0197.3.vec.insert = insertelement <4 x i8> %.sroa.0197.1, i8 %.fca.3.extract, i64 3
  br i1 %.reg2mem15.0.in, label %RangeIterator_next_.exit52.i290.preheader, label %.else

.else:                                            ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i290.preheader

RangeIterator_next_.exit52.i290.preheader:        ; preds = %.else, %print_benchmark_result.exit
  %.sroa.speculated196 = phi <4 x i8> [ <i8 70, i8 65, i8 73, i8 76>, %.else ], [ %.sroa.0197.3.vec.insert, %print_benchmark_result.exit ]
  %183 = phi ptr [ %10, %.else ], [ %6, %print_benchmark_result.exit ]
  %184 = phi ptr [ %9, %.else ], [ %5, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %.else ], [ %.sroa.gep30649, %print_benchmark_result.exit ]
  %.sroa.phi307 = phi ptr [ %.sroa.gep308, %.else ], [ %.sroa.gep30951, %print_benchmark_result.exit ]
  %.sroa.phi310 = phi ptr [ %.sroa.gep311, %.else ], [ %.sroa.gep31253, %print_benchmark_result.exit ]
  %185 = phi ptr [ %8, %.else ], [ %4, %print_benchmark_result.exit ]
  %.sroa.phi313 = phi ptr [ %.sroa.gep314, %.else ], [ %.sroa.gep31555, %print_benchmark_result.exit ]
  %.sroa.phi316 = phi ptr [ %.sroa.gep317, %.else ], [ %.sroa.gep31857, %print_benchmark_result.exit ]
  %.sroa.phi319 = phi ptr [ %.sroa.gep320, %.else ], [ %.sroa.gep32159, %print_benchmark_result.exit ]
  %186 = phi ptr [ %7, %.else ], [ %3, %print_benchmark_result.exit ]
  store ptr @_parameterization_Bufferi8, ptr %186, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi313, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi316, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi319, align 8
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %186)
  store ptr @buffer_typ, ptr %185, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi307, align 8
  store ptr @i32_typ, ptr %.sroa.phi310, align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %185) #41
  store ptr @_parameterization_String, ptr %184, align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %184)
  %190 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %183, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %183) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %result.i17.h2s301.sroa.0.0.vec.extract = extractelement <4 x i8> %.sroa.speculated196, i64 0
  store i8 %result.i17.h2s301.sroa.0.0.vec.extract, ptr %result.i5.i287.h2s300, align 1
  %scevgep295 = getelementptr inbounds i8, ptr %result.i5.i287.h2s300, i64 1
  %result.i17.h2s301.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sroa.speculated196, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i17.h2s301.sroa.0.1.vec.extract, ptr %scevgep295, align 1
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %197 = getelementptr inbounds i8, ptr %result.i5.i287.h2s300, i64 4
  store i8 0, ptr %197, align 1
  %puts.i177 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i287.h2s300) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #8

declare i64 @clock() local_unnamed_addr #18

define void @benchmark_insert_random(i32 %0) local_unnamed_addr #18 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i577.h2s600 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i5.i577.h2s600, align 2
  %result.i5.i558.h2s602 = alloca [28 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(28) %result.i5.i558.h2s602, i8 0, i64 28, i1 false)
  %result.i5.i539.h2s604 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i539.h2s604, i8 0, i64 5, i1 false)
  %result.i5.i.h2s606 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i.h2s606, i8 0, i64 19, i1 false)
  %oldProtect.i59 = alloca i32, align 4
  %oldProtect.i57 = alloca i32, align 4
  %oldProtect.i55 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0393.sroa.0 = alloca i8, align 8
  %3 = alloca [4 x ptr], align 8
  %4 = alloca { ptr, ptr, ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %result.i53 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i53, align 8
  %11 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i53) #41
  %result.i52 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  %result.i54 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i52, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i52, ptr noalias nofree noundef nonnull readnone @qbiggiwwnd, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i35 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i52) #48
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i52) #41
  %result.i51 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i55) #41
  %result.i56 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i51, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i55) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i55) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i51, ptr noalias nofree noundef nonnull readnone @xzhnfrekfk, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i34 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i51) #48
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i51) #41
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i53, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 10, 3
  %19 = getelementptr inbounds i8, ptr %result.i53, i64 48
  store ptr %ret.i35, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i53, i64 56
  store ptr %ret.i34, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i53, i64 40
  store i32 8, ptr %21, align 8
  %result.i1.i134 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %22 = getelementptr inbounds i8, ptr %result.i53, i64 24
  store ptr %result.i1.i134, ptr %22, align 8
  %result.i.i135 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %23 = getelementptr inbounds i8, ptr %result.i53, i64 32
  store ptr %result.i.i135, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %25 = getelementptr inbounds i8, ptr %result.i53, i64 44
  store i32 0, ptr %25, align 4
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #41
  %27 = sext i32 %0 to i64
  %28 = shl nsw i64 %27, 2
  %result.i2.i163 = call noalias ptr @bump_malloc_wrapper(i64 noundef %28) #49
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  %result.i48 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i48, align 8
  %30 = getelementptr inbounds i8, ptr %result.i48, i64 8
  store ptr @_parameterization_Bool, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %result.i48, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i48) #41
  %result.i47 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i57) #41
  %result.i58 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i47, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i57) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i57) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i47, ptr noalias nofree noundef nonnull readnone @mzrpmlixaa, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i33 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i47) #48
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i47) #41
  %result.i46 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i59) #41
  %result.i60 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i46, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i59) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i59) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i46, ptr noalias nofree noundef nonnull readnone @aslhbjemhr, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i46) #48
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i46) #41
  %35 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i48, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr undef, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 10, 3
  %38 = getelementptr inbounds i8, ptr %result.i48, i64 48
  store ptr %ret.i33, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %result.i48, i64 56
  store ptr %ret.i, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i48, i64 40
  store i32 8, ptr %40, align 8
  %result.i1.i177 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %41 = getelementptr inbounds i8, ptr %result.i48, i64 24
  store ptr %result.i1.i177, ptr %41, align 8
  %result.i.i178 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %42 = getelementptr inbounds i8, ptr %result.i48, i64 32
  store ptr %result.i.i178, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %result.i48, i64 44
  store i32 0, ptr %43, align 4
  %.sroa.gep = getelementptr inbounds i8, ptr %8, i64 8
  %.sroa.gep436 = getelementptr inbounds i8, ptr %8, i64 16
  %.sroa.gep439 = getelementptr inbounds i8, ptr %8, i64 24
  %.sroa.gep442 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep445 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep448 = getelementptr inbounds i8, ptr %7, i64 24
  %44 = icmp sgt i32 %0, 0
  br i1 %44, label %._crit_edge.lr.ph, label %._crit_edge2._crit_edge.thread

._crit_edge2._crit_edge.thread:                   ; preds = %1
  %.sroa.gep434420 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep440421 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep446422 = getelementptr inbounds i8, ptr %3, i64 16
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %46 = call i64 @clock()
  %.sroa.gep437125 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep443126 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep449127 = getelementptr inbounds i8, ptr %3, i64 24
  %47 = call i64 @clock()
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %49 = load i32, ptr %25, align 4
  %.not = icmp eq i32 %49, 0
  br label %RangeIterator_next_.exit52.i.preheader

._crit_edge.lr.ph:                                ; preds = %1
  %50 = add nsw i32 %0, -1
  %51 = zext nneg i32 %50 to i64
  %52 = zext nneg i32 %0 to i64
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #44
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %55 = phi i32 [ 123, %._crit_edge.lr.ph ], [ %58, %._crit_edge ]
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %.0116 = phi i32 [ -1, %._crit_edge.lr.ph ], [ %spec.select, %._crit_edge ]
  %56 = mul i32 %55, 1103515245
  %57 = add i32 %56, 12345
  %58 = and i32 %57, 2147483647
  %.sroa.0403.0.insert.ext = zext nneg i32 %58 to i160
  %59 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0403.0.insert.ext, 1
  %60 = shl i64 %indvars.iv, 2
  %61 = getelementptr i8, ptr %result.i2.i163, i64 %60
  store i32 %58, ptr %61, align 1
  %62 = icmp eq i64 %indvars.iv, %51
  %spec.select = select i1 %62, i32 %58, i32 %.0116
  store i1 true, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. = load i8, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.0.insert.ext = zext i8 %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. to i160
  %63 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0393.0.insert.ext, 1
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %59, { ptr, i160 } %63)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %52
  br i1 %exitcond.not, label %._crit_edge2._crit_edge, label %._crit_edge

._crit_edge2._crit_edge:                          ; preds = %._crit_edge
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %66 = load i32, ptr %43, align 4
  %67 = call i64 @clock()
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge3, %._crit_edge2._crit_edge
  %indvars.iv352 = phi i64 [ 0, %._crit_edge2._crit_edge ], [ %indvars.iv.next353, %._crit_edge3 ]
  %70 = shl i64 %indvars.iv352, 2
  %71 = getelementptr i8, ptr %result.i2.i163, i64 %70
  %72 = load i32, ptr %71, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %72 to i160
  %73 = add i32 %72, 1
  %74 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %.sroa.0373.0.insert.ext = zext i32 %73 to i160
  %75 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0373.0.insert.ext, 1
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %74, { ptr, i160 } %75)
  %indvars.iv.next353 = add nuw nsw i64 %indvars.iv352, 1
  %exitcond123.not = icmp eq i64 %indvars.iv.next353, %52
  br i1 %exitcond123.not, label %._crit_edge5, label %._crit_edge3

._crit_edge5:                                     ; preds = %._crit_edge3
  %.sroa.gep440 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep434 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep446 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep437 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep443 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep449 = getelementptr inbounds i8, ptr %3, i64 24
  %76 = call i64 @clock()
  %.sroa.0364.0.insert.ext = zext i32 %spec.select to i160
  %77 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0364.0.insert.ext, 1
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %79 = load ptr, ptr %19, align 8
  %80 = call i32 %79({ ptr, i160 } %77)
  %81 = load i32, ptr %21, align 8
  %82 = add i32 %81, -1
  %83 = and i32 %82, %80
  %84 = load ptr, ptr %22, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %86 = sext i32 %83 to i64
  %87 = shl nsw i64 %86, 5
  %88 = getelementptr i8, ptr %84, i64 %87
  %89 = load ptr, ptr %88, align 8
  %90 = icmp ne ptr %89, @nil_typ
  %91 = icmp ne ptr %89, null
  %.not48.i = and i1 %90, %91
  br i1 %.not48.i, label %92, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

92:                                               ; preds = %._crit_edge5
  %93 = getelementptr i8, ptr %88, i64 8
  %94 = load i64, ptr %93, align 4
  %.sroa_idx.i = getelementptr i8, ptr %88, i64 16
  %95 = load i64, ptr %.sroa_idx.i, align 4
  %96 = inttoptr i64 %94 to ptr
  %97 = inttoptr i64 %95 to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %89, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %89, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %89, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %89, 0
  %99 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %96, 1
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr %97, 2
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, i32 %offset.i14.i, 3
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %89) #41
  %104 = sext i32 %offset.i14.i to i64
  %105 = getelementptr ptr, ptr %89, i64 %104
  %106 = getelementptr i8, ptr %105, i64 64
  %107 = load ptr, ptr %106, align 8
  %result.i2.i = call ptr %107({ ptr, ptr, ptr, i32 } %101, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %108 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr nonnull align 8 %2)
  %109 = icmp eq i32 %108, %80
  br i1 %109, label %._crit_edge.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i:                                    ; preds = %92
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %89)
  %112 = getelementptr i8, ptr %105, i64 48
  %113 = load ptr, ptr %112, align 8
  %result.i1.i = call ptr %113({ ptr, ptr, ptr, i32 } %101, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %114 = call { ptr, i160 } %result.i1.i({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr nonnull align 8 %2)
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %116 = load ptr, ptr %20, align 8
  %117 = call i1 %116({ ptr, i160 } %114, { ptr, i160 } %77)
  br i1 %117, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i, %92, %._crit_edge5
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %125

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %89)
  %120 = getelementptr i8, ptr %105, i64 56
  %121 = load ptr, ptr %120, align 8
  %result.i.i458 = call ptr %121({ ptr, ptr, ptr, i32 } %101, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %122 = call { ptr, i160 } %result.i.i458({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr nonnull align 8 %2)
  %.fca.0.extract26.i = extractvalue { ptr, i160 } %122, 0
  %.fca.1.extract27.i = extractvalue { ptr, i160 } %122, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %123 = icmp ne ptr %.fca.0.extract26.i, @nil_typ
  %124 = icmp ne ptr %.fca.0.extract26.i, null
  %.not99.i = and i1 %123, %124
  %extract.t525 = trunc i160 %.fca.1.extract27.i to i32
  br i1 %.not99.i, label %CuckooMap_get_keyK.exit, label %125

125:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %126 = add i32 %80, 2127912214
  %127 = shl i32 %80, 12
  %128 = add i32 %126, %127
  %129 = ashr i32 %128, 19
  %130 = xor i32 %128, %129
  %131 = xor i32 %130, -949894596
  %132 = add i32 %131, 374761393
  %133 = shl i32 %131, 5
  %134 = add i32 %132, %133
  %135 = add i32 %134, -744332180
  %136 = shl i32 %134, 9
  %137 = xor i32 %135, %136
  %138 = add i32 %137, -42973499
  %139 = shl i32 %137, 3
  %140 = add i32 %138, %139
  %141 = ashr i32 %140, 16
  %142 = xor i32 %140, %141
  %143 = xor i32 %142, -1252372727
  %144 = load i32, ptr %21, align 8
  %145 = add i32 %144, -1
  %146 = and i32 %145, %143
  %147 = load ptr, ptr %23, align 8
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %149 = sext i32 %146 to i64
  %150 = shl nsw i64 %149, 5
  %151 = getelementptr i8, ptr %147, i64 %150
  %152 = load ptr, ptr %151, align 8
  %153 = icmp ne ptr %152, @nil_typ
  %154 = icmp ne ptr %152, null
  %.not48.i488 = and i1 %153, %154
  br i1 %.not48.i488, label %155, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513

155:                                              ; preds = %125
  %156 = getelementptr i8, ptr %151, i64 8
  %157 = load i64, ptr %156, align 4
  %.sroa_idx.i493 = getelementptr i8, ptr %151, i64 16
  %158 = load i64, ptr %.sroa_idx.i493, align 4
  %159 = inttoptr i64 %157 to ptr
  %160 = inttoptr i64 %158 to ptr
  %hash_coef_ptr.i3.i494 = getelementptr i8, ptr %152, i64 8
  %tbl_size_ptr.i4.i495 = getelementptr i8, ptr %152, i64 16
  %offset_tbl_ptr.i5.i496 = getelementptr i8, ptr %152, i64 40
  %hash_coef.i6.i497 = load i64, ptr %hash_coef_ptr.i3.i494, align 4
  %tbl_size.i7.i498 = load i64, ptr %tbl_size_ptr.i4.i495, align 4
  %offset_tbl.i8.i499 = load ptr, ptr %offset_tbl_ptr.i5.i496, align 8
  %product.i.i9.i500 = mul i64 %hash_coef.i6.i497, 4015701072841558310
  %shifted.i.i10.i501 = lshr i64 %product.i.i9.i500, 32
  %xored.i.i11.i502 = xor i64 %shifted.i.i10.i501, %product.i.i9.i500
  %hash.i.i12.i503 = and i64 %xored.i.i11.i502, %tbl_size.i7.i498
  %offset_ptr.i13.i504 = getelementptr i32, ptr %offset_tbl.i8.i499, i64 %hash.i.i12.i503
  %offset.i14.i505 = load i32, ptr %offset_ptr.i13.i504, align 4
  %161 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %152, 0
  %162 = insertvalue { ptr, ptr, ptr, i32 } %161, ptr %159, 1
  %163 = insertvalue { ptr, ptr, ptr, i32 } %162, ptr %160, 2
  %164 = insertvalue { ptr, ptr, ptr, i32 } %163, i32 %offset.i14.i505, 3
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %152) #41
  %167 = sext i32 %offset.i14.i505 to i64
  %168 = getelementptr ptr, ptr %152, i64 %167
  %169 = getelementptr i8, ptr %168, i64 64
  %170 = load ptr, ptr %169, align 8
  %result.i2.i506 = call ptr %170({ ptr, ptr, ptr, i32 } %164, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %171 = call i32 %result.i2.i506({ ptr, ptr, ptr, i32 } %164, { ptr, ptr, ptr, i32 } %164, ptr nonnull align 8 %2)
  %172 = icmp eq i32 %171, %80
  br i1 %172, label %._crit_edge.i507, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513

._crit_edge.i507:                                 ; preds = %155
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %152)
  %175 = getelementptr i8, ptr %168, i64 48
  %176 = load ptr, ptr %175, align 8
  %result.i1.i508 = call ptr %176({ ptr, ptr, ptr, i32 } %164, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %177 = call { ptr, i160 } %result.i1.i508({ ptr, ptr, ptr, i32 } %164, { ptr, ptr, ptr, i32 } %164, ptr nonnull align 8 %2)
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %179 = load ptr, ptr %20, align 8
  %180 = call i1 %179({ ptr, i160 } %177, { ptr, i160 } %77)
  br i1 %180, label %181, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513

181:                                              ; preds = %._crit_edge.i507
  %182 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %152)
  %184 = getelementptr i8, ptr %168, i64 56
  %185 = load ptr, ptr %184, align 8
  %result.i.i510 = call ptr %185({ ptr, ptr, ptr, i32 } %164, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %186 = call { ptr, i160 } %result.i.i510({ ptr, ptr, ptr, i32 } %164, { ptr, ptr, ptr, i32 } %164, ptr nonnull align 8 %2)
  %.fca.0.extract26.i511 = extractvalue { ptr, i160 } %186, 0
  %.fca.1.extract27.i512 = extractvalue { ptr, i160 } %186, 1
  %187 = trunc i160 %.fca.1.extract27.i512 to i32
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513: ; preds = %181, %._crit_edge.i507, %155, %125
  %.reg2mem38.sroa.3.0.i489 = phi i32 [ %187, %181 ], [ poison, %._crit_edge.i507 ], [ poison, %125 ], [ poison, %155 ]
  %.reg2mem36.0.i490 = phi ptr [ %.fca.0.extract26.i511, %181 ], [ @nil_typ, %._crit_edge.i507 ], [ @nil_typ, %125 ], [ @nil_typ, %155 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.not.i = icmp eq ptr %.reg2mem36.0.i490, null
  %188 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem36.0.i490
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not99.i524.off0 = phi i32 [ %.reg2mem38.sroa.3.0.i489, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513 ], [ %extract.t525, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem17.0.i = phi ptr [ %188, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit513 ], [ %.fca.0.extract26.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %189 = icmp ne ptr %.reg2mem17.0.i, @nil_typ
  %190 = icmp ne ptr %.reg2mem17.0.i, null
  %.not426 = and i1 %189, %190
  br i1 %.not426, label %._crit_edge7, label %._crit_edge6

._crit_edge7:                                     ; preds = %CuckooMap_get_keyK.exit
  %191 = add i32 %spec.select, 1
  %.not430 = icmp eq i32 %191, %.not99.i524.off0
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge7, %CuckooMap_get_keyK.exit
  %.2414 = phi i1 [ %.not430, %._crit_edge7 ], [ false, %CuckooMap_get_keyK.exit ]
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %193 = load i32, ptr %25, align 4
  %.not431 = icmp eq i32 %193, %66
  %194 = select i1 %.not431, i1 %.2414, i1 false
  br label %RangeIterator_next_.exit52.i.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge6, %._crit_edge2._crit_edge.thread
  %195 = phi i64 [ %67, %._crit_edge6 ], [ %46, %._crit_edge2._crit_edge.thread ]
  %196 = phi i32 [ %66, %._crit_edge6 ], [ 0, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep446427 = phi ptr [ %.sroa.gep446, %._crit_edge6 ], [ %.sroa.gep446422, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep440425 = phi ptr [ %.sroa.gep440, %._crit_edge6 ], [ %.sroa.gep440421, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep434423 = phi ptr [ %.sroa.gep434, %._crit_edge6 ], [ %.sroa.gep434420, %._crit_edge2._crit_edge.thread ]
  %197 = phi i64 [ %76, %._crit_edge6 ], [ %47, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep449132 = phi ptr [ %.sroa.gep449, %._crit_edge6 ], [ %.sroa.gep449127, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep443130 = phi ptr [ %.sroa.gep443, %._crit_edge6 ], [ %.sroa.gep443126, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep437128 = phi ptr [ %.sroa.gep437, %._crit_edge6 ], [ %.sroa.gep437125, %._crit_edge2._crit_edge.thread ]
  %.reg2mem21.0.in = phi i1 [ %194, %._crit_edge6 ], [ %.not, %._crit_edge2._crit_edge.thread ]
  %result.i45 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #49
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i45, align 1
  %198 = sub i64 %197, %195
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #41
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #41
  %result.i5.i = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #49
  %202 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %204 = load i8, ptr %result.i45, align 1
  store i8 %204, ptr %result.i5.i, align 1
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %206 = getelementptr i8, ptr %result.i45, i64 1
  %207 = load i8, ptr %206, align 1
  %208 = getelementptr i8, ptr %result.i5.i, i64 1
  store i8 %207, ptr %208, align 1
  %209 = getelementptr i8, ptr %result.i45, i64 2
  %210 = load i8, ptr %209, align 1
  %211 = getelementptr i8, ptr %result.i5.i, i64 2
  store i8 %210, ptr %211, align 1
  %212 = getelementptr i8, ptr %result.i45, i64 3
  %213 = load i8, ptr %212, align 1
  %214 = getelementptr i8, ptr %result.i5.i, i64 3
  store i8 %213, ptr %214, align 1
  %215 = getelementptr i8, ptr %result.i45, i64 4
  %216 = load i8, ptr %215, align 1
  %217 = getelementptr i8, ptr %result.i5.i, i64 4
  store i8 %216, ptr %217, align 1
  %218 = getelementptr i8, ptr %result.i45, i64 5
  %219 = load i8, ptr %218, align 1
  %220 = getelementptr i8, ptr %result.i5.i, i64 5
  store i8 %219, ptr %220, align 1
  %221 = getelementptr i8, ptr %result.i45, i64 6
  %222 = load i8, ptr %221, align 1
  %223 = getelementptr i8, ptr %result.i5.i, i64 6
  store i8 %222, ptr %223, align 1
  %224 = getelementptr i8, ptr %result.i45, i64 7
  %225 = load i8, ptr %224, align 1
  %226 = getelementptr i8, ptr %result.i5.i, i64 7
  store i8 %225, ptr %226, align 1
  %227 = getelementptr i8, ptr %result.i45, i64 8
  %228 = load i8, ptr %227, align 1
  %229 = getelementptr i8, ptr %result.i5.i, i64 8
  store i8 %228, ptr %229, align 1
  %230 = getelementptr i8, ptr %result.i45, i64 9
  %231 = load i8, ptr %230, align 1
  %232 = getelementptr i8, ptr %result.i5.i, i64 9
  store i8 %231, ptr %232, align 1
  %233 = getelementptr i8, ptr %result.i45, i64 10
  %234 = load i8, ptr %233, align 1
  %235 = getelementptr i8, ptr %result.i5.i, i64 10
  store i8 %234, ptr %235, align 1
  %236 = getelementptr i8, ptr %result.i45, i64 11
  %237 = load i8, ptr %236, align 1
  %238 = getelementptr i8, ptr %result.i5.i, i64 11
  store i8 %237, ptr %238, align 1
  %239 = getelementptr i8, ptr %result.i45, i64 12
  %240 = load i8, ptr %239, align 1
  %241 = getelementptr i8, ptr %result.i5.i, i64 12
  store i8 %240, ptr %241, align 1
  %242 = getelementptr i8, ptr %result.i5.i, i64 13
  store i8 0, ptr %242, align 1
  %puts.i609 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #54
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %243 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %243, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #56
  %244 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #56
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %245 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %245, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #56
  %246 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %198) #56
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #56
  br i1 %44, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader
  %247 = zext nneg i32 %0 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %248 = mul i64 %198, 1000000
  %249 = sdiv i64 %248, %247
  %250 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %250, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #56
  %251 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %249) #56
  %252 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %253 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %254 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %255 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #56
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %256 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %257 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i.h2s606, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s606, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep, align 1
  %258 = getelementptr inbounds i8, ptr %result.i5.i.h2s606, i64 18
  store i8 0, ptr %258, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i.h2s606) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.0.extract = select i1 %.reg2mem21.0.in, i8 80, i8 70
  %.sroa.0290.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0290.3 = select i1 %.reg2mem21.0.in, <4 x i8> %.sroa.0290.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0290.1.vec.insert = insertelement <4 x i8> %.sroa.0290.3, i8 65, i64 1
  %.fca.2.extract = select i1 %.reg2mem21.0.in, i8 83, i8 73
  %.sroa.0290.2 = select i1 %.reg2mem21.0.in, <4 x i8> %.sroa.0290.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0290.2.vec.insert = insertelement <4 x i8> %.sroa.0290.2, i8 %.fca.2.extract, i64 2
  %.fca.3.extract = select i1 %.reg2mem21.0.in, i8 83, i8 76
  %.sroa.0290.1 = select i1 %.reg2mem21.0.in, <4 x i8> %.sroa.0290.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0290.3.vec.insert = insertelement <4 x i8> %.sroa.0290.1, i8 %.fca.3.extract, i64 3
  br i1 %.reg2mem21.0.in, label %RangeIterator_next_.exit52.i542.preheader, label %.else

.else:                                            ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i542.preheader

RangeIterator_next_.exit52.i542.preheader:        ; preds = %.else, %print_benchmark_result.exit
  %.sroa.speculated289 = phi <4 x i8> [ <i8 70, i8 65, i8 73, i8 76>, %.else ], [ %.sroa.0290.3.vec.insert, %print_benchmark_result.exit ]
  %259 = phi ptr [ %10, %.else ], [ %6, %print_benchmark_result.exit ]
  %260 = phi ptr [ %9, %.else ], [ %5, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %.else ], [ %.sroa.gep434423, %print_benchmark_result.exit ]
  %.sroa.phi435 = phi ptr [ %.sroa.gep436, %.else ], [ %.sroa.gep437128, %print_benchmark_result.exit ]
  %.sroa.phi438 = phi ptr [ %.sroa.gep439, %.else ], [ %.sroa.gep440425, %print_benchmark_result.exit ]
  %261 = phi ptr [ %8, %.else ], [ %4, %print_benchmark_result.exit ]
  %.sroa.phi441 = phi ptr [ %.sroa.gep442, %.else ], [ %.sroa.gep443130, %print_benchmark_result.exit ]
  %.sroa.phi444 = phi ptr [ %.sroa.gep445, %.else ], [ %.sroa.gep446427, %print_benchmark_result.exit ]
  %.sroa.phi447 = phi ptr [ %.sroa.gep448, %.else ], [ %.sroa.gep449132, %print_benchmark_result.exit ]
  %262 = phi ptr [ %7, %.else ], [ %3, %print_benchmark_result.exit ]
  store ptr @_parameterization_Bufferi8, ptr %262, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi441, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi444, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi447, align 8
  %263 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %262)
  store ptr @buffer_typ, ptr %261, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi435, align 8
  store ptr @i32_typ, ptr %.sroa.phi438, align 8
  %264 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %261) #41
  store ptr @_parameterization_String, ptr %260, align 8
  %265 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %260)
  store ptr @String, ptr %259, align 8
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %259) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %267 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %268 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %result.i41.h2s605.sroa.0.0.vec.extract = extractelement <4 x i8> %.sroa.speculated289, i64 0
  store i8 %result.i41.h2s605.sroa.0.0.vec.extract, ptr %result.i5.i539.h2s604, align 1
  %scevgep587 = getelementptr inbounds i8, ptr %result.i5.i539.h2s604, i64 1
  %result.i41.h2s605.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sroa.speculated289, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i41.h2s605.sroa.0.1.vec.extract, ptr %scevgep587, align 1
  %269 = getelementptr inbounds i8, ptr %result.i5.i539.h2s604, i64 4
  store i8 0, ptr %269, align 1
  %puts.i376 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i539.h2s604) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %270 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %271 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i558.h2s602, align 1
  %scevgep592 = getelementptr inbounds i8, ptr %result.i5.i558.h2s602, i64 1
  store <26 x i8> <i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %scevgep592, align 1
  %272 = getelementptr inbounds i8, ptr %result.i5.i558.h2s602, i64 27
  store i8 0, ptr %272, align 1
  %puts.i397 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(28) %result.i5.i558.h2s602) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %273 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %196) #56
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 41, ptr %result.i5.i577.h2s600, align 2
  %278 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %279 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %280 = getelementptr inbounds i8, ptr %result.i5.i577.h2s600, i64 1
  store i8 0, ptr %280, align 1
  %puts.i418 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i5.i577.h2s600) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr #18 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i353.h2s376 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i353.h2s376, i8 0, i64 5, i1 false)
  %result.i5.i334.h2s378 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i334.h2s378, i8 0, i64 19, i1 false)
  %oldProtect.i30 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %3 = alloca [4 x ptr], align 8
  %4 = alloca [4 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %result.i28 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i28, align 8
  %12 = getelementptr inbounds i8, ptr %result.i28, i64 8
  store ptr @_parameterization_i32, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i28, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i28) #41
  %result.i27 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  %result.i29 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i27, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i27, ptr noalias nofree noundef nonnull readnone @ihchcttgxk, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i17 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i27) #48
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i27) #41
  %result.i26 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i30) #41
  %result.i31 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i26, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i30) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i30) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i26, ptr noalias nofree noundef nonnull readnone @eejnmacokr, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i26) #48
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i26) #41
  %17 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i28, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr undef, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 10, 3
  %20 = getelementptr inbounds i8, ptr %result.i28, i64 48
  store ptr %ret.i17, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i28, i64 56
  store ptr %ret.i, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i28, i64 40
  store i32 8, ptr %22, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %23 = getelementptr inbounds i8, ptr %result.i28, i64 24
  store ptr %result.i1.i, ptr %23, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %24 = getelementptr inbounds i8, ptr %result.i28, i64 32
  store ptr %result.i.i, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %26 = getelementptr inbounds i8, ptr %result.i28, i64 44
  store i32 0, ptr %26, align 4
  %.sroa.gep = getelementptr inbounds i8, ptr %9, i64 8
  %.sroa.gep316 = getelementptr inbounds i8, ptr %9, i64 16
  %.sroa.gep319 = getelementptr inbounds i8, ptr %9, i64 24
  %.sroa.gep322 = getelementptr inbounds i8, ptr %8, i64 8
  %.sroa.gep325 = getelementptr inbounds i8, ptr %8, i64 16
  %.sroa.gep328 = getelementptr inbounds i8, ptr %8, i64 24
  %27 = icmp sgt i32 %0, 0
  br i1 %27, label %._crit_edge.preheader, label %._crit_edge1._crit_edge.thread

._crit_edge1._crit_edge.thread:                   ; preds = %1
  %.sroa.gep31497 = getelementptr inbounds i8, ptr %5, i64 8
  %.sroa.gep32098 = getelementptr inbounds i8, ptr %5, i64 24
  %.sroa.gep32699 = getelementptr inbounds i8, ptr %4, i64 16
  %28 = call i64 @clock()
  %29 = getelementptr inbounds i8, ptr %3, i64 16
  br label %RangeIterator_next_.exit52.i.preheader387

._crit_edge.preheader:                            ; preds = %1
  %wide.trip.count = zext nneg i32 %0 to i64
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.preheader
  %indvars.iv = phi i64 [ 0, %._crit_edge.preheader ], [ %indvars.iv.next, %._crit_edge ]
  %.029872 = phi i64 [ 0, %._crit_edge.preheader ], [ %33, %._crit_edge ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %.sroa.0292.0.insert.ext = zext nneg i64 %indvars.iv to i160
  %31 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0292.0.insert.ext, 1
  %.sroa.0289.0.insert.ext = zext nneg i64 %indvars.iv.next to i160
  %32 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0289.0.insert.ext, 1
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %31, { ptr, i160 } %32)
  %33 = add i64 %.029872, %indvars.iv.next
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %._crit_edge
  %34 = call i64 @clock()
  %35 = getelementptr inbounds i8, ptr %3, i64 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %37

37:                                               ; preds = %._crit_edge2, %.lr.ph
  %.284 = phi i32 [ 0, %.lr.ph ], [ %166, %._crit_edge2 ]
  %.030083 = phi i64 [ 0, %.lr.ph ], [ %.1301, %._crit_edge2 ]
  %.030382 = phi i1 [ true, %.lr.ph ], [ %.1304, %._crit_edge2 ]
  %.sroa.0276.0.insert.ext = zext nneg i32 %.284 to i160
  %38 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0276.0.insert.ext, 1
  %39 = load ptr, ptr %20, align 8
  %40 = call i32 %39({ ptr, i160 } %38)
  %41 = load i32, ptr %22, align 8
  %42 = add i32 %41, -1
  %43 = and i32 %42, %40
  %44 = load ptr, ptr %23, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %46 = sext i32 %43 to i64
  %47 = shl nsw i64 %46, 5
  %48 = getelementptr i8, ptr %44, i64 %47
  %49 = load ptr, ptr %48, align 8
  %50 = icmp ne ptr %49, @nil_typ
  %51 = icmp ne ptr %49, null
  %.not48.i = and i1 %50, %51
  br i1 %.not48.i, label %52, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

52:                                               ; preds = %37
  %53 = getelementptr i8, ptr %48, i64 8
  %54 = load i64, ptr %53, align 4
  %.sroa_idx.i = getelementptr i8, ptr %48, i64 16
  %55 = load i64, ptr %.sroa_idx.i, align 4
  %56 = inttoptr i64 %54 to ptr
  %57 = inttoptr i64 %55 to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %49, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %49, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %49, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %58 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %49, 0
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %56, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %57, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %offset.i14.i, 3
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %49) #41
  %64 = sext i32 %offset.i14.i to i64
  %65 = getelementptr ptr, ptr %49, i64 %64
  %66 = getelementptr i8, ptr %65, i64 64
  %67 = load ptr, ptr %66, align 8
  %result.i2.i = call ptr %67({ ptr, ptr, ptr, i32 } %61, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %68 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull align 8 %2)
  %69 = icmp eq i32 %68, %40
  br i1 %69, label %._crit_edge.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i:                                    ; preds = %52
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %49)
  %72 = getelementptr i8, ptr %65, i64 48
  %73 = load ptr, ptr %72, align 8
  %result.i1.i253 = call ptr %73({ ptr, ptr, ptr, i32 } %61, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %74 = call { ptr, i160 } %result.i1.i253({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull align 8 %2)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %76 = load ptr, ptr %21, align 8
  %77 = call i1 %76({ ptr, i160 } %74, { ptr, i160 } %38)
  br i1 %77, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i, %52, %37
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %86

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %49)
  %80 = getelementptr i8, ptr %65, i64 56
  %81 = load ptr, ptr %80, align 8
  %result.i.i254 = call ptr %81({ ptr, ptr, ptr, i32 } %61, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %82 = call { ptr, i160 } %result.i.i254({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull align 8 %2)
  %.fca.0.extract26.i = extractvalue { ptr, i160 } %82, 0
  %.fca.1.extract27.i = extractvalue { ptr, i160 } %82, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %84 = icmp ne ptr %.fca.0.extract26.i, @nil_typ
  %85 = icmp ne ptr %.fca.0.extract26.i, null
  %.not99.i = and i1 %84, %85
  %extract.t320 = trunc i160 %.fca.1.extract27.i to i64
  br i1 %.not99.i, label %CuckooMap_get_keyK.exit, label %86

86:                                               ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %87 = add i32 %40, 2127912214
  %88 = shl i32 %40, 12
  %89 = add i32 %87, %88
  %90 = ashr i32 %89, 19
  %91 = xor i32 %89, %90
  %92 = xor i32 %91, -949894596
  %93 = add i32 %92, 374761393
  %94 = shl i32 %92, 5
  %95 = add i32 %93, %94
  %96 = add i32 %95, -744332180
  %97 = shl i32 %95, 9
  %98 = xor i32 %96, %97
  %99 = add i32 %98, -42973499
  %100 = shl i32 %98, 3
  %101 = add i32 %99, %100
  %102 = ashr i32 %101, 16
  %103 = xor i32 %101, %102
  %104 = xor i32 %103, -1252372727
  %105 = load i32, ptr %22, align 8
  %106 = add i32 %105, -1
  %107 = and i32 %106, %104
  %108 = load ptr, ptr %24, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %110 = sext i32 %107 to i64
  %111 = shl nsw i64 %110, 5
  %112 = getelementptr i8, ptr %108, i64 %111
  %113 = load ptr, ptr %112, align 8
  %114 = icmp ne ptr %113, @nil_typ
  %115 = icmp ne ptr %113, null
  %.not48.i284 = and i1 %114, %115
  br i1 %.not48.i284, label %116, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309

116:                                              ; preds = %86
  %117 = getelementptr i8, ptr %112, i64 8
  %118 = load i64, ptr %117, align 4
  %.sroa_idx.i289 = getelementptr i8, ptr %112, i64 16
  %119 = load i64, ptr %.sroa_idx.i289, align 4
  %120 = inttoptr i64 %118 to ptr
  %121 = inttoptr i64 %119 to ptr
  %hash_coef_ptr.i3.i290 = getelementptr i8, ptr %113, i64 8
  %tbl_size_ptr.i4.i291 = getelementptr i8, ptr %113, i64 16
  %offset_tbl_ptr.i5.i292 = getelementptr i8, ptr %113, i64 40
  %hash_coef.i6.i293 = load i64, ptr %hash_coef_ptr.i3.i290, align 4
  %tbl_size.i7.i294 = load i64, ptr %tbl_size_ptr.i4.i291, align 4
  %offset_tbl.i8.i295 = load ptr, ptr %offset_tbl_ptr.i5.i292, align 8
  %product.i.i9.i296 = mul i64 %hash_coef.i6.i293, 4015701072841558310
  %shifted.i.i10.i297 = lshr i64 %product.i.i9.i296, 32
  %xored.i.i11.i298 = xor i64 %shifted.i.i10.i297, %product.i.i9.i296
  %hash.i.i12.i299 = and i64 %xored.i.i11.i298, %tbl_size.i7.i294
  %offset_ptr.i13.i300 = getelementptr i32, ptr %offset_tbl.i8.i295, i64 %hash.i.i12.i299
  %offset.i14.i301 = load i32, ptr %offset_ptr.i13.i300, align 4
  %122 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %113, 0
  %123 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %120, 1
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %121, 2
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %offset.i14.i301, 3
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %113) #41
  %128 = sext i32 %offset.i14.i301 to i64
  %129 = getelementptr ptr, ptr %113, i64 %128
  %130 = getelementptr i8, ptr %129, i64 64
  %131 = load ptr, ptr %130, align 8
  %result.i2.i302 = call ptr %131({ ptr, ptr, ptr, i32 } %125, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %132 = call i32 %result.i2.i302({ ptr, ptr, ptr, i32 } %125, { ptr, ptr, ptr, i32 } %125, ptr nonnull align 8 %2)
  %133 = icmp eq i32 %132, %40
  br i1 %133, label %._crit_edge.i303, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309

._crit_edge.i303:                                 ; preds = %116
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %113)
  %136 = getelementptr i8, ptr %129, i64 48
  %137 = load ptr, ptr %136, align 8
  %result.i1.i304 = call ptr %137({ ptr, ptr, ptr, i32 } %125, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %138 = call { ptr, i160 } %result.i1.i304({ ptr, ptr, ptr, i32 } %125, { ptr, ptr, ptr, i32 } %125, ptr nonnull align 8 %2)
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %140 = load ptr, ptr %21, align 8
  %141 = call i1 %140({ ptr, i160 } %138, { ptr, i160 } %38)
  br i1 %141, label %142, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309

142:                                              ; preds = %._crit_edge.i303
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %113)
  %145 = getelementptr i8, ptr %129, i64 56
  %146 = load ptr, ptr %145, align 8
  %result.i.i306 = call ptr %146({ ptr, ptr, ptr, i32 } %125, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %147 = call { ptr, i160 } %result.i.i306({ ptr, ptr, ptr, i32 } %125, { ptr, ptr, ptr, i32 } %125, ptr nonnull align 8 %2)
  %.fca.0.extract26.i307 = extractvalue { ptr, i160 } %147, 0
  %.fca.1.extract27.i308 = extractvalue { ptr, i160 } %147, 1
  %148 = trunc i160 %.fca.1.extract27.i308 to i64
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309: ; preds = %142, %._crit_edge.i303, %116, %86
  %.reg2mem38.sroa.3.0.i285 = phi i64 [ %148, %142 ], [ poison, %._crit_edge.i303 ], [ poison, %86 ], [ poison, %116 ]
  %.reg2mem36.0.i286 = phi ptr [ %.fca.0.extract26.i307, %142 ], [ @nil_typ, %._crit_edge.i303 ], [ @nil_typ, %86 ], [ @nil_typ, %116 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i = icmp eq ptr %.reg2mem36.0.i286, null
  %150 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem36.0.i286
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not99.i319.off0 = phi i64 [ %.reg2mem38.sroa.3.0.i285, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309 ], [ %extract.t320, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem17.0.i = phi ptr [ %150, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit309 ], [ %.fca.0.extract26.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %151 = icmp ne ptr %.reg2mem17.0.i, @nil_typ
  %152 = icmp ne ptr %.reg2mem17.0.i, null
  %.not313 = and i1 %151, %152
  br i1 %.not313, label %153, label %RangeIterator_next_.exit52.i.preheader

153:                                              ; preds = %CuckooMap_get_keyK.exit
  %sext = shl i64 %.not99.i319.off0, 32
  %154 = ashr exact i64 %sext, 32
  %155 = add i64 %154, %.030083
  br label %._crit_edge2

RangeIterator_next_.exit52.i.preheader:           ; preds = %CuckooMap_get_keyK.exit
  %result.i25.h2s380 = alloca [56 x i8], align 1
  %156 = getelementptr inbounds i8, ptr %result.i25.h2s380, i64 55
  store i8 0, ptr %156, align 1
  store <55 x i8> <i8 69, i8 114, i8 114, i8 111, i8 114, i8 58, i8 32, i8 78, i8 105, i8 108, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i25.h2s380, align 1
  store ptr @_parameterization_Bufferi8, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %35, align 8
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %3)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %result.i5.i.h2s381 = alloca [56 x i8], align 1
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 69, ptr %result.i5.i.h2s381, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s381, i64 1
  %scevgep359 = getelementptr inbounds i8, ptr %result.i25.h2s380, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(55) %scevgep, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(55) %scevgep359, i64 noundef 54, i1 noundef false)
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %163 = getelementptr inbounds i8, ptr %result.i5.i.h2s381, i64 55
  store i8 0, ptr %163, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(56) %result.i5.i.h2s381) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %165 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.284) #56
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %153
  %.1304 = phi i1 [ %.030382, %153 ], [ false, %RangeIterator_next_.exit52.i.preheader ]
  %.1301 = phi i64 [ %155, %153 ], [ %.030083, %RangeIterator_next_.exit52.i.preheader ]
  %166 = add nuw nsw i32 %.284, 1
  %exitcond95.not = icmp eq i32 %166, %0
  br i1 %exitcond95.not, label %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit, label %37

IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit: ; preds = %._crit_edge2
  %.sroa.gep320 = getelementptr inbounds i8, ptr %5, i64 24
  %167 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep314 = getelementptr inbounds i8, ptr %5, i64 8
  %.sroa.gep326 = getelementptr inbounds i8, ptr %4, i64 16
  br label %RangeIterator_next_.exit52.i.preheader387

RangeIterator_next_.exit52.i.preheader387:        ; preds = %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit, %._crit_edge1._crit_edge.thread
  %168 = phi ptr [ %29, %._crit_edge1._crit_edge.thread ], [ %167, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  %169 = phi i64 [ %28, %._crit_edge1._crit_edge.thread ], [ %34, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  %.sroa.gep326103 = phi ptr [ %.sroa.gep32699, %._crit_edge1._crit_edge.thread ], [ %.sroa.gep326, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  %.sroa.gep320102 = phi ptr [ %.sroa.gep32098, %._crit_edge1._crit_edge.thread ], [ %.sroa.gep320, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  %.sroa.gep314101 = phi ptr [ %.sroa.gep31497, %._crit_edge1._crit_edge.thread ], [ %.sroa.gep314, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  %.0298.lcssa100 = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %33, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  %.0303.lcssa = phi i1 [ true, %._crit_edge1._crit_edge.thread ], [ %.1304, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  %.0300.lcssa = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %.1301, %IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64.exit49.loopexit ]
  store ptr @_parameterization_i32, ptr %168, align 8
  %.sroa.gep323 = getelementptr inbounds i8, ptr %4, i64 8
  %170 = call i64 @clock()
  %.not = icmp eq i64 %.0300.lcssa, %.0298.lcssa100
  %result.i23 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #49
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i23, align 1
  %171 = sub i64 %170, %169
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #41
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #41
  %result.i5.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #49
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %177 = load i8, ptr %result.i23, align 1
  store i8 %177, ptr %result.i5.i, align 1
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %179 = getelementptr i8, ptr %result.i23, i64 1
  %wide.load = load <16 x i8>, ptr %179, align 1
  %180 = getelementptr i8, ptr %result.i5.i, i64 1
  store <16 x i8> %wide.load, ptr %180, align 1
  %181 = getelementptr i8, ptr %result.i23, i64 17
  %182 = load i8, ptr %181, align 1
  %183 = getelementptr i8, ptr %result.i5.i, i64 17
  store i8 %182, ptr %183, align 1
  %184 = getelementptr i8, ptr %result.i5.i, i64 18
  store i8 0, ptr %184, align 1
  %puts.i384 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #54
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %185 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %185, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #56
  %186 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #56
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %187 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %187, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #56
  %188 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %171) #56
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #56
  br i1 %27, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader387
  %189 = zext nneg i32 %0 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %190 = mul i64 %171, 1000000
  %191 = sdiv i64 %190, %189
  %192 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %192, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #56
  %193 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %191) #56
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #56
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader387
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i334.h2s378, align 1
  %scevgep363 = getelementptr inbounds i8, ptr %result.i5.i334.h2s378, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep363, align 1
  %.sroa.gep317 = getelementptr inbounds i8, ptr %5, i64 16
  %.sroa.gep329 = getelementptr inbounds i8, ptr %4, i64 24
  %spec.select = select i1 %.not, i1 %.0303.lcssa, i1 false
  %200 = getelementptr inbounds i8, ptr %result.i5.i334.h2s378, i64 18
  store i8 0, ptr %200, align 1
  %puts.i203 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i334.h2s378) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.0.extract = select i1 %spec.select, i8 80, i8 70
  %.sroa.0191.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0191.3 = select i1 %spec.select, <4 x i8> %.sroa.0191.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0191.1.vec.insert = insertelement <4 x i8> %.sroa.0191.3, i8 65, i64 1
  %.fca.2.extract = select i1 %spec.select, i8 83, i8 73
  %.sroa.0191.2 = select i1 %spec.select, <4 x i8> %.sroa.0191.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0191.2.vec.insert = insertelement <4 x i8> %.sroa.0191.2, i8 %.fca.2.extract, i64 2
  %.fca.3.extract = select i1 %spec.select, i8 83, i8 76
  %.sroa.0191.1 = select i1 %spec.select, <4 x i8> %.sroa.0191.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0191.3.vec.insert = insertelement <4 x i8> %.sroa.0191.1, i8 %.fca.3.extract, i64 3
  br i1 %spec.select, label %RangeIterator_next_.exit52.i356.preheader, label %._crit_edge4.else

._crit_edge4.else:                                ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i356.preheader

RangeIterator_next_.exit52.i356.preheader:        ; preds = %._crit_edge4.else, %print_benchmark_result.exit
  %.sroa.speculated190 = phi <4 x i8> [ <i8 70, i8 65, i8 73, i8 76>, %._crit_edge4.else ], [ %.sroa.0191.3.vec.insert, %print_benchmark_result.exit ]
  %201 = phi ptr [ %11, %._crit_edge4.else ], [ %7, %print_benchmark_result.exit ]
  %202 = phi ptr [ %10, %._crit_edge4.else ], [ %6, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %._crit_edge4.else ], [ %.sroa.gep314101, %print_benchmark_result.exit ]
  %.sroa.phi315 = phi ptr [ %.sroa.gep316, %._crit_edge4.else ], [ %.sroa.gep317, %print_benchmark_result.exit ]
  %.sroa.phi318 = phi ptr [ %.sroa.gep319, %._crit_edge4.else ], [ %.sroa.gep320102, %print_benchmark_result.exit ]
  %203 = phi ptr [ %9, %._crit_edge4.else ], [ %5, %print_benchmark_result.exit ]
  %.sroa.phi321 = phi ptr [ %.sroa.gep322, %._crit_edge4.else ], [ %.sroa.gep323, %print_benchmark_result.exit ]
  %.sroa.phi324 = phi ptr [ %.sroa.gep325, %._crit_edge4.else ], [ %.sroa.gep326103, %print_benchmark_result.exit ]
  %.sroa.phi327 = phi ptr [ %.sroa.gep328, %._crit_edge4.else ], [ %.sroa.gep329, %print_benchmark_result.exit ]
  %204 = phi ptr [ %8, %._crit_edge4.else ], [ %4, %print_benchmark_result.exit ]
  store ptr @_parameterization_Bufferi8, ptr %204, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi321, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi324, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi327, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %204)
  store ptr @buffer_typ, ptr %203, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi315, align 8
  store ptr @i32_typ, ptr %.sroa.phi318, align 8
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %203) #41
  store ptr @_parameterization_String, ptr %202, align 8
  %207 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %202)
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %201, align 8
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %201) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %210 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %211 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %result.i19.h2s377.sroa.0.0.vec.extract = extractelement <4 x i8> %.sroa.speculated190, i64 0
  store i8 %result.i19.h2s377.sroa.0.0.vec.extract, ptr %result.i5.i353.h2s376, align 1
  %scevgep368 = getelementptr inbounds i8, ptr %result.i5.i353.h2s376, i64 1
  %result.i19.h2s377.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sroa.speculated190, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i19.h2s377.sroa.0.1.vec.extract, ptr %scevgep368, align 1
  %213 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %214 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %215 = getelementptr inbounds i8, ptr %result.i5.i353.h2s376, i64 4
  store i8 0, ptr %215, align 1
  %puts.i224 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i353.h2s376) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr #18 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i777.h2s814 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i777.h2s814, i8 0, i64 5, i1 false)
  %result.i5.i758.h2s816 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i758.h2s816, i8 0, i64 19, i1 false)
  %result.i5.i720.h2s818 = alloca [34 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(34) %result.i5.i720.h2s818, i8 0, i64 34, i1 false)
  %result.i5.i.h2s820 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i.h2s820, i8 0, i64 30, i1 false)
  %oldProtect.i62 = alloca i32, align 4
  %oldProtect.i60 = alloca i32, align 4
  %oldProtect.i58 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0393.sroa.0 = alloca i8, align 8
  %3 = alloca [4 x ptr], align 8
  %4 = alloca { ptr, ptr, ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %result.i56 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i56, align 8
  %11 = getelementptr inbounds i8, ptr %result.i56, i64 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i56, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i56) #41
  %result.i55 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  %result.i57 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i55, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i55, ptr noalias nofree noundef nonnull readnone @eltauzrbyc, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i36 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i55) #48
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i55) #41
  %result.i54 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i58) #41
  %result.i59 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i54, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i58) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i58) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i54, ptr noalias nofree noundef nonnull readnone @ppinaaxjdc, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i35 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i54) #48
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i54) #41
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i56, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 10, 3
  %19 = getelementptr inbounds i8, ptr %result.i56, i64 48
  store ptr %ret.i36, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i56, i64 56
  store ptr %ret.i35, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i56, i64 40
  store i32 8, ptr %21, align 8
  %result.i1.i178 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %22 = getelementptr inbounds i8, ptr %result.i56, i64 24
  store ptr %result.i1.i178, ptr %22, align 8
  %result.i.i179 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %23 = getelementptr inbounds i8, ptr %result.i56, i64 32
  store ptr %result.i.i179, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %result.i56, i64 44
  store i32 0, ptr %24, align 4
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #41
  %26 = sext i32 %0 to i64
  %27 = shl nsw i64 %26, 2
  %result.i2.i207 = call noalias ptr @bump_malloc_wrapper(i64 noundef %27) #49
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  %result.i51 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i51, align 8
  %29 = getelementptr inbounds i8, ptr %result.i51, i64 8
  store ptr @_parameterization_Bool, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i51, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i51) #41
  %result.i50 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i60) #41
  %result.i61 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i50, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i60) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i60) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i50, ptr noalias nofree noundef nonnull readnone @goxxgxvwti, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i34 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i50) #48
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i50) #41
  %result.i49 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #41
  %result.i63 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i49, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i49, ptr noalias nofree noundef nonnull readnone @ztufuhgpns, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i49) #48
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i49) #41
  %34 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i51, 1
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr undef, 2
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 10, 3
  %37 = getelementptr inbounds i8, ptr %result.i51, i64 48
  store ptr %ret.i34, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %result.i51, i64 56
  store ptr %ret.i, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %result.i51, i64 40
  store i32 8, ptr %39, align 8
  %result.i1.i221 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %40 = getelementptr inbounds i8, ptr %result.i51, i64 24
  store ptr %result.i1.i221, ptr %40, align 8
  %result.i.i222 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %41 = getelementptr inbounds i8, ptr %result.i51, i64 32
  store ptr %result.i.i222, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %43 = getelementptr inbounds i8, ptr %result.i51, i64 44
  store i32 0, ptr %43, align 4
  %44 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %8, i64 8
  %.sroa.gep457 = getelementptr inbounds i8, ptr %8, i64 16
  %.sroa.gep460 = getelementptr inbounds i8, ptr %8, i64 24
  %.sroa.gep463 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep466 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep469 = getelementptr inbounds i8, ptr %7, i64 24
  %45 = icmp sgt i32 %0, 0
  %46 = icmp sgt i32 %44, 0
  %spec.select148 = and i1 %45, %46
  br i1 %spec.select148, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #41
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %49

49:                                               ; preds = %._crit_edge1, %.lr.ph
  %50 = phi i32 [ 456, %.lr.ph ], [ %53, %._crit_edge1 ]
  %.0431154 = phi i32 [ 0, %.lr.ph ], [ %182, %._crit_edge1 ]
  %.0432153 = phi i32 [ 0, %.lr.ph ], [ %.1433, %._crit_edge1 ]
  %.0444152 = phi i64 [ 0, %.lr.ph ], [ %.1445, %._crit_edge1 ]
  %51 = mul i32 %50, 1103515245
  %52 = add i32 %51, 12345
  %53 = and i32 %52, 2147483647
  %.sroa.0421.0.insert.ext = zext nneg i32 %53 to i160
  %54 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0421.0.insert.ext, 1
  %55 = load ptr, ptr %37, align 8
  %56 = call i32 %55({ ptr, i160 } %54)
  %57 = load i32, ptr %39, align 8
  %58 = add i32 %57, -1
  %59 = and i32 %58, %56
  %60 = load ptr, ptr %40, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %62 = sext i32 %59 to i64
  %63 = shl nsw i64 %62, 5
  %64 = getelementptr i8, ptr %60, i64 %63
  %65 = load ptr, ptr %64, align 8
  %66 = icmp ne ptr %65, @nil_typ
  %67 = icmp ne ptr %65, null
  %.not48.i = and i1 %66, %67
  br i1 %.not48.i, label %68, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

68:                                               ; preds = %49
  %69 = getelementptr i8, ptr %64, i64 8
  %70 = load i64, ptr %69, align 4
  %.sroa_idx.i = getelementptr i8, ptr %64, i64 16
  %71 = load i64, ptr %.sroa_idx.i, align 4
  %72 = inttoptr i64 %70 to ptr
  %73 = inttoptr i64 %71 to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %65, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %65, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %65, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %65, 0
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %72, 1
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %73, 2
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %offset.i14.i, 3
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %65) #41
  %80 = sext i32 %offset.i14.i to i64
  %81 = getelementptr ptr, ptr %65, i64 %80
  %82 = getelementptr i8, ptr %81, i64 64
  %83 = load ptr, ptr %82, align 8
  %result.i2.i508 = call ptr %83({ ptr, ptr, ptr, i32 } %77, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %84 = call i32 %result.i2.i508({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull align 8 %2)
  %85 = icmp eq i32 %84, %56
  br i1 %85, label %._crit_edge.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i:                                    ; preds = %68
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %65)
  %88 = getelementptr i8, ptr %81, i64 48
  %89 = load ptr, ptr %88, align 8
  %result.i1.i = call ptr %89({ ptr, ptr, ptr, i32 } %77, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %90 = call { ptr, i160 } %result.i1.i({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull align 8 %2)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %92 = load ptr, ptr %38, align 8
  %93 = call i1 %92({ ptr, i160 } %90, { ptr, i160 } %54)
  br i1 %93, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i, %68, %49
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %102

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %65)
  %96 = getelementptr i8, ptr %81, i64 56
  %97 = load ptr, ptr %96, align 8
  %result.i.i509 = call ptr %97({ ptr, ptr, ptr, i32 } %77, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %98 = call { ptr, i160 } %result.i.i509({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull align 8 %2)
  %.fca.0.extract26.i = extractvalue { ptr, i160 } %98, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %100 = icmp ne ptr %.fca.0.extract26.i, @nil_typ
  %101 = icmp ne ptr %.fca.0.extract26.i, null
  %.not99.i = and i1 %100, %101
  br i1 %.not99.i, label %CuckooMap_get_keyK.exit, label %102

102:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %103 = add i32 %56, 2127912214
  %104 = shl i32 %56, 12
  %105 = add i32 %103, %104
  %106 = ashr i32 %105, 19
  %107 = xor i32 %105, %106
  %108 = xor i32 %107, -949894596
  %109 = add i32 %108, 374761393
  %110 = shl i32 %108, 5
  %111 = add i32 %109, %110
  %112 = add i32 %111, -744332180
  %113 = shl i32 %111, 9
  %114 = xor i32 %112, %113
  %115 = add i32 %114, -42973499
  %116 = shl i32 %114, 3
  %117 = add i32 %115, %116
  %118 = ashr i32 %117, 16
  %119 = xor i32 %117, %118
  %120 = xor i32 %119, -1252372727
  %121 = load i32, ptr %39, align 8
  %122 = add i32 %121, -1
  %123 = and i32 %122, %120
  %124 = load ptr, ptr %41, align 8
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %126 = sext i32 %123 to i64
  %127 = shl nsw i64 %126, 5
  %128 = getelementptr i8, ptr %124, i64 %127
  %129 = load ptr, ptr %128, align 8
  %130 = icmp ne ptr %129, @nil_typ
  %131 = icmp ne ptr %129, null
  %.not48.i538 = and i1 %130, %131
  br i1 %.not48.i538, label %132, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit563

132:                                              ; preds = %102
  %133 = getelementptr i8, ptr %128, i64 8
  %134 = load i64, ptr %133, align 4
  %.sroa_idx.i543 = getelementptr i8, ptr %128, i64 16
  %135 = load i64, ptr %.sroa_idx.i543, align 4
  %136 = inttoptr i64 %134 to ptr
  %137 = inttoptr i64 %135 to ptr
  %hash_coef_ptr.i3.i544 = getelementptr i8, ptr %129, i64 8
  %tbl_size_ptr.i4.i545 = getelementptr i8, ptr %129, i64 16
  %offset_tbl_ptr.i5.i546 = getelementptr i8, ptr %129, i64 40
  %hash_coef.i6.i547 = load i64, ptr %hash_coef_ptr.i3.i544, align 4
  %tbl_size.i7.i548 = load i64, ptr %tbl_size_ptr.i4.i545, align 4
  %offset_tbl.i8.i549 = load ptr, ptr %offset_tbl_ptr.i5.i546, align 8
  %product.i.i9.i550 = mul i64 %hash_coef.i6.i547, 4015701072841558310
  %shifted.i.i10.i551 = lshr i64 %product.i.i9.i550, 32
  %xored.i.i11.i552 = xor i64 %shifted.i.i10.i551, %product.i.i9.i550
  %hash.i.i12.i553 = and i64 %xored.i.i11.i552, %tbl_size.i7.i548
  %offset_ptr.i13.i554 = getelementptr i32, ptr %offset_tbl.i8.i549, i64 %hash.i.i12.i553
  %offset.i14.i555 = load i32, ptr %offset_ptr.i13.i554, align 4
  %138 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %129, 0
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, ptr %136, 1
  %140 = insertvalue { ptr, ptr, ptr, i32 } %139, ptr %137, 2
  %141 = insertvalue { ptr, ptr, ptr, i32 } %140, i32 %offset.i14.i555, 3
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %129) #41
  %144 = sext i32 %offset.i14.i555 to i64
  %145 = getelementptr ptr, ptr %129, i64 %144
  %146 = getelementptr i8, ptr %145, i64 64
  %147 = load ptr, ptr %146, align 8
  %result.i2.i556 = call ptr %147({ ptr, ptr, ptr, i32 } %141, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %148 = call i32 %result.i2.i556({ ptr, ptr, ptr, i32 } %141, { ptr, ptr, ptr, i32 } %141, ptr nonnull align 8 %2)
  %149 = icmp eq i32 %148, %56
  br i1 %149, label %._crit_edge.i557, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit563

._crit_edge.i557:                                 ; preds = %132
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %129)
  %152 = getelementptr i8, ptr %145, i64 48
  %153 = load ptr, ptr %152, align 8
  %result.i1.i558 = call ptr %153({ ptr, ptr, ptr, i32 } %141, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %154 = call { ptr, i160 } %result.i1.i558({ ptr, ptr, ptr, i32 } %141, { ptr, ptr, ptr, i32 } %141, ptr nonnull align 8 %2)
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %156 = load ptr, ptr %38, align 8
  %157 = call i1 %156({ ptr, i160 } %154, { ptr, i160 } %54)
  br i1 %157, label %158, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit563

158:                                              ; preds = %._crit_edge.i557
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %129)
  %161 = getelementptr i8, ptr %145, i64 56
  %162 = load ptr, ptr %161, align 8
  %result.i.i560 = call ptr %162({ ptr, ptr, ptr, i32 } %141, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %163 = call { ptr, i160 } %result.i.i560({ ptr, ptr, ptr, i32 } %141, { ptr, ptr, ptr, i32 } %141, ptr nonnull align 8 %2)
  %.fca.0.extract26.i561 = extractvalue { ptr, i160 } %163, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit563

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit563: ; preds = %158, %._crit_edge.i557, %132, %102
  %.reg2mem36.0.i540 = phi ptr [ %.fca.0.extract26.i561, %158 ], [ @nil_typ, %._crit_edge.i557 ], [ @nil_typ, %102 ], [ @nil_typ, %132 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i = icmp eq ptr %.reg2mem36.0.i540, null
  %165 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem36.0.i540
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit563, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.reg2mem17.0.i = phi ptr [ %165, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit563 ], [ %.fca.0.extract26.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %166 = icmp eq ptr %.reg2mem17.0.i, @nil_typ
  %167 = icmp eq ptr %.reg2mem17.0.i, null
  %168 = or i1 %166, %167
  br i1 %168, label %169, label %._crit_edge1

169:                                              ; preds = %CuckooMap_get_keyK.exit
  %170 = add nuw i32 %53, 1
  %.sroa.0403.0.insert.ext = zext i32 %170 to i160
  %171 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0403.0.insert.ext, 1
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %54, { ptr, i160 } %171)
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %174 = sext i32 %.0432153 to i64
  %175 = shl nsw i64 %174, 2
  %176 = getelementptr i8, ptr %result.i2.i207, i64 %175
  store i32 %53, ptr %176, align 1
  store i1 true, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. = load i8, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.0.insert.ext = zext i8 %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. to i160
  %177 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0393.0.insert.ext, 1
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %36, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %54, { ptr, i160 } %177)
  %179 = sext i32 %170 to i64
  %180 = add i64 %.0444152, %179
  %181 = add nsw i32 %.0432153, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %169, %CuckooMap_get_keyK.exit
  %.1445 = phi i64 [ %180, %169 ], [ %.0444152, %CuckooMap_get_keyK.exit ]
  %.1433 = phi i32 [ %181, %169 ], [ %.0432153, %CuckooMap_get_keyK.exit ]
  %182 = add nuw nsw i32 %.0431154, 1
  %183 = icmp slt i32 %.1433, %0
  %184 = icmp slt i32 %182, %44
  %spec.select = select i1 %183, i1 %184, i1 false
  br i1 %spec.select, label %49, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.0444.lcssa = phi i64 [ 0, %1 ], [ %.1445, %._crit_edge1 ]
  %.0432.lcssa = phi i32 [ 0, %1 ], [ %.1433, %._crit_edge1 ]
  %.sroa.gep455 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep458 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep461 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep464 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep467 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep470 = getelementptr inbounds i8, ptr %3, i64 24
  %185 = icmp slt i32 %.0432.lcssa, %0
  br i1 %185, label %RangeIterator_next_.exit52.i.preheader, label %._crit_edge4

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge3._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %186 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 87, ptr %result.i5.i.h2s820, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s820, i64 1
  store <28 x i8> <i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %scevgep, align 1
  %188 = getelementptr inbounds i8, ptr %result.i5.i.h2s820, i64 29
  store i8 0, ptr %188, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i.h2s820) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %189 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0432.lcssa) #56
  %190 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 32, ptr %result.i5.i720.h2s818, align 1
  %scevgep788 = getelementptr inbounds i8, ptr %result.i5.i720.h2s818, i64 1
  store <32 x i8> <i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %scevgep788, align 1
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %196 = getelementptr inbounds i8, ptr %result.i5.i720.h2s818, i64 33
  store i8 0, ptr %196, align 1
  %puts.i420 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(34) %result.i5.i720.h2s818) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %._crit_edge3._crit_edge
  %.0449 = phi i32 [ %.0432.lcssa, %RangeIterator_next_.exit52.i.preheader ], [ %0, %._crit_edge3._crit_edge ]
  %197 = call i64 @clock()
  %198 = icmp sgt i32 %.0449, 0
  br i1 %198, label %.lr.ph170.preheader, label %RangeIterator_next_.exit52.i.preheader828

.lr.ph170.preheader:                              ; preds = %._crit_edge4
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %200 = zext nneg i32 %.0449 to i64
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %.lr.ph170

.lr.ph170:                                        ; preds = %._crit_edge5, %.lr.ph170.preheader
  %indvars.iv = phi i64 [ 0, %.lr.ph170.preheader ], [ %indvars.iv.next, %._crit_edge5 ]
  %.0434169 = phi i64 [ 0, %.lr.ph170.preheader ], [ %.1435, %._crit_edge5 ]
  %.0437168 = phi i1 [ true, %.lr.ph170.preheader ], [ %.1438, %._crit_edge5 ]
  %202 = shl i64 %indvars.iv, 2
  %203 = getelementptr i8, ptr %result.i2.i207, i64 %202
  %204 = load i32, ptr %203, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %204 to i160
  %205 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %206 = load ptr, ptr %19, align 8
  %207 = call i32 %206({ ptr, i160 } %205)
  %208 = load i32, ptr %21, align 8
  %209 = add i32 %208, -1
  %210 = and i32 %209, %207
  %211 = load ptr, ptr %22, align 8
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %213 = sext i32 %210 to i64
  %214 = shl nsw i64 %213, 5
  %215 = getelementptr i8, ptr %211, i64 %214
  %216 = load ptr, ptr %215, align 8
  %217 = icmp ne ptr %216, @nil_typ
  %218 = icmp ne ptr %216, null
  %.not48.i606 = and i1 %217, %218
  br i1 %.not48.i606, label %219, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630.thread

219:                                              ; preds = %.lr.ph170
  %220 = getelementptr i8, ptr %215, i64 8
  %221 = load i64, ptr %220, align 4
  %.sroa_idx.i611 = getelementptr i8, ptr %215, i64 16
  %222 = load i64, ptr %.sroa_idx.i611, align 4
  %223 = inttoptr i64 %221 to ptr
  %224 = inttoptr i64 %222 to ptr
  %hash_coef_ptr.i3.i612 = getelementptr i8, ptr %216, i64 8
  %tbl_size_ptr.i4.i613 = getelementptr i8, ptr %216, i64 16
  %offset_tbl_ptr.i5.i614 = getelementptr i8, ptr %216, i64 40
  %hash_coef.i6.i615 = load i64, ptr %hash_coef_ptr.i3.i612, align 4
  %tbl_size.i7.i616 = load i64, ptr %tbl_size_ptr.i4.i613, align 4
  %offset_tbl.i8.i617 = load ptr, ptr %offset_tbl_ptr.i5.i614, align 8
  %product.i.i9.i618 = mul i64 %hash_coef.i6.i615, 4015701072841558310
  %shifted.i.i10.i619 = lshr i64 %product.i.i9.i618, 32
  %xored.i.i11.i620 = xor i64 %shifted.i.i10.i619, %product.i.i9.i618
  %hash.i.i12.i621 = and i64 %xored.i.i11.i620, %tbl_size.i7.i616
  %offset_ptr.i13.i622 = getelementptr i32, ptr %offset_tbl.i8.i617, i64 %hash.i.i12.i621
  %offset.i14.i623 = load i32, ptr %offset_ptr.i13.i622, align 4
  %225 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %216, 0
  %226 = insertvalue { ptr, ptr, ptr, i32 } %225, ptr %223, 1
  %227 = insertvalue { ptr, ptr, ptr, i32 } %226, ptr %224, 2
  %228 = insertvalue { ptr, ptr, ptr, i32 } %227, i32 %offset.i14.i623, 3
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %216) #41
  %231 = sext i32 %offset.i14.i623 to i64
  %232 = getelementptr ptr, ptr %216, i64 %231
  %233 = getelementptr i8, ptr %232, i64 64
  %234 = load ptr, ptr %233, align 8
  %result.i2.i = call ptr %234({ ptr, ptr, ptr, i32 } %228, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %235 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %228, { ptr, ptr, ptr, i32 } %228, ptr nonnull align 8 %2)
  %236 = icmp eq i32 %235, %207
  br i1 %236, label %._crit_edge.i624, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630.thread

._crit_edge.i624:                                 ; preds = %219
  %237 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %238 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %216)
  %239 = getelementptr i8, ptr %232, i64 48
  %240 = load ptr, ptr %239, align 8
  %result.i1.i625 = call ptr %240({ ptr, ptr, ptr, i32 } %228, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %241 = call { ptr, i160 } %result.i1.i625({ ptr, ptr, ptr, i32 } %228, { ptr, ptr, ptr, i32 } %228, ptr nonnull align 8 %2)
  %242 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %243 = load ptr, ptr %20, align 8
  %244 = call i1 %243({ ptr, i160 } %241, { ptr, i160 } %205)
  br i1 %244, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630.thread: ; preds = %._crit_edge.i624, %219, %.lr.ph170
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %253

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630: ; preds = %._crit_edge.i624
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %246 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %216)
  %247 = getelementptr i8, ptr %232, i64 56
  %248 = load ptr, ptr %247, align 8
  %result.i.i627 = call ptr %248({ ptr, ptr, ptr, i32 } %228, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %249 = call { ptr, i160 } %result.i.i627({ ptr, ptr, ptr, i32 } %228, { ptr, ptr, ptr, i32 } %228, ptr nonnull align 8 %2)
  %.fca.0.extract26.i628 = extractvalue { ptr, i160 } %249, 0
  %.fca.1.extract27.i629 = extractvalue { ptr, i160 } %249, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %250 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %251 = icmp ne ptr %.fca.0.extract26.i628, @nil_typ
  %252 = icmp ne ptr %.fca.0.extract26.i628, null
  %.not99.i330 = and i1 %251, %252
  %extract.t706 = trunc i160 %.fca.1.extract27.i629 to i64
  br i1 %.not99.i330, label %CuckooMap_get_keyK.exit342, label %253

253:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630.thread
  %254 = add i32 %207, 2127912214
  %255 = shl i32 %207, 12
  %256 = add i32 %254, %255
  %257 = ashr i32 %256, 19
  %258 = xor i32 %256, %257
  %259 = xor i32 %258, -949894596
  %260 = add i32 %259, 374761393
  %261 = shl i32 %259, 5
  %262 = add i32 %260, %261
  %263 = add i32 %262, -744332180
  %264 = shl i32 %262, 9
  %265 = xor i32 %263, %264
  %266 = add i32 %265, -42973499
  %267 = shl i32 %265, 3
  %268 = add i32 %266, %267
  %269 = ashr i32 %268, 16
  %270 = xor i32 %268, %269
  %271 = xor i32 %270, -1252372727
  %272 = load i32, ptr %21, align 8
  %273 = add i32 %272, -1
  %274 = and i32 %273, %271
  %275 = load ptr, ptr %23, align 8
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %277 = sext i32 %274 to i64
  %278 = shl nsw i64 %277, 5
  %279 = getelementptr i8, ptr %275, i64 %278
  %280 = load ptr, ptr %279, align 8
  %281 = icmp ne ptr %280, @nil_typ
  %282 = icmp ne ptr %280, null
  %.not48.i660 = and i1 %281, %282
  br i1 %.not48.i660, label %283, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685

283:                                              ; preds = %253
  %284 = getelementptr i8, ptr %279, i64 8
  %285 = load i64, ptr %284, align 4
  %.sroa_idx.i665 = getelementptr i8, ptr %279, i64 16
  %286 = load i64, ptr %.sroa_idx.i665, align 4
  %287 = inttoptr i64 %285 to ptr
  %288 = inttoptr i64 %286 to ptr
  %hash_coef_ptr.i3.i666 = getelementptr i8, ptr %280, i64 8
  %tbl_size_ptr.i4.i667 = getelementptr i8, ptr %280, i64 16
  %offset_tbl_ptr.i5.i668 = getelementptr i8, ptr %280, i64 40
  %hash_coef.i6.i669 = load i64, ptr %hash_coef_ptr.i3.i666, align 4
  %tbl_size.i7.i670 = load i64, ptr %tbl_size_ptr.i4.i667, align 4
  %offset_tbl.i8.i671 = load ptr, ptr %offset_tbl_ptr.i5.i668, align 8
  %product.i.i9.i672 = mul i64 %hash_coef.i6.i669, 4015701072841558310
  %shifted.i.i10.i673 = lshr i64 %product.i.i9.i672, 32
  %xored.i.i11.i674 = xor i64 %shifted.i.i10.i673, %product.i.i9.i672
  %hash.i.i12.i675 = and i64 %xored.i.i11.i674, %tbl_size.i7.i670
  %offset_ptr.i13.i676 = getelementptr i32, ptr %offset_tbl.i8.i671, i64 %hash.i.i12.i675
  %offset.i14.i677 = load i32, ptr %offset_ptr.i13.i676, align 4
  %289 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %280, 0
  %290 = insertvalue { ptr, ptr, ptr, i32 } %289, ptr %287, 1
  %291 = insertvalue { ptr, ptr, ptr, i32 } %290, ptr %288, 2
  %292 = insertvalue { ptr, ptr, ptr, i32 } %291, i32 %offset.i14.i677, 3
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %294 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %280) #41
  %295 = sext i32 %offset.i14.i677 to i64
  %296 = getelementptr ptr, ptr %280, i64 %295
  %297 = getelementptr i8, ptr %296, i64 64
  %298 = load ptr, ptr %297, align 8
  %result.i2.i678 = call ptr %298({ ptr, ptr, ptr, i32 } %292, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %299 = call i32 %result.i2.i678({ ptr, ptr, ptr, i32 } %292, { ptr, ptr, ptr, i32 } %292, ptr nonnull align 8 %2)
  %300 = icmp eq i32 %299, %207
  br i1 %300, label %._crit_edge.i679, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685

._crit_edge.i679:                                 ; preds = %283
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %302 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %280)
  %303 = getelementptr i8, ptr %296, i64 48
  %304 = load ptr, ptr %303, align 8
  %result.i1.i680 = call ptr %304({ ptr, ptr, ptr, i32 } %292, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %305 = call { ptr, i160 } %result.i1.i680({ ptr, ptr, ptr, i32 } %292, { ptr, ptr, ptr, i32 } %292, ptr nonnull align 8 %2)
  %306 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %307 = load ptr, ptr %20, align 8
  %308 = call i1 %307({ ptr, i160 } %305, { ptr, i160 } %205)
  br i1 %308, label %309, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685

309:                                              ; preds = %._crit_edge.i679
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %311 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %280)
  %312 = getelementptr i8, ptr %296, i64 56
  %313 = load ptr, ptr %312, align 8
  %result.i.i682 = call ptr %313({ ptr, ptr, ptr, i32 } %292, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %314 = call { ptr, i160 } %result.i.i682({ ptr, ptr, ptr, i32 } %292, { ptr, ptr, ptr, i32 } %292, ptr nonnull align 8 %2)
  %.fca.0.extract26.i683 = extractvalue { ptr, i160 } %314, 0
  %.fca.1.extract27.i684 = extractvalue { ptr, i160 } %314, 1
  %315 = trunc i160 %.fca.1.extract27.i684 to i64
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685: ; preds = %309, %._crit_edge.i679, %283, %253
  %.reg2mem38.sroa.3.0.i661 = phi i64 [ %315, %309 ], [ poison, %._crit_edge.i679 ], [ poison, %253 ], [ poison, %283 ]
  %.reg2mem36.0.i662 = phi ptr [ %.fca.0.extract26.i683, %309 ], [ @nil_typ, %._crit_edge.i679 ], [ @nil_typ, %253 ], [ @nil_typ, %283 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %316 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i335 = icmp eq ptr %.reg2mem36.0.i662, null
  %317 = select i1 %.not.i335, ptr @nil_typ, ptr %.reg2mem36.0.i662
  br label %CuckooMap_get_keyK.exit342

CuckooMap_get_keyK.exit342:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630
  %.not99.i330705.off0 = phi i64 [ %.reg2mem38.sroa.3.0.i661, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685 ], [ %extract.t706, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630 ]
  %.reg2mem17.0.i336 = phi ptr [ %317, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit685 ], [ %.fca.0.extract26.i628, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit630 ]
  %318 = icmp ne ptr %.reg2mem17.0.i336, @nil_typ
  %319 = icmp ne ptr %.reg2mem17.0.i336, null
  %.not453 = and i1 %318, %319
  br i1 %.not453, label %320, label %RangeIterator_next_.exit52.i742.preheader

320:                                              ; preds = %CuckooMap_get_keyK.exit342
  %sext = shl i64 %.not99.i330705.off0, 32
  %321 = ashr exact i64 %sext, 32
  %322 = add i64 %321, %.0434169
  br label %._crit_edge5

RangeIterator_next_.exit52.i742.preheader:        ; preds = %CuckooMap_get_keyK.exit342
  %result.i44.h2s822 = alloca [52 x i8], align 1
  %323 = getelementptr inbounds i8, ptr %result.i44.h2s822, i64 51
  store i8 0, ptr %323, align 1
  store <51 x i8> <i8 69, i8 114, i8 114, i8 111, i8 114, i8 58, i8 32, i8 78, i8 105, i8 108, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 114, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i44.h2s822, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %324 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %result.i5.i739.h2s823 = alloca [52 x i8], align 1
  %326 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 69, ptr %result.i5.i739.h2s823, align 1
  %scevgep793 = getelementptr inbounds i8, ptr %result.i5.i739.h2s823, i64 1
  %scevgep794 = getelementptr inbounds i8, ptr %result.i44.h2s822, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(51) %scevgep793, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(51) %scevgep794, i64 noundef 50, i1 noundef false)
  %327 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %329 = getelementptr inbounds i8, ptr %result.i5.i739.h2s823, i64 51
  store i8 0, ptr %329, align 1
  %puts.i439 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(52) %result.i5.i739.h2s823) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %330 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %331 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %204) #56
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %RangeIterator_next_.exit52.i742.preheader, %320
  %.1438 = phi i1 [ %.0437168, %320 ], [ false, %RangeIterator_next_.exit52.i742.preheader ]
  %.1435 = phi i64 [ %322, %320 ], [ %.0434169, %RangeIterator_next_.exit52.i742.preheader ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %200
  br i1 %exitcond.not, label %RangeIterator_next_.exit52.i.preheader828, label %.lr.ph170

RangeIterator_next_.exit52.i.preheader828:        ; preds = %._crit_edge5, %._crit_edge4
  %.0437.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.1438, %._crit_edge5 ]
  %.0434.lcssa = phi i64 [ 0, %._crit_edge4 ], [ %.1435, %._crit_edge5 ]
  %332 = call i64 @clock()
  %.not = icmp eq i64 %.0434.lcssa, %.0444.lcssa
  %result.i42 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #49
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i42, align 1
  %333 = sub i64 %332, %197
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %334 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #41
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %335 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #41
  %result.i5.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #49
  %337 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %338 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %339 = load i8, ptr %result.i42, align 1
  store i8 %339, ptr %result.i5.i, align 1
  %340 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %341 = getelementptr i8, ptr %result.i42, i64 1
  %342 = load i8, ptr %341, align 1
  %343 = getelementptr i8, ptr %result.i5.i, i64 1
  store i8 %342, ptr %343, align 1
  %344 = getelementptr i8, ptr %result.i42, i64 2
  %345 = load i8, ptr %344, align 1
  %346 = getelementptr i8, ptr %result.i5.i, i64 2
  store i8 %345, ptr %346, align 1
  %347 = getelementptr i8, ptr %result.i42, i64 3
  %348 = load i8, ptr %347, align 1
  %349 = getelementptr i8, ptr %result.i5.i, i64 3
  store i8 %348, ptr %349, align 1
  %350 = getelementptr i8, ptr %result.i42, i64 4
  %351 = load i8, ptr %350, align 1
  %352 = getelementptr i8, ptr %result.i5.i, i64 4
  store i8 %351, ptr %352, align 1
  %353 = getelementptr i8, ptr %result.i42, i64 5
  %354 = load i8, ptr %353, align 1
  %355 = getelementptr i8, ptr %result.i5.i, i64 5
  store i8 %354, ptr %355, align 1
  %356 = getelementptr i8, ptr %result.i42, i64 6
  %357 = load i8, ptr %356, align 1
  %358 = getelementptr i8, ptr %result.i5.i, i64 6
  store i8 %357, ptr %358, align 1
  %359 = getelementptr i8, ptr %result.i42, i64 7
  %360 = load i8, ptr %359, align 1
  %361 = getelementptr i8, ptr %result.i5.i, i64 7
  store i8 %360, ptr %361, align 1
  %362 = getelementptr i8, ptr %result.i42, i64 8
  %363 = load i8, ptr %362, align 1
  %364 = getelementptr i8, ptr %result.i5.i, i64 8
  store i8 %363, ptr %364, align 1
  %365 = getelementptr i8, ptr %result.i42, i64 9
  %366 = load i8, ptr %365, align 1
  %367 = getelementptr i8, ptr %result.i5.i, i64 9
  store i8 %366, ptr %367, align 1
  %368 = getelementptr i8, ptr %result.i42, i64 10
  %369 = load i8, ptr %368, align 1
  %370 = getelementptr i8, ptr %result.i5.i, i64 10
  store i8 %369, ptr %370, align 1
  %371 = getelementptr i8, ptr %result.i42, i64 11
  %372 = load i8, ptr %371, align 1
  %373 = getelementptr i8, ptr %result.i5.i, i64 11
  store i8 %372, ptr %373, align 1
  %374 = getelementptr i8, ptr %result.i42, i64 12
  %375 = load i8, ptr %374, align 1
  %376 = getelementptr i8, ptr %result.i5.i, i64 12
  store i8 %375, ptr %376, align 1
  %377 = getelementptr i8, ptr %result.i42, i64 13
  %378 = load i8, ptr %377, align 1
  %379 = getelementptr i8, ptr %result.i5.i, i64 13
  store i8 %378, ptr %379, align 1
  %380 = getelementptr i8, ptr %result.i5.i, i64 14
  store i8 0, ptr %380, align 1
  %puts.i825 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #54
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %381 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %381, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #56
  %382 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0449) #56
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %383 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %383, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #56
  %384 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %333) #56
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #56
  br i1 %198, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader828
  %385 = zext nneg i32 %.0449 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %386 = mul i64 %333, 1000000
  %387 = sdiv i64 %386, %385
  %388 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %388, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #56
  %389 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %387) #56
  %390 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %391 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %393 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #56
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader828
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %394 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i758.h2s816, align 1
  %scevgep798 = getelementptr inbounds i8, ptr %result.i5.i758.h2s816, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep798, align 1
  %spec.select454 = select i1 %.not, i1 %.0437.lcssa, i1 false
  %396 = getelementptr inbounds i8, ptr %result.i5.i758.h2s816, i64 18
  store i8 0, ptr %396, align 1
  %puts.i460 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i758.h2s816) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.0.extract = select i1 %spec.select454, i8 80, i8 70
  %.sroa.0245.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0245.3 = select i1 %spec.select454, <4 x i8> %.sroa.0245.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0245.1.vec.insert = insertelement <4 x i8> %.sroa.0245.3, i8 65, i64 1
  %.fca.2.extract = select i1 %spec.select454, i8 83, i8 73
  %.sroa.0245.2 = select i1 %spec.select454, <4 x i8> %.sroa.0245.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0245.2.vec.insert = insertelement <4 x i8> %.sroa.0245.2, i8 %.fca.2.extract, i64 2
  %.fca.3.extract = select i1 %spec.select454, i8 83, i8 76
  %.sroa.0245.1 = select i1 %spec.select454, <4 x i8> %.sroa.0245.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0245.3.vec.insert = insertelement <4 x i8> %.sroa.0245.1, i8 %.fca.3.extract, i64 3
  br i1 %spec.select454, label %RangeIterator_next_.exit52.i780.preheader, label %._crit_edge7.else

._crit_edge7.else:                                ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i780.preheader

RangeIterator_next_.exit52.i780.preheader:        ; preds = %._crit_edge7.else, %print_benchmark_result.exit
  %.sroa.speculated244 = phi <4 x i8> [ <i8 70, i8 65, i8 73, i8 76>, %._crit_edge7.else ], [ %.sroa.0245.3.vec.insert, %print_benchmark_result.exit ]
  %397 = phi ptr [ %10, %._crit_edge7.else ], [ %6, %print_benchmark_result.exit ]
  %398 = phi ptr [ %9, %._crit_edge7.else ], [ %5, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %._crit_edge7.else ], [ %.sroa.gep455, %print_benchmark_result.exit ]
  %.sroa.phi456 = phi ptr [ %.sroa.gep457, %._crit_edge7.else ], [ %.sroa.gep458, %print_benchmark_result.exit ]
  %.sroa.phi459 = phi ptr [ %.sroa.gep460, %._crit_edge7.else ], [ %.sroa.gep461, %print_benchmark_result.exit ]
  %399 = phi ptr [ %8, %._crit_edge7.else ], [ %4, %print_benchmark_result.exit ]
  %.sroa.phi462 = phi ptr [ %.sroa.gep463, %._crit_edge7.else ], [ %.sroa.gep464, %print_benchmark_result.exit ]
  %.sroa.phi465 = phi ptr [ %.sroa.gep466, %._crit_edge7.else ], [ %.sroa.gep467, %print_benchmark_result.exit ]
  %.sroa.phi468 = phi ptr [ %.sroa.gep469, %._crit_edge7.else ], [ %.sroa.gep470, %print_benchmark_result.exit ]
  %400 = phi ptr [ %7, %._crit_edge7.else ], [ %3, %print_benchmark_result.exit ]
  store ptr @_parameterization_Bufferi8, ptr %400, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi462, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi465, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi468, align 8
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %400)
  store ptr @buffer_typ, ptr %399, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi456, align 8
  store ptr @i32_typ, ptr %.sroa.phi459, align 8
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %399) #41
  store ptr @_parameterization_String, ptr %398, align 8
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %398)
  %404 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %397, align 8
  %405 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %397) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %406 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %407 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %408 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %result.i38.h2s815.sroa.0.0.vec.extract = extractelement <4 x i8> %.sroa.speculated244, i64 0
  store i8 %result.i38.h2s815.sroa.0.0.vec.extract, ptr %result.i5.i777.h2s814, align 1
  %scevgep803 = getelementptr inbounds i8, ptr %result.i5.i777.h2s814, i64 1
  %result.i38.h2s815.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sroa.speculated244, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i38.h2s815.sroa.0.1.vec.extract, ptr %scevgep803, align 1
  %409 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %410 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %411 = getelementptr inbounds i8, ptr %result.i5.i777.h2s814, i64 4
  store i8 0, ptr %411, align 1
  %puts.i480 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i777.h2s814) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr #18 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i1140.h2s1188 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i5.i1140.h2s1188, align 2
  %result.i5.i1121.h2s1190 = alloca [9 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i5.i1121.h2s1190, i8 0, i64 9, i1 false)
  %result.i5.i1102.h2s1192 = alloca [14 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i5.i1102.h2s1192, i8 0, i64 14, i1 false)
  %result.i5.i1083.h2s1194 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i1083.h2s1194, i8 0, i64 5, i1 false)
  %result.i5.i1064.h2s1196 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i1064.h2s1196, i8 0, i64 19, i1 false)
  %result.i5.i1045.h2s1198 = alloca [23 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(23) %result.i5.i1045.h2s1198, i8 0, i64 23, i1 false)
  %result.i5.i.h2s1200 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i.h2s1200, i8 0, i64 30, i1 false)
  %oldProtect.i78 = alloca i32, align 4
  %oldProtect.i76 = alloca i32, align 4
  %oldProtect.i74 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0509.sroa.0 = alloca i8, align 8
  %3 = alloca [4 x ptr], align 8
  %4 = alloca { ptr, ptr, ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %result.i72 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i72, align 8
  %11 = getelementptr inbounds i8, ptr %result.i72, i64 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i72, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i72) #41
  %result.i71 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  %result.i73 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i71, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i71, ptr noalias nofree noundef nonnull readnone @lsrvbzeimc, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i47 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i71) #48
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i71) #41
  %result.i70 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i74) #41
  %result.i75 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i70, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i74) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i74) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i70, ptr noalias nofree noundef nonnull readnone @llfzdiimhe, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i46 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i70) #48
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i70) #41
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i72, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 10, 3
  %19 = getelementptr inbounds i8, ptr %result.i72, i64 48
  store ptr %ret.i47, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i72, i64 56
  store ptr %ret.i46, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i72, i64 40
  store i32 8, ptr %21, align 8
  %result.i1.i218 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %22 = getelementptr inbounds i8, ptr %result.i72, i64 24
  store ptr %result.i1.i218, ptr %22, align 8
  %result.i.i219 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %23 = getelementptr inbounds i8, ptr %result.i72, i64 32
  store ptr %result.i.i219, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %result.i72, i64 44
  store i32 0, ptr %24, align 4
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #41
  %result.i67 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i67, align 8
  %26 = getelementptr inbounds i8, ptr %result.i67, i64 8
  store ptr @_parameterization_Bool, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i67, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i67) #41
  %result.i66 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i76) #41
  %result.i77 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i66, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i76) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i76) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i66, ptr noalias nofree noundef nonnull readnone @ahgwqksoob, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i45 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i66) #48
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i66) #41
  %result.i65 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #41
  %result.i79 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i65, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i65, ptr noalias nofree noundef nonnull readnone @cckwdxkqty, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i65) #48
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i65) #41
  %31 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i67, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr undef, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 10, 3
  %34 = getelementptr inbounds i8, ptr %result.i67, i64 48
  store ptr %ret.i45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i67, i64 56
  store ptr %ret.i, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i67, i64 40
  store i32 8, ptr %36, align 8
  %result.i1.i258 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %37 = getelementptr inbounds i8, ptr %result.i67, i64 24
  store ptr %result.i1.i258, ptr %37, align 8
  %result.i.i259 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %38 = getelementptr inbounds i8, ptr %result.i67, i64 32
  store ptr %result.i.i259, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %40 = getelementptr inbounds i8, ptr %result.i67, i64 44
  store i32 0, ptr %40, align 4
  %41 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %8, i64 8
  %.sroa.gep576 = getelementptr inbounds i8, ptr %8, i64 16
  %.sroa.gep579 = getelementptr inbounds i8, ptr %8, i64 24
  %.sroa.gep582 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep585 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep588 = getelementptr inbounds i8, ptr %7, i64 24
  %42 = icmp sgt i32 %0, 0
  %43 = icmp sgt i32 %41, 0
  %spec.select191 = and i1 %42, %43
  br i1 %spec.select191, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #41
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %46

46:                                               ; preds = %._crit_edge1, %.lr.ph
  %47 = phi i32 [ 789, %.lr.ph ], [ %50, %._crit_edge1 ]
  %.0543195 = phi i32 [ 0, %.lr.ph ], [ %173, %._crit_edge1 ]
  %.0546194 = phi i32 [ 0, %.lr.ph ], [ %.1547, %._crit_edge1 ]
  %48 = mul i32 %47, 1103515245
  %49 = add i32 %48, 12345
  %50 = and i32 %49, 2147483647
  %.sroa.0533.0.insert.ext = zext nneg i32 %50 to i160
  %51 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0533.0.insert.ext, 1
  %52 = load ptr, ptr %34, align 8
  %53 = call i32 %52({ ptr, i160 } %51)
  %54 = load i32, ptr %36, align 8
  %55 = add i32 %54, -1
  %56 = and i32 %55, %53
  %57 = load ptr, ptr %37, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %59 = sext i32 %56 to i64
  %60 = shl nsw i64 %59, 5
  %61 = getelementptr i8, ptr %57, i64 %60
  %62 = load ptr, ptr %61, align 8
  %63 = icmp ne ptr %62, @nil_typ
  %64 = icmp ne ptr %62, null
  %.not48.i = and i1 %63, %64
  br i1 %.not48.i, label %65, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

65:                                               ; preds = %46
  %66 = getelementptr i8, ptr %61, i64 8
  %67 = load i64, ptr %66, align 4
  %.sroa_idx.i = getelementptr i8, ptr %61, i64 16
  %68 = load i64, ptr %.sroa_idx.i, align 4
  %69 = inttoptr i64 %67 to ptr
  %70 = inttoptr i64 %68 to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %62, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %62, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %62, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %71 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %69, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %70, 2
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 %offset.i14.i, 3
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %62) #41
  %77 = sext i32 %offset.i14.i to i64
  %78 = getelementptr ptr, ptr %62, i64 %77
  %79 = getelementptr i8, ptr %78, i64 64
  %80 = load ptr, ptr %79, align 8
  %result.i2.i707 = call ptr %80({ ptr, ptr, ptr, i32 } %74, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %81 = call i32 %result.i2.i707({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr nonnull align 8 %2)
  %82 = icmp eq i32 %81, %53
  br i1 %82, label %._crit_edge.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i:                                    ; preds = %65
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %62)
  %85 = getelementptr i8, ptr %78, i64 48
  %86 = load ptr, ptr %85, align 8
  %result.i1.i = call ptr %86({ ptr, ptr, ptr, i32 } %74, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %87 = call { ptr, i160 } %result.i1.i({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr nonnull align 8 %2)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %89 = load ptr, ptr %35, align 8
  %90 = call i1 %89({ ptr, i160 } %87, { ptr, i160 } %51)
  br i1 %90, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i, %65, %46
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %99

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %62)
  %93 = getelementptr i8, ptr %78, i64 56
  %94 = load ptr, ptr %93, align 8
  %result.i.i708 = call ptr %94({ ptr, ptr, ptr, i32 } %74, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %95 = call { ptr, i160 } %result.i.i708({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr nonnull align 8 %2)
  %.fca.0.extract26.i = extractvalue { ptr, i160 } %95, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %97 = icmp ne ptr %.fca.0.extract26.i, @nil_typ
  %98 = icmp ne ptr %.fca.0.extract26.i, null
  %.not99.i = and i1 %97, %98
  br i1 %.not99.i, label %CuckooMap_get_keyK.exit, label %99

99:                                               ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %100 = add i32 %53, 2127912214
  %101 = shl i32 %53, 12
  %102 = add i32 %100, %101
  %103 = ashr i32 %102, 19
  %104 = xor i32 %102, %103
  %105 = xor i32 %104, -949894596
  %106 = add i32 %105, 374761393
  %107 = shl i32 %105, 5
  %108 = add i32 %106, %107
  %109 = add i32 %108, -744332180
  %110 = shl i32 %108, 9
  %111 = xor i32 %109, %110
  %112 = add i32 %111, -42973499
  %113 = shl i32 %111, 3
  %114 = add i32 %112, %113
  %115 = ashr i32 %114, 16
  %116 = xor i32 %114, %115
  %117 = xor i32 %116, -1252372727
  %118 = load i32, ptr %36, align 8
  %119 = add i32 %118, -1
  %120 = and i32 %119, %117
  %121 = load ptr, ptr %38, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %123 = sext i32 %120 to i64
  %124 = shl nsw i64 %123, 5
  %125 = getelementptr i8, ptr %121, i64 %124
  %126 = load ptr, ptr %125, align 8
  %127 = icmp ne ptr %126, @nil_typ
  %128 = icmp ne ptr %126, null
  %.not48.i737 = and i1 %127, %128
  br i1 %.not48.i737, label %129, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit762

129:                                              ; preds = %99
  %130 = getelementptr i8, ptr %125, i64 8
  %131 = load i64, ptr %130, align 4
  %.sroa_idx.i742 = getelementptr i8, ptr %125, i64 16
  %132 = load i64, ptr %.sroa_idx.i742, align 4
  %133 = inttoptr i64 %131 to ptr
  %134 = inttoptr i64 %132 to ptr
  %hash_coef_ptr.i3.i743 = getelementptr i8, ptr %126, i64 8
  %tbl_size_ptr.i4.i744 = getelementptr i8, ptr %126, i64 16
  %offset_tbl_ptr.i5.i745 = getelementptr i8, ptr %126, i64 40
  %hash_coef.i6.i746 = load i64, ptr %hash_coef_ptr.i3.i743, align 4
  %tbl_size.i7.i747 = load i64, ptr %tbl_size_ptr.i4.i744, align 4
  %offset_tbl.i8.i748 = load ptr, ptr %offset_tbl_ptr.i5.i745, align 8
  %product.i.i9.i749 = mul i64 %hash_coef.i6.i746, 4015701072841558310
  %shifted.i.i10.i750 = lshr i64 %product.i.i9.i749, 32
  %xored.i.i11.i751 = xor i64 %shifted.i.i10.i750, %product.i.i9.i749
  %hash.i.i12.i752 = and i64 %xored.i.i11.i751, %tbl_size.i7.i747
  %offset_ptr.i13.i753 = getelementptr i32, ptr %offset_tbl.i8.i748, i64 %hash.i.i12.i752
  %offset.i14.i754 = load i32, ptr %offset_ptr.i13.i753, align 4
  %135 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %126, 0
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, ptr %133, 1
  %137 = insertvalue { ptr, ptr, ptr, i32 } %136, ptr %134, 2
  %138 = insertvalue { ptr, ptr, ptr, i32 } %137, i32 %offset.i14.i754, 3
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %126) #41
  %141 = sext i32 %offset.i14.i754 to i64
  %142 = getelementptr ptr, ptr %126, i64 %141
  %143 = getelementptr i8, ptr %142, i64 64
  %144 = load ptr, ptr %143, align 8
  %result.i2.i755 = call ptr %144({ ptr, ptr, ptr, i32 } %138, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %145 = call i32 %result.i2.i755({ ptr, ptr, ptr, i32 } %138, { ptr, ptr, ptr, i32 } %138, ptr nonnull align 8 %2)
  %146 = icmp eq i32 %145, %53
  br i1 %146, label %._crit_edge.i756, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit762

._crit_edge.i756:                                 ; preds = %129
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %126)
  %149 = getelementptr i8, ptr %142, i64 48
  %150 = load ptr, ptr %149, align 8
  %result.i1.i757 = call ptr %150({ ptr, ptr, ptr, i32 } %138, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %151 = call { ptr, i160 } %result.i1.i757({ ptr, ptr, ptr, i32 } %138, { ptr, ptr, ptr, i32 } %138, ptr nonnull align 8 %2)
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %153 = load ptr, ptr %35, align 8
  %154 = call i1 %153({ ptr, i160 } %151, { ptr, i160 } %51)
  br i1 %154, label %155, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit762

155:                                              ; preds = %._crit_edge.i756
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %126)
  %158 = getelementptr i8, ptr %142, i64 56
  %159 = load ptr, ptr %158, align 8
  %result.i.i759 = call ptr %159({ ptr, ptr, ptr, i32 } %138, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %160 = call { ptr, i160 } %result.i.i759({ ptr, ptr, ptr, i32 } %138, { ptr, ptr, ptr, i32 } %138, ptr nonnull align 8 %2)
  %.fca.0.extract26.i760 = extractvalue { ptr, i160 } %160, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit762

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit762: ; preds = %155, %._crit_edge.i756, %129, %99
  %.reg2mem36.0.i739 = phi ptr [ %.fca.0.extract26.i760, %155 ], [ @nil_typ, %._crit_edge.i756 ], [ @nil_typ, %99 ], [ @nil_typ, %129 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i = icmp eq ptr %.reg2mem36.0.i739, null
  %162 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem36.0.i739
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit762, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.reg2mem17.0.i = phi ptr [ %162, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit762 ], [ %.fca.0.extract26.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %163 = icmp eq ptr %.reg2mem17.0.i, @nil_typ
  %164 = icmp eq ptr %.reg2mem17.0.i, null
  %165 = or i1 %163, %164
  br i1 %165, label %166, label %._crit_edge1

166:                                              ; preds = %CuckooMap_get_keyK.exit
  %167 = add nuw i32 %50, 1
  %.sroa.0516.0.insert.ext = zext i32 %167 to i160
  %168 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0516.0.insert.ext, 1
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %51, { ptr, i160 } %168)
  store i1 true, ptr %.sroa.0509.sroa.0, align 8
  %.sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.0. = load i8, ptr %.sroa.0509.sroa.0, align 8
  %.sroa.0509.0.insert.ext = zext i8 %.sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.0. to i160
  %170 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0509.0.insert.ext, 1
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %51, { ptr, i160 } %170)
  %172 = add nsw i32 %.0546194, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %166, %CuckooMap_get_keyK.exit
  %.1547 = phi i32 [ %172, %166 ], [ %.0546194, %CuckooMap_get_keyK.exit ]
  %173 = add nuw nsw i32 %.0543195, 1
  %174 = icmp slt i32 %.1547, %0
  %175 = icmp slt i32 %173, %41
  %spec.select = select i1 %174, i1 %175, i1 false
  br i1 %spec.select, label %46, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.sroa.gep574 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep580 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep586 = getelementptr inbounds i8, ptr %3, i64 16
  %176 = sext i32 %0 to i64
  %177 = shl nsw i64 %176, 2
  %result.i2.i307 = call noalias ptr @bump_malloc_wrapper(i64 noundef %177) #49
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %179 = mul i32 %0, 20
  %180 = icmp sgt i32 %179, 0
  %spec.select573200 = and i1 %42, %180
  br i1 %spec.select573200, label %.lr.ph204, label %._crit_edge7._crit_edge

.lr.ph204:                                        ; preds = %._crit_edge3._crit_edge
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #44
  %182 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %183

183:                                              ; preds = %._crit_edge5, %.lr.ph204
  %184 = phi i32 [ 987, %.lr.ph204 ], [ %187, %._crit_edge5 ]
  %.0542203 = phi i32 [ 0, %.lr.ph204 ], [ %.1, %._crit_edge5 ]
  %.2545202 = phi i32 [ 0, %.lr.ph204 ], [ %309, %._crit_edge5 ]
  %185 = mul i32 %184, 1103515245
  %186 = add i32 %185, 12345
  %187 = and i32 %186, 2147483647
  %.sroa.0472.0.insert.ext = zext nneg i32 %187 to i160
  %188 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0472.0.insert.ext, 1
  %189 = load ptr, ptr %34, align 8
  %190 = call i32 %189({ ptr, i160 } %188)
  %191 = load i32, ptr %36, align 8
  %192 = add i32 %191, -1
  %193 = and i32 %192, %190
  %194 = load ptr, ptr %37, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = sext i32 %193 to i64
  %197 = shl nsw i64 %196, 5
  %198 = getelementptr i8, ptr %194, i64 %197
  %199 = load ptr, ptr %198, align 8
  %200 = icmp ne ptr %199, @nil_typ
  %201 = icmp ne ptr %199, null
  %.not48.i804 = and i1 %200, %201
  br i1 %.not48.i804, label %202, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829.thread

202:                                              ; preds = %183
  %203 = getelementptr i8, ptr %198, i64 8
  %204 = load i64, ptr %203, align 4
  %.sroa_idx.i809 = getelementptr i8, ptr %198, i64 16
  %205 = load i64, ptr %.sroa_idx.i809, align 4
  %206 = inttoptr i64 %204 to ptr
  %207 = inttoptr i64 %205 to ptr
  %hash_coef_ptr.i3.i810 = getelementptr i8, ptr %199, i64 8
  %tbl_size_ptr.i4.i811 = getelementptr i8, ptr %199, i64 16
  %offset_tbl_ptr.i5.i812 = getelementptr i8, ptr %199, i64 40
  %hash_coef.i6.i813 = load i64, ptr %hash_coef_ptr.i3.i810, align 4
  %tbl_size.i7.i814 = load i64, ptr %tbl_size_ptr.i4.i811, align 4
  %offset_tbl.i8.i815 = load ptr, ptr %offset_tbl_ptr.i5.i812, align 8
  %product.i.i9.i816 = mul i64 %hash_coef.i6.i813, 4015701072841558310
  %shifted.i.i10.i817 = lshr i64 %product.i.i9.i816, 32
  %xored.i.i11.i818 = xor i64 %shifted.i.i10.i817, %product.i.i9.i816
  %hash.i.i12.i819 = and i64 %xored.i.i11.i818, %tbl_size.i7.i814
  %offset_ptr.i13.i820 = getelementptr i32, ptr %offset_tbl.i8.i815, i64 %hash.i.i12.i819
  %offset.i14.i821 = load i32, ptr %offset_ptr.i13.i820, align 4
  %208 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %199, 0
  %209 = insertvalue { ptr, ptr, ptr, i32 } %208, ptr %206, 1
  %210 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %207, 2
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, i32 %offset.i14.i821, 3
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %213 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %199) #41
  %214 = sext i32 %offset.i14.i821 to i64
  %215 = getelementptr ptr, ptr %199, i64 %214
  %216 = getelementptr i8, ptr %215, i64 64
  %217 = load ptr, ptr %216, align 8
  %result.i2.i822 = call ptr %217({ ptr, ptr, ptr, i32 } %211, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %218 = call i32 %result.i2.i822({ ptr, ptr, ptr, i32 } %211, { ptr, ptr, ptr, i32 } %211, ptr nonnull align 8 %2)
  %219 = icmp eq i32 %218, %190
  br i1 %219, label %._crit_edge.i823, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829.thread

._crit_edge.i823:                                 ; preds = %202
  %220 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %221 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %199)
  %222 = getelementptr i8, ptr %215, i64 48
  %223 = load ptr, ptr %222, align 8
  %result.i1.i824 = call ptr %223({ ptr, ptr, ptr, i32 } %211, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %224 = call { ptr, i160 } %result.i1.i824({ ptr, ptr, ptr, i32 } %211, { ptr, ptr, ptr, i32 } %211, ptr nonnull align 8 %2)
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %226 = load ptr, ptr %35, align 8
  %227 = call i1 %226({ ptr, i160 } %224, { ptr, i160 } %188)
  br i1 %227, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829.thread: ; preds = %._crit_edge.i823, %202, %183
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %236

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829: ; preds = %._crit_edge.i823
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %199)
  %230 = getelementptr i8, ptr %215, i64 56
  %231 = load ptr, ptr %230, align 8
  %result.i.i826 = call ptr %231({ ptr, ptr, ptr, i32 } %211, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %232 = call { ptr, i160 } %result.i.i826({ ptr, ptr, ptr, i32 } %211, { ptr, ptr, ptr, i32 } %211, ptr nonnull align 8 %2)
  %.fca.0.extract26.i827 = extractvalue { ptr, i160 } %232, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %233 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %234 = icmp ne ptr %.fca.0.extract26.i827, @nil_typ
  %235 = icmp ne ptr %.fca.0.extract26.i827, null
  %.not99.i343 = and i1 %234, %235
  br i1 %.not99.i343, label %CuckooMap_get_keyK.exit357, label %236

236:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829.thread
  %237 = add i32 %190, 2127912214
  %238 = shl i32 %190, 12
  %239 = add i32 %237, %238
  %240 = ashr i32 %239, 19
  %241 = xor i32 %239, %240
  %242 = xor i32 %241, -949894596
  %243 = add i32 %242, 374761393
  %244 = shl i32 %242, 5
  %245 = add i32 %243, %244
  %246 = add i32 %245, -744332180
  %247 = shl i32 %245, 9
  %248 = xor i32 %246, %247
  %249 = add i32 %248, -42973499
  %250 = shl i32 %248, 3
  %251 = add i32 %249, %250
  %252 = ashr i32 %251, 16
  %253 = xor i32 %251, %252
  %254 = xor i32 %253, -1252372727
  %255 = load i32, ptr %36, align 8
  %256 = add i32 %255, -1
  %257 = and i32 %256, %254
  %258 = load ptr, ptr %38, align 8
  %259 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %260 = sext i32 %257 to i64
  %261 = shl nsw i64 %260, 5
  %262 = getelementptr i8, ptr %258, i64 %261
  %263 = load ptr, ptr %262, align 8
  %264 = icmp ne ptr %263, @nil_typ
  %265 = icmp ne ptr %263, null
  %.not48.i859 = and i1 %264, %265
  br i1 %.not48.i859, label %266, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit884

266:                                              ; preds = %236
  %267 = getelementptr i8, ptr %262, i64 8
  %268 = load i64, ptr %267, align 4
  %.sroa_idx.i864 = getelementptr i8, ptr %262, i64 16
  %269 = load i64, ptr %.sroa_idx.i864, align 4
  %270 = inttoptr i64 %268 to ptr
  %271 = inttoptr i64 %269 to ptr
  %hash_coef_ptr.i3.i865 = getelementptr i8, ptr %263, i64 8
  %tbl_size_ptr.i4.i866 = getelementptr i8, ptr %263, i64 16
  %offset_tbl_ptr.i5.i867 = getelementptr i8, ptr %263, i64 40
  %hash_coef.i6.i868 = load i64, ptr %hash_coef_ptr.i3.i865, align 4
  %tbl_size.i7.i869 = load i64, ptr %tbl_size_ptr.i4.i866, align 4
  %offset_tbl.i8.i870 = load ptr, ptr %offset_tbl_ptr.i5.i867, align 8
  %product.i.i9.i871 = mul i64 %hash_coef.i6.i868, 4015701072841558310
  %shifted.i.i10.i872 = lshr i64 %product.i.i9.i871, 32
  %xored.i.i11.i873 = xor i64 %shifted.i.i10.i872, %product.i.i9.i871
  %hash.i.i12.i874 = and i64 %xored.i.i11.i873, %tbl_size.i7.i869
  %offset_ptr.i13.i875 = getelementptr i32, ptr %offset_tbl.i8.i870, i64 %hash.i.i12.i874
  %offset.i14.i876 = load i32, ptr %offset_ptr.i13.i875, align 4
  %272 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %263, 0
  %273 = insertvalue { ptr, ptr, ptr, i32 } %272, ptr %270, 1
  %274 = insertvalue { ptr, ptr, ptr, i32 } %273, ptr %271, 2
  %275 = insertvalue { ptr, ptr, ptr, i32 } %274, i32 %offset.i14.i876, 3
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %263) #41
  %278 = sext i32 %offset.i14.i876 to i64
  %279 = getelementptr ptr, ptr %263, i64 %278
  %280 = getelementptr i8, ptr %279, i64 64
  %281 = load ptr, ptr %280, align 8
  %result.i2.i877 = call ptr %281({ ptr, ptr, ptr, i32 } %275, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %282 = call i32 %result.i2.i877({ ptr, ptr, ptr, i32 } %275, { ptr, ptr, ptr, i32 } %275, ptr nonnull align 8 %2)
  %283 = icmp eq i32 %282, %190
  br i1 %283, label %._crit_edge.i878, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit884

._crit_edge.i878:                                 ; preds = %266
  %284 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %263)
  %286 = getelementptr i8, ptr %279, i64 48
  %287 = load ptr, ptr %286, align 8
  %result.i1.i879 = call ptr %287({ ptr, ptr, ptr, i32 } %275, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %288 = call { ptr, i160 } %result.i1.i879({ ptr, ptr, ptr, i32 } %275, { ptr, ptr, ptr, i32 } %275, ptr nonnull align 8 %2)
  %289 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %290 = load ptr, ptr %35, align 8
  %291 = call i1 %290({ ptr, i160 } %288, { ptr, i160 } %188)
  br i1 %291, label %292, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit884

292:                                              ; preds = %._crit_edge.i878
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %294 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %263)
  %295 = getelementptr i8, ptr %279, i64 56
  %296 = load ptr, ptr %295, align 8
  %result.i.i881 = call ptr %296({ ptr, ptr, ptr, i32 } %275, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %297 = call { ptr, i160 } %result.i.i881({ ptr, ptr, ptr, i32 } %275, { ptr, ptr, ptr, i32 } %275, ptr nonnull align 8 %2)
  %.fca.0.extract26.i882 = extractvalue { ptr, i160 } %297, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit884

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit884: ; preds = %292, %._crit_edge.i878, %266, %236
  %.reg2mem36.0.i861 = phi ptr [ %.fca.0.extract26.i882, %292 ], [ @nil_typ, %._crit_edge.i878 ], [ @nil_typ, %236 ], [ @nil_typ, %266 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %298 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i350 = icmp eq ptr %.reg2mem36.0.i861, null
  %299 = select i1 %.not.i350, ptr @nil_typ, ptr %.reg2mem36.0.i861
  br label %CuckooMap_get_keyK.exit357

CuckooMap_get_keyK.exit357:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit884, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829
  %.reg2mem17.0.i351 = phi ptr [ %299, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit884 ], [ %.fca.0.extract26.i827, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit829 ]
  %300 = icmp eq ptr %.reg2mem17.0.i351, @nil_typ
  %301 = icmp eq ptr %.reg2mem17.0.i351, null
  %302 = or i1 %300, %301
  br i1 %302, label %303, label %._crit_edge5

303:                                              ; preds = %CuckooMap_get_keyK.exit357
  %304 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %305 = sext i32 %.0542203 to i64
  %306 = shl nsw i64 %305, 2
  %307 = getelementptr i8, ptr %result.i2.i307, i64 %306
  store i32 %187, ptr %307, align 1
  %308 = add nsw i32 %.0542203, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %303, %CuckooMap_get_keyK.exit357
  %.1 = phi i32 [ %308, %303 ], [ %.0542203, %CuckooMap_get_keyK.exit357 ]
  %309 = add nuw nsw i32 %.2545202, 1
  %310 = icmp slt i32 %.1, %0
  %311 = icmp slt i32 %309, %179
  %spec.select573 = select i1 %310, i1 %311, i1 false
  br i1 %spec.select573, label %183, label %._crit_edge7._crit_edge

._crit_edge7._crit_edge:                          ; preds = %._crit_edge5, %._crit_edge3._crit_edge
  %.0542.lcssa = phi i32 [ 0, %._crit_edge3._crit_edge ], [ %.1, %._crit_edge5 ]
  %.sroa.gep577 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep583 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep589 = getelementptr inbounds i8, ptr %3, i64 24
  %312 = icmp slt i32 %.0542.lcssa, %0
  br i1 %312, label %RangeIterator_next_.exit52.i.preheader, label %._crit_edge8

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge7._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %313 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %314 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 87, ptr %result.i5.i.h2s1200, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s1200, i64 1
  store <28 x i8> <i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %scevgep, align 1
  %315 = getelementptr inbounds i8, ptr %result.i5.i.h2s1200, i64 29
  store i8 0, ptr %315, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i.h2s1200) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %316 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0542.lcssa) #56
  %317 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %318 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %319 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %320 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 32, ptr %result.i5.i1045.h2s1198, align 1
  %scevgep1152 = getelementptr inbounds i8, ptr %result.i5.i1045.h2s1198, i64 1
  store <21 x i8> <i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %scevgep1152, align 1
  %321 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %322 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %323 = getelementptr inbounds i8, ptr %result.i5.i1045.h2s1198, i64 22
  store i8 0, ptr %323, align 1
  %puts.i577 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(23) %result.i5.i1045.h2s1198) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %._crit_edge7._crit_edge
  %.0569 = phi i32 [ %.0542.lcssa, %RangeIterator_next_.exit52.i.preheader ], [ %0, %._crit_edge7._crit_edge ]
  %324 = call i64 @clock()
  %325 = icmp sgt i32 %.0569, 0
  br i1 %325, label %._crit_edge9.preheader, label %453

._crit_edge9.preheader:                           ; preds = %._crit_edge8
  %326 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %327 = zext nneg i32 %.0569 to i64
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %CuckooMap_get_keyK.exit446, %._crit_edge9.preheader
  %indvars.iv = phi i64 [ 0, %._crit_edge9.preheader ], [ %indvars.iv.next, %CuckooMap_get_keyK.exit446 ]
  %.0550209 = phi i32 [ 0, %._crit_edge9.preheader ], [ %.2552, %CuckooMap_get_keyK.exit446 ]
  %.0553208 = phi i32 [ 0, %._crit_edge9.preheader ], [ %.2555, %CuckooMap_get_keyK.exit446 ]
  %329 = shl i64 %indvars.iv, 2
  %330 = getelementptr i8, ptr %result.i2.i307, i64 %329
  %331 = load i32, ptr %330, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %331 to i160
  %332 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %333 = load ptr, ptr %19, align 8
  %334 = call i32 %333({ ptr, i160 } %332)
  %335 = load i32, ptr %21, align 8
  %336 = add i32 %335, -1
  %337 = and i32 %336, %334
  %338 = load ptr, ptr %22, align 8
  %339 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %340 = sext i32 %337 to i64
  %341 = shl nsw i64 %340, 5
  %342 = getelementptr i8, ptr %338, i64 %341
  %343 = load ptr, ptr %342, align 8
  %344 = icmp ne ptr %343, @nil_typ
  %345 = icmp ne ptr %343, null
  %.not48.i926 = and i1 %344, %345
  br i1 %.not48.i926, label %346, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950.thread

346:                                              ; preds = %._crit_edge9
  %347 = getelementptr i8, ptr %342, i64 8
  %348 = load i64, ptr %347, align 4
  %.sroa_idx.i931 = getelementptr i8, ptr %342, i64 16
  %349 = load i64, ptr %.sroa_idx.i931, align 4
  %350 = inttoptr i64 %348 to ptr
  %351 = inttoptr i64 %349 to ptr
  %hash_coef_ptr.i3.i932 = getelementptr i8, ptr %343, i64 8
  %tbl_size_ptr.i4.i933 = getelementptr i8, ptr %343, i64 16
  %offset_tbl_ptr.i5.i934 = getelementptr i8, ptr %343, i64 40
  %hash_coef.i6.i935 = load i64, ptr %hash_coef_ptr.i3.i932, align 4
  %tbl_size.i7.i936 = load i64, ptr %tbl_size_ptr.i4.i933, align 4
  %offset_tbl.i8.i937 = load ptr, ptr %offset_tbl_ptr.i5.i934, align 8
  %product.i.i9.i938 = mul i64 %hash_coef.i6.i935, 4015701072841558310
  %shifted.i.i10.i939 = lshr i64 %product.i.i9.i938, 32
  %xored.i.i11.i940 = xor i64 %shifted.i.i10.i939, %product.i.i9.i938
  %hash.i.i12.i941 = and i64 %xored.i.i11.i940, %tbl_size.i7.i936
  %offset_ptr.i13.i942 = getelementptr i32, ptr %offset_tbl.i8.i937, i64 %hash.i.i12.i941
  %offset.i14.i943 = load i32, ptr %offset_ptr.i13.i942, align 4
  %352 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %343, 0
  %353 = insertvalue { ptr, ptr, ptr, i32 } %352, ptr %350, 1
  %354 = insertvalue { ptr, ptr, ptr, i32 } %353, ptr %351, 2
  %355 = insertvalue { ptr, ptr, ptr, i32 } %354, i32 %offset.i14.i943, 3
  %356 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %357 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %343) #41
  %358 = sext i32 %offset.i14.i943 to i64
  %359 = getelementptr ptr, ptr %343, i64 %358
  %360 = getelementptr i8, ptr %359, i64 64
  %361 = load ptr, ptr %360, align 8
  %result.i2.i = call ptr %361({ ptr, ptr, ptr, i32 } %355, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %362 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %355, { ptr, ptr, ptr, i32 } %355, ptr nonnull align 8 %2)
  %363 = icmp eq i32 %362, %334
  br i1 %363, label %._crit_edge.i944, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950.thread

._crit_edge.i944:                                 ; preds = %346
  %364 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %365 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %343)
  %366 = getelementptr i8, ptr %359, i64 48
  %367 = load ptr, ptr %366, align 8
  %result.i1.i945 = call ptr %367({ ptr, ptr, ptr, i32 } %355, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %368 = call { ptr, i160 } %result.i1.i945({ ptr, ptr, ptr, i32 } %355, { ptr, ptr, ptr, i32 } %355, ptr nonnull align 8 %2)
  %369 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %370 = load ptr, ptr %20, align 8
  %371 = call i1 %370({ ptr, i160 } %368, { ptr, i160 } %332)
  br i1 %371, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950.thread: ; preds = %._crit_edge.i944, %346, %._crit_edge9
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %380

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950: ; preds = %._crit_edge.i944
  %372 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %373 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %343)
  %374 = getelementptr i8, ptr %359, i64 56
  %375 = load ptr, ptr %374, align 8
  %result.i.i947 = call ptr %375({ ptr, ptr, ptr, i32 } %355, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %376 = call { ptr, i160 } %result.i.i947({ ptr, ptr, ptr, i32 } %355, { ptr, ptr, ptr, i32 } %355, ptr nonnull align 8 %2)
  %.fca.0.extract26.i948 = extractvalue { ptr, i160 } %376, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %377 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %378 = icmp ne ptr %.fca.0.extract26.i948, @nil_typ
  %379 = icmp ne ptr %.fca.0.extract26.i948, null
  %.not99.i434 = and i1 %378, %379
  br i1 %.not99.i434, label %CuckooMap_get_keyK.exit446, label %380

380:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950.thread
  %381 = add i32 %334, 2127912214
  %382 = shl i32 %334, 12
  %383 = add i32 %381, %382
  %384 = ashr i32 %383, 19
  %385 = xor i32 %383, %384
  %386 = xor i32 %385, -949894596
  %387 = add i32 %386, 374761393
  %388 = shl i32 %386, 5
  %389 = add i32 %387, %388
  %390 = add i32 %389, -744332180
  %391 = shl i32 %389, 9
  %392 = xor i32 %390, %391
  %393 = add i32 %392, -42973499
  %394 = shl i32 %392, 3
  %395 = add i32 %393, %394
  %396 = ashr i32 %395, 16
  %397 = xor i32 %395, %396
  %398 = xor i32 %397, -1252372727
  %399 = load i32, ptr %21, align 8
  %400 = add i32 %399, -1
  %401 = and i32 %400, %398
  %402 = load ptr, ptr %23, align 8
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %404 = sext i32 %401 to i64
  %405 = shl nsw i64 %404, 5
  %406 = getelementptr i8, ptr %402, i64 %405
  %407 = load ptr, ptr %406, align 8
  %408 = icmp ne ptr %407, @nil_typ
  %409 = icmp ne ptr %407, null
  %.not48.i980 = and i1 %408, %409
  br i1 %.not48.i980, label %410, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1005

410:                                              ; preds = %380
  %411 = getelementptr i8, ptr %406, i64 8
  %412 = load i64, ptr %411, align 4
  %.sroa_idx.i985 = getelementptr i8, ptr %406, i64 16
  %413 = load i64, ptr %.sroa_idx.i985, align 4
  %414 = inttoptr i64 %412 to ptr
  %415 = inttoptr i64 %413 to ptr
  %hash_coef_ptr.i3.i986 = getelementptr i8, ptr %407, i64 8
  %tbl_size_ptr.i4.i987 = getelementptr i8, ptr %407, i64 16
  %offset_tbl_ptr.i5.i988 = getelementptr i8, ptr %407, i64 40
  %hash_coef.i6.i989 = load i64, ptr %hash_coef_ptr.i3.i986, align 4
  %tbl_size.i7.i990 = load i64, ptr %tbl_size_ptr.i4.i987, align 4
  %offset_tbl.i8.i991 = load ptr, ptr %offset_tbl_ptr.i5.i988, align 8
  %product.i.i9.i992 = mul i64 %hash_coef.i6.i989, 4015701072841558310
  %shifted.i.i10.i993 = lshr i64 %product.i.i9.i992, 32
  %xored.i.i11.i994 = xor i64 %shifted.i.i10.i993, %product.i.i9.i992
  %hash.i.i12.i995 = and i64 %xored.i.i11.i994, %tbl_size.i7.i990
  %offset_ptr.i13.i996 = getelementptr i32, ptr %offset_tbl.i8.i991, i64 %hash.i.i12.i995
  %offset.i14.i997 = load i32, ptr %offset_ptr.i13.i996, align 4
  %416 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %407, 0
  %417 = insertvalue { ptr, ptr, ptr, i32 } %416, ptr %414, 1
  %418 = insertvalue { ptr, ptr, ptr, i32 } %417, ptr %415, 2
  %419 = insertvalue { ptr, ptr, ptr, i32 } %418, i32 %offset.i14.i997, 3
  %420 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %421 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %407) #41
  %422 = sext i32 %offset.i14.i997 to i64
  %423 = getelementptr ptr, ptr %407, i64 %422
  %424 = getelementptr i8, ptr %423, i64 64
  %425 = load ptr, ptr %424, align 8
  %result.i2.i998 = call ptr %425({ ptr, ptr, ptr, i32 } %419, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %426 = call i32 %result.i2.i998({ ptr, ptr, ptr, i32 } %419, { ptr, ptr, ptr, i32 } %419, ptr nonnull align 8 %2)
  %427 = icmp eq i32 %426, %334
  br i1 %427, label %._crit_edge.i999, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1005

._crit_edge.i999:                                 ; preds = %410
  %428 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %429 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %407)
  %430 = getelementptr i8, ptr %423, i64 48
  %431 = load ptr, ptr %430, align 8
  %result.i1.i1000 = call ptr %431({ ptr, ptr, ptr, i32 } %419, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %432 = call { ptr, i160 } %result.i1.i1000({ ptr, ptr, ptr, i32 } %419, { ptr, ptr, ptr, i32 } %419, ptr nonnull align 8 %2)
  %433 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %434 = load ptr, ptr %20, align 8
  %435 = call i1 %434({ ptr, i160 } %432, { ptr, i160 } %332)
  br i1 %435, label %436, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1005

436:                                              ; preds = %._crit_edge.i999
  %437 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %438 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %407)
  %439 = getelementptr i8, ptr %423, i64 56
  %440 = load ptr, ptr %439, align 8
  %result.i.i1002 = call ptr %440({ ptr, ptr, ptr, i32 } %419, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %441 = call { ptr, i160 } %result.i.i1002({ ptr, ptr, ptr, i32 } %419, { ptr, ptr, ptr, i32 } %419, ptr nonnull align 8 %2)
  %.fca.0.extract26.i1003 = extractvalue { ptr, i160 } %441, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1005

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1005: ; preds = %436, %._crit_edge.i999, %410, %380
  %.reg2mem36.0.i982 = phi ptr [ %.fca.0.extract26.i1003, %436 ], [ @nil_typ, %._crit_edge.i999 ], [ @nil_typ, %380 ], [ @nil_typ, %410 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %442 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i439 = icmp eq ptr %.reg2mem36.0.i982, null
  %443 = select i1 %.not.i439, ptr @nil_typ, ptr %.reg2mem36.0.i982
  br label %CuckooMap_get_keyK.exit446

CuckooMap_get_keyK.exit446:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1005, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950
  %.reg2mem17.0.i440 = phi ptr [ %443, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1005 ], [ %.fca.0.extract26.i948, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit950 ]
  %444 = icmp eq ptr %.reg2mem17.0.i440, @nil_typ
  %445 = icmp eq ptr %.reg2mem17.0.i440, null
  %446 = or i1 %444, %445
  %.0550..0553 = select i1 %446, i32 %.0550209, i32 %.0553208
  %447 = add i32 %.0550..0553, 1
  %.2555 = select i1 %446, i32 %.0553208, i32 %447
  %.2552 = select i1 %446, i32 %447, i32 %.0550209
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %327
  br i1 %exitcond.not, label %448, label %._crit_edge9

448:                                              ; preds = %CuckooMap_get_keyK.exit446
  %449 = call i64 @clock()
  %450 = mul i32 %.2555, 100
  %451 = sdiv i32 %450, %.0569
  %.fr = freeze i32 %451
  %452 = icmp slt i32 %.fr, 5
  br label %RangeIterator_next_.exit52.i.preheader1206

453:                                              ; preds = %._crit_edge8
  %454 = call i64 @clock()
  br label %RangeIterator_next_.exit52.i.preheader1206

RangeIterator_next_.exit52.i.preheader1206:       ; preds = %453, %448
  %455 = phi i64 [ %449, %448 ], [ %454, %453 ]
  %.0550.lcssa216 = phi i32 [ %.2552, %448 ], [ 0, %453 ]
  %.0553.lcssa215 = phi i32 [ %.2555, %448 ], [ 0, %453 ]
  %.reg2mem27.0.in = phi i1 [ %452, %448 ], [ true, %453 ]
  %result.i59 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %result.i59, align 1
  %456 = sub i64 %455, %324
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #41
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %459 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #41
  %result.i5.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %461 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %462 = load i8, ptr %result.i59, align 1
  store i8 %462, ptr %result.i5.i, align 1
  %463 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %464 = getelementptr i8, ptr %result.i59, i64 1
  %465 = load i8, ptr %464, align 1
  %466 = getelementptr i8, ptr %result.i5.i, i64 1
  store i8 %465, ptr %466, align 1
  %467 = getelementptr i8, ptr %result.i59, i64 2
  %468 = load i8, ptr %467, align 1
  %469 = getelementptr i8, ptr %result.i5.i, i64 2
  store i8 %468, ptr %469, align 1
  %470 = getelementptr i8, ptr %result.i59, i64 3
  %471 = load i8, ptr %470, align 1
  %472 = getelementptr i8, ptr %result.i5.i, i64 3
  store i8 %471, ptr %472, align 1
  %473 = getelementptr i8, ptr %result.i59, i64 4
  %474 = load i8, ptr %473, align 1
  %475 = getelementptr i8, ptr %result.i5.i, i64 4
  store i8 %474, ptr %475, align 1
  %476 = getelementptr i8, ptr %result.i59, i64 5
  %477 = load i8, ptr %476, align 1
  %478 = getelementptr i8, ptr %result.i5.i, i64 5
  store i8 %477, ptr %478, align 1
  %479 = getelementptr i8, ptr %result.i59, i64 6
  %480 = load i8, ptr %479, align 1
  %481 = getelementptr i8, ptr %result.i5.i, i64 6
  store i8 %480, ptr %481, align 1
  %482 = getelementptr i8, ptr %result.i59, i64 7
  %483 = load i8, ptr %482, align 1
  %484 = getelementptr i8, ptr %result.i5.i, i64 7
  store i8 %483, ptr %484, align 1
  %485 = getelementptr i8, ptr %result.i59, i64 8
  %486 = load i8, ptr %485, align 1
  %487 = getelementptr i8, ptr %result.i5.i, i64 8
  store i8 %486, ptr %487, align 1
  %488 = getelementptr i8, ptr %result.i59, i64 9
  %489 = load i8, ptr %488, align 1
  %490 = getelementptr i8, ptr %result.i5.i, i64 9
  store i8 %489, ptr %490, align 1
  %491 = getelementptr i8, ptr %result.i59, i64 10
  %492 = load i8, ptr %491, align 1
  %493 = getelementptr i8, ptr %result.i5.i, i64 10
  store i8 %492, ptr %493, align 1
  %494 = getelementptr i8, ptr %result.i59, i64 11
  %495 = load i8, ptr %494, align 1
  %496 = getelementptr i8, ptr %result.i5.i, i64 11
  store i8 %495, ptr %496, align 1
  %497 = getelementptr i8, ptr %result.i59, i64 12
  %498 = load i8, ptr %497, align 1
  %499 = getelementptr i8, ptr %result.i5.i, i64 12
  store i8 %498, ptr %499, align 1
  %500 = getelementptr i8, ptr %result.i59, i64 13
  %501 = load i8, ptr %500, align 1
  %502 = getelementptr i8, ptr %result.i5.i, i64 13
  store i8 %501, ptr %502, align 1
  %503 = getelementptr i8, ptr %result.i59, i64 14
  %504 = load i8, ptr %503, align 1
  %505 = getelementptr i8, ptr %result.i5.i, i64 14
  store i8 %504, ptr %505, align 1
  %506 = getelementptr i8, ptr %result.i5.i, i64 15
  store i8 0, ptr %506, align 1
  %puts.i1203 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #54
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %507 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %507, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #56
  %508 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0569) #56
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %509 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %509, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #56
  %510 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %456) #56
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #56
  br i1 %325, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader1206
  %511 = zext nneg i32 %.0569 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %512 = mul i64 %456, 1000000
  %513 = sdiv i64 %512, %511
  %514 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %514, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #56
  %515 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %513) #56
  %516 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %517 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %518 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %519 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #56
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader1206
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %520 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %521 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i1064.h2s1196, align 1
  %scevgep1157 = getelementptr inbounds i8, ptr %result.i5.i1064.h2s1196, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep1157, align 1
  %522 = getelementptr inbounds i8, ptr %result.i5.i1064.h2s1196, i64 18
  store i8 0, ptr %522, align 1
  %puts.i597 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i1064.h2s1196) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br i1 %.reg2mem27.0.in, label %RangeIterator_next_.exit52.i1086.preheader, label %.else

.else:                                            ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i1086.preheader

RangeIterator_next_.exit52.i1086.preheader:       ; preds = %.else, %print_benchmark_result.exit
  %.sink = phi <4 x i8> [ <i8 70, i8 65, i8 73, i8 76>, %.else ], [ <i8 80, i8 65, i8 83, i8 83>, %print_benchmark_result.exit ]
  %523 = phi ptr [ %10, %.else ], [ %6, %print_benchmark_result.exit ]
  %524 = phi ptr [ %9, %.else ], [ %5, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %.else ], [ %.sroa.gep574, %print_benchmark_result.exit ]
  %.sroa.phi575 = phi ptr [ %.sroa.gep576, %.else ], [ %.sroa.gep577, %print_benchmark_result.exit ]
  %.sroa.phi578 = phi ptr [ %.sroa.gep579, %.else ], [ %.sroa.gep580, %print_benchmark_result.exit ]
  %525 = phi ptr [ %8, %.else ], [ %4, %print_benchmark_result.exit ]
  %.sroa.phi581 = phi ptr [ %.sroa.gep582, %.else ], [ %.sroa.gep583, %print_benchmark_result.exit ]
  %.sroa.phi584 = phi ptr [ %.sroa.gep585, %.else ], [ %.sroa.gep586, %print_benchmark_result.exit ]
  %.sroa.phi587 = phi ptr [ %.sroa.gep588, %.else ], [ %.sroa.gep589, %print_benchmark_result.exit ]
  %526 = phi ptr [ %7, %.else ], [ %3, %print_benchmark_result.exit ]
  store ptr @_parameterization_Bufferi8, ptr %526, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi581, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi584, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi587, align 8
  %527 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %526)
  store ptr @buffer_typ, ptr %525, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi575, align 8
  store ptr @i32_typ, ptr %.sroa.phi578, align 8
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %525) #41
  store ptr @_parameterization_String, ptr %524, align 8
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %524)
  store ptr @String, ptr %523, align 8
  %530 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %523) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %531 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %532 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %result.i55.h2s1195.sroa.0.0.vec.extract = extractelement <4 x i8> %.sink, i64 0
  store i8 %result.i55.h2s1195.sroa.0.0.vec.extract, ptr %result.i5.i1083.h2s1194, align 1
  %scevgep1162 = getelementptr inbounds i8, ptr %result.i5.i1083.h2s1194, i64 1
  %result.i55.h2s1195.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sink, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i55.h2s1195.sroa.0.1.vec.extract, ptr %scevgep1162, align 1
  %533 = getelementptr inbounds i8, ptr %result.i5.i1083.h2s1194, i64 4
  store i8 0, ptr %533, align 1
  %puts.i617 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i1083.h2s1194) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %534 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %535 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i1102.h2s1192, align 1
  %scevgep1167 = getelementptr inbounds i8, ptr %result.i5.i1102.h2s1192, i64 1
  store <12 x i8> <i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %scevgep1167, align 1
  %536 = getelementptr inbounds i8, ptr %result.i5.i1102.h2s1192, i64 13
  store i8 0, ptr %536, align 1
  %puts.i637 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(14) %result.i5.i1102.h2s1192) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %537 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0550.lcssa216) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %538 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %539 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 44, ptr %result.i5.i1121.h2s1190, align 1
  %scevgep1172 = getelementptr inbounds i8, ptr %result.i5.i1121.h2s1190, i64 1
  store <7 x i8> <i8 32, i8 72, i8 105, i8 116, i8 115, i8 58, i8 32>, ptr %scevgep1172, align 1
  %540 = getelementptr inbounds i8, ptr %result.i5.i1121.h2s1190, i64 8
  store i8 0, ptr %540, align 1
  %puts.i657 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(9) %result.i5.i1121.h2s1190) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %541 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0553.lcssa215) #56
  %542 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %543 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %544 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %545 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 41, ptr %result.i5.i1140.h2s1188, align 2
  %546 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %548 = getelementptr inbounds i8, ptr %result.i5.i1140.h2s1188, i64 1
  store i8 0, ptr %548, align 1
  %puts.i677 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i5.i1140.h2s1188) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr #18 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i1215.h2s1265 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i5.i1215.h2s1265, align 2
  %result.i5.i1196.h2s1267 = alloca [21 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(21) %result.i5.i1196.h2s1267, i8 0, i64 21, i1 false)
  %result.i5.i1177.h2s1269 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i1177.h2s1269, i8 0, i64 5, i1 false)
  %result.i5.i1158.h2s1271 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i1158.h2s1271, i8 0, i64 19, i1 false)
  %result.i5.i1101.h2s1273 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i1101.h2s1273, i8 0, i64 30, i1 false)
  %result.i5.i.h2s1275 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i.h2s1275, i8 0, i64 30, i1 false)
  %oldProtect.i82 = alloca i32, align 4
  %oldProtect.i80 = alloca i32, align 4
  %oldProtect.i78 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %3 = alloca [2 x ptr], align 8
  %4 = alloca [2 x ptr], align 8
  %.sroa.0500.sroa.0 = alloca i8, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca [4 x ptr], align 8
  %7 = alloca { ptr, ptr, ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [4 x ptr], align 8
  %11 = alloca { ptr, ptr, ptr, ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %result.i76 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i76, align 8
  %14 = getelementptr inbounds i8, ptr %result.i76, i64 8
  store ptr @_parameterization_i32, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i76, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i76) #41
  %result.i75 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  %result.i77 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i75, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i75, ptr noalias nofree noundef nonnull readnone @ybmjkqijeh, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i50 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i75) #48
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i75) #41
  %result.i74 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #41
  %result.i79 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i74, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i74, ptr noalias nofree noundef nonnull readnone @vyzyclalfc, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i49 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i74) #48
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i74) #41
  %19 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i76, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr undef, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 10, 3
  %22 = getelementptr inbounds i8, ptr %result.i76, i64 48
  store ptr %ret.i50, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i76, i64 56
  store ptr %ret.i49, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %result.i76, i64 40
  store i32 8, ptr %24, align 8
  %result.i1.i259 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %25 = getelementptr inbounds i8, ptr %result.i76, i64 24
  store ptr %result.i1.i259, ptr %25, align 8
  %result.i.i260 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %26 = getelementptr inbounds i8, ptr %result.i76, i64 32
  store ptr %result.i.i260, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i76, i64 44
  store i32 0, ptr %27, align 4
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #41
  %29 = sext i32 %0 to i64
  %30 = shl nsw i64 %29, 2
  %result.i2.i288 = call noalias ptr @bump_malloc_wrapper(i64 noundef %30) #49
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  %result.i71 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #49
  store ptr @_parameterization_i32, ptr %result.i71, align 8
  %32 = getelementptr inbounds i8, ptr %result.i71, i64 8
  store ptr @_parameterization_Bool, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i71, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i71) #41
  %result.i70 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i80) #41
  %result.i81 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i70, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i80) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i80) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i70, ptr noalias nofree noundef nonnull readnone @nbugdksdmt, ptr noalias nofree noundef nonnull readnone @i32_hasher) #41
  %ret.i48 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i70) #48
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i70) #41
  %result.i69 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i82) #41
  %result.i83 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i69, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i82) #58
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i82) #41
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i69, ptr noalias nofree noundef nonnull readnone @cniklhvjbm, ptr noalias nofree noundef nonnull readnone @i32_eq) #41
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i69) #48
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i69) #41
  %37 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i71, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr undef, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 10, 3
  %40 = getelementptr inbounds i8, ptr %result.i71, i64 48
  store ptr %ret.i48, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %result.i71, i64 56
  store ptr %ret.i, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i71, i64 40
  store i32 8, ptr %42, align 8
  %result.i1.i302 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %43 = getelementptr inbounds i8, ptr %result.i71, i64 24
  store ptr %result.i1.i302, ptr %43, align 8
  %result.i.i303 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %44 = getelementptr inbounds i8, ptr %result.i71, i64 32
  store ptr %result.i.i303, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %46 = getelementptr inbounds i8, ptr %result.i71, i64 44
  store i32 0, ptr %46, align 4
  %47 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %11, i64 8
  %.sroa.gep567 = getelementptr inbounds i8, ptr %11, i64 16
  %.sroa.gep570 = getelementptr inbounds i8, ptr %11, i64 24
  %.sroa.gep573 = getelementptr inbounds i8, ptr %10, i64 8
  %.sroa.gep576 = getelementptr inbounds i8, ptr %10, i64 16
  %.sroa.gep579 = getelementptr inbounds i8, ptr %10, i64 24
  %48 = getelementptr inbounds i8, ptr %3, i64 8
  %49 = getelementptr inbounds i8, ptr %4, i64 8
  %50 = getelementptr inbounds i8, ptr %5, i64 8
  %.promoted = load ptr, ptr %48, align 8
  %.promoted209 = load ptr, ptr %49, align 8
  %.promoted212 = load ptr, ptr %50, align 8
  %51 = icmp sgt i32 %0, 0
  %52 = icmp sgt i32 %47, 0
  %spec.select214 = and i1 %51, %52
  br i1 %spec.select214, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #41
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %55

55:                                               ; preds = %._crit_edge1, %.lr.ph
  %56 = phi i32 [ 101112, %.lr.ph ], [ %59, %._crit_edge1 ]
  %.0537219 = phi i32 [ 0, %.lr.ph ], [ %189, %._crit_edge1 ]
  %.0538218 = phi i32 [ 0, %.lr.ph ], [ %.1539, %._crit_edge1 ]
  %_parameterization_i32208217 = phi ptr [ %.promoted, %.lr.ph ], [ %_parameterization_i32, %._crit_edge1 ]
  %_parameterization_i32211216 = phi ptr [ %.promoted209, %.lr.ph ], [ %_parameterization_i32210, %._crit_edge1 ]
  %_parameterization_Bool213215 = phi ptr [ %.promoted212, %.lr.ph ], [ %_parameterization_Bool, %._crit_edge1 ]
  %57 = mul i32 %56, 1103515245
  %58 = add i32 %57, 12345
  %59 = and i32 %58, 2147483647
  %.sroa.0527.0.insert.ext = zext nneg i32 %59 to i160
  %60 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0527.0.insert.ext, 1
  %61 = load ptr, ptr %40, align 8
  %62 = call i32 %61({ ptr, i160 } %60)
  %63 = load i32, ptr %42, align 8
  %64 = add i32 %63, -1
  %65 = and i32 %64, %62
  %66 = load ptr, ptr %43, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %68 = sext i32 %65 to i64
  %69 = shl nsw i64 %68, 5
  %70 = getelementptr i8, ptr %66, i64 %69
  %71 = load ptr, ptr %70, align 8
  %72 = icmp ne ptr %71, @nil_typ
  %73 = icmp ne ptr %71, null
  %.not48.i = and i1 %72, %73
  br i1 %.not48.i, label %74, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

74:                                               ; preds = %55
  %75 = getelementptr i8, ptr %70, i64 8
  %76 = load i64, ptr %75, align 4
  %.sroa_idx.i = getelementptr i8, ptr %70, i64 16
  %77 = load i64, ptr %.sroa_idx.i, align 4
  %78 = inttoptr i64 %76 to ptr
  %79 = inttoptr i64 %77 to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %71, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %71, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %71, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %80 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %71, 0
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %78, 1
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %79, 2
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, i32 %offset.i14.i, 3
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %71) #41
  %86 = sext i32 %offset.i14.i to i64
  %87 = getelementptr ptr, ptr %71, i64 %86
  %88 = getelementptr i8, ptr %87, i64 64
  %89 = load ptr, ptr %88, align 8
  %result.i2.i761 = call ptr %89({ ptr, ptr, ptr, i32 } %83, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %90 = call i32 %result.i2.i761({ ptr, ptr, ptr, i32 } %83, { ptr, ptr, ptr, i32 } %83, ptr nonnull align 8 %2)
  %91 = icmp eq i32 %90, %62
  br i1 %91, label %._crit_edge.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i:                                    ; preds = %74
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %71)
  %94 = getelementptr i8, ptr %87, i64 48
  %95 = load ptr, ptr %94, align 8
  %result.i1.i = call ptr %95({ ptr, ptr, ptr, i32 } %83, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %96 = call { ptr, i160 } %result.i1.i({ ptr, ptr, ptr, i32 } %83, { ptr, ptr, ptr, i32 } %83, ptr nonnull align 8 %2)
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %98 = load ptr, ptr %41, align 8
  %99 = call i1 %98({ ptr, i160 } %96, { ptr, i160 } %60)
  br i1 %99, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i, %74, %55
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %108

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %71)
  %102 = getelementptr i8, ptr %87, i64 56
  %103 = load ptr, ptr %102, align 8
  %result.i.i762 = call ptr %103({ ptr, ptr, ptr, i32 } %83, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %104 = call { ptr, i160 } %result.i.i762({ ptr, ptr, ptr, i32 } %83, { ptr, ptr, ptr, i32 } %83, ptr nonnull align 8 %2)
  %.fca.0.extract26.i = extractvalue { ptr, i160 } %104, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %106 = icmp ne ptr %.fca.0.extract26.i, @nil_typ
  %107 = icmp ne ptr %.fca.0.extract26.i, null
  %.not99.i = and i1 %106, %107
  br i1 %.not99.i, label %CuckooMap_get_keyK.exit, label %108

108:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %109 = add i32 %62, 2127912214
  %110 = shl i32 %62, 12
  %111 = add i32 %109, %110
  %112 = ashr i32 %111, 19
  %113 = xor i32 %111, %112
  %114 = xor i32 %113, -949894596
  %115 = add i32 %114, 374761393
  %116 = shl i32 %114, 5
  %117 = add i32 %115, %116
  %118 = add i32 %117, -744332180
  %119 = shl i32 %117, 9
  %120 = xor i32 %118, %119
  %121 = add i32 %120, -42973499
  %122 = shl i32 %120, 3
  %123 = add i32 %121, %122
  %124 = ashr i32 %123, 16
  %125 = xor i32 %123, %124
  %126 = xor i32 %125, -1252372727
  %127 = load i32, ptr %42, align 8
  %128 = add i32 %127, -1
  %129 = and i32 %128, %126
  %130 = load ptr, ptr %44, align 8
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %132 = sext i32 %129 to i64
  %133 = shl nsw i64 %132, 5
  %134 = getelementptr i8, ptr %130, i64 %133
  %135 = load ptr, ptr %134, align 8
  %136 = icmp ne ptr %135, @nil_typ
  %137 = icmp ne ptr %135, null
  %.not48.i791 = and i1 %136, %137
  br i1 %.not48.i791, label %138, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit816

138:                                              ; preds = %108
  %139 = getelementptr i8, ptr %134, i64 8
  %140 = load i64, ptr %139, align 4
  %.sroa_idx.i796 = getelementptr i8, ptr %134, i64 16
  %141 = load i64, ptr %.sroa_idx.i796, align 4
  %142 = inttoptr i64 %140 to ptr
  %143 = inttoptr i64 %141 to ptr
  %hash_coef_ptr.i3.i797 = getelementptr i8, ptr %135, i64 8
  %tbl_size_ptr.i4.i798 = getelementptr i8, ptr %135, i64 16
  %offset_tbl_ptr.i5.i799 = getelementptr i8, ptr %135, i64 40
  %hash_coef.i6.i800 = load i64, ptr %hash_coef_ptr.i3.i797, align 4
  %tbl_size.i7.i801 = load i64, ptr %tbl_size_ptr.i4.i798, align 4
  %offset_tbl.i8.i802 = load ptr, ptr %offset_tbl_ptr.i5.i799, align 8
  %product.i.i9.i803 = mul i64 %hash_coef.i6.i800, 4015701072841558310
  %shifted.i.i10.i804 = lshr i64 %product.i.i9.i803, 32
  %xored.i.i11.i805 = xor i64 %shifted.i.i10.i804, %product.i.i9.i803
  %hash.i.i12.i806 = and i64 %xored.i.i11.i805, %tbl_size.i7.i801
  %offset_ptr.i13.i807 = getelementptr i32, ptr %offset_tbl.i8.i802, i64 %hash.i.i12.i806
  %offset.i14.i808 = load i32, ptr %offset_ptr.i13.i807, align 4
  %144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %135, 0
  %145 = insertvalue { ptr, ptr, ptr, i32 } %144, ptr %142, 1
  %146 = insertvalue { ptr, ptr, ptr, i32 } %145, ptr %143, 2
  %147 = insertvalue { ptr, ptr, ptr, i32 } %146, i32 %offset.i14.i808, 3
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %135) #41
  %150 = sext i32 %offset.i14.i808 to i64
  %151 = getelementptr ptr, ptr %135, i64 %150
  %152 = getelementptr i8, ptr %151, i64 64
  %153 = load ptr, ptr %152, align 8
  %result.i2.i809 = call ptr %153({ ptr, ptr, ptr, i32 } %147, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %154 = call i32 %result.i2.i809({ ptr, ptr, ptr, i32 } %147, { ptr, ptr, ptr, i32 } %147, ptr nonnull align 8 %2)
  %155 = icmp eq i32 %154, %62
  br i1 %155, label %._crit_edge.i810, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit816

._crit_edge.i810:                                 ; preds = %138
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %135)
  %158 = getelementptr i8, ptr %151, i64 48
  %159 = load ptr, ptr %158, align 8
  %result.i1.i811 = call ptr %159({ ptr, ptr, ptr, i32 } %147, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %160 = call { ptr, i160 } %result.i1.i811({ ptr, ptr, ptr, i32 } %147, { ptr, ptr, ptr, i32 } %147, ptr nonnull align 8 %2)
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %162 = load ptr, ptr %41, align 8
  %163 = call i1 %162({ ptr, i160 } %160, { ptr, i160 } %60)
  br i1 %163, label %164, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit816

164:                                              ; preds = %._crit_edge.i810
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %135)
  %167 = getelementptr i8, ptr %151, i64 56
  %168 = load ptr, ptr %167, align 8
  %result.i.i813 = call ptr %168({ ptr, ptr, ptr, i32 } %147, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %169 = call { ptr, i160 } %result.i.i813({ ptr, ptr, ptr, i32 } %147, { ptr, ptr, ptr, i32 } %147, ptr nonnull align 8 %2)
  %.fca.0.extract26.i814 = extractvalue { ptr, i160 } %169, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit816

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit816: ; preds = %164, %._crit_edge.i810, %138, %108
  %.reg2mem36.0.i793 = phi ptr [ %.fca.0.extract26.i814, %164 ], [ @nil_typ, %._crit_edge.i810 ], [ @nil_typ, %108 ], [ @nil_typ, %138 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i = icmp eq ptr %.reg2mem36.0.i793, null
  %171 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem36.0.i793
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit816, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.reg2mem17.0.i = phi ptr [ %171, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit816 ], [ %.fca.0.extract26.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %172 = icmp eq ptr %.reg2mem17.0.i, @nil_typ
  %173 = icmp eq ptr %.reg2mem17.0.i, null
  %174 = or i1 %172, %173
  br i1 %174, label %175, label %._crit_edge1

175:                                              ; preds = %CuckooMap_get_keyK.exit
  %176 = add nuw i32 %59, 1
  %.sroa.0510.0.insert.ext = zext i32 %176 to i160
  %177 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0510.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %3)
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %60, { ptr, i160 } %177)
  store ptr @_parameterization_i32, ptr %4, align 8
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %4)
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %182 = sext i32 %.0538218 to i64
  %183 = shl nsw i64 %182, 2
  %184 = getelementptr i8, ptr %result.i2.i288, i64 %183
  store i32 %59, ptr %184, align 1
  store i1 true, ptr %.sroa.0500.sroa.0, align 8
  %.sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.0. = load i8, ptr %.sroa.0500.sroa.0, align 8
  %.sroa.0500.0.insert.ext = zext i8 %.sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.0. to i160
  %185 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0500.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  %186 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } poison, ptr nofree nonnull align 8 poison, { ptr, i160 } %60, { ptr, i160 } %185)
  %188 = add nsw i32 %.0538218, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %175, %CuckooMap_get_keyK.exit
  %_parameterization_Bool = phi ptr [ @_parameterization_Bool, %175 ], [ %_parameterization_Bool213215, %CuckooMap_get_keyK.exit ]
  %_parameterization_i32210 = phi ptr [ @_parameterization_i32, %175 ], [ %_parameterization_i32211216, %CuckooMap_get_keyK.exit ]
  %_parameterization_i32 = phi ptr [ @_parameterization_i32, %175 ], [ %_parameterization_i32208217, %CuckooMap_get_keyK.exit ]
  %.1539 = phi i32 [ %188, %175 ], [ %.0538218, %CuckooMap_get_keyK.exit ]
  %189 = add nuw nsw i32 %.0537219, 1
  %190 = icmp slt i32 %.1539, %0
  %191 = icmp slt i32 %189, %47
  %spec.select = select i1 %190, i1 %191, i1 false
  br i1 %spec.select, label %55, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %_parameterization_Bool213.lcssa = phi ptr [ %.promoted212, %1 ], [ %_parameterization_Bool, %._crit_edge1 ]
  %_parameterization_i32211.lcssa = phi ptr [ %.promoted209, %1 ], [ %_parameterization_i32210, %._crit_edge1 ]
  %_parameterization_i32208.lcssa = phi ptr [ %.promoted, %1 ], [ %_parameterization_i32, %._crit_edge1 ]
  %.0538.lcssa = phi i32 [ 0, %1 ], [ %.1539, %._crit_edge1 ]
  store ptr %_parameterization_i32208.lcssa, ptr %48, align 8
  store ptr %_parameterization_i32211.lcssa, ptr %49, align 8
  store ptr %_parameterization_Bool213.lcssa, ptr %50, align 8
  %.sroa.gep565 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep568 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep571 = getelementptr inbounds i8, ptr %7, i64 24
  %.sroa.gep574 = getelementptr inbounds i8, ptr %6, i64 8
  %.sroa.gep577 = getelementptr inbounds i8, ptr %6, i64 16
  %.sroa.gep580 = getelementptr inbounds i8, ptr %6, i64 24
  %192 = icmp slt i32 %.0538.lcssa, %0
  br i1 %192, label %RangeIterator_next_.exit52.i.preheader, label %._crit_edge4

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge3._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 87, ptr %result.i5.i.h2s1275, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s1275, i64 1
  store <28 x i8> <i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %scevgep, align 1
  %195 = getelementptr inbounds i8, ptr %result.i5.i.h2s1275, i64 29
  store i8 0, ptr %195, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i.h2s1275) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0538.lcssa) #56
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 32, ptr %result.i5.i1101.h2s1273, align 1
  %scevgep1227 = getelementptr inbounds i8, ptr %result.i5.i1101.h2s1273, i64 1
  store <28 x i8> <i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %scevgep1227, align 1
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %202 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %203 = getelementptr inbounds i8, ptr %result.i5.i1101.h2s1273, i64 29
  store i8 0, ptr %203, align 1
  %puts.i613 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i1101.h2s1273) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %._crit_edge3._crit_edge
  %.0552 = phi i32 [ %.0538.lcssa, %RangeIterator_next_.exit52.i.preheader ], [ %0, %._crit_edge3._crit_edge ]
  %204 = call i64 @clock()
  %205 = icmp sgt i32 %.0552, 0
  br i1 %205, label %.lr.ph245.preheader, label %._crit_edge8

.lr.ph245.preheader:                              ; preds = %._crit_edge4
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %207 = zext nneg i32 %.0552 to i64
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  br label %.lr.ph245

.lr.ph245:                                        ; preds = %._crit_edge5, %.lr.ph245.preheader
  %indvars.iv = phi i64 [ 0, %.lr.ph245.preheader ], [ %indvars.iv.next, %._crit_edge5 ]
  %.0540244 = phi i32 [ 0, %.lr.ph245.preheader ], [ %.1541, %._crit_edge5 ]
  %.0543243 = phi i1 [ true, %.lr.ph245.preheader ], [ %.2545, %._crit_edge5 ]
  %209 = shl i64 %indvars.iv, 2
  %210 = getelementptr i8, ptr %result.i2.i288, i64 %209
  %211 = load i32, ptr %210, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %211 to i160
  %212 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %213 = load ptr, ptr %22, align 8
  %214 = call i32 %213({ ptr, i160 } %212)
  %215 = load i32, ptr %24, align 8
  %216 = add i32 %215, -1
  %217 = and i32 %216, %214
  %218 = load ptr, ptr %25, align 8
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %220 = sext i32 %217 to i64
  %221 = shl nsw i64 %220, 5
  %222 = getelementptr i8, ptr %218, i64 %221
  %223 = load ptr, ptr %222, align 8
  %224 = icmp ne ptr %223, @nil_typ
  %225 = icmp ne ptr %223, null
  %.not62.i = and i1 %224, %225
  br i1 %.not62.i, label %226, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

226:                                              ; preds = %.lr.ph245
  %227 = getelementptr i8, ptr %222, i64 8
  %228 = load i64, ptr %227, align 4
  %.sroa_idx.i863 = getelementptr i8, ptr %222, i64 16
  %229 = load i64, ptr %.sroa_idx.i863, align 4
  %230 = inttoptr i64 %228 to ptr
  %231 = inttoptr i64 %229 to ptr
  %hash_coef_ptr.i3.i864 = getelementptr i8, ptr %223, i64 8
  %tbl_size_ptr.i4.i865 = getelementptr i8, ptr %223, i64 16
  %offset_tbl_ptr.i5.i866 = getelementptr i8, ptr %223, i64 40
  %hash_coef.i6.i867 = load i64, ptr %hash_coef_ptr.i3.i864, align 4
  %tbl_size.i7.i868 = load i64, ptr %tbl_size_ptr.i4.i865, align 4
  %offset_tbl.i8.i869 = load ptr, ptr %offset_tbl_ptr.i5.i866, align 8
  %product.i.i9.i870 = mul i64 %hash_coef.i6.i867, 4015701072841558310
  %shifted.i.i10.i871 = lshr i64 %product.i.i9.i870, 32
  %xored.i.i11.i872 = xor i64 %shifted.i.i10.i871, %product.i.i9.i870
  %hash.i.i12.i873 = and i64 %xored.i.i11.i872, %tbl_size.i7.i868
  %offset_ptr.i13.i874 = getelementptr i32, ptr %offset_tbl.i8.i869, i64 %hash.i.i12.i873
  %offset.i14.i875 = load i32, ptr %offset_ptr.i13.i874, align 4
  %232 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %223, 0
  %233 = insertvalue { ptr, ptr, ptr, i32 } %232, ptr %230, 1
  %234 = insertvalue { ptr, ptr, ptr, i32 } %233, ptr %231, 2
  %235 = insertvalue { ptr, ptr, ptr, i32 } %234, i32 %offset.i14.i875, 3
  %236 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %237 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %223) #41
  %238 = sext i32 %offset.i14.i875 to i64
  %239 = getelementptr ptr, ptr %223, i64 %238
  %240 = getelementptr i8, ptr %239, i64 64
  %241 = load ptr, ptr %240, align 8
  %result.i2.i = call ptr %241({ ptr, ptr, ptr, i32 } %235, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %242 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %235, { ptr, ptr, ptr, i32 } %235, ptr nonnull align 8 %2)
  %243 = icmp eq i32 %242, %214
  br i1 %243, label %._crit_edge.i876, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i876:                                 ; preds = %226
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %223)
  %246 = getelementptr i8, ptr %239, i64 48
  %247 = load ptr, ptr %246, align 8
  %result.i1.i877 = call ptr %247({ ptr, ptr, ptr, i32 } %235, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %248 = call { ptr, i160 } %result.i1.i877({ ptr, ptr, ptr, i32 } %235, { ptr, ptr, ptr, i32 } %235, ptr nonnull align 8 %2)
  %249 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %250 = load ptr, ptr %23, align 8
  %251 = call i1 %250({ ptr, i160 } %248, { ptr, i160 } %212)
  br i1 %251, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i876, %226, %.lr.ph245
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %262

CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i876
  %252 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %253 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %223)
  %254 = getelementptr i8, ptr %239, i64 56
  %255 = load ptr, ptr %254, align 8
  %result.i.i878 = call ptr %255({ ptr, ptr, ptr, i32 } %235, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %256 = call { ptr, i160 } %result.i.i878({ ptr, ptr, ptr, i32 } %235, { ptr, ptr, ptr, i32 } %235, ptr nonnull align 8 %2)
  %.fca.0.extract40.i = extractvalue { ptr, i160 } %256, 0
  %.fca.1.extract41.i = extractvalue { ptr, i160 } %256, 1
  store ptr @nil_typ, ptr %222, align 8
  %257 = load i32, ptr %27, align 4
  %258 = add i32 %257, -1
  store i32 %258, ptr %27, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %259 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %260 = icmp ne ptr %.fca.0.extract40.i, @nil_typ
  %261 = icmp ne ptr %.fca.0.extract40.i, null
  %.not99.i411 = and i1 %260, %261
  %extract.t1087 = trunc i160 %.fca.1.extract41.i to i32
  br i1 %.not99.i411, label %CuckooMap_remove_keyK.exit, label %262

262:                                              ; preds = %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %263 = add i32 %214, 2127912214
  %264 = shl i32 %214, 12
  %265 = add i32 %263, %264
  %266 = ashr i32 %265, 19
  %267 = xor i32 %265, %266
  %268 = xor i32 %267, -949894596
  %269 = add i32 %268, 374761393
  %270 = shl i32 %268, 5
  %271 = add i32 %269, %270
  %272 = add i32 %271, -744332180
  %273 = shl i32 %271, 9
  %274 = xor i32 %272, %273
  %275 = add i32 %274, -42973499
  %276 = shl i32 %274, 3
  %277 = add i32 %275, %276
  %278 = ashr i32 %277, 16
  %279 = xor i32 %277, %278
  %280 = xor i32 %279, -1252372727
  %281 = load i32, ptr %24, align 8
  %282 = add i32 %281, -1
  %283 = and i32 %282, %280
  %284 = load ptr, ptr %26, align 8
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %286 = sext i32 %283 to i64
  %287 = shl nsw i64 %286, 5
  %288 = getelementptr i8, ptr %284, i64 %287
  %289 = load ptr, ptr %288, align 8
  %290 = icmp ne ptr %289, @nil_typ
  %291 = icmp ne ptr %289, null
  %.not62.i909 = and i1 %290, %291
  br i1 %.not62.i909, label %292, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934

292:                                              ; preds = %262
  %293 = getelementptr i8, ptr %288, i64 8
  %294 = load i64, ptr %293, align 4
  %.sroa_idx.i914 = getelementptr i8, ptr %288, i64 16
  %295 = load i64, ptr %.sroa_idx.i914, align 4
  %296 = inttoptr i64 %294 to ptr
  %297 = inttoptr i64 %295 to ptr
  %hash_coef_ptr.i3.i915 = getelementptr i8, ptr %289, i64 8
  %tbl_size_ptr.i4.i916 = getelementptr i8, ptr %289, i64 16
  %offset_tbl_ptr.i5.i917 = getelementptr i8, ptr %289, i64 40
  %hash_coef.i6.i918 = load i64, ptr %hash_coef_ptr.i3.i915, align 4
  %tbl_size.i7.i919 = load i64, ptr %tbl_size_ptr.i4.i916, align 4
  %offset_tbl.i8.i920 = load ptr, ptr %offset_tbl_ptr.i5.i917, align 8
  %product.i.i9.i921 = mul i64 %hash_coef.i6.i918, 4015701072841558310
  %shifted.i.i10.i922 = lshr i64 %product.i.i9.i921, 32
  %xored.i.i11.i923 = xor i64 %shifted.i.i10.i922, %product.i.i9.i921
  %hash.i.i12.i924 = and i64 %xored.i.i11.i923, %tbl_size.i7.i919
  %offset_ptr.i13.i925 = getelementptr i32, ptr %offset_tbl.i8.i920, i64 %hash.i.i12.i924
  %offset.i14.i926 = load i32, ptr %offset_ptr.i13.i925, align 4
  %298 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %289, 0
  %299 = insertvalue { ptr, ptr, ptr, i32 } %298, ptr %296, 1
  %300 = insertvalue { ptr, ptr, ptr, i32 } %299, ptr %297, 2
  %301 = insertvalue { ptr, ptr, ptr, i32 } %300, i32 %offset.i14.i926, 3
  %302 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %303 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %289) #41
  %304 = sext i32 %offset.i14.i926 to i64
  %305 = getelementptr ptr, ptr %289, i64 %304
  %306 = getelementptr i8, ptr %305, i64 64
  %307 = load ptr, ptr %306, align 8
  %result.i2.i927 = call ptr %307({ ptr, ptr, ptr, i32 } %301, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %308 = call i32 %result.i2.i927({ ptr, ptr, ptr, i32 } %301, { ptr, ptr, ptr, i32 } %301, ptr nonnull align 8 %2)
  %309 = icmp eq i32 %308, %214
  br i1 %309, label %._crit_edge.i928, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934

._crit_edge.i928:                                 ; preds = %292
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %311 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %289)
  %312 = getelementptr i8, ptr %305, i64 48
  %313 = load ptr, ptr %312, align 8
  %result.i1.i929 = call ptr %313({ ptr, ptr, ptr, i32 } %301, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %314 = call { ptr, i160 } %result.i1.i929({ ptr, ptr, ptr, i32 } %301, { ptr, ptr, ptr, i32 } %301, ptr nonnull align 8 %2)
  %315 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %316 = load ptr, ptr %23, align 8
  %317 = call i1 %316({ ptr, i160 } %314, { ptr, i160 } %212)
  br i1 %317, label %318, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934

318:                                              ; preds = %._crit_edge.i928
  %319 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %320 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %289)
  %321 = getelementptr i8, ptr %305, i64 56
  %322 = load ptr, ptr %321, align 8
  %result.i.i931 = call ptr %322({ ptr, ptr, ptr, i32 } %301, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %323 = call { ptr, i160 } %result.i.i931({ ptr, ptr, ptr, i32 } %301, { ptr, ptr, ptr, i32 } %301, ptr nonnull align 8 %2)
  %.fca.0.extract40.i932 = extractvalue { ptr, i160 } %323, 0
  %.fca.1.extract41.i933 = extractvalue { ptr, i160 } %323, 1
  store ptr @nil_typ, ptr %288, align 8
  %324 = load i32, ptr %27, align 4
  %325 = add i32 %324, -1
  store i32 %325, ptr %27, align 4
  %326 = trunc i160 %.fca.1.extract41.i933 to i32
  br label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934

CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934: ; preds = %318, %._crit_edge.i928, %292, %262
  %.reg2mem38.sroa.3.0.i910 = phi i32 [ %326, %318 ], [ poison, %._crit_edge.i928 ], [ poison, %262 ], [ poison, %292 ]
  %.reg2mem36.0.i911 = phi ptr [ %.fca.0.extract40.i932, %318 ], [ @nil_typ, %._crit_edge.i928 ], [ @nil_typ, %262 ], [ @nil_typ, %292 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %327 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i416 = icmp eq ptr %.reg2mem36.0.i911, null
  %328 = select i1 %.not.i416, ptr @nil_typ, ptr %.reg2mem36.0.i911
  br label %CuckooMap_remove_keyK.exit

CuckooMap_remove_keyK.exit:                       ; preds = %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not99.i4111081.off0 = phi i32 [ %.reg2mem38.sroa.3.0.i910, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934 ], [ %extract.t1087, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem17.0.i417 = phi ptr [ %328, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit934 ], [ %.fca.0.extract40.i, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %329 = icmp ne ptr %.reg2mem17.0.i417, @nil_typ
  %330 = icmp ne ptr %.reg2mem17.0.i417, null
  %.not556 = and i1 %329, %330
  br i1 %.not556, label %331, label %RangeIterator_next_.exit52.i1142.preheader

331:                                              ; preds = %CuckooMap_remove_keyK.exit
  %332 = add i32 %211, 1
  %.not = icmp eq i32 %332, %.not99.i4111081.off0
  br i1 %.not, label %._crit_edge6, label %RangeIterator_next_.exit52.i1123.preheader

RangeIterator_next_.exit52.i1123.preheader:       ; preds = %331
  %result.i64.h2s1279 = alloca [46 x i8], align 1
  %333 = getelementptr inbounds i8, ptr %result.i64.h2s1279, i64 45
  store i8 0, ptr %333, align 1
  store <45 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 119, i8 114, i8 111, i8 110, i8 103, i8 32, i8 118, i8 97, i8 108, i8 117, i8 101, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i64.h2s1279, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %334 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %335 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %result.i5.i1120.h2s1280 = alloca [46 x i8], align 1
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 87, ptr %result.i5.i1120.h2s1280, align 1
  %scevgep1237 = getelementptr inbounds i8, ptr %result.i5.i1120.h2s1280, i64 1
  %scevgep1238 = getelementptr inbounds i8, ptr %result.i64.h2s1279, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(45) %scevgep1237, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(45) %scevgep1238, i64 noundef 44, i1 noundef false)
  %337 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %338 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %339 = getelementptr inbounds i8, ptr %result.i5.i1120.h2s1280, i64 45
  store i8 0, ptr %339, align 1
  %puts.i632 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(46) %result.i5.i1120.h2s1280) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %340 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %341 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %211) #56
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %RangeIterator_next_.exit52.i1123.preheader, %331
  %.1544 = phi i1 [ false, %RangeIterator_next_.exit52.i1123.preheader ], [ %.0543243, %331 ]
  %342 = add i32 %.0540244, 1
  br label %._crit_edge5

RangeIterator_next_.exit52.i1142.preheader:       ; preds = %CuckooMap_remove_keyK.exit
  %result.i62.h2s1277 = alloca [38 x i8], align 1
  %343 = getelementptr inbounds i8, ptr %result.i62.h2s1277, i64 37
  store i8 0, ptr %343, align 1
  store <37 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 78, i8 105, i8 108, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i62.h2s1277, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %344 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %345 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %result.i5.i1139.h2s1278 = alloca [38 x i8], align 1
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 87, ptr %result.i5.i1139.h2s1278, align 1
  %scevgep1232 = getelementptr inbounds i8, ptr %result.i5.i1139.h2s1278, i64 1
  %scevgep1233 = getelementptr inbounds i8, ptr %result.i62.h2s1277, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(37) %scevgep1232, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(37) %scevgep1233, i64 noundef 36, i1 noundef false)
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %348 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %349 = getelementptr inbounds i8, ptr %result.i5.i1139.h2s1278, i64 37
  store i8 0, ptr %349, align 1
  %puts.i652 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(38) %result.i5.i1139.h2s1278) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %350 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %351 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %211) #56
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %RangeIterator_next_.exit52.i1142.preheader, %._crit_edge6
  %.2545 = phi i1 [ %.1544, %._crit_edge6 ], [ false, %RangeIterator_next_.exit52.i1142.preheader ]
  %.1541 = phi i32 [ %342, %._crit_edge6 ], [ %.0540244, %RangeIterator_next_.exit52.i1142.preheader ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %207
  br i1 %exitcond.not, label %._crit_edge8, label %.lr.ph245

._crit_edge8:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0543.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.2545, %._crit_edge5 ]
  %.0540.lcssa = phi i32 [ 0, %._crit_edge4 ], [ %.1541, %._crit_edge5 ]
  %352 = call i64 @clock()
  %.not557 = icmp eq i32 %.0540.lcssa, %.0552
  %353 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %354 = load i32, ptr %27, align 4
  %.not558 = icmp eq i32 %354, 0
  %355 = select i1 %.not558, i1 %.not557, i1 false
  %spec.select564 = select i1 %355, i1 %.0543.lcssa, i1 false
  br i1 %205, label %356, label %RangeIterator_next_.exit52.i.preheader1286

356:                                              ; preds = %._crit_edge8
  %357 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #44
  %358 = load i32, ptr %result.i2.i288, align 1
  %.sroa.2.sroa.0.0.insert.ext.i935 = zext i32 %358 to i160
  %359 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i935, 1
  %360 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %361 = load ptr, ptr %22, align 8
  %362 = call i32 %361({ ptr, i160 } %359)
  %363 = load i32, ptr %24, align 8
  %364 = add i32 %363, -1
  %365 = and i32 %364, %362
  %366 = load ptr, ptr %25, align 8
  %367 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %368 = sext i32 %365 to i64
  %369 = shl nsw i64 %368, 5
  %370 = getelementptr i8, ptr %366, i64 %369
  %371 = load ptr, ptr %370, align 8
  %372 = icmp ne ptr %371, @nil_typ
  %373 = icmp ne ptr %371, null
  %.not48.i977 = and i1 %372, %373
  br i1 %.not48.i977, label %374, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001.thread

374:                                              ; preds = %356
  %375 = getelementptr i8, ptr %370, i64 8
  %376 = load i64, ptr %375, align 4
  %.sroa_idx.i982 = getelementptr i8, ptr %370, i64 16
  %377 = load i64, ptr %.sroa_idx.i982, align 4
  %378 = inttoptr i64 %376 to ptr
  %379 = inttoptr i64 %377 to ptr
  %hash_coef_ptr.i3.i983 = getelementptr i8, ptr %371, i64 8
  %tbl_size_ptr.i4.i984 = getelementptr i8, ptr %371, i64 16
  %offset_tbl_ptr.i5.i985 = getelementptr i8, ptr %371, i64 40
  %hash_coef.i6.i986 = load i64, ptr %hash_coef_ptr.i3.i983, align 4
  %tbl_size.i7.i987 = load i64, ptr %tbl_size_ptr.i4.i984, align 4
  %offset_tbl.i8.i988 = load ptr, ptr %offset_tbl_ptr.i5.i985, align 8
  %product.i.i9.i989 = mul i64 %hash_coef.i6.i986, 4015701072841558310
  %shifted.i.i10.i990 = lshr i64 %product.i.i9.i989, 32
  %xored.i.i11.i991 = xor i64 %shifted.i.i10.i990, %product.i.i9.i989
  %hash.i.i12.i992 = and i64 %xored.i.i11.i991, %tbl_size.i7.i987
  %offset_ptr.i13.i993 = getelementptr i32, ptr %offset_tbl.i8.i988, i64 %hash.i.i12.i992
  %offset.i14.i994 = load i32, ptr %offset_ptr.i13.i993, align 4
  %380 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %371, 0
  %381 = insertvalue { ptr, ptr, ptr, i32 } %380, ptr %378, 1
  %382 = insertvalue { ptr, ptr, ptr, i32 } %381, ptr %379, 2
  %383 = insertvalue { ptr, ptr, ptr, i32 } %382, i32 %offset.i14.i994, 3
  %384 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %385 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %371) #41
  %386 = sext i32 %offset.i14.i994 to i64
  %387 = getelementptr ptr, ptr %371, i64 %386
  %388 = getelementptr i8, ptr %387, i64 64
  %389 = load ptr, ptr %388, align 8
  %result.i2.i995 = call ptr %389({ ptr, ptr, ptr, i32 } %383, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %390 = call i32 %result.i2.i995({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull align 8 %2)
  %391 = icmp eq i32 %390, %362
  br i1 %391, label %._crit_edge.i996, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001.thread

._crit_edge.i996:                                 ; preds = %374
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %393 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %371)
  %394 = getelementptr i8, ptr %387, i64 48
  %395 = load ptr, ptr %394, align 8
  %result.i1.i997 = call ptr %395({ ptr, ptr, ptr, i32 } %383, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %396 = call { ptr, i160 } %result.i1.i997({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull align 8 %2)
  %397 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %398 = load ptr, ptr %23, align 8
  %399 = call i1 %398({ ptr, i160 } %396, { ptr, i160 } %359)
  br i1 %399, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001.thread: ; preds = %._crit_edge.i996, %374, %356
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %408

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001: ; preds = %._crit_edge.i996
  %400 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %371)
  %402 = getelementptr i8, ptr %387, i64 56
  %403 = load ptr, ptr %402, align 8
  %result.i.i = call ptr %403({ ptr, ptr, ptr, i32 } %383, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %404 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull align 8 %2)
  %.fca.0.extract26.i999 = extractvalue { ptr, i160 } %404, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %405 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %406 = icmp ne ptr %.fca.0.extract26.i999, @nil_typ
  %407 = icmp ne ptr %.fca.0.extract26.i999, null
  %.not99.i506 = and i1 %406, %407
  br i1 %.not99.i506, label %CuckooMap_get_keyK.exit520, label %408

408:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001.thread
  %409 = add i32 %362, 2127912214
  %410 = shl i32 %362, 12
  %411 = add i32 %409, %410
  %412 = ashr i32 %411, 19
  %413 = xor i32 %411, %412
  %414 = xor i32 %413, -949894596
  %415 = add i32 %414, 374761393
  %416 = shl i32 %414, 5
  %417 = add i32 %415, %416
  %418 = add i32 %417, -744332180
  %419 = shl i32 %417, 9
  %420 = xor i32 %418, %419
  %421 = add i32 %420, -42973499
  %422 = shl i32 %420, 3
  %423 = add i32 %421, %422
  %424 = ashr i32 %423, 16
  %425 = xor i32 %423, %424
  %426 = xor i32 %425, -1252372727
  %427 = load i32, ptr %24, align 8
  %428 = add i32 %427, -1
  %429 = and i32 %428, %426
  %430 = load ptr, ptr %26, align 8
  %431 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %432 = sext i32 %429 to i64
  %433 = shl nsw i64 %432, 5
  %434 = getelementptr i8, ptr %430, i64 %433
  %435 = load ptr, ptr %434, align 8
  %436 = icmp ne ptr %435, @nil_typ
  %437 = icmp ne ptr %435, null
  %.not48.i1031 = and i1 %436, %437
  br i1 %.not48.i1031, label %438, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1056

438:                                              ; preds = %408
  %439 = getelementptr i8, ptr %434, i64 8
  %440 = load i64, ptr %439, align 4
  %.sroa_idx.i1036 = getelementptr i8, ptr %434, i64 16
  %441 = load i64, ptr %.sroa_idx.i1036, align 4
  %442 = inttoptr i64 %440 to ptr
  %443 = inttoptr i64 %441 to ptr
  %hash_coef_ptr.i3.i1037 = getelementptr i8, ptr %435, i64 8
  %tbl_size_ptr.i4.i1038 = getelementptr i8, ptr %435, i64 16
  %offset_tbl_ptr.i5.i1039 = getelementptr i8, ptr %435, i64 40
  %hash_coef.i6.i1040 = load i64, ptr %hash_coef_ptr.i3.i1037, align 4
  %tbl_size.i7.i1041 = load i64, ptr %tbl_size_ptr.i4.i1038, align 4
  %offset_tbl.i8.i1042 = load ptr, ptr %offset_tbl_ptr.i5.i1039, align 8
  %product.i.i9.i1043 = mul i64 %hash_coef.i6.i1040, 4015701072841558310
  %shifted.i.i10.i1044 = lshr i64 %product.i.i9.i1043, 32
  %xored.i.i11.i1045 = xor i64 %shifted.i.i10.i1044, %product.i.i9.i1043
  %hash.i.i12.i1046 = and i64 %xored.i.i11.i1045, %tbl_size.i7.i1041
  %offset_ptr.i13.i1047 = getelementptr i32, ptr %offset_tbl.i8.i1042, i64 %hash.i.i12.i1046
  %offset.i14.i1048 = load i32, ptr %offset_ptr.i13.i1047, align 4
  %444 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %435, 0
  %445 = insertvalue { ptr, ptr, ptr, i32 } %444, ptr %442, 1
  %446 = insertvalue { ptr, ptr, ptr, i32 } %445, ptr %443, 2
  %447 = insertvalue { ptr, ptr, ptr, i32 } %446, i32 %offset.i14.i1048, 3
  %448 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %449 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %435) #41
  %450 = sext i32 %offset.i14.i1048 to i64
  %451 = getelementptr ptr, ptr %435, i64 %450
  %452 = getelementptr i8, ptr %451, i64 64
  %453 = load ptr, ptr %452, align 8
  %result.i2.i1049 = call ptr %453({ ptr, ptr, ptr, i32 } %447, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %454 = call i32 %result.i2.i1049({ ptr, ptr, ptr, i32 } %447, { ptr, ptr, ptr, i32 } %447, ptr nonnull align 8 %2)
  %455 = icmp eq i32 %454, %362
  br i1 %455, label %._crit_edge.i1050, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1056

._crit_edge.i1050:                                ; preds = %438
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %435)
  %458 = getelementptr i8, ptr %451, i64 48
  %459 = load ptr, ptr %458, align 8
  %result.i1.i1051 = call ptr %459({ ptr, ptr, ptr, i32 } %447, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %460 = call { ptr, i160 } %result.i1.i1051({ ptr, ptr, ptr, i32 } %447, { ptr, ptr, ptr, i32 } %447, ptr nonnull align 8 %2)
  %461 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %462 = load ptr, ptr %23, align 8
  %463 = call i1 %462({ ptr, i160 } %460, { ptr, i160 } %359)
  br i1 %463, label %464, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1056

464:                                              ; preds = %._crit_edge.i1050
  %465 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %466 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %435)
  %467 = getelementptr i8, ptr %451, i64 56
  %468 = load ptr, ptr %467, align 8
  %result.i.i1053 = call ptr %468({ ptr, ptr, ptr, i32 } %447, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  %469 = call { ptr, i160 } %result.i.i1053({ ptr, ptr, ptr, i32 } %447, { ptr, ptr, ptr, i32 } %447, ptr nonnull align 8 %2)
  %.fca.0.extract26.i1054 = extractvalue { ptr, i160 } %469, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1056

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1056: ; preds = %464, %._crit_edge.i1050, %438, %408
  %.reg2mem36.0.i1033 = phi ptr [ %.fca.0.extract26.i1054, %464 ], [ @nil_typ, %._crit_edge.i1050 ], [ @nil_typ, %408 ], [ @nil_typ, %438 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %470 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.not.i513 = icmp eq ptr %.reg2mem36.0.i1033, null
  %471 = select i1 %.not.i513, ptr @nil_typ, ptr %.reg2mem36.0.i1033
  br label %CuckooMap_get_keyK.exit520

CuckooMap_get_keyK.exit520:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1056, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001
  %.reg2mem17.0.i514 = phi ptr [ %471, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1056 ], [ %.fca.0.extract26.i999, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1001 ]
  %472 = icmp eq ptr %.reg2mem17.0.i514, @nil_typ
  %473 = icmp eq ptr %.reg2mem17.0.i514, null
  %.not561.not = or i1 %472, %473
  %spec.select563 = select i1 %.not561.not, i1 %spec.select564, i1 false
  br label %RangeIterator_next_.exit52.i.preheader1286

RangeIterator_next_.exit52.i.preheader1286:       ; preds = %CuckooMap_get_keyK.exit520, %._crit_edge8
  %.6 = phi i1 [ %spec.select564, %._crit_edge8 ], [ %spec.select563, %CuckooMap_get_keyK.exit520 ]
  %result.i60 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #49
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i60, align 1
  %474 = sub i64 %352, %204
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %475 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #41
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %476 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %477 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #41
  %result.i5.i = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #49
  %478 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %479 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %480 = load i8, ptr %result.i60, align 1
  store i8 %480, ptr %result.i5.i, align 1
  %481 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %482 = getelementptr i8, ptr %result.i60, i64 1
  %483 = load i8, ptr %482, align 1
  %484 = getelementptr i8, ptr %result.i5.i, i64 1
  store i8 %483, ptr %484, align 1
  %485 = getelementptr i8, ptr %result.i60, i64 2
  %486 = load i8, ptr %485, align 1
  %487 = getelementptr i8, ptr %result.i5.i, i64 2
  store i8 %486, ptr %487, align 1
  %488 = getelementptr i8, ptr %result.i60, i64 3
  %489 = load i8, ptr %488, align 1
  %490 = getelementptr i8, ptr %result.i5.i, i64 3
  store i8 %489, ptr %490, align 1
  %491 = getelementptr i8, ptr %result.i60, i64 4
  %492 = load i8, ptr %491, align 1
  %493 = getelementptr i8, ptr %result.i5.i, i64 4
  store i8 %492, ptr %493, align 1
  %494 = getelementptr i8, ptr %result.i60, i64 5
  %495 = load i8, ptr %494, align 1
  %496 = getelementptr i8, ptr %result.i5.i, i64 5
  store i8 %495, ptr %496, align 1
  %497 = getelementptr i8, ptr %result.i60, i64 6
  %498 = load i8, ptr %497, align 1
  %499 = getelementptr i8, ptr %result.i5.i, i64 6
  store i8 %498, ptr %499, align 1
  %500 = getelementptr i8, ptr %result.i60, i64 7
  %501 = load i8, ptr %500, align 1
  %502 = getelementptr i8, ptr %result.i5.i, i64 7
  store i8 %501, ptr %502, align 1
  %503 = getelementptr i8, ptr %result.i60, i64 8
  %504 = load i8, ptr %503, align 1
  %505 = getelementptr i8, ptr %result.i5.i, i64 8
  store i8 %504, ptr %505, align 1
  %506 = getelementptr i8, ptr %result.i60, i64 9
  %507 = load i8, ptr %506, align 1
  %508 = getelementptr i8, ptr %result.i5.i, i64 9
  store i8 %507, ptr %508, align 1
  %509 = getelementptr i8, ptr %result.i60, i64 10
  %510 = load i8, ptr %509, align 1
  %511 = getelementptr i8, ptr %result.i5.i, i64 10
  store i8 %510, ptr %511, align 1
  %512 = getelementptr i8, ptr %result.i60, i64 11
  %513 = load i8, ptr %512, align 1
  %514 = getelementptr i8, ptr %result.i5.i, i64 11
  store i8 %513, ptr %514, align 1
  %515 = getelementptr i8, ptr %result.i60, i64 12
  %516 = load i8, ptr %515, align 1
  %517 = getelementptr i8, ptr %result.i5.i, i64 12
  store i8 %516, ptr %517, align 1
  %518 = getelementptr i8, ptr %result.i5.i, i64 13
  store i8 0, ptr %518, align 1
  %puts.i1283 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #54
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %519 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %519, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #56
  %520 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0552) #56
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %521 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %521, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #56
  %522 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %474) #56
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #56
  br i1 %205, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader1286
  %523 = zext nneg i32 %.0552 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %524 = mul i64 %474, 1000000
  %525 = sdiv i64 %524, %523
  %526 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %526, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #56
  %527 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %525) #56
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #57
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %530 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %531 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #56
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader1286
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %532 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %533 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i1158.h2s1271, align 1
  %scevgep1242 = getelementptr inbounds i8, ptr %result.i5.i1158.h2s1271, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep1242, align 1
  %534 = getelementptr inbounds i8, ptr %result.i5.i1158.h2s1271, i64 18
  store i8 0, ptr %534, align 1
  %puts.i673 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i1158.h2s1271) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.0.extract = select i1 %.6, i8 80, i8 70
  %.sroa.0295.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0295.3 = select i1 %.6, <4 x i8> %.sroa.0295.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0295.1.vec.insert = insertelement <4 x i8> %.sroa.0295.3, i8 65, i64 1
  %.fca.2.extract = select i1 %.6, i8 83, i8 73
  %.sroa.0295.2 = select i1 %.6, <4 x i8> %.sroa.0295.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0295.2.vec.insert = insertelement <4 x i8> %.sroa.0295.2, i8 %.fca.2.extract, i64 2
  %.fca.3.extract = select i1 %.6, i8 83, i8 76
  %.sroa.0295.1 = select i1 %.6, <4 x i8> %.sroa.0295.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0295.3.vec.insert = insertelement <4 x i8> %.sroa.0295.1, i8 %.fca.3.extract, i64 3
  br i1 %.6, label %RangeIterator_next_.exit52.i1180.preheader, label %._crit_edge10.else

._crit_edge10.else:                               ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i1180.preheader

RangeIterator_next_.exit52.i1180.preheader:       ; preds = %._crit_edge10.else, %print_benchmark_result.exit
  %.sroa.speculated294 = phi <4 x i8> [ <i8 70, i8 65, i8 73, i8 76>, %._crit_edge10.else ], [ %.sroa.0295.3.vec.insert, %print_benchmark_result.exit ]
  %535 = phi ptr [ %13, %._crit_edge10.else ], [ %9, %print_benchmark_result.exit ]
  %536 = phi ptr [ %12, %._crit_edge10.else ], [ %8, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %._crit_edge10.else ], [ %.sroa.gep565, %print_benchmark_result.exit ]
  %.sroa.phi566 = phi ptr [ %.sroa.gep567, %._crit_edge10.else ], [ %.sroa.gep568, %print_benchmark_result.exit ]
  %.sroa.phi569 = phi ptr [ %.sroa.gep570, %._crit_edge10.else ], [ %.sroa.gep571, %print_benchmark_result.exit ]
  %537 = phi ptr [ %11, %._crit_edge10.else ], [ %7, %print_benchmark_result.exit ]
  %.sroa.phi572 = phi ptr [ %.sroa.gep573, %._crit_edge10.else ], [ %.sroa.gep574, %print_benchmark_result.exit ]
  %.sroa.phi575 = phi ptr [ %.sroa.gep576, %._crit_edge10.else ], [ %.sroa.gep577, %print_benchmark_result.exit ]
  %.sroa.phi578 = phi ptr [ %.sroa.gep579, %._crit_edge10.else ], [ %.sroa.gep580, %print_benchmark_result.exit ]
  %538 = phi ptr [ %10, %._crit_edge10.else ], [ %6, %print_benchmark_result.exit ]
  store ptr @_parameterization_Bufferi8, ptr %538, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi572, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi575, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi578, align 8
  %539 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %538)
  store ptr @buffer_typ, ptr %537, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi566, align 8
  store ptr @i32_typ, ptr %.sroa.phi569, align 8
  %540 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %537) #41
  store ptr @_parameterization_String, ptr %536, align 8
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %536)
  store ptr @String, ptr %535, align 8
  %542 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %535) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %543 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %544 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %result.i56.h2s1270.sroa.0.0.vec.extract = extractelement <4 x i8> %.sroa.speculated294, i64 0
  store i8 %result.i56.h2s1270.sroa.0.0.vec.extract, ptr %result.i5.i1177.h2s1269, align 1
  %scevgep1247 = getelementptr inbounds i8, ptr %result.i5.i1177.h2s1269, i64 1
  %result.i56.h2s1270.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sroa.speculated294, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i56.h2s1270.sroa.0.1.vec.extract, ptr %scevgep1247, align 1
  %545 = getelementptr inbounds i8, ptr %result.i5.i1177.h2s1269, i64 4
  store i8 0, ptr %545, align 1
  %puts.i693 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i1177.h2s1269) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %546 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  store i8 32, ptr %result.i5.i1196.h2s1267, align 1
  %scevgep1252 = getelementptr inbounds i8, ptr %result.i5.i1196.h2s1267, i64 1
  store <19 x i8> <i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %scevgep1252, align 1
  %548 = getelementptr inbounds i8, ptr %result.i5.i1196.h2s1267, i64 20
  store i8 0, ptr %548, align 1
  %puts.i713 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(21) %result.i5.i1196.h2s1267) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %549 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0540.lcssa) #56
  %550 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %551 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #41
  %553 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 41, ptr %result.i5.i1215.h2s1265, align 2
  %554 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %556 = getelementptr inbounds i8, ptr %result.i5.i1215.h2s1265, i64 1
  store i8 0, ptr %556, align 1
  %puts.i733 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i5.i1215.h2s1265) #54
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define noundef i32 @main() local_unnamed_addr #18 {
RangeIterator_next_.exit52.i.preheader:
  %result.i5.i65.h2s76 = alloca [28 x i8], align 1
  %result.i5.i.h2s78 = alloca [23 x i8], align 1
  call void @setup_landing_pad()
  %0 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 45, ptr %result.i5.i.h2s78, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s78, i64 1
  store <21 x i8> <i8 45, i8 45, i8 32, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %scevgep, align 1
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %4 = getelementptr inbounds i8, ptr %result.i5.i.h2s78, i64 22
  store i8 0, ptr %4, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(23) %result.i5.i.h2s78) #54
  call void @benchmark_insert_sequential(i32 noundef 1000000)
  call void @benchmark_insert_random(i32 noundef 1000000)
  call void @benchmark_get_sequential_hit(i32 noundef 1000000)
  call void @benchmark_get_random_hit(i32 noundef 1000000)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 45, ptr %result.i5.i65.h2s76, align 1
  %scevgep73 = getelementptr inbounds i8, ptr %result.i5.i65.h2s76, i64 1
  store <26 x i8> <i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %scevgep73, align 1
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %9 = getelementptr inbounds i8, ptr %result.i5.i65.h2s76, i64 27
  store i8 0, ptr %9, align 1
  %puts.i51 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(28) %result.i5.i65.h2s76) #54
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_bool_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @IO_B__Self_print_xBool__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xi8__Self_print_xString__Self_print_xi32__Self_print_xNil__Self_print_xi64__Self_print_xf64(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #32 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #41
  %3 = load ptr, ptr %0, align 8
  %4 = icmp eq ptr %3, @nil_typ
  %5 = icmp eq ptr %3, null
  %6 = or i1 %4, %5
  br i1 %6, label %._crit_edge, label %7

7:                                                ; preds = %1
  %8 = icmp eq ptr %3, @i32_typ
  br i1 %8, label %._crit_edge, label %9

9:                                                ; preds = %7
  %10 = icmp eq ptr %3, @bool_typ
  br i1 %10, label %._crit_edge, label %11

11:                                               ; preds = %9
  %12 = icmp eq ptr %3, @i64_typ
  br i1 %12, label %._crit_edge, label %13

13:                                               ; preds = %11
  %14 = icmp eq ptr %3, @f64_typ
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %13
  %16 = icmp eq ptr %3, @i8_typ
  br i1 %16, label %._crit_edge, label %17

17:                                               ; preds = %15
  %18 = getelementptr i8, ptr %3, i64 8
  %19 = getelementptr i8, ptr %3, i64 16
  %20 = getelementptr i8, ptr %3, i64 24
  %21 = getelementptr i8, ptr %3, i64 32
  %22 = load i64, ptr %18, align 4
  %23 = load i64, ptr %19, align 4
  %24 = load ptr, ptr %20, align 8
  %25 = load ptr, ptr %21, align 8
  %result.i4 = call i1 %24(i64 %23, i64 %22, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %25) #45
  br i1 %result.i4, label %26, label %.critedge

26:                                               ; preds = %17
  %result.i3 = call i1 %24(i64 %23, i64 %22, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %25) #45
  br i1 %result.i3, label %.critedge, label %27

27:                                               ; preds = %26
  %result.i2 = call i1 %24(i64 %23, i64 %22, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %25) #45
  br i1 %result.i2, label %.critedge, label %._crit_edge

.critedge:                                        ; preds = %27, %26, %17
  %result.i1 = call i1 %24(i64 %23, i64 %22, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %25) #45
  br i1 %result.i1, label %28, label %.critedge14

28:                                               ; preds = %.critedge
  %result.i = call i1 %24(i64 %23, i64 %22, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %25) #45
  br i1 %result.i, label %.critedge14, label %._crit_edge

.critedge14:                                      ; preds = %28, %.critedge
  br label %._crit_edge

._crit_edge:                                      ; preds = %.critedge14, %28, %27, %15, %13, %11, %9, %7, %1
  %.reg2mem25.0 = phi i64 [ 7, %1 ], [ 6, %7 ], [ 1, %9 ], [ 8, %11 ], [ 9, %13 ], [ 4, %15 ], [ 2, %28 ], [ 3, %27 ], [ 5, %.critedge14 ]
  %29 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %.reg2mem25.0
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xBool(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %result.i5.i49.h2s63 = alloca [6 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(6) %result.i5.i49.h2s63, i8 0, i64 6, i1 false)
  %result.i5.i.h2s65 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i.h2s65, i8 0, i64 5, i1 false)
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %3 = trunc i160 %.fca.1.extract to i1
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  br i1 %3, label %RangeIterator_next_.exit52.i.preheader, label %RangeIterator_next_.exit52.i52.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %2
  store i8 116, ptr %result.i5.i.h2s65, align 1
  %scevgep60 = getelementptr inbounds i8, ptr %result.i5.i.h2s65, i64 1
  store <3 x i8> <i8 114, i8 117, i8 101>, ptr %scevgep60, align 1
  br label %String_c_string_.exit

RangeIterator_next_.exit52.i52.preheader:         ; preds = %2
  store i8 102, ptr %result.i5.i49.h2s63, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i49.h2s63, i64 1
  store i32 1702063201, ptr %scevgep, align 1
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %RangeIterator_next_.exit52.i52.preheader, %RangeIterator_next_.exit52.i.preheader
  %5 = phi i64 [ 4, %RangeIterator_next_.exit52.i.preheader ], [ 5, %RangeIterator_next_.exit52.i52.preheader ]
  %result.i5.i49.sink = phi ptr [ %result.i5.i.h2s65, %RangeIterator_next_.exit52.i.preheader ], [ %result.i5.i49.h2s63, %RangeIterator_next_.exit52.i52.preheader ]
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %8 = getelementptr i8, ptr %result.i5.i49.sink, i64 %5
  store i8 0, ptr %8, align 1
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i49.sink) #54
  ret void
}

define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #18 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract12 = extractvalue { ptr, i160 } %1, 1
  %.sroa.214.8.extract.trunc = trunc i160 %.fca.1.extract12 to i64
  %.sroa.415.8.extract.shift = lshr i160 %.fca.1.extract12, 64
  %.sroa.415.8.extract.trunc = trunc i160 %.sroa.415.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.214.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.415.8.extract.trunc to ptr
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #41
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #41
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3)
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 6499063144389013426
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract5, i64 %23
  %25 = getelementptr i8, ptr %24, i64 104
  %26 = load ptr, ptr %25, align 8
  %result.i = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  %27 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %3)
  %.fca.0.extract = extractvalue { ptr } %27, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #54
  ret void
}

define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #18 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract12 = extractvalue { ptr, i160 } %1, 1
  %.sroa.214.8.extract.trunc = trunc i160 %.fca.1.extract12 to i64
  %.sroa.415.8.extract.shift = lshr i160 %.fca.1.extract12, 64
  %.sroa.415.8.extract.trunc = trunc i160 %.sroa.415.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.214.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.415.8.extract.trunc to ptr
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7260840641129990118
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #41
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #41
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = load ptr, ptr %13, align 8
  %result.i1 = call ptr %14({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  %15 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3)
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 6499063144389013426
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i13, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %22 = sext i32 %offset.i13 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract5, i64 %22
  %24 = getelementptr i8, ptr %23, i64 104
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  %26 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %3)
  %.fca.0.extract = extractvalue { ptr } %26, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #54
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %sext = shl i32 %.sroa.1.8.extract.trunc, 24
  %3 = ashr exact i32 %sext, 24
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #56
  ret void
}

define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #18 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #41
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #41
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 104
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3)
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #54
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #56
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
RangeIterator_next_.exit52.i.preheader:
  %result.i5.i.h2s19 = alloca [4 x i8], align 4
  store i32 7104878, ptr %result.i5.i.h2s19, align 4
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i.h2s19) #54
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #56
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #56
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #25

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i32, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i32 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i32_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(4) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  store i32 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @String_field_String_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #41
  ret ptr @String__Self_from_bytes_source_bytesBufferi8_source_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #41
  ret ptr @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #41
  ret ptr @String__Self_from_c_string_c_stringBufferi8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_byte_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_empty_(ptr nocapture nofree %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #41
  ret ptr @String__Self_empty_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_iterable_iterableIterableCharacter(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #41
  ret ptr @String__Self_from_iterable_iterableIterableCharacter
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_charCharacter({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_last_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_extend_otherIterableT_extend_otherString_extend_otherCollectionCharacter({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %12) #45
  br i1 %result.i1, label %._crit_edge, label %13

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #45
  %spec.select = select i1 %result.i, i64 69, i64 67
  br label %._crit_edge

._crit_edge:                                      ; preds = %13, %2
  %.reg2mem7.0 = phi i64 [ 68, %2 ], [ %spec.select, %13 ]
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr [314 x ptr], ptr %14, i64 0, i64 %.reg2mem7.0
  %16 = getelementptr i8, ptr %15, i64 80
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 648
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 656
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 664
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 672
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 680
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 688
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 696
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 704
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 712
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 80, i64 81
  %8 = getelementptr [314 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 736
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 84, i64 83
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 85, i64 86
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 88, i64 87
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 90, i64 89
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 808
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %11 = getelementptr i8, ptr %result.i5, i64 16
  store i32 %2, ptr %11, align 8
  %12 = sext i32 %2 to i64
  %result.i.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %12) #49
  store ptr %result.i.i, ptr %result.i5, align 8
  %13 = getelementptr i8, ptr %result.i5, i64 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #41
  %15 = getelementptr i8, ptr %result.i5, i64 12
  store <2 x i32> zeroinitializer, ptr %13, align 8
  %16 = getelementptr inbounds i8, ptr %7, i64 8
  %17 = getelementptr inbounds i8, ptr %7, i64 16
  %18 = getelementptr inbounds i8, ptr %7, i64 24
  %19 = getelementptr inbounds i8, ptr %8, i64 8
  %20 = getelementptr inbounds i8, ptr %8, i64 16
  %21 = getelementptr inbounds i8, ptr %8, i64 24
  %22 = getelementptr inbounds i8, ptr %9, i64 8
  %23 = getelementptr inbounds i8, ptr %10, i64 8
  %24 = icmp sgt i32 %2, 0
  br i1 %24, label %.lr.ph.preheader, label %._crit_edge3._crit_edge

.lr.ph.preheader:                                 ; preds = %3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode) #57
  %.fca.0.extract10.i = extractvalue { ptr } %1, 0
  br label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge, %.lr.ph.preheader
  %.pre112175 = phi ptr [ %.pre112172, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %26 = phi ptr [ %146, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %27 = phi i32 [ %147, %._crit_edge ], [ %2, %.lr.ph.preheader ]
  %.pre113.pre = phi i32 [ %148, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.013 = phi i32 [ %.1, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.not.i = icmp slt i32 %.013, %2
  br i1 %.not.i, label %._crit_edge.i, label %._crit_edge1.thread

._crit_edge.i:                                    ; preds = %.lr.ph
  %28 = sext i32 %.013 to i64
  %29 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %28
  %30 = load i8, ptr %29, align 1
  %31 = sext i8 %30 to i32
  %32 = icmp sgt i8 %30, -1
  %spec.select.i = zext i1 %32 to i32
  %33 = and i32 %31, -32
  %34 = icmp eq i32 %33, -64
  %.1149.i = select i1 %34, i32 2, i32 %spec.select.i
  %35 = and i32 %31, -16
  %36 = icmp eq i32 %35, -32
  %.2150.i = select i1 %36, i32 3, i32 %.1149.i
  %37 = and i32 %31, -8
  %38 = icmp eq i32 %37, -16
  %.3151.i = select i1 %38, i32 4, i32 %.2150.i
  %39 = icmp eq i32 %.3151.i, 0
  %40 = add i32 %.3151.i, %.013
  %41 = icmp sgt i32 %40, %2
  %.0152.i = or i1 %39, %41
  br i1 %.0152.i, label %._crit_edge1.thread, label %42

42:                                               ; preds = %._crit_edge.i
  %43 = and i32 %31, 7
  %44 = and i32 %31, 15
  %45 = and i32 %31, 31
  %spec.select171.i = select i1 %32, i32 %31, i32 0
  %.1.i = select i1 %34, i32 %45, i32 %spec.select171.i
  %.2.i = select i1 %36, i32 %44, i32 %.1.i
  %.3.i = select i1 %38, i32 %43, i32 %.2.i
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %48

48:                                               ; preds = %42
  %49 = getelementptr i8, ptr %29, i64 1
  %50 = load i8, ptr %49, align 1
  %51 = sext i8 %50 to i32
  %52 = and i32 %51, -64
  %.not15.i = icmp eq i32 %52, -128
  %53 = shl nsw i32 %.3.i, 6
  %54 = and i32 %51, 63
  %55 = or disjoint i32 %54, %53
  br i1 %.not15.i, label %56, label %._crit_edge1.thread

56:                                               ; preds = %48
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %57

57:                                               ; preds = %56
  %58 = add i32 %.013, 2
  %59 = sext i32 %58 to i64
  %60 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = sext i8 %61 to i32
  %63 = and i32 %62, -64
  %.not15.i.1 = icmp eq i32 %63, -128
  %64 = shl i32 %55, 6
  %65 = and i32 %62, 63
  %66 = or disjoint i32 %65, %64
  br i1 %.not15.i.1, label %67, label %._crit_edge1.thread

67:                                               ; preds = %57
  %not. = xor i1 %38, true
  %exitcond.not.2 = and i1 %36, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %68

68:                                               ; preds = %67
  %69 = add i32 %.013, 3
  %70 = sext i32 %69 to i64
  %71 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %70
  %72 = load i8, ptr %71, align 1
  %73 = sext i8 %72 to i32
  %74 = and i32 %73, -64
  %.not15.i.2 = icmp eq i32 %74, -128
  br i1 %.not15.i.2, label %75, label %._crit_edge1.thread

75:                                               ; preds = %68
  %76 = and i32 %73, 63
  %77 = shl i32 %66, 6
  %78 = or disjoint i32 %76, %77
  br i1 %38, label %._crit_edge5.i, label %._crit_edge1.thread

._crit_edge4.i:                                   ; preds = %56
  %79 = icmp slt i32 %55, -128
  br i1 %79, label %._crit_edge1.thread, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %75, %67, %42
  %.4.i.lcssa225 = phi i32 [ %55, %._crit_edge4.i ], [ %78, %75 ], [ %66, %67 ], [ %.3.i, %42 ]
  %not..i = xor i1 %38, true
  %80 = and i1 %36, %not..i
  %81 = icmp slt i32 %.4.i.lcssa225, 2048
  %spec.select173.i = select i1 %80, i1 %81, i1 false
  %82 = icmp slt i32 %.4.i.lcssa225, 65536
  %spec.select174.i = select i1 %38, i1 %82, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %._crit_edge1.thread, label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge5.i
  %83 = and i32 %.4.i.lcssa225, -2048
  %spec.select176.i = icmp eq i32 %83, -10240
  %84 = icmp sgt i32 %.4.i.lcssa225, 1114111
  %spec.select177.i = or i1 %84, %spec.select176.i
  br i1 %spec.select177.i, label %._crit_edge1.thread, label %._crit_edge1

._crit_edge1.thread:                              ; preds = %.critedge175.i, %._crit_edge5.i, %._crit_edge4.i, %75, %68, %57, %48, %._crit_edge.i, %.lr.ph
  call fastcc void @String__Self_from_bytes_source_bytesBufferi8_source_leni32.cold.1(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %5, ptr noalias nocapture nofree noundef nonnull align 8 %4, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %16, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %17, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %19, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %20, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %22, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %10, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %23) #59
  br label %._crit_edge

._crit_edge1:                                     ; preds = %.critedge175.i
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  %85 = add i32 %.3151.i, %.pre113.pre
  %.not.i17 = icmp slt i32 %85, %27
  br i1 %.not.i17, label %._crit_edge.i18, label %86

86:                                               ; preds = %._crit_edge1
  %87 = shl i32 %27, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  %.not.i87 = icmp sgt i32 %87, %27
  br i1 %.not.i87, label %88, label %String_reserve_new_capacityi32.exit

88:                                               ; preds = %86
  store i32 %87, ptr %11, align 8
  %89 = sext i32 %87 to i64
  %result.i5.i88 = call noalias ptr @bump_malloc_wrapper(i64 noundef %89) #49
  store ptr %result.i5.i88, ptr %result.i5, align 8
  %90 = add i32 %.pre113.pre, -1
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %94 = icmp slt i32 %90, 0
  br i1 %94, label %String_reserve_new_capacityi32.exit, label %._crit_edge.i93.lr.ph

._crit_edge.i93.lr.ph:                            ; preds = %88
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %97 = load i8, ptr %26, align 1
  store i8 %97, ptr %result.i5.i88, align 1
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %99 = icmp eq i32 %90, 0
  br i1 %99, label %String_reserve_new_capacityi32.exit, label %RangeIterator_next_.exit198.lr.ph

RangeIterator_next_.exit198.lr.ph:                ; preds = %._crit_edge.i93.lr.ph
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  br label %RangeIterator_next_.exit198

RangeIterator_next_.exit198:                      ; preds = %RangeIterator_next_.exit198, %RangeIterator_next_.exit198.lr.ph
  %101 = phi i32 [ 1, %RangeIterator_next_.exit198.lr.ph ], [ %102, %RangeIterator_next_.exit198 ]
  %102 = add i32 %101, 1
  %103 = sext i32 %101 to i64
  %104 = getelementptr i8, ptr %26, i64 %103
  %105 = load i8, ptr %104, align 1
  %106 = getelementptr i8, ptr %result.i5.i88, i64 %103
  store i8 %105, ptr %106, align 1
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %109 = icmp sgt i32 %102, %90
  br i1 %109, label %String_reserve_new_capacityi32.exit, label %RangeIterator_next_.exit198

String_reserve_new_capacityi32.exit:              ; preds = %RangeIterator_next_.exit198, %._crit_edge.i93.lr.ph, %88, %86
  %.pre112173 = phi ptr [ %.pre112175, %86 ], [ %result.i5.i88, %88 ], [ %result.i5.i88, %._crit_edge.i93.lr.ph ], [ %result.i5.i88, %RangeIterator_next_.exit198 ]
  %110 = phi i32 [ %27, %86 ], [ %87, %88 ], [ %87, %._crit_edge.i93.lr.ph ], [ %87, %RangeIterator_next_.exit198 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  br label %._crit_edge.i18

._crit_edge.i18:                                  ; preds = %String_reserve_new_capacityi32.exit, %._crit_edge1
  %.pre112 = phi ptr [ %.pre112173, %String_reserve_new_capacityi32.exit ], [ %.pre112175, %._crit_edge1 ]
  %111 = phi i32 [ %110, %String_reserve_new_capacityi32.exit ], [ %27, %._crit_edge1 ]
  %112 = add nsw i32 %.3151.i, -1
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %result.i2.i.h2s222 = alloca [12 x i8], align 1
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %115 = getelementptr inbounds i8, ptr %result.i2.i.h2s222, i64 4
  store i32 %112, ptr %115, align 4
  %116 = getelementptr inbounds i8, ptr %result.i2.i.h2s222, i64 8
  store i32 1, ptr %116, align 4
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  store i32 1, ptr %result.i2.i.h2s222, align 4
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %120 = load i8, ptr %29, align 1
  %121 = sext i32 %.pre113.pre to i64
  %122 = getelementptr i8, ptr %.pre112, i64 %121
  store i8 %120, ptr %122, align 1
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %124 = load i32, ptr %result.i2.i.h2s222, align 4
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %126 = load i32, ptr %115, align 4
  %127 = icmp sgt i32 %124, %126
  br i1 %127, label %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit, label %RangeIterator_next_.exit160

RangeIterator_next_.exit160:                      ; preds = %RangeIterator_next_.exit160, %._crit_edge.i18
  %128 = phi i32 [ %139, %RangeIterator_next_.exit160 ], [ %124, %._crit_edge.i18 ]
  %129 = load i32, ptr %116, align 4
  %130 = add i32 %129, %128
  store i32 %130, ptr %result.i2.i.h2s222, align 4
  %131 = add i32 %128, %.pre113.pre
  %132 = add i32 %128, %.013
  %133 = sext i32 %132 to i64
  %134 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %133
  %135 = load i8, ptr %134, align 1
  %136 = sext i32 %131 to i64
  %137 = getelementptr i8, ptr %.pre112, i64 %136
  store i8 %135, ptr %137, align 1
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #41
  %139 = load i32, ptr %result.i2.i.h2s222, align 4
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %141 = load i32, ptr %115, align 4
  %142 = icmp sgt i32 %139, %141
  br i1 %142, label %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit, label %RangeIterator_next_.exit160

String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit: ; preds = %RangeIterator_next_.exit160, %._crit_edge.i18
  %143 = load i32, ptr %15, align 4
  %144 = add i32 %143, 1
  store i32 %144, ptr %15, align 4
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store i32 %85, ptr %13, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  br label %._crit_edge

._crit_edge:                                      ; preds = %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit, %._crit_edge1.thread
  %.pre112172 = phi ptr [ %.pre112, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %.pre112175, %._crit_edge1.thread ]
  %146 = phi ptr [ %.pre112, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %26, %._crit_edge1.thread ]
  %147 = phi i32 [ %111, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %27, %._crit_edge1.thread ]
  %148 = phi i32 [ %85, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %.pre113.pre, %._crit_edge1.thread ]
  %.1 = phi i32 [ %40, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %.013, %._crit_edge1.thread ]
  %149 = icmp slt i32 %.1, %2
  br i1 %149, label %.lr.ph, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge, %3
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %150 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %151 = insertvalue { ptr, ptr, ptr, i32 } %150, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %151
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2) #34 {
  %result.i.i21.h2s514 = alloca [3 x i8], align 1
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %4 = getelementptr i8, ptr %result.i7, i64 16
  store i32 %2, ptr %4, align 8
  %5 = sext i32 %2 to i64
  %result.i.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %5) #49
  store ptr %result.i.i, ptr %result.i7, align 8
  %6 = getelementptr i8, ptr %result.i7, i64 8
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %8 = getelementptr i8, ptr %result.i7, i64 12
  store <2 x i32> zeroinitializer, ptr %6, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  store i8 -17, ptr %result.i.i21.h2s514, align 1
  %10 = getelementptr inbounds i8, ptr %result.i.i21.h2s514, i64 1
  store i8 -65, ptr %10, align 1
  %11 = getelementptr inbounds i8, ptr %result.i.i21.h2s514, i64 2
  store i8 -67, ptr %11, align 1
  %12 = icmp sgt i32 %2, 0
  br i1 %12, label %.lr.ph.preheader, label %._crit_edge1._crit_edge

.lr.ph.preheader:                                 ; preds = %3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %.fca.0.extract10.i = extractvalue { ptr } %1, 0
  br label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge, %.lr.ph.preheader
  %.pre256404 = phi ptr [ %.pre256400, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %14 = phi i32 [ %170, %._crit_edge ], [ %2, %.lr.ph.preheader ]
  %15 = phi ptr [ %.pre254393, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %16 = phi i32 [ %171, %._crit_edge ], [ %2, %.lr.ph.preheader ]
  %.pre257.pre = phi i32 [ %.sink, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.017 = phi i32 [ %.1, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.not.i = icmp slt i32 %.017, %2
  br i1 %.not.i, label %._crit_edge.i, label %select.unfold

._crit_edge.i:                                    ; preds = %.lr.ph
  %17 = sext i32 %.017 to i64
  %18 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %17
  %19 = load i8, ptr %18, align 1
  %20 = sext i8 %19 to i32
  %21 = icmp sgt i8 %19, -1
  %spec.select.i = zext i1 %21 to i32
  %22 = and i32 %20, -32
  %23 = icmp eq i32 %22, -64
  %.1149.i = select i1 %23, i32 2, i32 %spec.select.i
  %24 = and i32 %20, -16
  %25 = icmp eq i32 %24, -32
  %.2150.i = select i1 %25, i32 3, i32 %.1149.i
  %26 = and i32 %20, -8
  %27 = icmp eq i32 %26, -16
  %.3151.i = select i1 %27, i32 4, i32 %.2150.i
  %28 = icmp eq i32 %.3151.i, 0
  %29 = add i32 %.3151.i, %.017
  %30 = icmp sgt i32 %29, %2
  %.0152.i = or i1 %28, %30
  br i1 %.0152.i, label %select.unfold, label %31

31:                                               ; preds = %._crit_edge.i
  %32 = and i32 %20, 7
  %33 = and i32 %20, 15
  %34 = and i32 %20, 31
  %spec.select171.i = select i1 %21, i32 %20, i32 0
  %.1.i = select i1 %23, i32 %34, i32 %spec.select171.i
  %.2.i = select i1 %25, i32 %33, i32 %.1.i
  %.3.i = select i1 %27, i32 %32, i32 %.2.i
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %36

36:                                               ; preds = %31
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %38 = getelementptr i8, ptr %18, i64 1
  %39 = load i8, ptr %38, align 1
  %40 = sext i8 %39 to i32
  %41 = and i32 %40, -64
  %.not15.i = icmp eq i32 %41, -128
  %42 = shl nsw i32 %.3.i, 6
  %43 = and i32 %40, 63
  %44 = or disjoint i32 %43, %42
  br i1 %.not15.i, label %45, label %select.unfold

45:                                               ; preds = %36
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %46

46:                                               ; preds = %45
  %47 = add i32 %.017, 2
  %48 = sext i32 %47 to i64
  %49 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %48
  %50 = load i8, ptr %49, align 1
  %51 = sext i8 %50 to i32
  %52 = and i32 %51, -64
  %.not15.i.1 = icmp eq i32 %52, -128
  %53 = shl i32 %44, 6
  %54 = and i32 %51, 63
  %55 = or disjoint i32 %54, %53
  br i1 %.not15.i.1, label %56, label %select.unfold

56:                                               ; preds = %46
  %not. = xor i1 %27, true
  %exitcond.not.2 = and i1 %25, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %57

57:                                               ; preds = %56
  %58 = add i32 %.017, 3
  %59 = sext i32 %58 to i64
  %60 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = sext i8 %61 to i32
  %63 = and i32 %62, -64
  %.not15.i.2 = icmp eq i32 %63, -128
  br i1 %.not15.i.2, label %64, label %select.unfold

64:                                               ; preds = %57
  %65 = and i32 %62, 63
  %66 = shl i32 %55, 6
  %67 = or disjoint i32 %65, %66
  br i1 %27, label %._crit_edge5.i, label %select.unfold

._crit_edge4.i:                                   ; preds = %45
  %68 = icmp slt i32 %44, -128
  br i1 %68, label %select.unfold, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %64, %56, %31
  %.4.i.lcssa519 = phi i32 [ %44, %._crit_edge4.i ], [ %67, %64 ], [ %55, %56 ], [ %.3.i, %31 ]
  %not..i = xor i1 %27, true
  %69 = and i1 %25, %not..i
  %70 = icmp slt i32 %.4.i.lcssa519, 2048
  %spec.select173.i = select i1 %69, i1 %70, i1 false
  %71 = icmp slt i32 %.4.i.lcssa519, 65536
  %spec.select174.i = select i1 %27, i1 %71, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %select.unfold, label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge5.i
  %72 = and i32 %.4.i.lcssa519, -2048
  %spec.select176.i = icmp eq i32 %72, -10240
  %73 = icmp sgt i32 %.4.i.lcssa519, 1114111
  %spec.select177.i = or i1 %73, %spec.select176.i
  br i1 %spec.select177.i, label %select.unfold, label %74

74:                                               ; preds = %.critedge175.i
  %75 = add i32 %.3151.i, %.pre257.pre
  %.not.i23 = icmp slt i32 %75, %16
  br i1 %.not.i23, label %._crit_edge.i24, label %76

76:                                               ; preds = %74
  %77 = shl nuw i32 %16, 1
  %.not.i181 = icmp sgt i32 %77, %16
  br i1 %.not.i181, label %78, label %._crit_edge.i24

78:                                               ; preds = %76
  store i32 %77, ptr %4, align 8
  %79 = zext nneg i32 %77 to i64
  %result.i5.i182 = call noalias ptr @bump_malloc_wrapper(i64 noundef %79) #49
  store ptr %result.i5.i182, ptr %result.i7, align 8
  %80 = add i32 %.pre257.pre, -1
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %82 = icmp slt i32 %80, 0
  br i1 %82, label %._crit_edge.i24, label %._crit_edge.i187.lr.ph

._crit_edge.i187.lr.ph:                           ; preds = %78
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %85 = load i8, ptr %15, align 1
  store i8 %85, ptr %result.i5.i182, align 1
  %86 = icmp eq i32 %80, 0
  br i1 %86, label %._crit_edge.i24, label %RangeIterator_next_.exit431.lr.ph

RangeIterator_next_.exit431.lr.ph:                ; preds = %._crit_edge.i187.lr.ph
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  br label %RangeIterator_next_.exit431

RangeIterator_next_.exit431:                      ; preds = %RangeIterator_next_.exit431, %RangeIterator_next_.exit431.lr.ph
  %88 = phi i32 [ 1, %RangeIterator_next_.exit431.lr.ph ], [ %89, %RangeIterator_next_.exit431 ]
  %89 = add i32 %88, 1
  %90 = sext i32 %88 to i64
  %91 = getelementptr i8, ptr %15, i64 %90
  %92 = load i8, ptr %91, align 1
  %93 = getelementptr i8, ptr %result.i5.i182, i64 %90
  store i8 %92, ptr %93, align 1
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %95 = icmp sgt i32 %89, %80
  br i1 %95, label %._crit_edge.i24, label %RangeIterator_next_.exit431

._crit_edge.i24:                                  ; preds = %RangeIterator_next_.exit431, %._crit_edge.i187.lr.ph, %78, %76, %74
  %.pre256403 = phi ptr [ %.pre256404, %74 ], [ %.pre256404, %76 ], [ %result.i5.i182, %78 ], [ %result.i5.i182, %._crit_edge.i187.lr.ph ], [ %result.i5.i182, %RangeIterator_next_.exit431 ]
  %96 = phi i32 [ %14, %74 ], [ %14, %76 ], [ %77, %78 ], [ %77, %._crit_edge.i187.lr.ph ], [ %77, %RangeIterator_next_.exit431 ]
  %.pre254 = phi ptr [ %15, %74 ], [ %15, %76 ], [ %result.i5.i182, %78 ], [ %result.i5.i182, %._crit_edge.i187.lr.ph ], [ %result.i5.i182, %RangeIterator_next_.exit431 ]
  %97 = phi i32 [ %16, %74 ], [ %16, %76 ], [ %77, %78 ], [ %77, %._crit_edge.i187.lr.ph ], [ %77, %RangeIterator_next_.exit431 ]
  %98 = add nsw i32 %.3151.i, -1
  %result.i2.i.h2s515 = alloca [12 x i8], align 1
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %100 = getelementptr inbounds i8, ptr %result.i2.i.h2s515, i64 4
  store i32 %98, ptr %100, align 4
  %101 = getelementptr inbounds i8, ptr %result.i2.i.h2s515, i64 8
  store i32 1, ptr %101, align 4
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  store i32 1, ptr %result.i2.i.h2s515, align 4
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %104 = load i8, ptr %18, align 1
  %105 = sext i32 %.pre257.pre to i64
  %106 = getelementptr i8, ptr %.pre254, i64 %105
  store i8 %104, ptr %106, align 1
  %107 = load i32, ptr %result.i2.i.h2s515, align 4
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %109 = load i32, ptr %100, align 4
  %110 = icmp sgt i32 %107, %109
  br i1 %110, label %._crit_edge, label %RangeIterator_next_.exit305

RangeIterator_next_.exit305:                      ; preds = %RangeIterator_next_.exit305, %._crit_edge.i24
  %111 = phi i32 [ %121, %RangeIterator_next_.exit305 ], [ %107, %._crit_edge.i24 ]
  %112 = load i32, ptr %101, align 4
  %113 = add i32 %112, %111
  store i32 %113, ptr %result.i2.i.h2s515, align 4
  %114 = add i32 %111, %.pre257.pre
  %115 = add i32 %111, %.017
  %116 = sext i32 %115 to i64
  %117 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %116
  %118 = load i8, ptr %117, align 1
  %119 = sext i32 %114 to i64
  %120 = getelementptr i8, ptr %.pre254, i64 %119
  store i8 %118, ptr %120, align 1
  %121 = load i32, ptr %result.i2.i.h2s515, align 4
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %123 = load i32, ptr %100, align 4
  %124 = icmp sgt i32 %121, %123
  br i1 %124, label %._crit_edge, label %RangeIterator_next_.exit305

select.unfold:                                    ; preds = %.critedge175.i, %._crit_edge5.i, %._crit_edge4.i, %64, %57, %46, %36, %._crit_edge.i, %.lr.ph
  %125 = add i32 %.pre257.pre, 3
  %.not.i28 = icmp slt i32 %125, %14
  br i1 %.not.i28, label %._crit_edge1.i42.lr.ph, label %126

126:                                              ; preds = %select.unfold
  %127 = shl nuw i32 %14, 1
  %.not.i190 = icmp sgt i32 %127, %14
  br i1 %.not.i190, label %128, label %._crit_edge1.i42.lr.ph

128:                                              ; preds = %126
  store i32 %127, ptr %4, align 8
  %129 = zext nneg i32 %127 to i64
  %result.i5.i192 = call noalias ptr @bump_malloc_wrapper(i64 noundef %129) #49
  store ptr %result.i5.i192, ptr %result.i7, align 8
  %130 = add i32 %.pre257.pre, -1
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %132 = icmp slt i32 %130, 0
  br i1 %132, label %._crit_edge1.i42.lr.ph, label %._crit_edge.i203.lr.ph

._crit_edge.i203.lr.ph:                           ; preds = %128
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %135 = load i8, ptr %15, align 1
  store i8 %135, ptr %result.i5.i192, align 1
  %136 = icmp eq i32 %130, 0
  br i1 %136, label %._crit_edge1.i42.lr.ph, label %RangeIterator_next_.exit469.lr.ph

RangeIterator_next_.exit469.lr.ph:                ; preds = %._crit_edge.i203.lr.ph
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  br label %RangeIterator_next_.exit469

RangeIterator_next_.exit469:                      ; preds = %RangeIterator_next_.exit469, %RangeIterator_next_.exit469.lr.ph
  %138 = phi i32 [ 1, %RangeIterator_next_.exit469.lr.ph ], [ %139, %RangeIterator_next_.exit469 ]
  %139 = add i32 %138, 1
  %140 = sext i32 %138 to i64
  %141 = getelementptr i8, ptr %15, i64 %140
  %142 = load i8, ptr %141, align 1
  %143 = getelementptr i8, ptr %result.i5.i192, i64 %140
  store i8 %142, ptr %143, align 1
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %145 = icmp sgt i32 %139, %130
  br i1 %145, label %._crit_edge1.i42.lr.ph, label %RangeIterator_next_.exit469

._crit_edge1.i42.lr.ph:                           ; preds = %RangeIterator_next_.exit469, %._crit_edge.i203.lr.ph, %128, %126, %select.unfold
  %.pre256 = phi ptr [ %.pre256404, %select.unfold ], [ %.pre256404, %126 ], [ %result.i5.i192, %128 ], [ %result.i5.i192, %._crit_edge.i203.lr.ph ], [ %result.i5.i192, %RangeIterator_next_.exit469 ]
  %146 = phi i32 [ %14, %select.unfold ], [ %14, %126 ], [ %127, %128 ], [ %127, %._crit_edge.i203.lr.ph ], [ %127, %RangeIterator_next_.exit469 ]
  %result.i2.i177.h2s516 = alloca [12 x i8], align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %148 = getelementptr inbounds i8, ptr %result.i2.i177.h2s516, i64 4
  %149 = getelementptr inbounds i8, ptr %result.i2.i177.h2s516, i64 8
  store i32 1, ptr %149, align 8
  store <2 x i32> <i32 1, i32 2>, ptr %result.i2.i177.h2s516, align 8
  %150 = load i8, ptr %result.i.i21.h2s514, align 1
  %151 = sext i32 %.pre257.pre to i64
  %152 = getelementptr i8, ptr %.pre256, i64 %151
  store i8 %150, ptr %152, align 1
  %153 = load i32, ptr %result.i2.i177.h2s516, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %155 = load i32, ptr %148, align 4
  %156 = icmp sgt i32 %153, %155
  br i1 %156, label %._crit_edge, label %RangeIterator_next_.exit371

RangeIterator_next_.exit371:                      ; preds = %RangeIterator_next_.exit371, %._crit_edge1.i42.lr.ph
  %157 = phi i32 [ %166, %RangeIterator_next_.exit371 ], [ %153, %._crit_edge1.i42.lr.ph ]
  %158 = load i32, ptr %149, align 8
  %159 = add i32 %158, %157
  store i32 %159, ptr %result.i2.i177.h2s516, align 8
  %160 = add i32 %157, %.pre257.pre
  %161 = sext i32 %157 to i64
  %162 = getelementptr i8, ptr %result.i.i21.h2s514, i64 %161
  %163 = load i8, ptr %162, align 1
  %164 = sext i32 %160 to i64
  %165 = getelementptr i8, ptr %.pre256, i64 %164
  store i8 %163, ptr %165, align 1
  %166 = load i32, ptr %result.i2.i177.h2s516, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %168 = load i32, ptr %148, align 4
  %169 = icmp sgt i32 %166, %168
  br i1 %169, label %._crit_edge, label %RangeIterator_next_.exit371

._crit_edge:                                      ; preds = %RangeIterator_next_.exit371, %._crit_edge1.i42.lr.ph, %RangeIterator_next_.exit305, %._crit_edge.i24
  %.pre256400 = phi ptr [ %.pre256403, %._crit_edge.i24 ], [ %.pre256, %._crit_edge1.i42.lr.ph ], [ %.pre256, %RangeIterator_next_.exit371 ], [ %.pre256403, %RangeIterator_next_.exit305 ]
  %170 = phi i32 [ %96, %._crit_edge.i24 ], [ %146, %._crit_edge1.i42.lr.ph ], [ %146, %RangeIterator_next_.exit371 ], [ %96, %RangeIterator_next_.exit305 ]
  %.pre254393 = phi ptr [ %.pre254, %._crit_edge.i24 ], [ %.pre256, %._crit_edge1.i42.lr.ph ], [ %.pre256, %RangeIterator_next_.exit371 ], [ %.pre254, %RangeIterator_next_.exit305 ]
  %171 = phi i32 [ %97, %._crit_edge.i24 ], [ %146, %._crit_edge1.i42.lr.ph ], [ %146, %RangeIterator_next_.exit371 ], [ %97, %RangeIterator_next_.exit305 ]
  %.sink = phi i32 [ %75, %._crit_edge.i24 ], [ %125, %._crit_edge1.i42.lr.ph ], [ %125, %RangeIterator_next_.exit371 ], [ %75, %RangeIterator_next_.exit305 ]
  %.4.vec.extract.pn = phi i32 [ %.3151.i, %._crit_edge.i24 ], [ 1, %._crit_edge1.i42.lr.ph ], [ 1, %RangeIterator_next_.exit371 ], [ %.3151.i, %RangeIterator_next_.exit305 ]
  %storemerge.in = load i32, ptr %8, align 4
  %storemerge = add i32 %storemerge.in, 1
  store i32 %storemerge, ptr %8, align 4
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store i32 %.sink, ptr %6, align 8
  %.1 = add i32 %.4.vec.extract.pn, %.017
  %173 = icmp slt i32 %.1, %2
  br i1 %173, label %.lr.ph, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %174 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %175 = insertvalue { ptr, ptr, ptr, i32 } %174, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %175
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree readnone %0, { ptr } %1) #34 {
  %result.i.i14.h2s510 = alloca [3 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i14.h2s510, i8 0, i64 3, i1 false)
  %.fca.0.extract = extractvalue { ptr } %1, 0
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %2
  %.0 = phi i32 [ 0, %2 ], [ %.1, %._crit_edge ]
  %3 = sext i32 %.0 to i64
  %4 = getelementptr i8, ptr %.fca.0.extract, i64 %3
  %5 = load i8, ptr %4, align 1
  %.not = icmp ne i8 %5, 0
  %6 = zext i1 %.not to i32
  %.1 = add i32 %.0, %6
  br i1 %.not, label %._crit_edge, label %7

7:                                                ; preds = %._crit_edge
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %8 = getelementptr i8, ptr %result.i7.i, i64 16
  store i32 %.1, ptr %8, align 8
  %9 = sext i32 %.1 to i64
  %result.i.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %9) #49
  store ptr %result.i.i, ptr %result.i7.i, align 8
  %10 = getelementptr i8, ptr %result.i7.i, i64 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %12 = getelementptr i8, ptr %result.i7.i, i64 12
  store <2 x i32> zeroinitializer, ptr %10, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  store i8 -17, ptr %result.i.i14.h2s510, align 1
  %14 = getelementptr inbounds i8, ptr %result.i.i14.h2s510, i64 1
  store i8 -65, ptr %14, align 1
  %15 = getelementptr inbounds i8, ptr %result.i.i14.h2s510, i64 2
  store i8 -67, ptr %15, align 1
  %16 = icmp sgt i32 %.1, 0
  br i1 %16, label %.lr.ph.preheader, label %String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32.exit

.lr.ph.preheader:                                 ; preds = %7
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  br label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge.i, %.lr.ph.preheader
  %.pre252400 = phi ptr [ %.pre252396, %._crit_edge.i ], [ %result.i.i, %.lr.ph.preheader ]
  %18 = phi i32 [ %174, %._crit_edge.i ], [ %.1, %.lr.ph.preheader ]
  %19 = phi ptr [ %.pre250389, %._crit_edge.i ], [ %result.i.i, %.lr.ph.preheader ]
  %20 = phi i32 [ %175, %._crit_edge.i ], [ %.1, %.lr.ph.preheader ]
  %.pre253.pre = phi i32 [ %.sink, %._crit_edge.i ], [ 0, %.lr.ph.preheader ]
  %.0.i10 = phi i32 [ %.1.i, %._crit_edge.i ], [ 0, %.lr.ph.preheader ]
  %.not.i = icmp slt i32 %.0.i10, %.1
  br i1 %.not.i, label %._crit_edge.i15, label %select.unfold

._crit_edge.i15:                                  ; preds = %.lr.ph
  %21 = sext i32 %.0.i10 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract, i64 %21
  %23 = load i8, ptr %22, align 1
  %24 = sext i8 %23 to i32
  %25 = icmp sgt i8 %23, -1
  %spec.select.i = zext i1 %25 to i32
  %26 = and i32 %24, -32
  %27 = icmp eq i32 %26, -64
  %.1149.i = select i1 %27, i32 2, i32 %spec.select.i
  %28 = and i32 %24, -16
  %29 = icmp eq i32 %28, -32
  %.2150.i = select i1 %29, i32 3, i32 %.1149.i
  %30 = and i32 %24, -8
  %31 = icmp eq i32 %30, -16
  %.3151.i = select i1 %31, i32 4, i32 %.2150.i
  %32 = icmp eq i32 %.3151.i, 0
  %33 = add i32 %.3151.i, %.0.i10
  %34 = icmp sgt i32 %33, %.1
  %.0152.i = or i1 %32, %34
  br i1 %.0152.i, label %select.unfold, label %35

35:                                               ; preds = %._crit_edge.i15
  %36 = and i32 %24, 7
  %37 = and i32 %24, 15
  %38 = and i32 %24, 31
  %spec.select171.i = select i1 %25, i32 %24, i32 0
  %.1.i16 = select i1 %27, i32 %38, i32 %spec.select171.i
  %.2.i = select i1 %29, i32 %37, i32 %.1.i16
  %.3.i = select i1 %31, i32 %36, i32 %.2.i
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %40

40:                                               ; preds = %35
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %42 = getelementptr i8, ptr %22, i64 1
  %43 = load i8, ptr %42, align 1
  %44 = sext i8 %43 to i32
  %45 = and i32 %44, -64
  %.not15.i = icmp eq i32 %45, -128
  %46 = shl nsw i32 %.3.i, 6
  %47 = and i32 %44, 63
  %48 = or disjoint i32 %47, %46
  br i1 %.not15.i, label %49, label %select.unfold

49:                                               ; preds = %40
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %50

50:                                               ; preds = %49
  %51 = add i32 %.0.i10, 2
  %52 = sext i32 %51 to i64
  %53 = getelementptr i8, ptr %.fca.0.extract, i64 %52
  %54 = load i8, ptr %53, align 1
  %55 = sext i8 %54 to i32
  %56 = and i32 %55, -64
  %.not15.i.1 = icmp eq i32 %56, -128
  %57 = shl i32 %48, 6
  %58 = and i32 %55, 63
  %59 = or disjoint i32 %58, %57
  br i1 %.not15.i.1, label %60, label %select.unfold

60:                                               ; preds = %50
  %not. = xor i1 %31, true
  %exitcond.not.2 = and i1 %29, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %61

61:                                               ; preds = %60
  %62 = add i32 %.0.i10, 3
  %63 = sext i32 %62 to i64
  %64 = getelementptr i8, ptr %.fca.0.extract, i64 %63
  %65 = load i8, ptr %64, align 1
  %66 = sext i8 %65 to i32
  %67 = and i32 %66, -64
  %.not15.i.2 = icmp eq i32 %67, -128
  br i1 %.not15.i.2, label %68, label %select.unfold

68:                                               ; preds = %61
  %69 = and i32 %66, 63
  %70 = shl i32 %59, 6
  %71 = or disjoint i32 %69, %70
  br i1 %31, label %._crit_edge5.i, label %select.unfold

._crit_edge4.i:                                   ; preds = %49
  %72 = icmp slt i32 %48, -128
  br i1 %72, label %select.unfold, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %68, %60, %35
  %.4.i.lcssa515 = phi i32 [ %48, %._crit_edge4.i ], [ %71, %68 ], [ %59, %60 ], [ %.3.i, %35 ]
  %not..i = xor i1 %31, true
  %73 = and i1 %29, %not..i
  %74 = icmp slt i32 %.4.i.lcssa515, 2048
  %spec.select173.i = select i1 %73, i1 %74, i1 false
  %75 = icmp slt i32 %.4.i.lcssa515, 65536
  %spec.select174.i = select i1 %31, i1 %75, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %select.unfold, label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge5.i
  %76 = and i32 %.4.i.lcssa515, -2048
  %spec.select176.i = icmp eq i32 %76, -10240
  %77 = icmp sgt i32 %.4.i.lcssa515, 1114111
  %spec.select177.i = or i1 %77, %spec.select176.i
  br i1 %spec.select177.i, label %select.unfold, label %78

78:                                               ; preds = %.critedge175.i
  %79 = add i32 %.3151.i, %.pre253.pre
  %.not.i18 = icmp slt i32 %79, %20
  br i1 %.not.i18, label %._crit_edge.i19, label %80

80:                                               ; preds = %78
  %81 = shl i32 %20, 1
  %.not.i177 = icmp sgt i32 %81, %20
  br i1 %.not.i177, label %82, label %._crit_edge.i19

82:                                               ; preds = %80
  store i32 %81, ptr %8, align 8
  %83 = sext i32 %81 to i64
  %result.i5.i178 = call noalias ptr @bump_malloc_wrapper(i64 noundef %83) #49
  store ptr %result.i5.i178, ptr %result.i7.i, align 8
  %84 = add i32 %.pre253.pre, -1
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %86 = icmp slt i32 %84, 0
  br i1 %86, label %._crit_edge.i19, label %._crit_edge.i183.lr.ph

._crit_edge.i183.lr.ph:                           ; preds = %82
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %89 = load i8, ptr %19, align 1
  store i8 %89, ptr %result.i5.i178, align 1
  %90 = icmp eq i32 %84, 0
  br i1 %90, label %._crit_edge.i19, label %RangeIterator_next_.exit427.lr.ph

RangeIterator_next_.exit427.lr.ph:                ; preds = %._crit_edge.i183.lr.ph
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  br label %RangeIterator_next_.exit427

RangeIterator_next_.exit427:                      ; preds = %RangeIterator_next_.exit427, %RangeIterator_next_.exit427.lr.ph
  %92 = phi i32 [ 1, %RangeIterator_next_.exit427.lr.ph ], [ %93, %RangeIterator_next_.exit427 ]
  %93 = add i32 %92, 1
  %94 = sext i32 %92 to i64
  %95 = getelementptr i8, ptr %19, i64 %94
  %96 = load i8, ptr %95, align 1
  %97 = getelementptr i8, ptr %result.i5.i178, i64 %94
  store i8 %96, ptr %97, align 1
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %99 = icmp sgt i32 %93, %84
  br i1 %99, label %._crit_edge.i19, label %RangeIterator_next_.exit427

._crit_edge.i19:                                  ; preds = %RangeIterator_next_.exit427, %._crit_edge.i183.lr.ph, %82, %80, %78
  %.pre252399 = phi ptr [ %.pre252400, %78 ], [ %.pre252400, %80 ], [ %result.i5.i178, %82 ], [ %result.i5.i178, %._crit_edge.i183.lr.ph ], [ %result.i5.i178, %RangeIterator_next_.exit427 ]
  %100 = phi i32 [ %18, %78 ], [ %18, %80 ], [ %81, %82 ], [ %81, %._crit_edge.i183.lr.ph ], [ %81, %RangeIterator_next_.exit427 ]
  %.pre250 = phi ptr [ %19, %78 ], [ %19, %80 ], [ %result.i5.i178, %82 ], [ %result.i5.i178, %._crit_edge.i183.lr.ph ], [ %result.i5.i178, %RangeIterator_next_.exit427 ]
  %101 = phi i32 [ %20, %78 ], [ %20, %80 ], [ %81, %82 ], [ %81, %._crit_edge.i183.lr.ph ], [ %81, %RangeIterator_next_.exit427 ]
  %102 = add nsw i32 %.3151.i, -1
  %result.i2.i.h2s511 = alloca [12 x i8], align 1
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %104 = getelementptr inbounds i8, ptr %result.i2.i.h2s511, i64 4
  store i32 %102, ptr %104, align 4
  %105 = getelementptr inbounds i8, ptr %result.i2.i.h2s511, i64 8
  store i32 1, ptr %105, align 4
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  store i32 1, ptr %result.i2.i.h2s511, align 4
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %108 = load i8, ptr %22, align 1
  %109 = sext i32 %.pre253.pre to i64
  %110 = getelementptr i8, ptr %.pre250, i64 %109
  store i8 %108, ptr %110, align 1
  %111 = load i32, ptr %result.i2.i.h2s511, align 4
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %113 = load i32, ptr %104, align 4
  %114 = icmp sgt i32 %111, %113
  br i1 %114, label %._crit_edge.i, label %RangeIterator_next_.exit301

RangeIterator_next_.exit301:                      ; preds = %RangeIterator_next_.exit301, %._crit_edge.i19
  %115 = phi i32 [ %125, %RangeIterator_next_.exit301 ], [ %111, %._crit_edge.i19 ]
  %116 = load i32, ptr %105, align 4
  %117 = add i32 %116, %115
  store i32 %117, ptr %result.i2.i.h2s511, align 4
  %118 = add i32 %115, %.pre253.pre
  %119 = add i32 %115, %.0.i10
  %120 = sext i32 %119 to i64
  %121 = getelementptr i8, ptr %.fca.0.extract, i64 %120
  %122 = load i8, ptr %121, align 1
  %123 = sext i32 %118 to i64
  %124 = getelementptr i8, ptr %.pre250, i64 %123
  store i8 %122, ptr %124, align 1
  %125 = load i32, ptr %result.i2.i.h2s511, align 4
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %127 = load i32, ptr %104, align 4
  %128 = icmp sgt i32 %125, %127
  br i1 %128, label %._crit_edge.i, label %RangeIterator_next_.exit301

select.unfold:                                    ; preds = %.critedge175.i, %._crit_edge5.i, %._crit_edge4.i, %68, %61, %50, %40, %._crit_edge.i15, %.lr.ph
  %129 = add i32 %.pre253.pre, 3
  %.not.i23 = icmp slt i32 %129, %18
  br i1 %.not.i23, label %._crit_edge1.i37.lr.ph, label %130

130:                                              ; preds = %select.unfold
  %131 = shl i32 %18, 1
  %.not.i186 = icmp sgt i32 %131, %18
  br i1 %.not.i186, label %132, label %._crit_edge1.i37.lr.ph

132:                                              ; preds = %130
  store i32 %131, ptr %8, align 8
  %133 = sext i32 %131 to i64
  %result.i5.i188 = call noalias ptr @bump_malloc_wrapper(i64 noundef %133) #49
  store ptr %result.i5.i188, ptr %result.i7.i, align 8
  %134 = add i32 %.pre253.pre, -1
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %136 = icmp slt i32 %134, 0
  br i1 %136, label %._crit_edge1.i37.lr.ph, label %._crit_edge.i199.lr.ph

._crit_edge.i199.lr.ph:                           ; preds = %132
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %139 = load i8, ptr %19, align 1
  store i8 %139, ptr %result.i5.i188, align 1
  %140 = icmp eq i32 %134, 0
  br i1 %140, label %._crit_edge1.i37.lr.ph, label %RangeIterator_next_.exit465.lr.ph

RangeIterator_next_.exit465.lr.ph:                ; preds = %._crit_edge.i199.lr.ph
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  br label %RangeIterator_next_.exit465

RangeIterator_next_.exit465:                      ; preds = %RangeIterator_next_.exit465, %RangeIterator_next_.exit465.lr.ph
  %142 = phi i32 [ 1, %RangeIterator_next_.exit465.lr.ph ], [ %143, %RangeIterator_next_.exit465 ]
  %143 = add i32 %142, 1
  %144 = sext i32 %142 to i64
  %145 = getelementptr i8, ptr %19, i64 %144
  %146 = load i8, ptr %145, align 1
  %147 = getelementptr i8, ptr %result.i5.i188, i64 %144
  store i8 %146, ptr %147, align 1
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %149 = icmp sgt i32 %143, %134
  br i1 %149, label %._crit_edge1.i37.lr.ph, label %RangeIterator_next_.exit465

._crit_edge1.i37.lr.ph:                           ; preds = %RangeIterator_next_.exit465, %._crit_edge.i199.lr.ph, %132, %130, %select.unfold
  %.pre252 = phi ptr [ %.pre252400, %select.unfold ], [ %.pre252400, %130 ], [ %result.i5.i188, %132 ], [ %result.i5.i188, %._crit_edge.i199.lr.ph ], [ %result.i5.i188, %RangeIterator_next_.exit465 ]
  %150 = phi i32 [ %18, %select.unfold ], [ %18, %130 ], [ %131, %132 ], [ %131, %._crit_edge.i199.lr.ph ], [ %131, %RangeIterator_next_.exit465 ]
  %result.i2.i173.h2s512 = alloca [12 x i8], align 8
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %152 = getelementptr inbounds i8, ptr %result.i2.i173.h2s512, i64 4
  %153 = getelementptr inbounds i8, ptr %result.i2.i173.h2s512, i64 8
  store i32 1, ptr %153, align 8
  store <2 x i32> <i32 1, i32 2>, ptr %result.i2.i173.h2s512, align 8
  %154 = load i8, ptr %result.i.i14.h2s510, align 1
  %155 = sext i32 %.pre253.pre to i64
  %156 = getelementptr i8, ptr %.pre252, i64 %155
  store i8 %154, ptr %156, align 1
  %157 = load i32, ptr %result.i2.i173.h2s512, align 8
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %159 = load i32, ptr %152, align 4
  %160 = icmp sgt i32 %157, %159
  br i1 %160, label %._crit_edge.i, label %RangeIterator_next_.exit367

RangeIterator_next_.exit367:                      ; preds = %RangeIterator_next_.exit367, %._crit_edge1.i37.lr.ph
  %161 = phi i32 [ %170, %RangeIterator_next_.exit367 ], [ %157, %._crit_edge1.i37.lr.ph ]
  %162 = load i32, ptr %153, align 8
  %163 = add i32 %162, %161
  store i32 %163, ptr %result.i2.i173.h2s512, align 8
  %164 = add i32 %161, %.pre253.pre
  %165 = sext i32 %161 to i64
  %166 = getelementptr i8, ptr %result.i.i14.h2s510, i64 %165
  %167 = load i8, ptr %166, align 1
  %168 = sext i32 %164 to i64
  %169 = getelementptr i8, ptr %.pre252, i64 %168
  store i8 %167, ptr %169, align 1
  %170 = load i32, ptr %result.i2.i173.h2s512, align 8
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %172 = load i32, ptr %152, align 4
  %173 = icmp sgt i32 %170, %172
  br i1 %173, label %._crit_edge.i, label %RangeIterator_next_.exit367

._crit_edge.i:                                    ; preds = %RangeIterator_next_.exit367, %._crit_edge1.i37.lr.ph, %RangeIterator_next_.exit301, %._crit_edge.i19
  %.pre252396 = phi ptr [ %.pre252399, %._crit_edge.i19 ], [ %.pre252, %._crit_edge1.i37.lr.ph ], [ %.pre252, %RangeIterator_next_.exit367 ], [ %.pre252399, %RangeIterator_next_.exit301 ]
  %174 = phi i32 [ %100, %._crit_edge.i19 ], [ %150, %._crit_edge1.i37.lr.ph ], [ %150, %RangeIterator_next_.exit367 ], [ %100, %RangeIterator_next_.exit301 ]
  %.pre250389 = phi ptr [ %.pre250, %._crit_edge.i19 ], [ %.pre252, %._crit_edge1.i37.lr.ph ], [ %.pre252, %RangeIterator_next_.exit367 ], [ %.pre250, %RangeIterator_next_.exit301 ]
  %175 = phi i32 [ %101, %._crit_edge.i19 ], [ %150, %._crit_edge1.i37.lr.ph ], [ %150, %RangeIterator_next_.exit367 ], [ %101, %RangeIterator_next_.exit301 ]
  %.sink = phi i32 [ %79, %._crit_edge.i19 ], [ %129, %._crit_edge1.i37.lr.ph ], [ %129, %RangeIterator_next_.exit367 ], [ %79, %RangeIterator_next_.exit301 ]
  %.4.vec.extract.i.pn = phi i32 [ %.3151.i, %._crit_edge.i19 ], [ 1, %._crit_edge1.i37.lr.ph ], [ 1, %RangeIterator_next_.exit367 ], [ %.3151.i, %RangeIterator_next_.exit301 ]
  %storemerge.in = load i32, ptr %12, align 4
  %storemerge = add i32 %storemerge.in, 1
  store i32 %storemerge, ptr %12, align 4
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store i32 %.sink, ptr %10, align 8
  %.1.i = add i32 %.4.vec.extract.i.pn, %.0.i10
  %177 = icmp slt i32 %.1.i, %.1
  br i1 %177, label %.lr.ph, label %String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32.exit

String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32.exit: ; preds = %._crit_edge.i, %7
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7.i, 1
  %178 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %179 = insertvalue { ptr, ptr, ptr, i32 } %178, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %179
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %9(ptr %.fca.1.extract, { ptr } %10) #42
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %12 = getelementptr i8, ptr %6, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 1) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #42
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %22 = getelementptr i8, ptr %6, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = getelementptr i8, ptr %23, i64 8
  %25 = load ptr, ptr %24, align 8
  call void %25(ptr %.fca.1.extract, i32 0) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #42
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract) #43
  %16 = sext i32 %15 to i64
  %result.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %16) #49
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %18 = load ptr, ptr %7, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %20(ptr %.fca.1.extract, { ptr } %21) #42
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %23 = getelementptr i8, ptr %7, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  call void %26(ptr %.fca.1.extract, i32 0) #42
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %28 = getelementptr i8, ptr %7, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, i32 0) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5, i32 %6) #5 {
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #41
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract16, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #44
  %15 = getelementptr i8, ptr %10, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, i32 %4) #42
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #44
  %20 = getelementptr i8, ptr %10, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #42
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #44
  %25 = getelementptr i8, ptr %10, i64 24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %.fca.1.extract, i32 %6) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_byte_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: nounwind
define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46) #57
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract46, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract47) #43
  %11 = add i32 %10, 1
  %12 = sext i32 %11 to i64
  %result.i5 = call noalias ptr @bump_malloc_wrapper(i64 noundef %12) #49
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract47) #43
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %18 = call i32 %15(ptr %.fca.1.extract47) #43
  %19 = add i32 %18, -1
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %22 = icmp slt i32 %19, 0
  br i1 %22, label %.critedge, label %._crit_edge.lr.ph

._crit_edge.lr.ph:                                ; preds = %3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %24 = load ptr, ptr %6, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr } %25(ptr %.fca.1.extract47) #43
  %.fca.0.extract6262 = extractvalue { ptr } %26, 0
  %27 = load i8, ptr %.fca.0.extract6262, align 1
  store i8 %27, ptr %result.i5, align 1
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %29 = icmp eq i32 %19, 0
  br i1 %29, label %.critedge, label %RangeIterator_next_.exit52

RangeIterator_next_.exit52:                       ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph
  %30 = phi i32 [ %31, %RangeIterator_next_.exit52 ], [ 1, %._crit_edge.lr.ph ]
  %31 = add i32 %30, 1
  %32 = load ptr, ptr %6, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr } %33(ptr %.fca.1.extract47) #43
  %.fca.0.extract62 = extractvalue { ptr } %34, 0
  %35 = sext i32 %30 to i64
  %36 = getelementptr i8, ptr %.fca.0.extract62, i64 %35
  %37 = load i8, ptr %36, align 1
  %38 = getelementptr i8, ptr %result.i5, i64 %35
  store i8 %37, ptr %38, align 1
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %40 = icmp sgt i32 %31, %19
  br i1 %40, label %.critedge, label %RangeIterator_next_.exit52

.critedge:                                        ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph, %3
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %42 = load ptr, ptr %7, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %.fca.1.extract47) #43
  %45 = sext i32 %44 to i64
  %46 = getelementptr i8, ptr %result.i5, i64 %45
  store i8 0, ptr %46, align 1
  %47 = insertvalue { ptr } undef, ptr %result.i5, 0
  ret { ptr } %47
}

define { ptr, ptr, ptr, i32 } @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #18 {
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #57
  %10 = sext i32 %offset.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract45, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract) #43
  %16 = add i32 %15, %5
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract45)
  %18 = getelementptr i8, ptr %11, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %.fca.1.extract) #43
  %.not = icmp slt i32 %16, %21
  br i1 %.not, label %._crit_edge, label %22

22:                                               ; preds = %6
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %24 = call i32 %20(ptr %.fca.1.extract) #43
  %25 = shl i32 %24, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %.fca.1.extract, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.2.extract, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %offset.i, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %32 = getelementptr i8, ptr %11, i64 120
  %33 = load ptr, ptr %32, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i4 = call ptr %33({ ptr, ptr, ptr, i32 } %29, ptr nocapture nofree noundef nonnull readonly align 8 %8) #47
  call void %result.i4({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull align 8 dereferenceable(8) %7, i32 %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %6
  %34 = add i32 %5, -1
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %37 = icmp slt i32 %34, 0
  br i1 %37, label %.critedge, label %._crit_edge1.lr.ph

._crit_edge1.lr.ph:                               ; preds = %._crit_edge
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge1, %._crit_edge1.lr.ph
  %result.i2.i.h2s74.sroa.0.0 = phi i32 [ 1, %._crit_edge1.lr.ph ], [ %55, %._crit_edge1 ]
  %.sroa.026.0.insert.ext.i.pn.in = phi i32 [ 0, %._crit_edge1.lr.ph ], [ %result.i2.i.h2s74.sroa.0.0, %._crit_edge1 ]
  %39 = load ptr, ptr %12, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call i32 %40(ptr %.fca.1.extract) #43
  %42 = add i32 %41, %.sroa.026.0.insert.ext.i.pn.in
  %43 = add i32 %.sroa.026.0.insert.ext.i.pn.in, %4
  %44 = sext i32 %43 to i64
  %45 = getelementptr i8, ptr %.fca.0.extract, i64 %44
  %46 = load i8, ptr %45, align 1
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %48 = load ptr, ptr %11, align 8
  %49 = load ptr, ptr %48, align 8
  %50 = call { ptr } %49(ptr %.fca.1.extract) #43
  %.fca.0.extract59 = extractvalue { ptr } %50, 0
  %51 = sext i32 %42 to i64
  %52 = getelementptr i8, ptr %.fca.0.extract59, i64 %51
  store i8 %46, ptr %52, align 1
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %54 = icmp sgt i32 %result.i2.i.h2s74.sroa.0.0, %34
  %55 = add i32 %result.i2.i.h2s74.sroa.0.0, 1
  br i1 %54, label %.critedge, label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1, %._crit_edge
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %57 = getelementptr i8, ptr %11, i64 16
  %58 = load ptr, ptr %57, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call i32 %59(ptr %.fca.1.extract) #43
  %61 = add i32 %60, 1
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %63 = getelementptr i8, ptr %58, i64 8
  %64 = load ptr, ptr %63, align 8
  call void %64(ptr %.fca.1.extract, i32 %61) #42
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %66 = load ptr, ptr %12, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call i32 %67(ptr %.fca.1.extract) #43
  %69 = add i32 %68, %5
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %71 = getelementptr i8, ptr %66, i64 8
  %72 = load ptr, ptr %71, align 8
  call void %72(ptr %.fca.1.extract, i32 %69) #42
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 6499063144389013426
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %73 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.1.extract, 1
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %.fca.2.extract, 2
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, i32 %offset.i29, 3
  ret { ptr, ptr, ptr, i32 } %76
}

; Function Attrs: nounwind
define void @String_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #28 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #57
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #43
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %.critedge

12:                                               ; preds = %4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 %3) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr } %18(ptr %.fca.1.extract) #43
  %.fca.0.extract80 = extractvalue { ptr } %19, 0
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call i32 %22(ptr %.fca.1.extract) #43
  %24 = sext i32 %23 to i64
  %result.i5 = call noalias ptr @bump_malloc_wrapper(i64 noundef %24) #49
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %26 = load ptr, ptr %7, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i5, 0
  call void %28(ptr %.fca.1.extract, { ptr } %29) #42
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract) #43
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %36 = call i32 %33(ptr %.fca.1.extract) #43
  %37 = add i32 %36, -1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %40 = icmp slt i32 %37, 0
  br i1 %40, label %.critedge, label %._crit_edge.lr.ph

._crit_edge.lr.ph:                                ; preds = %12
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %42 = load i8, ptr %.fca.0.extract80, align 1
  %43 = load ptr, ptr %7, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr } %44(ptr %.fca.1.extract) #43
  %.fca.0.extract3162 = extractvalue { ptr } %45, 0
  store i8 %42, ptr %.fca.0.extract3162, align 1
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %47 = icmp eq i32 %37, 0
  br i1 %47, label %.critedge, label %RangeIterator_next_.exit52

RangeIterator_next_.exit52:                       ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph
  %48 = phi i32 [ %49, %RangeIterator_next_.exit52 ], [ 1, %._crit_edge.lr.ph ]
  %49 = add i32 %48, 1
  %50 = sext i32 %48 to i64
  %51 = getelementptr i8, ptr %.fca.0.extract80, i64 %50
  %52 = load i8, ptr %51, align 1
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr } %54(ptr %.fca.1.extract) #43
  %.fca.0.extract31 = extractvalue { ptr } %55, 0
  %56 = getelementptr i8, ptr %.fca.0.extract31, i64 %50
  store i8 %52, ptr %56, align 1
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %58 = icmp sgt i32 %49, %37
  br i1 %58, label %.critedge, label %RangeIterator_next_.exit52

.critedge:                                        ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph, %12, %4
  ret void
}

define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i7 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i8 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i7, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i8, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i9, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 6499063144389013426
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #57
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract24, i64 %9
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract25) #43
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %offset.i18, 3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %21 = sext i32 %offset.i18 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract, i64 %21
  %23 = getelementptr i8, ptr %22, i64 88
  %24 = load ptr, ptr %23, align 8
  %result.i5 = call ptr %24({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %25 = call i32 %result.i5({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %5)
  %.not = icmp eq i32 %14, %25
  br i1 %.not, label %26, label %.critedge

26:                                               ; preds = %4
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract24)
  %28 = load ptr, ptr %11, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %.fca.1.extract25) #43
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract24)
  %32 = call i32 %29(ptr %.fca.1.extract25) #43
  %33 = add i32 %32, -1
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #41
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %37 = getelementptr i8, ptr %22, i64 144
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #41
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  br label %40

40:                                               ; preds = %43, %26
  %41 = phi i32 [ %44, %43 ], [ 0, %26 ]
  %42 = icmp sgt i32 %41, %33
  br i1 %42, label %.critedge, label %43

43:                                               ; preds = %40
  %44 = add i32 %41, 1
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract24)
  %47 = load ptr, ptr %10, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract25) #43
  %.fca.0.extract38 = extractvalue { ptr } %49, 0
  %50 = sext i32 %41 to i64
  %51 = getelementptr i8, ptr %.fca.0.extract38, i64 %50
  %52 = load i8, ptr %51, align 1
  store ptr @_parameterization_i32, ptr %6, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %55 = load ptr, ptr %37, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i1 = call ptr %55({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly %7) #47
  %56 = call i8 %result.i1({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 dereferenceable(8) %6, i32 %41)
  %.not86 = icmp eq i8 %52, %56
  br i1 %.not86, label %40, label %.critedge

.critedge:                                        ; preds = %43, %40, %4
  %.reg2mem20.0 = phi i1 [ false, %4 ], [ %42, %43 ], [ %42, %40 ]
  ret i1 %.reg2mem20.0
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i64 } @String_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr %.fca.1.extract11) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #44
  %12 = getelementptr i8, ptr %7, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract11) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode) #44
  %.fca.0.extract10.i = extractvalue { ptr } %10, 0
  %.not.i = icmp slt i32 %3, %15
  br i1 %.not.i, label %._crit_edge.i, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

._crit_edge.i:                                    ; preds = %4
  %17 = sext i32 %3 to i64
  %18 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %17
  %19 = load i8, ptr %18, align 1
  %20 = sext i8 %19 to i32
  %21 = icmp sgt i8 %19, -1
  %spec.select.i = zext i1 %21 to i32
  %22 = and i32 %20, -32
  %23 = icmp eq i32 %22, -64
  %.1149.i = select i1 %23, i32 2, i32 %spec.select.i
  %24 = and i32 %20, -16
  %25 = icmp eq i32 %24, -32
  %.2150.i = select i1 %25, i32 3, i32 %.1149.i
  %26 = and i32 %20, -8
  %27 = icmp eq i32 %26, -16
  %.3151.i = select i1 %27, i32 4, i32 %.2150.i
  %28 = icmp eq i32 %.3151.i, 0
  %29 = add i32 %.3151.i, %3
  %30 = icmp sgt i32 %29, %15
  %.0152.i = or i1 %28, %30
  br i1 %.0152.i, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit, label %31

31:                                               ; preds = %._crit_edge.i
  %32 = and i32 %20, 7
  %33 = and i32 %20, 15
  %34 = and i32 %20, 31
  %spec.select171.i = select i1 %21, i32 %20, i32 0
  %.1.i = select i1 %23, i32 %34, i32 %spec.select171.i
  %.2.i = select i1 %25, i32 %33, i32 %.1.i
  %.3.i = select i1 %27, i32 %32, i32 %.2.i
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %37

37:                                               ; preds = %31
  %38 = getelementptr i8, ptr %18, i64 1
  %39 = load i8, ptr %38, align 1
  %40 = sext i8 %39 to i32
  %41 = and i32 %40, -64
  %.not15.i = icmp eq i32 %41, -128
  %42 = shl nsw i32 %.3.i, 6
  %43 = and i32 %40, 63
  %44 = or disjoint i32 %43, %42
  br i1 %.not15.i, label %45, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

45:                                               ; preds = %37
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %46

46:                                               ; preds = %45
  %47 = add i32 %3, 2
  %48 = sext i32 %47 to i64
  %49 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %48
  %50 = load i8, ptr %49, align 1
  %51 = sext i8 %50 to i32
  %52 = and i32 %51, -64
  %.not15.i.1 = icmp eq i32 %52, -128
  %53 = shl i32 %44, 6
  %54 = and i32 %51, 63
  %55 = or disjoint i32 %54, %53
  br i1 %.not15.i.1, label %56, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

56:                                               ; preds = %46
  %not. = xor i1 %27, true
  %exitcond.not.2 = and i1 %25, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %57

57:                                               ; preds = %56
  %58 = add i32 %3, 3
  %59 = sext i32 %58 to i64
  %60 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = sext i8 %61 to i32
  %63 = and i32 %62, -64
  %.not15.i.2 = icmp eq i32 %63, -128
  br i1 %.not15.i.2, label %64, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

64:                                               ; preds = %57
  %65 = and i32 %62, 63
  %66 = shl i32 %55, 6
  %67 = or disjoint i32 %65, %66
  br i1 %27, label %._crit_edge5.i, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

._crit_edge4.i:                                   ; preds = %45
  %68 = icmp slt i32 %44, -128
  br i1 %68, label %.critedge175.i, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %64, %56, %31
  %.4.i.lcssa10 = phi i32 [ %44, %._crit_edge4.i ], [ %67, %64 ], [ %55, %56 ], [ %.3.i, %31 ]
  %not..i = xor i1 %27, true
  %69 = and i1 %25, %not..i
  %70 = icmp slt i32 %.4.i.lcssa10, 2048
  %spec.select173.i = select i1 %69, i1 %70, i1 false
  %71 = icmp slt i32 %.4.i.lcssa10, 65536
  %spec.select174.i = select i1 %27, i1 %71, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %.critedge175.i, label %._crit_edge7.i

._crit_edge7.i:                                   ; preds = %._crit_edge5.i
  %72 = and i32 %.4.i.lcssa10, -2048
  %spec.select176.i = icmp eq i32 %72, -10240
  br label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge7.i, %._crit_edge5.i, %._crit_edge4.i
  %.4.i.lcssa11 = phi i32 [ %.4.i.lcssa10, %._crit_edge7.i ], [ %44, %._crit_edge4.i ], [ %.4.i.lcssa10, %._crit_edge5.i ]
  %.0158.i = phi i1 [ %spec.select176.i, %._crit_edge7.i ], [ true, %._crit_edge4.i ], [ true, %._crit_edge5.i ]
  %73 = icmp sgt i32 %.4.i.lcssa11, 1114111
  %spec.select177.i = select i1 %.0158.i, i1 true, i1 %73
  %.0.vec.insert.i = insertelement <2 x i32> poison, i32 %.4.i.lcssa11, i64 0
  %.4.vec.insert.i = insertelement <2 x i32> %.0.vec.insert.i, i32 %.3151.i, i64 1
  %74 = bitcast <2 x i32> %.4.vec.insert.i to i64
  %75 = select i1 %spec.select177.i, ptr @nil_typ, ptr @tuple_typ
  br label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit: ; preds = %.critedge175.i, %64, %57, %46, %37, %._crit_edge.i, %4
  %.reg2mem55.0.i = phi ptr [ @nil_typ, %4 ], [ @nil_typ, %._crit_edge.i ], [ %75, %.critedge175.i ], [ @nil_typ, %57 ], [ @nil_typ, %46 ], [ @nil_typ, %37 ], [ @nil_typ, %64 ]
  %.reg2mem57.sroa.3.0.i = phi i64 [ poison, %4 ], [ poison, %._crit_edge.i ], [ %74, %.critedge175.i ], [ poison, %57 ], [ poison, %46 ], [ poison, %37 ], [ poison, %64 ]
  %.reload54.fca.0.insert.i = insertvalue { ptr, i64 } poison, ptr %.reg2mem55.0.i, 0
  %.reload54.fca.1.insert.i = insertvalue { ptr, i64 } %.reload54.fca.0.insert.i, i64 %.reg2mem57.sroa.3.0.i, 1
  ret { ptr, i64 } %.reload54.fca.1.insert.i
}

; Function Attrs: mustprogress nounwind willreturn
define i8 @String_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr %.fca.1.extract) #43
  %.fca.0.extract = extractvalue { ptr } %10, 0
  %11 = sext i32 %3 to i64
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load i8, ptr %12, align 1
  ret i8 %13
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i8 %4) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract7, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract) #43
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = sext i32 %3 to i64
  %13 = getelementptr i8, ptr %.fca.0.extract, i64 %12
  store i8 %4, ptr %13, align 1
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %.fca.0.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58) #57
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract58, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract59) #43
  %11 = sext i32 %10 to i64
  %result.i8 = call noalias ptr @bump_malloc_wrapper(i64 noundef %11) #49
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract59) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %17 = call i32 %14(ptr %.fca.1.extract59) #43
  %18 = add i32 %17, -1
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %21 = icmp slt i32 %18, 0
  br i1 %21, label %.critedge, label %._crit_edge.lr.ph

._crit_edge.lr.ph:                                ; preds = %3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %23 = load ptr, ptr %6, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call { ptr } %24(ptr %.fca.1.extract59) #43
  %.fca.0.extract8778 = extractvalue { ptr } %25, 0
  %26 = load i8, ptr %.fca.0.extract8778, align 1
  store i8 %26, ptr %result.i8, align 1
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %28 = icmp eq i32 %18, 0
  br i1 %28, label %.critedge, label %RangeIterator_next_.exit68

RangeIterator_next_.exit68:                       ; preds = %RangeIterator_next_.exit68, %._crit_edge.lr.ph
  %29 = phi i32 [ %30, %RangeIterator_next_.exit68 ], [ 1, %._crit_edge.lr.ph ]
  %30 = add i32 %29, 1
  %31 = load ptr, ptr %6, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr } %32(ptr %.fca.1.extract59) #43
  %.fca.0.extract87 = extractvalue { ptr } %33, 0
  %34 = sext i32 %29 to i64
  %35 = getelementptr i8, ptr %.fca.0.extract87, i64 %34
  %36 = load i8, ptr %35, align 1
  %37 = getelementptr i8, ptr %result.i8, i64 %34
  store i8 %36, ptr %37, align 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %39 = icmp sgt i32 %30, %18
  br i1 %39, label %.critedge, label %RangeIterator_next_.exit68

.critedge:                                        ; preds = %RangeIterator_next_.exit68, %._crit_edge.lr.ph, %3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %41 = load ptr, ptr %7, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %.fca.1.extract59) #43
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %45 = getelementptr i8, ptr %6, i64 16
  %46 = load ptr, ptr %45, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call i32 %47(ptr %.fca.1.extract59) #43
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %50 = call i32 %42(ptr %.fca.1.extract59) #43
  %result.i6 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call i32 %53(ptr %.fca.1.extract59) #43
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %56 = load ptr, ptr %45, align 8
  %57 = load ptr, ptr %56, align 8
  %58 = call i32 %57(ptr %.fca.1.extract59) #43
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %60 = call i32 %53(ptr %.fca.1.extract59) #43
  %61 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr undef, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 10, 3
  store ptr %result.i8, ptr %result.i6, align 8
  %64 = getelementptr i8, ptr %result.i6, i64 8
  store i32 %54, ptr %64, align 8
  %65 = getelementptr i8, ptr %result.i6, i64 12
  store i32 %58, ptr %65, align 4
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %67 = getelementptr i8, ptr %result.i6, i64 16
  store i32 %60, ptr %67, align 8
  ret { ptr, ptr, ptr, i32 } %63
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String__Self_empty_(ptr nocapture nofree readnone %0) #35 {
  %result.i2 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %2 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %3 = insertvalue { ptr, ptr, ptr, i32 } %2, ptr undef, 2
  %result.i.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  store ptr %result.i.i, ptr %result.i2, align 8
  %4 = getelementptr i8, ptr %result.i2, i64 16
  store i32 1, ptr %4, align 8
  %5 = getelementptr i8, ptr %result.i2, i64 8
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  store <2 x i32> zeroinitializer, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %3, i32 102, 3
  ret { ptr, ptr, ptr, i32 } %7
}

define { ptr, ptr, ptr, i32 } @String__Self_from_iterable_iterableIterableCharacter(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #18 {
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i2.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %result.i.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  store ptr %result.i.i, ptr %result.i2.i, align 8
  %3 = getelementptr i8, ptr %result.i2.i, i64 16
  store i32 1, ptr %3, align 8
  %4 = getelementptr i8, ptr %result.i2.i, i64 8
  store <2 x i32> zeroinitializer, ptr %4, align 8
  %5 = alloca [1 x ptr], align 8
  store ptr @_parameterization_IterableCharacter, ptr %5, align 8
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #41
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #41
  %8 = getelementptr i8, ptr %.fca.0.extract25, i64 24
  %9 = getelementptr i8, ptr %.fca.0.extract25, i64 32
  %10 = load i64, ptr %hash_coef_ptr.i, align 4
  %11 = load i64, ptr %tbl_size_ptr.i, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %result.i1.i = call i1 %12(i64 %11, i64 %10, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %13) #45
  br i1 %result.i1.i, label %String_B_extend_otherIterableT_extend_otherString_extend_otherCollectionCharacter.exit, label %14

14:                                               ; preds = %2
  %result.i.i26 = call i1 %12(i64 %11, i64 %10, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %13) #45
  %spec.select.i = select i1 %result.i.i26, i64 69, i64 67
  br label %String_B_extend_otherIterableT_extend_otherString_extend_otherCollectionCharacter.exit

String_B_extend_otherIterableT_extend_otherString_extend_otherCollectionCharacter.exit: ; preds = %14, %2
  %.reg2mem7.0.i = phi i64 [ 68, %2 ], [ %spec.select.i, %14 ]
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2.i, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 10, 3
  %18 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract25, 0
  %.sroa.624.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.624.8.insert.shift = shl nuw i160 %.sroa.624.8.insert.ext, 128
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %19 = ptrtoint ptr %.fca.2.extract27 to i64
  %.sroa.523.8.insert.ext = zext i64 %19 to i160
  %.sroa.523.8.insert.shift = shl nuw nsw i160 %.sroa.523.8.insert.ext, 64
  %.sroa.523.8.insert.insert = or disjoint i160 %.sroa.624.8.insert.shift, %.sroa.523.8.insert.shift
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %20 = ptrtoint ptr %.fca.1.extract26 to i64
  %.sroa.322.8.insert.ext = zext i64 %20 to i160
  %.sroa.322.8.insert.insert = or disjoint i160 %.sroa.523.8.insert.insert, %.sroa.322.8.insert.ext
  %21 = insertvalue { ptr, i160 } %18, i160 %.sroa.322.8.insert.insert, 1
  %22 = getelementptr [314 x ptr], ptr @String, i64 0, i64 %.reg2mem7.0.i
  %23 = getelementptr i8, ptr %22, i64 80
  %24 = load ptr, ptr %23, align 8
  %25 = call { ptr, i160 } %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(8) %5, { ptr, i160 } %21)
  %.fca.0.extract = extractvalue { ptr, i160 } %25, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %25, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %26 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %27 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, -83120161364696977
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %26, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %27, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %offset.i25, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define { ptr, ptr, ptr, i32 } @String_append_charCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract40 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract39, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract39, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract39, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract28 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %3, 1
  %.sroa.231.8.extract.trunc = trunc i160 %.fca.1.extract29 to i64
  %.sroa.432.8.extract.shift = lshr i160 %.fca.1.extract29, 64
  %.sroa.432.8.extract.trunc = trunc i160 %.sroa.432.8.extract.shift to i64
  %6 = inttoptr i64 %.sroa.231.8.extract.trunc to ptr
  %7 = inttoptr i64 %.sroa.432.8.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 6681222582356018452
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %6, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %7, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i13, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract28) #41
  %14 = sext i32 %offset.i13 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract28, i64 %14
  %16 = getelementptr i8, ptr %15, i64 24
  %17 = load ptr, ptr %16, align 8
  %result.i1 = call ptr %17({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %18 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 %5)
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 6499063144389013426
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %19 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract14, 0
  %20 = ptrtoint ptr %.fca.1.extract15 to i64
  %21 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i25 to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.513.8.insert.ext = zext i64 %21 to i160
  %.sroa.513.8.insert.shift = shl nuw nsw i160 %.sroa.513.8.insert.ext, 64
  %.sroa.513.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.513.8.insert.shift
  %.sroa.312.8.insert.ext = zext i64 %20 to i160
  %.sroa.312.8.insert.insert = or disjoint i160 %.sroa.513.8.insert.insert, %.sroa.312.8.insert.ext
  %22 = insertvalue { ptr, i160 } %19, i160 %.sroa.312.8.insert.insert, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract40, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract41, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i, 3
  %27 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract39)
  %30 = sext i32 %offset.i to i64
  %31 = getelementptr ptr, ptr %.fca.0.extract39, i64 %30
  %32 = getelementptr i8, ptr %31, i64 216
  %33 = load ptr, ptr %32, align 8
  %34 = alloca { ptr }, align 8
  store ptr %.fca.0.extract14, ptr %34, align 8
  %result.i = call ptr %33({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %34) #47
  %35 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %27, { ptr, i160 } %22)
  %.fca.0.extract = extractvalue { ptr, i160 } %35, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %35, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %36 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %37 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i29 = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i30 = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i31 = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i32 = mul i64 %hash_coef.i29, -83120161364696977
  %shifted.i.i33 = lshr i64 %product.i.i32, 32
  %xored.i.i34 = xor i64 %shifted.i.i33, %product.i.i32
  %hash.i.i35 = and i64 %xored.i.i34, %tbl_size.i30
  %offset_ptr.i36 = getelementptr i32, ptr %offset_tbl.i31, i64 %hash.i.i35
  %offset.i37 = load i32, ptr %offset_ptr.i36, align 4
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %36, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %37, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %offset.i37, 3
  ret { ptr, ptr, ptr, i32 } %41
}

define i32 @List_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract, i64 %11
  %13 = getelementptr i8, ptr %12, i64 80
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %15 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  ret i32 %15
}

define { ptr, i160 } @List_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract15, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #41
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract14, i64 %11
  %13 = getelementptr i8, ptr %12, i64 88
  %14 = load ptr, ptr %13, align 8
  %result.i2 = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %15 = call i1 %result.i2({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  br i1 %15, label %34, label %16

16:                                               ; preds = %3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %19 = getelementptr i8, ptr %12, i64 96
  %20 = load ptr, ptr %19, align 8
  %result.i1 = call ptr %20({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %21 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %21, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %21, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %21, 2
  %hash_coef_ptr.i3 = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i4 = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i5 = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i3, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i4, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i5, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, 7049076106841707882
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract33, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract34, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i14, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract32)
  %28 = sext i32 %offset.i14 to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract32, i64 %28
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %result.i = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %32 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %4)
  %.fca.0.extract19 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract20 = extractvalue { ptr, i160 } %32, 1
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  br label %34

34:                                               ; preds = %16, %3
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract19, %16 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract20, %16 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

define { ptr, i160 } @List_last_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract12, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #41
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract11, i64 %11
  %13 = getelementptr i8, ptr %12, i64 80
  %14 = load ptr, ptr %13, align 8
  %result.i1 = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %15 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %16 = add i32 %15, -1
  %17 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %20 = getelementptr i8, ptr %12, i64 64
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %22, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %22) #47
  %23 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 dereferenceable(8) %17, i32 %16)
  ret { ptr, i160 } %23
}

define { ptr, ptr, ptr, i32 } @List_extend_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract36 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i4 = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i5 = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i6 = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i7 = load i64, ptr %hash_coef_ptr.i4, align 4
  %tbl_size.i8 = load i64, ptr %tbl_size_ptr.i5, align 4
  %offset_tbl.i9 = load ptr, ptr %offset_tbl_ptr.i6, align 8
  %product.i.i10 = mul i64 %hash_coef.i7, 3037712219555723519
  %shifted.i.i11 = lshr i64 %product.i.i10, 32
  %xored.i.i12 = xor i64 %shifted.i.i11, %product.i.i10
  %hash.i.i13 = and i64 %xored.i.i12, %tbl_size.i8
  %offset_ptr.i14 = getelementptr i32, ptr %offset_tbl.i9, i64 %hash.i.i13
  %offset.i15 = load i32, ptr %offset_ptr.i14, align 4
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract14, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract15, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i15, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #57
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #57
  %14 = sext i32 %offset.i15 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract13, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %result.i3 = call ptr %17({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %18 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %hash_coef_ptr.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i19 = load i64, ptr %hash_coef_ptr.i16, align 4
  %tbl_size.i20 = load i64, ptr %tbl_size_ptr.i17, align 4
  %offset_tbl.i21 = load ptr, ptr %offset_tbl_ptr.i18, align 8
  %product.i.i22 = mul i64 %hash_coef.i19, 8673632051301757104
  %shifted.i.i23 = lshr i64 %product.i.i22, 32
  %xored.i.i24 = xor i64 %shifted.i.i23, %product.i.i22
  %hash.i.i25 = and i64 %xored.i.i24, %tbl_size.i20
  %offset_ptr.i26 = getelementptr i32, ptr %offset_tbl.i21, i64 %hash.i.i25
  %offset.i27 = load i32, ptr %offset_ptr.i26, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %offset.i27, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %25 = sext i32 %offset.i27 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = sext i32 %offset.i to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract34, i64 %28
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.1.extract35, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.2.extract36, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %offset.i, 3
  %34 = getelementptr i8, ptr %29, i64 24
  %35 = load ptr, ptr %27, align 8
  %result.i240 = call ptr %35({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %36 = call { ptr, i160 } %result.i240({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %5)
  %.fca.0.extract6341 = extractvalue { ptr, i160 } %36, 0
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %38 = icmp ne ptr %.fca.0.extract6341, @nil_typ
  %39 = icmp ne ptr %.fca.0.extract6341, null
  %.not6942 = and i1 %38, %39
  br i1 %.not6942, label %._crit_edge.lr.ph, label %.critedge

._crit_edge.lr.ph:                                ; preds = %4
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.fca.0.extract6343 = phi ptr [ %.fca.0.extract6341, %._crit_edge.lr.ph ], [ %.fca.0.extract63, %._crit_edge ]
  %41 = phi { ptr, i160 } [ %36, %._crit_edge.lr.ph ], [ %48, %._crit_edge ]
  %42 = load ptr, ptr %29, align 8
  %result.i = call ptr %42(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #45
  store ptr %result.i, ptr %6, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %45 = load ptr, ptr %34, align 8
  store ptr %.fca.0.extract6343, ptr %7, align 8
  %result.i1 = call ptr %45({ ptr, ptr, ptr, i32 } %33, ptr nocapture nofree noundef nonnull readonly %7) #47
  %46 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull align 8 dereferenceable(8) %6, { ptr, i160 } %41)
  %47 = load ptr, ptr %27, align 8
  %result.i2 = call ptr %47({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %5) #47
  %48 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %5)
  %.fca.0.extract63 = extractvalue { ptr, i160 } %48, 0
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %50 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %51 = icmp ne ptr %.fca.0.extract63, null
  %.not69 = and i1 %50, %51
  br i1 %.not69, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  %hash_coef.i31 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i32 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i33 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i34 = mul i64 %hash_coef.i31, -83120161364696977
  %shifted.i.i35 = lshr i64 %product.i.i34, 32
  %xored.i.i36 = xor i64 %shifted.i.i35, %product.i.i34
  %hash.i.i37 = and i64 %xored.i.i36, %tbl_size.i32
  %offset_ptr.i38 = getelementptr i32, ptr %offset_tbl.i33, i64 %hash.i.i37
  %offset.i39 = load i32, ptr %offset_ptr.i38, align 4
  %52 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %offset.i39, 3
  ret { ptr, ptr, ptr, i32 } %52
}

define { ptr, i160 } @String_extend_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract28 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %3, 1
  %.sroa.4.8.extract.trunc = trunc i160 %.fca.1.extract29 to i64
  %10 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %.sroa.8.8.extract.shift = lshr i160 %.fca.1.extract29, 64
  %.sroa.8.8.extract.trunc = trunc i160 %.sroa.8.8.extract.shift to i64
  %11 = inttoptr i64 %.sroa.8.8.extract.trunc to ptr
  %hash_coef_ptr.i10 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i11 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i10, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i11, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i12, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 6499063144389013426
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %11, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i21, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #57
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract28) #57
  %18 = sext i32 %offset.i21 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract28, i64 %18
  %20 = getelementptr i8, ptr %19, i64 88
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %22 = call i32 %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract32)
  %24 = sext i32 %offset.i to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract32, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = call i32 %28(ptr %.fca.1.extract33) #43
  %30 = add i32 %29, %22
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract33, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract34, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %offset.i, 3
  %35 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract32)
  %38 = getelementptr i8, ptr %25, i64 120
  %39 = load ptr, ptr %38, align 8
  %40 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %40, align 8
  %result.i7 = call ptr %39({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly align 8 %40) #47
  call void %result.i7({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 dereferenceable(8) %35, i32 %30)
  %41 = add i32 %22, -1
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #41
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %45 = getelementptr i8, ptr %19, i64 144
  %46 = getelementptr inbounds i8, ptr %8, i64 8
  %47 = getelementptr i8, ptr %25, i64 152
  %48 = getelementptr inbounds i8, ptr %9, i64 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #41
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %51 = icmp slt i32 %41, 0
  br i1 %51, label %.critedge, label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %4
  %storemerge = phi i32 [ %63, %._crit_edge ], [ 1, %4 ]
  %.sroa.026.0.insert.ext.i63.pn.in = phi i32 [ %storemerge, %._crit_edge ], [ 0, %4 ]
  %52 = add i32 %.sroa.026.0.insert.ext.i63.pn.in, %29
  store ptr @_parameterization_i32, ptr %6, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %55 = load ptr, ptr %45, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i3 = call ptr %55({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %7) #47
  %56 = call i8 %result.i3({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 dereferenceable(8) %6, i32 %.sroa.026.0.insert.ext.i63.pn.in)
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr @_parameterization_i8, ptr %46, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %59 = load ptr, ptr %47, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr @i8_typ, ptr %48, align 8
  %result.i2 = call ptr %59({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %9) #47
  call void %result.i2({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 dereferenceable(16) %8, i32 %52, i8 %56)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #41
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %62 = icmp sgt i32 %storemerge, %41
  %63 = add i32 %storemerge, 1
  br i1 %62, label %.critedge, label %._crit_edge

.critedge:                                        ; preds = %._crit_edge, %4
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %65 = load ptr, ptr %26, align 8
  %66 = getelementptr i8, ptr %65, i64 8
  %67 = load ptr, ptr %66, align 8
  call void %67(ptr %.fca.1.extract33, i32 %30) #42
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %69 = getelementptr i8, ptr %25, i64 16
  %70 = load ptr, ptr %69, align 8
  %71 = load ptr, ptr %70, align 8
  %72 = call i32 %71(ptr %.fca.1.extract33) #43
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %75 = getelementptr i8, ptr %19, i64 240
  %76 = load ptr, ptr %75, align 8
  %result.i1 = call ptr %76({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %77 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %78 = add i32 %77, %72
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %80 = load ptr, ptr %69, align 8
  %81 = getelementptr i8, ptr %80, i64 8
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %.fca.1.extract33, i32 %78) #42
  %83 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract32, 0
  %84 = ptrtoint ptr %.fca.1.extract33 to i64
  %85 = ptrtoint ptr %.fca.2.extract34 to i64
  %.sroa.19.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.19.8.insert.shift = shl nuw i160 %.sroa.19.8.insert.ext, 128
  %.sroa.16.8.insert.ext = zext i64 %85 to i160
  %.sroa.16.8.insert.shift = shl nuw nsw i160 %.sroa.16.8.insert.ext, 64
  %.sroa.16.8.insert.insert = or disjoint i160 %.sroa.19.8.insert.shift, %.sroa.16.8.insert.shift
  %.sroa.871.8.insert.ext = zext i64 %84 to i160
  %.sroa.871.8.insert.insert = or disjoint i160 %.sroa.16.8.insert.insert, %.sroa.871.8.insert.ext
  %86 = insertvalue { ptr, i160 } %83, i160 %.sroa.871.8.insert.insert, 1
  ret { ptr, i160 } %86
}

define { ptr, i160 } @String_extend_otherCollectionCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract11 = extractvalue { ptr, i160 } %3, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract11 to i64
  %10 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.6.8.extract.shift = lshr i160 %.fca.1.extract11, 64
  %.sroa.6.8.extract.trunc = trunc i160 %.sroa.6.8.extract.shift to i64
  %11 = inttoptr i64 %.sroa.6.8.extract.trunc to ptr
  %hash_coef_ptr.i7 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i8 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i9 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i7, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i8, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i9, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 1375598993350293883
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %11, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i18, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #57
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #57
  %18 = sext i32 %offset.i18 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract10, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i6 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %hash_coef_ptr.i19 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i22 = load i64, ptr %hash_coef_ptr.i19, align 4
  %tbl_size.i23 = load i64, ptr %tbl_size_ptr.i20, align 4
  %offset_tbl.i24 = load ptr, ptr %offset_tbl_ptr.i21, align 8
  %product.i.i25 = mul i64 %hash_coef.i22, 8673632051301757104
  %shifted.i.i26 = lshr i64 %product.i.i25, 32
  %xored.i.i27 = xor i64 %shifted.i.i26, %product.i.i25
  %hash.i.i28 = and i64 %xored.i.i27, %tbl_size.i23
  %offset_ptr.i29 = getelementptr i32, ptr %offset_tbl.i24, i64 %hash.i.i28
  %offset.i30 = load i32, ptr %offset_ptr.i29, align 4
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i30, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %29 = sext i32 %offset.i30 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract, i64 %29
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i569 = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %33 = call { ptr, i160 } %result.i569({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %5)
  %.fca.0.extract8970 = extractvalue { ptr, i160 } %33, 0
  %34 = icmp ne ptr %.fca.0.extract8970, @nil_typ
  %35 = icmp ne ptr %.fca.0.extract8970, null
  %.not9771 = and i1 %34, %35
  br i1 %.not9771, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %4
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.fca.0.extract8973 = phi ptr [ %.fca.0.extract8970, %._crit_edge.lr.ph ], [ %.fca.0.extract89, %._crit_edge ]
  %37 = phi { ptr, i160 } [ %33, %._crit_edge.lr.ph ], [ %52, %._crit_edge ]
  %.072 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %50, %._crit_edge ]
  %.fca.1.extract90 = extractvalue { ptr, i160 } %37, 1
  %.sroa.794.8.extract.shift = lshr i160 %.fca.1.extract90, 64
  %.sroa.794.8.extract.trunc = trunc i160 %.sroa.794.8.extract.shift to i64
  %.sroa.493.8.extract.trunc = trunc i160 %.fca.1.extract90 to i64
  %38 = inttoptr i64 %.sroa.493.8.extract.trunc to ptr
  %39 = inttoptr i64 %.sroa.794.8.extract.trunc to ptr
  %hash_coef_ptr.i31 = getelementptr i8, ptr %.fca.0.extract8973, i64 8
  %tbl_size_ptr.i32 = getelementptr i8, ptr %.fca.0.extract8973, i64 16
  %offset_tbl_ptr.i33 = getelementptr i8, ptr %.fca.0.extract8973, i64 40
  %hash_coef.i34 = load i64, ptr %hash_coef_ptr.i31, align 4
  %tbl_size.i35 = load i64, ptr %tbl_size_ptr.i32, align 4
  %offset_tbl.i36 = load ptr, ptr %offset_tbl_ptr.i33, align 8
  %product.i.i37 = mul i64 %hash_coef.i34, 6681222582356018452
  %shifted.i.i38 = lshr i64 %product.i.i37, 32
  %xored.i.i39 = xor i64 %shifted.i.i38, %product.i.i37
  %hash.i.i40 = and i64 %xored.i.i39, %tbl_size.i35
  %offset_ptr.i41 = getelementptr i32, ptr %offset_tbl.i36, i64 %hash.i.i40
  %offset.i42 = load i32, ptr %offset_ptr.i41, align 4
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8973, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %38, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %39, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %offset.i42, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8973)
  %45 = sext i32 %offset.i42 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract8973, i64 %45
  %47 = getelementptr i8, ptr %46, i64 40
  %48 = load ptr, ptr %47, align 8
  %result.i4 = call ptr %48({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %49 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %5)
  %50 = add i32 %49, %.072
  %51 = load ptr, ptr %31, align 8
  %result.i5 = call ptr %51({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %5) #47
  %52 = call { ptr, i160 } %result.i5({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %5)
  %.fca.0.extract89 = extractvalue { ptr, i160 } %52, 0
  %53 = icmp ne ptr %.fca.0.extract89, @nil_typ
  %54 = icmp ne ptr %.fca.0.extract89, null
  %.not97 = and i1 %53, %54
  br i1 %.not97, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %.0.lcssa = phi i32 [ 0, %4 ], [ %50, %._crit_edge ]
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract14)
  %56 = sext i32 %offset.i to i64
  %57 = getelementptr ptr, ptr %.fca.0.extract14, i64 %56
  %58 = getelementptr i8, ptr %57, i64 8
  %59 = load ptr, ptr %58, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call i32 %60(ptr %.fca.1.extract15) #43
  %62 = add i32 %61, %.0.lcssa
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %.fca.1.extract15, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %.fca.2.extract16, 2
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %offset.i, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract14)
  %69 = getelementptr i8, ptr %57, i64 120
  %70 = load ptr, ptr %69, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i3 = call ptr %70({ ptr, ptr, ptr, i32 } %66, ptr nocapture nofree noundef nonnull readonly %7) #47
  call void %result.i3({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull align 8 dereferenceable(8) %6, i32 %62)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract10)
  %73 = load ptr, ptr %20, align 8
  %result.i2 = call ptr %73({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %74 = call { ptr, ptr, ptr, i32 } %result.i2({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %.fca.0.extract62 = extractvalue { ptr, ptr, ptr, i32 } %74, 0
  %.fca.1.extract63 = extractvalue { ptr, ptr, ptr, i32 } %74, 1
  %.fca.2.extract64 = extractvalue { ptr, ptr, ptr, i32 } %74, 2
  %hash_coef_ptr.i43 = getelementptr i8, ptr %.fca.0.extract62, i64 8
  %tbl_size_ptr.i44 = getelementptr i8, ptr %.fca.0.extract62, i64 16
  %offset_tbl_ptr.i45 = getelementptr i8, ptr %.fca.0.extract62, i64 40
  %hash_coef.i46 = load i64, ptr %hash_coef_ptr.i43, align 4
  %tbl_size.i47 = load i64, ptr %tbl_size_ptr.i44, align 4
  %offset_tbl.i48 = load ptr, ptr %offset_tbl_ptr.i45, align 8
  %product.i.i49 = mul i64 %hash_coef.i46, 8673632051301757104
  %shifted.i.i50 = lshr i64 %product.i.i49, 32
  %xored.i.i51 = xor i64 %shifted.i.i50, %product.i.i49
  %hash.i.i52 = and i64 %xored.i.i51, %tbl_size.i47
  %offset_ptr.i53 = getelementptr i32, ptr %offset_tbl.i48, i64 %hash.i.i52
  %offset.i54 = load i32, ptr %offset_ptr.i53, align 4
  %75 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract62, 0
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %.fca.1.extract63, 1
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.2.extract64, 2
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, i32 %offset.i54, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract62)
  %81 = sext i32 %offset.i54 to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract62, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = getelementptr i8, ptr %57, i64 184
  %85 = load ptr, ptr %83, align 8
  %result.i174 = call ptr %85({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %86 = call { ptr, i160 } %result.i174({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %5)
  %.fca.0.extract4775 = extractvalue { ptr, i160 } %86, 0
  %87 = icmp ne ptr %.fca.0.extract4775, @nil_typ
  %88 = icmp ne ptr %.fca.0.extract4775, null
  %.not9976 = and i1 %87, %88
  br i1 %.not9976, label %._crit_edge2, label %.critedge

._crit_edge2:                                     ; preds = %._crit_edge2, %._crit_edge1._crit_edge
  %.fca.0.extract4777 = phi ptr [ %.fca.0.extract47, %._crit_edge2 ], [ %.fca.0.extract4775, %._crit_edge1._crit_edge ]
  %89 = phi { ptr, i160 } [ %98, %._crit_edge2 ], [ %86, %._crit_edge1._crit_edge ]
  %.fca.1.extract48 = extractvalue { ptr, i160 } %89, 1
  %hash_coef_ptr.i55 = getelementptr i8, ptr %.fca.0.extract4777, i64 8
  %tbl_size_ptr.i56 = getelementptr i8, ptr %.fca.0.extract4777, i64 16
  %offset_tbl_ptr.i57 = getelementptr i8, ptr %.fca.0.extract4777, i64 40
  %hash_coef.i58 = load i64, ptr %hash_coef_ptr.i55, align 4
  %tbl_size.i59 = load i64, ptr %tbl_size_ptr.i56, align 4
  %offset_tbl.i60 = load ptr, ptr %offset_tbl_ptr.i57, align 8
  %product.i.i61 = mul i64 %hash_coef.i58, 6681222582356018452
  %shifted.i.i62 = lshr i64 %product.i.i61, 32
  %xored.i.i63 = xor i64 %shifted.i.i62, %product.i.i61
  %hash.i.i64 = and i64 %xored.i.i63, %tbl_size.i59
  %offset_ptr.i65 = getelementptr i32, ptr %offset_tbl.i60, i64 %hash.i.i64
  %offset.i66 = load i32, ptr %offset_ptr.i65, align 4
  %90 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract4777, 0
  %.sroa.3.0.insert.ext = zext i32 %offset.i66 to i160
  %.sroa.3.0.insert.shift = shl nuw i160 %.sroa.3.0.insert.ext, 128
  %91 = and i160 %.fca.1.extract48, 340282366920938463463374607431768211455
  %.sroa.032.0.insert.insert = or disjoint i160 %.sroa.3.0.insert.shift, %91
  %92 = insertvalue { ptr, i160 } %90, i160 %.sroa.032.0.insert.insert, 1
  store ptr @_parameterization_Character, ptr %8, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %95 = load ptr, ptr %84, align 8
  store ptr %.fca.0.extract4777, ptr %9, align 8
  %result.i = call ptr %95({ ptr, ptr, ptr, i32 } %66, ptr nocapture nofree noundef nonnull readonly %9) #47
  %96 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %92)
  %97 = load ptr, ptr %83, align 8
  %result.i1 = call ptr %97({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly %5) #47
  %98 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %5)
  %.fca.0.extract47 = extractvalue { ptr, i160 } %98, 0
  %99 = icmp ne ptr %.fca.0.extract47, @nil_typ
  %100 = icmp ne ptr %.fca.0.extract47, null
  %.not99 = and i1 %99, %100
  br i1 %.not99, label %._crit_edge2, label %.critedge

.critedge:                                        ; preds = %._crit_edge2, %._crit_edge1._crit_edge
  %101 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract14, 0
  %102 = ptrtoint ptr %.fca.1.extract15 to i64
  %103 = ptrtoint ptr %.fca.2.extract16 to i64
  %.sroa.13.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.13.8.insert.shift = shl nuw i160 %.sroa.13.8.insert.ext, 128
  %.sroa.10.8.insert.ext = zext i64 %103 to i160
  %.sroa.10.8.insert.shift = shl nuw nsw i160 %.sroa.10.8.insert.ext, 64
  %.sroa.10.8.insert.insert = or disjoint i160 %.sroa.13.8.insert.shift, %.sroa.10.8.insert.shift
  %.sroa.5.8.insert.ext = zext i64 %102 to i160
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.10.8.insert.insert, %.sroa.5.8.insert.ext
  %104 = insertvalue { ptr, i160 } %101, i160 %.sroa.5.8.insert.insert, 1
  ret { ptr, i160 } %104
}

define { ptr, i160 } @List_get_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract17, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #57
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #57
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract16, i64 %12
  %14 = getelementptr i8, ptr %13, i64 80
  %15 = load ptr, ptr %14, align 8
  %result.i5 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %16 = call i32 %result.i5({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.not = icmp slt i32 %3, %16
  br i1 %.not, label %17, label %.thread53

17:                                               ; preds = %4
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract16)
  %20 = getelementptr i8, ptr %13, i64 136
  %21 = load ptr, ptr %20, align 8
  %result.i4 = call ptr %21({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract56 = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract58 = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract60 = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %hash_coef_ptr.i6 = getelementptr i8, ptr %.fca.0.extract56, i64 8
  %tbl_size_ptr.i7 = getelementptr i8, ptr %.fca.0.extract56, i64 16
  %offset_tbl_ptr.i8 = getelementptr i8, ptr %.fca.0.extract56, i64 40
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i6, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i7, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i8, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, 1375598993350293883
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract56, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract58, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract60, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i17, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract56)
  %29 = sext i32 %offset.i17 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract56, i64 %29
  %31 = getelementptr i8, ptr %30, i64 24
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %33 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %5)
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %hash_coef_ptr.i18 = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i19 = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i20 = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i18, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i19, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i20, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 8673632051301757104
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract43, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract45, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %offset.i29, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract41)
  %40 = sext i32 %offset.i29 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract41, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  br label %43

43:                                               ; preds = %48, %17
  %44 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %44({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %45 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %5)
  %.fca.0.extract30 = extractvalue { ptr, i160 } %45, 0
  %46 = icmp ne ptr %.fca.0.extract30, @nil_typ
  %47 = icmp ne ptr %.fca.0.extract30, null
  %.not70 = and i1 %46, %47
  br i1 %.not70, label %48, label %.thread53

48:                                               ; preds = %43
  %.fca.1.extract31 = extractvalue { ptr, i160 } %45, 1
  %.sroa.382.8.extract.shift = lshr i160 %.fca.1.extract31, 64
  %.sroa.382.8.extract.trunc = trunc i160 %.sroa.382.8.extract.shift to i64
  %.sroa.081.8.extract.trunc = trunc i160 %.fca.1.extract31 to i64
  %49 = inttoptr i64 %.sroa.081.8.extract.trunc to ptr
  %50 = inttoptr i64 %.sroa.382.8.extract.trunc to ptr
  %hash_coef_ptr.i30 = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i31 = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i32 = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i33 = load i64, ptr %hash_coef_ptr.i30, align 4
  %tbl_size.i34 = load i64, ptr %tbl_size_ptr.i31, align 4
  %offset_tbl.i35 = load ptr, ptr %offset_tbl_ptr.i32, align 8
  %product.i.i36 = mul i64 %hash_coef.i33, 9197944775169318296
  %shifted.i.i37 = lshr i64 %product.i.i36, 32
  %xored.i.i38 = xor i64 %shifted.i.i37, %product.i.i36
  %hash.i.i39 = and i64 %xored.i.i38, %tbl_size.i34
  %offset_ptr.i40 = getelementptr i32, ptr %offset_tbl.i35, i64 %hash.i.i39
  %offset.i41 = load i32, ptr %offset_ptr.i40, align 4
  %51 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract30, 0
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %49, 1
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %50, 2
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, i32 %offset.i41, 3
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract30)
  %57 = sext i32 %offset.i41 to i64
  %58 = getelementptr ptr, ptr %.fca.0.extract30, i64 %57
  %59 = getelementptr i8, ptr %58, i64 40
  %60 = load ptr, ptr %59, align 8
  %result.i1 = call ptr %60({ ptr, ptr, ptr, i32 } %54, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %61 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull align 8 %5)
  %.fca.1.extract27 = extractvalue { ptr, i160 } %61, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract27 to i32
  %.not59 = icmp eq i32 %3, %.sroa.1.8.extract.trunc
  br i1 %.not59, label %62, label %43

62:                                               ; preds = %48
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract30)
  %65 = getelementptr i8, ptr %58, i64 48
  %66 = load ptr, ptr %65, align 8
  %result.i = call ptr %66({ ptr, ptr, ptr, i32 } %54, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %67 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull align 8 %5)
  %.fca.0.extract20 = extractvalue { ptr, i160 } %67, 0
  %.fca.1.extract21 = extractvalue { ptr, i160 } %67, 1
  br label %.thread53

.thread53:                                        ; preds = %62, %43, %4
  %.reg2mem36.sroa.0.0 = phi ptr [ @nil_typ, %4 ], [ %.fca.0.extract20, %62 ], [ poison, %43 ]
  %.reg2mem36.sroa.3.0 = phi i160 [ undef, %4 ], [ %.fca.1.extract21, %62 ], [ undef, %43 ]
  %.reload37.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem36.sroa.0.0, 0
  %.reload37.fca.1.insert = insertvalue { ptr, i160 } %.reload37.fca.0.insert, i160 %.reg2mem36.sroa.3.0, 1
  ret { ptr, i160 } %.reload37.fca.1.insert
}

define { ptr, i32 } @List_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #18 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract20, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #57
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract19) #57
  %13 = sext i32 %offset.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract19, i64 %13
  %15 = getelementptr i8, ptr %14, i64 88
  %16 = load ptr, ptr %15, align 8
  %result.i5 = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %17 = call i1 %result.i5({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6)
  br i1 %17, label %.thread53, label %18

18:                                               ; preds = %5
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract19)
  %21 = getelementptr i8, ptr %14, i64 136
  %22 = load ptr, ptr %21, align 8
  %result.i4 = call ptr %22({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %23 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6)
  %.fca.0.extract67 = extractvalue { ptr, ptr, ptr, i32 } %23, 0
  %.fca.1.extract69 = extractvalue { ptr, ptr, ptr, i32 } %23, 1
  %.fca.2.extract71 = extractvalue { ptr, ptr, ptr, i32 } %23, 2
  %hash_coef_ptr.i6 = getelementptr i8, ptr %.fca.0.extract67, i64 8
  %tbl_size_ptr.i7 = getelementptr i8, ptr %.fca.0.extract67, i64 16
  %offset_tbl_ptr.i8 = getelementptr i8, ptr %.fca.0.extract67, i64 40
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i6, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i7, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i8, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, 1375598993350293883
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract67, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract69, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract71, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %offset.i17, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %30 = sext i32 %offset.i17 to i64
  %31 = getelementptr ptr, ptr %.fca.0.extract67, i64 %30
  %32 = getelementptr i8, ptr %31, i64 24
  %33 = load ptr, ptr %32, align 8
  %result.i3 = call ptr %33({ ptr, ptr, ptr, i32 } %27, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %34 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %6)
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract54 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract56 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %hash_coef_ptr.i18 = getelementptr i8, ptr %.fca.0.extract52, i64 8
  %tbl_size_ptr.i19 = getelementptr i8, ptr %.fca.0.extract52, i64 16
  %offset_tbl_ptr.i20 = getelementptr i8, ptr %.fca.0.extract52, i64 40
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i18, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i19, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i20, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 8673632051301757104
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract52, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract54, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract56, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %offset.i29, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract52)
  %41 = sext i32 %offset.i29 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract52, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  br label %44

44:                                               ; preds = %49, %18
  %45 = load ptr, ptr %43, align 8
  %result.i2 = call ptr %45({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %46 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %6)
  %.fca.0.extract41 = extractvalue { ptr, i160 } %46, 0
  %47 = icmp ne ptr %.fca.0.extract41, @nil_typ
  %48 = icmp ne ptr %.fca.0.extract41, null
  %.not84 = and i1 %47, %48
  br i1 %.not84, label %49, label %.thread53

49:                                               ; preds = %44
  %.fca.1.extract42 = extractvalue { ptr, i160 } %46, 1
  %.sroa.396.8.extract.shift = lshr i160 %.fca.1.extract42, 64
  %.sroa.396.8.extract.trunc = trunc i160 %.sroa.396.8.extract.shift to i64
  %.sroa.095.8.extract.trunc = trunc i160 %.fca.1.extract42 to i64
  %50 = inttoptr i64 %.sroa.095.8.extract.trunc to ptr
  %51 = inttoptr i64 %.sroa.396.8.extract.trunc to ptr
  %hash_coef_ptr.i30 = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i31 = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i32 = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i33 = load i64, ptr %hash_coef_ptr.i30, align 4
  %tbl_size.i34 = load i64, ptr %tbl_size_ptr.i31, align 4
  %offset_tbl.i35 = load ptr, ptr %offset_tbl_ptr.i32, align 8
  %product.i.i36 = mul i64 %hash_coef.i33, 9197944775169318296
  %shifted.i.i37 = lshr i64 %product.i.i36, 32
  %xored.i.i38 = xor i64 %shifted.i.i37, %product.i.i36
  %hash.i.i39 = and i64 %xored.i.i38, %tbl_size.i34
  %offset_ptr.i40 = getelementptr i32, ptr %offset_tbl.i35, i64 %hash.i.i39
  %offset.i41 = load i32, ptr %offset_ptr.i40, align 4
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %50, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %51, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %offset.i41, 3
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract41)
  %58 = sext i32 %offset.i41 to i64
  %59 = getelementptr ptr, ptr %.fca.0.extract41, i64 %58
  %60 = getelementptr i8, ptr %59, i64 48
  %61 = load ptr, ptr %60, align 8
  %result.i1 = call ptr %61({ ptr, ptr, ptr, i32 } %55, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %62 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull align 8 %6)
  %63 = call i1 %.fca.0.extract({ ptr, i160 } %62, { ptr, i160 } %3)
  br i1 %63, label %64, label %44

64:                                               ; preds = %49
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract41)
  %67 = getelementptr i8, ptr %59, i64 40
  %68 = load ptr, ptr %67, align 8
  %result.i = call ptr %68({ ptr, ptr, ptr, i32 } %55, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %69 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull align 8 %6)
  %.fca.1.extract27 = extractvalue { ptr, i160 } %69, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract27 to i32
  br label %.thread53

.thread53:                                        ; preds = %64, %44, %5
  %.reg2mem46.sroa.3.0 = phi i32 [ poison, %5 ], [ %.sroa.1.8.extract.trunc, %64 ], [ poison, %44 ]
  %.reg2mem44.0 = phi ptr [ @nil_typ, %5 ], [ @i32_typ, %64 ], [ @nil_typ, %44 ]
  %.reload43.fca.0.insert = insertvalue { ptr, i32 } poison, ptr %.reg2mem44.0, 0
  %.reload43.fca.1.insert = insertvalue { ptr, i32 } %.reload43.fca.0.insert, i32 %.reg2mem46.sroa.3.0, 1
  ret { ptr, i32 } %.reload43.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

define i1 @Collection_is_empty_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract, i64 %11
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %15 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %16 = icmp eq i32 %15, 0
  ret i1 %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #35 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %result.i2 = call noalias align 8 dereferenceable_or_null(40) ptr @bump_malloc_wrapper(i64 noundef 40) #49
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  store ptr %.fca.0.extract, ptr %result.i2, align 8
  %6 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %result.i2, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %result.i2, i64 24
  store i32 %offset.i, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 16 dereferenceable(208) @StringIterator) #44
  %10 = getelementptr i8, ptr %result.i2, i64 32
  store i32 0, ptr %10, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 23, 3
  ret { ptr, ptr, ptr, i32 } %11
}

define void @Iterable_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract19, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract20, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #57
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #57
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract18, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %result.i14 = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %27 = call { ptr, i160 } %result.i14({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract3315 = extractvalue { ptr, i160 } %27, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %29 = icmp ne ptr %.fca.0.extract3315, @nil_typ
  %30 = icmp ne ptr %.fca.0.extract3315, null
  %.not3916 = and i1 %29, %30
  br i1 %.not3916, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge, %4
  %31 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %27, %4 ]
  call void %.fca.0.extract8({ ptr, i160 } %31)
  %32 = load ptr, ptr %25, align 8
  %result.i = call ptr %32({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #47
  %33 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract33 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %35 = icmp ne ptr %.fca.0.extract33, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract33, null
  %.not39 = and i1 %35, %36
  br i1 %.not39, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  ret void
}

define { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #18 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract27, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract28, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #57
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract26) #57
  %13 = sext i32 %offset.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract26, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i1 = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %17 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i13, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %24 = sext i32 %offset.i13 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i19 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %28 = call { ptr, i160 } %result.i19({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6)
  %.fca.0.extract5120 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract26)
  %30 = icmp ne ptr %.fca.0.extract5120, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract5120, null
  %.not5921 = and i1 %30, %31
  br i1 %.not5921, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %5
  %32 = phi { ptr, i160 } [ %35, %._crit_edge ], [ %28, %5 ]
  %.pn22 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %3, %5 ]
  %33 = call { ptr, i160 } %.fca.0.extract8({ ptr, i160 } %.pn22, { ptr, i160 } %32)
  %34 = load ptr, ptr %26, align 8
  %result.i = call ptr %34({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #47
  %35 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6)
  %.fca.0.extract51 = extractvalue { ptr, i160 } %35, 0
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract26)
  %37 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %38 = icmp ne ptr %.fca.0.extract51, null
  %.not59 = and i1 %37, %38
  br i1 %.not59, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %5
  %.pn.lcssa = phi { ptr, i160 } [ %3, %5 ], [ %33, %._crit_edge ]
  ret { ptr, i160 } %.pn.lcssa
}

define noundef i1 @Iterable_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract19, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract20, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #57
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #57
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract18, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract36 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %30 = icmp eq ptr %.fca.0.extract36, @nil_typ
  %31 = icmp eq ptr %.fca.0.extract36, null
  %.not39.not = or i1 %30, %31
  br i1 %.not39.not, label %.critedge, label %32

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract8({ ptr, i160 } %28)
  br i1 %33, label %26, label %.critedge

.critedge:                                        ; preds = %32, %26
  ret i1 %.not39.not
}

define noundef i1 @Iterable_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract19, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract20, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #57
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #57
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract18, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract34 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %30 = icmp ne ptr %.fca.0.extract34, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract34, null
  %.not37 = and i1 %30, %31
  br i1 %.not37, label %32, label %.critedge

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract8({ ptr, i160 } %28)
  br i1 %33, label %.critedge, label %26

.critedge:                                        ; preds = %32, %26
  ret i1 %.not37
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %result.i6 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %9 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i1, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i6, i64 24
  store ptr null, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i6) #41
  store ptr @Pair, ptr %result.i6, align 8
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i1, ptr %result.i5, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i6, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #41
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 1375598993350293883
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @EnumeratedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @EnumeratedCollection) #41
  %19 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 %offset.i18, ptr %22, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 107, 3
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, { ptr } %3) #36 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store ptr %result.i2, ptr %result.i7, align 8
  %12 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %11, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract32, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef nonnull align 16 dereferenceable(520) @MapIterable) #41
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 40, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, { ptr } %3) #36 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store ptr %result.i2, ptr %result.i7, align 8
  %12 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %11, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 1375598993350293883
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MappedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract32, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1064) @MappedCollection) #41
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 108, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #36 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %result.i7 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #41
  %14 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract32, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @FilterIterable) #41
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %19, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %20
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #45
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #49
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @ChainIterable) #41
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 3037712219555723519
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @ChainIterable) #41
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #45
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #49
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 1375598993350293883
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @ChainedCollection) #41
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 1375598993350293883
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @ChainedCollection) #41
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 107, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #45
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #49
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 1375598993350293883
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleavedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection) #41
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 1375598993350293883
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection) #41
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 107, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #45
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #49
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @InterleaveIterable) #41
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 3037712219555723519
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @InterleaveIterable) #41
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #45
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #45
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #41
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #49
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #41
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 3037712219555723519
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ZipIterable) #41
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 3037712219555723519
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ZipIterable) #41
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 41, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #45
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #45
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #41
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #49
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #41
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 1375598993350293883
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZippedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ZippedCollection) #41
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 1375598993350293883
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ZippedCollection) #41
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 109, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #45
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #45
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #41
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #49
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #41
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 3037712219555723519
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ProductIterable) #41
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 3037712219555723519
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ProductIterable) #41
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 41, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #45
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #45
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #41
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #49
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #41
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 1375598993350293883
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #41
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #41
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ProductCollection) #41
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 1375598993350293883
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ProductCollection) #41
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 109, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i, 3
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Container(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 29, i64 30
  %8 = getelementptr [124 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 34, i64 35
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 39, i64 38
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -310975631771072937
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define i32 @ProductCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -310975631771072937
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract19) #43
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract3) #44
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract17)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract19) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = mul i32 %38, %22
  ret i32 %39
}

define { ptr, ptr, ptr, i32 } @ProductCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract103 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -310975631771072937
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract103, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract105) #43
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract66, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract68, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract70, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64) #44
  %18 = sext i32 %.fca.3.extract70 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract64, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract105) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %29 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i2 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %result.i11 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %35 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %result.i2, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr null, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i11)
  store ptr @Pair, ptr %result.i11, align 8
  %result.i10 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_wrapper(i64 noundef 152) #49
  store ptr %result.i3, ptr %result.i10, align 8
  %39 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %result.i11, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(152) %result.i10)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract105) #43
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract29, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract31, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract33, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract27)
  %52 = sext i32 %.fca.3.extract33 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract27, i64 %52
  %54 = getelementptr i8, ptr %53, i64 24
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract105) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr undef, 2
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #41
  %69 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.0.extract19, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.1.extract21, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store ptr %.fca.2.extract23, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %result.i10, i64 48
  store i32 %offset.i23, ptr %72, align 8
  %hash_coef.i17.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i18.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i19.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i20.i = mul i64 %hash_coef.i17.i, 3037712219555723519
  %shifted.i.i21.i = lshr i64 %product.i.i20.i, 32
  %xored.i.i22.i = xor i64 %shifted.i.i21.i, %product.i.i20.i
  %hash.i.i23.i = and i64 %xored.i.i22.i, %tbl_size.i18.i
  %offset_ptr.i24.i = getelementptr i32, ptr %offset_tbl.i19.i, i64 %hash.i.i23.i
  %offset.i25.i = load i32, ptr %offset_ptr.i24.i, align 4
  %73 = getelementptr inbounds i8, ptr %result.i10, i64 88
  store ptr %.fca.0.extract, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %result.i10, i64 96
  store ptr %.fca.1.extract, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %result.i10, i64 104
  store ptr %.fca.2.extract, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i10, i64 112
  store i32 %offset.i25.i, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #44
  %78 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %offset.i25.i, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %81 = sext i32 %offset.i25.i to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  %result.i1.i = call ptr %84({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %85 = call { ptr, ptr, ptr, i32 } %result.i1.i({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %4)
  %.fca.0.extract11.i = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract13.i = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract15.i = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %hash_coef_ptr.i26.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 8
  %tbl_size_ptr.i27.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 16
  %offset_tbl_ptr.i28.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 40
  %hash_coef.i29.i = load i64, ptr %hash_coef_ptr.i26.i, align 4
  %tbl_size.i30.i = load i64, ptr %tbl_size_ptr.i27.i, align 4
  %offset_tbl.i31.i = load ptr, ptr %offset_tbl_ptr.i28.i, align 8
  %product.i.i32.i = mul i64 %hash_coef.i29.i, 8673632051301757104
  %shifted.i.i33.i = lshr i64 %product.i.i32.i, 32
  %xored.i.i34.i = xor i64 %shifted.i.i33.i, %product.i.i32.i
  %hash.i.i35.i = and i64 %xored.i.i34.i, %tbl_size.i30.i
  %offset_ptr.i36.i = getelementptr i32, ptr %offset_tbl.i31.i, i64 %hash.i.i35.i
  %offset.i37.i = load i32, ptr %offset_ptr.i36.i, align 4
  %86 = getelementptr inbounds i8, ptr %result.i10, i64 56
  store ptr %.fca.0.extract11.i, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i10, i64 64
  store ptr %.fca.1.extract13.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i10, i64 72
  store ptr %.fca.2.extract15.i, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i10, i64 80
  store i32 %offset.i37.i, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %91 = load ptr, ptr %69, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %70, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %71, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %72, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %result.i.i = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %105 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %4)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %107 = getelementptr inbounds i8, ptr %result.i10, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %105, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %105, 1
  store ptr %.fca.0.extract.i, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %result.i10, i64 128
  store i160 %.fca.1.extract.i, ptr %108, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %109 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %109
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #18 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract92 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract94 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract92, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract92, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract92, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1697250377212095568
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract61 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract63 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract65 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract61, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract61, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract61, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract92, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract61, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract63, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract65, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i13, 3
  call void %13(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %17) #42
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract39, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract39, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract39, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 3037712219555723519
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92) #44
  %19 = getelementptr i8, ptr %9, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract41, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract43, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i25, 3
  call void %22(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %26) #42
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92) #44
  %28 = load ptr, ptr %19, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr, ptr, ptr, i32 } %29(ptr %.fca.1.extract94) #43
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %30, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %30, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %30, 2
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %30, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract23, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract25, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %.fca.3.extract27, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #44
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract21) #44
  %37 = sext i32 %.fca.3.extract27 to i64
  %38 = getelementptr ptr, ptr %.fca.0.extract21, i64 %37
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %result.i1 = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %41 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %6)
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i29 = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i30 = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i31 = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i32 = mul i64 %hash_coef.i29, 8673632051301757104
  %shifted.i.i33 = lshr i64 %product.i.i32, 32
  %xored.i.i34 = xor i64 %shifted.i.i33, %product.i.i32
  %hash.i.i35 = and i64 %xored.i.i34, %tbl_size.i30
  %offset_ptr.i36 = getelementptr i32, ptr %offset_tbl.i31, i64 %hash.i.i35
  %offset.i37 = load i32, ptr %offset_ptr.i36, align 4
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92)
  %43 = getelementptr i8, ptr %9, i64 32
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract13, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract15, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i37, 3
  call void %46(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %50) #42
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92)
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract94) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.1.extract2, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.2.extract, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %.fca.3.extract, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %61 = sext i32 %.fca.3.extract to i64
  %62 = getelementptr ptr, ptr %.fca.0.extract1, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %result.i = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  %65 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %6)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92)
  %67 = getelementptr i8, ptr %9, i64 48
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %.fca.1.extract94, { ptr, i160 } %65) #42
  ret void
}

define { ptr, i160 } @ProductIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1697250377212095568
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract47) #57
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract47, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract48) #43
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract47)
  %13 = getelementptr i8, ptr %7, i64 32
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = getelementptr i8, ptr %7, i64 24
  %16 = getelementptr i8, ptr %7, i64 40
  %.056 = extractvalue { ptr, i160 } %11, 0
  %17 = icmp ne ptr %.056, @nil_typ
  %18 = icmp ne ptr %.056, null
  %.not13257 = and i1 %17, %18
  br i1 %.not13257, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  br label %20

20:                                               ; preds = %39, %.lr.ph
  %.pn58 = phi { ptr, i160 } [ %11, %.lr.ph ], [ %84, %39 ]
  %21 = load ptr, ptr %13, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call { ptr, ptr, ptr, i32 } %22(ptr %.fca.1.extract48) #43
  %.fca.0.extract113 = extractvalue { ptr, ptr, ptr, i32 } %23, 0
  %.fca.1.extract115 = extractvalue { ptr, ptr, ptr, i32 } %23, 1
  %.fca.2.extract117 = extractvalue { ptr, ptr, ptr, i32 } %23, 2
  %.fca.3.extract119 = extractvalue { ptr, ptr, ptr, i32 } %23, 3
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract113, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract115, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract117, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %.fca.3.extract119, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract113)
  %30 = sext i32 %.fca.3.extract119 to i64
  %31 = getelementptr ptr, ptr %.fca.0.extract113, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %result.i8 = call ptr %33({ ptr, ptr, ptr, i32 } %27, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %34 = call { ptr, i160 } %result.i8({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4)
  %.fca.0.extract106 = extractvalue { ptr, i160 } %34, 0
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %36 = icmp eq ptr %.fca.0.extract106, @nil_typ
  %37 = icmp eq ptr %.fca.0.extract106, null
  %.not134.not = or i1 %36, %37
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  br i1 %.not134.not, label %39, label %87

39:                                               ; preds = %20
  %40 = load ptr, ptr %15, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract48) #43
  %.fca.0.extract87 = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract89 = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract91 = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract93 = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract87, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract89, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract91, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract93, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract87)
  %49 = sext i32 %.fca.3.extract93 to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract87, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i7 = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %53 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %55 = load ptr, ptr %8, align 8
  %56 = getelementptr i8, ptr %55, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %.fca.1.extract48, { ptr, i160 } %53) #42
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %59 = load ptr, ptr %16, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %.fca.1.extract48) #43
  %.fca.0.extract77 = extractvalue { ptr, ptr, ptr, i32 } %61, 0
  %.fca.1.extract78 = extractvalue { ptr, ptr, ptr, i32 } %61, 1
  %.fca.2.extract79 = extractvalue { ptr, ptr, ptr, i32 } %61, 2
  %.fca.3.extract80 = extractvalue { ptr, ptr, ptr, i32 } %61, 3
  %62 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract77, 0
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.1.extract78, 1
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %.fca.2.extract79, 2
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 %.fca.3.extract80, 3
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract77)
  %68 = sext i32 %.fca.3.extract80 to i64
  %69 = getelementptr ptr, ptr %.fca.0.extract77, i64 %68
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  %result.i6 = call ptr %71({ ptr, ptr, ptr, i32 } %65, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %72 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } %65, ptr nonnull align 8 %4)
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %72, 0
  %.fca.1.extract70 = extractvalue { ptr, ptr, ptr, i32 } %72, 1
  %.fca.2.extract71 = extractvalue { ptr, ptr, ptr, i32 } %72, 2
  %hash_coef_ptr.i10 = getelementptr i8, ptr %.fca.0.extract69, i64 8
  %tbl_size_ptr.i11 = getelementptr i8, ptr %.fca.0.extract69, i64 16
  %offset_tbl_ptr.i12 = getelementptr i8, ptr %.fca.0.extract69, i64 40
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i10, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i11, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i12, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 8673632051301757104
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %74 = load ptr, ptr %13, align 8
  %75 = getelementptr i8, ptr %74, i64 8
  %76 = load ptr, ptr %75, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.fca.1.extract70, 1
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %.fca.2.extract71, 2
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 %offset.i21, 3
  call void %76(ptr %.fca.1.extract48, { ptr, ptr, ptr, i32 } %80) #42
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %82 = load ptr, ptr %8, align 8
  %83 = load ptr, ptr %82, align 8
  %84 = call { ptr, i160 } %83(ptr %.fca.1.extract48) #43
  %.0 = extractvalue { ptr, i160 } %84, 0
  %85 = icmp ne ptr %.0, @nil_typ
  %86 = icmp ne ptr %.0, null
  %.not132 = and i1 %85, %86
  br i1 %.not132, label %20, label %.loopexit

87:                                               ; preds = %20
  %88 = load ptr, ptr %7, align 8
  %result.i3 = call align 8 ptr %88(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #45
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %90 = load ptr, ptr %14, align 8
  %result.i2 = call align 8 ptr %90(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #45
  %91 = load ptr, ptr %result.i3, align 8, !alias.scope !1
  %92 = getelementptr i8, ptr %91, i64 72
  %93 = load ptr, ptr %92, align 8, !alias.scope !1
  %result.i1.i = call { i64, i64 } %93(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45, !alias.scope !1
  %94 = extractvalue { i64, i64 } %result.i1.i, 0
  %95 = extractvalue { i64, i64 } %result.i1.i, 1
  %96 = urem i64 16, %95
  %97 = icmp eq i64 %96, 0
  %98 = sub i64 %95, %96
  %99 = select i1 %97, i64 0, i64 %98
  %100 = add i64 %94, 16
  %101 = add i64 %100, %99
  %102 = load ptr, ptr %result.i2, align 8, !alias.scope !1
  %103 = getelementptr i8, ptr %102, i64 72
  %104 = load ptr, ptr %103, align 8, !alias.scope !1
  %result.i.i = call { i64, i64 } %104(ptr nocapture nofree nonnull readonly align 8 %result.i2) #45, !alias.scope !1
  %105 = extractvalue { i64, i64 } %result.i.i, 0
  %106 = extractvalue { i64, i64 } %result.i.i, 1
  %107 = call i64 @llvm.umax.i64(i64 %95, i64 %106) #60
  %108 = call i64 @llvm.umax.i64(i64 %107, i64 noundef 8) #60, !range !4
  %109 = urem i64 %101, %106
  %110 = icmp eq i64 %109, 0
  %111 = sub i64 %106, %109
  %112 = select i1 %110, i64 0, i64 %111
  %113 = add i64 %105, %101
  %114 = add i64 %113, %112
  %115 = urem i64 %114, %108
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %108, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = add i64 %118, %114
  %result.i9 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %119) #49
  store ptr %result.i3, ptr %result.i9, align 8
  %120 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i2, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i9)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %124 = load ptr, ptr %result.i3, align 8
  %125 = getelementptr i8, ptr %124, i64 72
  %126 = load ptr, ptr %125, align 8
  %result.i.i69 = call { i64, i64 } %126(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45
  %127 = extractvalue { i64, i64 } %result.i.i69, 1
  %128 = urem i64 16, %127
  %129 = icmp eq i64 %128, 0
  %reass.sub86 = sub i64 %127, %128
  %130 = add i64 %reass.sub86, 16
  %131 = select i1 %129, i64 16, i64 %130
  %132 = getelementptr i8, ptr %result.i9, i64 %131
  %133 = getelementptr i8, ptr %124, i64 64
  %134 = load ptr, ptr %133, align 8
  call void %134({ ptr, i160 } %.pn58, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %132) #46
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #44
  %136 = load ptr, ptr %result.i9, align 8
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr i8, ptr %137, i64 72
  %139 = load ptr, ptr %138, align 8
  %result.i1.i70 = call { i64, i64 } %139(ptr nocapture nofree nonnull readonly align 8 %136) #45
  %140 = extractvalue { i64, i64 } %result.i1.i70, 0
  %141 = extractvalue { i64, i64 } %result.i1.i70, 1
  %142 = urem i64 16, %141
  %143 = icmp eq i64 %142, 0
  %144 = sub i64 %141, %142
  %145 = select i1 %143, i64 0, i64 %144
  %146 = add i64 %140, 16
  %147 = add i64 %146, %145
  %148 = load ptr, ptr %120, align 8
  %149 = load ptr, ptr %148, align 8
  %150 = getelementptr i8, ptr %149, i64 72
  %151 = load ptr, ptr %150, align 8
  %result.i.i71 = call { i64, i64 } %151(ptr nocapture nofree nonnull readonly align 8 %148) #45
  %152 = extractvalue { i64, i64 } %result.i.i71, 1
  %153 = urem i64 %147, %152
  %154 = icmp eq i64 %153, 0
  %155 = sub i64 %152, %153
  %156 = select i1 %154, i64 0, i64 %155
  %157 = getelementptr i8, ptr %result.i9, i64 %147
  %158 = getelementptr i8, ptr %157, i64 %156
  %159 = getelementptr i8, ptr %149, i64 64
  %160 = load ptr, ptr %159, align 8
  call void %160({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly align 8 %148, ptr nocapture nofree writeonly %158) #46
  %161 = ptrtoint ptr %result.i9 to i64
  %.sroa.3.8.insert.ext = zext i64 %161 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.loopexit

.loopexit:                                        ; preds = %87, %39, %3
  %.reg2mem12.sroa.0.0 = phi ptr [ @Pair, %87 ], [ @nil_typ, %3 ], [ @nil_typ, %39 ]
  %.reg2mem12.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %87 ], [ undef, %3 ], [ undef, %39 ]
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem12.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.reg2mem12.sroa.3.0, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #37 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #45
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #45
  %20 = extractvalue { i64, i64 } %result.i, 0
  %21 = extractvalue { i64, i64 } %result.i, 1
  %22 = call i64 @llvm.umax.i64(i64 %8, i64 %21) #60
  %23 = call i64 @llvm.umax.i64(i64 %22, i64 noundef 8) #60, !range !4
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %33, %29
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readnone %0, ptr nocapture nofree readnone %1) #1 {
  ret { ptr, i160 } { ptr @nil_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nil_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree readnone %2) #1 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator_getter_current_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 8
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_current_first(ptr nocapture nofree writeonly align 8 %0, { ptr, i160 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_first_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_first_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_function_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_function_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract19, { ptr, i160 } %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #44
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract19, { ptr, i160 } %4) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_second(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i1 = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #45
  %6 = extractvalue { i64, i64 } %result.i1, 0
  %7 = extractvalue { i64, i64 } %result.i1, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 16
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %15) #45
  %19 = extractvalue { i64, i64 } %result.i, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly align 8 %15) #45
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_second(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #45
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #45
  %20 = extractvalue { i64, i64 } %result.i, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %16, ptr nocapture nofree writeonly %26) #46
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_first(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #45
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 16, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 16
  %10 = select i1 %8, i64 16, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly align 8 %2) #45
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_first(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #45
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %3, ptr nocapture nofree writeonly %12) #46
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Collection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4128338911757318636
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @ProductIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract103 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4128338911757318636
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract103, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract105) #43
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract66, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract68, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract70, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64) #44
  %18 = sext i32 %.fca.3.extract70 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract64, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract105) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %29 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i2 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %result.i11 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %35 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %result.i2, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr null, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i11)
  store ptr @Pair, ptr %result.i11, align 8
  %result.i10 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_wrapper(i64 noundef 152) #49
  store ptr %result.i3, ptr %result.i10, align 8
  %39 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %result.i11, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(152) %result.i10)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract105) #43
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract29, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract31, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract33, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract27)
  %52 = sext i32 %.fca.3.extract33 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract27, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract105) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr undef, 2
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #41
  %69 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.0.extract19, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.1.extract21, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store ptr %.fca.2.extract23, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %result.i10, i64 48
  store i32 %offset.i23, ptr %72, align 8
  %hash_coef.i17.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i18.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i19.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i20.i = mul i64 %hash_coef.i17.i, 3037712219555723519
  %shifted.i.i21.i = lshr i64 %product.i.i20.i, 32
  %xored.i.i22.i = xor i64 %shifted.i.i21.i, %product.i.i20.i
  %hash.i.i23.i = and i64 %xored.i.i22.i, %tbl_size.i18.i
  %offset_ptr.i24.i = getelementptr i32, ptr %offset_tbl.i19.i, i64 %hash.i.i23.i
  %offset.i25.i = load i32, ptr %offset_ptr.i24.i, align 4
  %73 = getelementptr inbounds i8, ptr %result.i10, i64 88
  store ptr %.fca.0.extract, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %result.i10, i64 96
  store ptr %.fca.1.extract, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %result.i10, i64 104
  store ptr %.fca.2.extract, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i10, i64 112
  store i32 %offset.i25.i, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #44
  %78 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %offset.i25.i, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %81 = sext i32 %offset.i25.i to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  %result.i1.i = call ptr %84({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %85 = call { ptr, ptr, ptr, i32 } %result.i1.i({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %4)
  %.fca.0.extract11.i = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract13.i = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract15.i = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %hash_coef_ptr.i26.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 8
  %tbl_size_ptr.i27.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 16
  %offset_tbl_ptr.i28.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 40
  %hash_coef.i29.i = load i64, ptr %hash_coef_ptr.i26.i, align 4
  %tbl_size.i30.i = load i64, ptr %tbl_size_ptr.i27.i, align 4
  %offset_tbl.i31.i = load ptr, ptr %offset_tbl_ptr.i28.i, align 8
  %product.i.i32.i = mul i64 %hash_coef.i29.i, 8673632051301757104
  %shifted.i.i33.i = lshr i64 %product.i.i32.i, 32
  %xored.i.i34.i = xor i64 %shifted.i.i33.i, %product.i.i32.i
  %hash.i.i35.i = and i64 %xored.i.i34.i, %tbl_size.i30.i
  %offset_ptr.i36.i = getelementptr i32, ptr %offset_tbl.i31.i, i64 %hash.i.i35.i
  %offset.i37.i = load i32, ptr %offset_ptr.i36.i, align 4
  %86 = getelementptr inbounds i8, ptr %result.i10, i64 56
  store ptr %.fca.0.extract11.i, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i10, i64 64
  store ptr %.fca.1.extract13.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i10, i64 72
  store ptr %.fca.2.extract15.i, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i10, i64 80
  store i32 %offset.i37.i, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %91 = load ptr, ptr %69, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %70, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %71, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %72, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %result.i.i = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %105 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %4)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %107 = getelementptr inbounds i8, ptr %result.i10, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %105, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %105, 1
  store ptr %.fca.0.extract.i, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %result.i10, i64 128
  store i160 %.fca.1.extract.i, ptr %108, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %109 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %109
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %result.i6 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %9 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i1, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i6, i64 24
  store ptr null, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i6) #41
  store ptr @Pair, ptr %result.i6, align 8
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i1, ptr %result.i5, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i6, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #41
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 3037712219555723519
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumeration, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Enumeration) #41
  %19 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 %offset.i18, ptr %22, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumeration(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Enumeration_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -2805197119131967777
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @Enumeration_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -2805197119131967777
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract63, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract65) #43
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract39) #44
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i5 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %24 = load ptr, ptr %7, align 8
  %result.i1 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #45
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %result.i8 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %26 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i1, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr null, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i8)
  store ptr @Pair, ptr %result.i8, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store ptr %result.i1, ptr %result.i7, align 8
  %30 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i8, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %33 = load ptr, ptr %8, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr nonnull %.fca.1.extract65) #43
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract15, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract16, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %.fca.3.extract17, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract14)
  %42 = sext i32 %.fca.3.extract17 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract14, i64 %42
  %44 = getelementptr i8, ptr %43, i64 8
  %45 = load ptr, ptr %44, align 8
  %result.i4 = call ptr %45({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %46 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 2
  %hash_coef_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i12 = load i64, ptr %hash_coef_ptr.i9, align 4
  %tbl_size.i13 = load i64, ptr %tbl_size_ptr.i10, align 4
  %offset_tbl.i14 = load ptr, ptr %offset_tbl_ptr.i11, align 8
  %product.i.i15 = mul i64 %hash_coef.i12, 8673632051301757104
  %shifted.i.i16 = lshr i64 %product.i.i15, 32
  %xored.i.i17 = xor i64 %shifted.i.i16, %product.i.i15
  %hash.i.i18 = and i64 %xored.i.i17, %tbl_size.i13
  %offset_ptr.i19 = getelementptr i32, ptr %offset_tbl.i14, i64 %hash.i.i18
  %offset.i20 = load i32, ptr %offset_ptr.i19, align 4
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %50 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i20, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator) #44
  %55 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store i32 0, ptr %55, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %56
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumerator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Enumerator_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -3435222131909153872
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #44
  %17 = getelementptr i8, ptr %7, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract18, i32 0) #42
  ret void
}

define { ptr, i160 } @Enumerator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -3435222131909153872
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract33) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract33, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract35) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i4 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, i160 } %result.i4({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract33)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not62 = and i1 %24, %25
  br i1 %.not62, label %26, label %75

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr nonnull %.fca.1.extract35) #43
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %33 = call i32 %30(ptr nonnull %.fca.1.extract35) #43
  %34 = add i32 %33, 1
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %36 = getelementptr i8, ptr %29, i64 8
  %37 = load ptr, ptr %36, align 8
  call void %37(ptr nonnull %.fca.1.extract35, i32 %34) #42
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %39 = load ptr, ptr %7, align 8
  %result.i1 = call align 8 ptr %39(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #45
  %40 = load ptr, ptr %result.i1, align 8, !alias.scope !5
  %41 = getelementptr i8, ptr %40, i64 72
  %42 = load ptr, ptr %41, align 8, !alias.scope !5
  %result.i.i = call { i64, i64 } %42(ptr nocapture nofree nonnull readonly align 8 %result.i1) #45, !alias.scope !5
  %43 = extractvalue { i64, i64 } %result.i.i, 0
  %44 = extractvalue { i64, i64 } %result.i.i, 1
  %45 = call i64 @llvm.umax.i64(i64 %44, i64 noundef 8), !range !4
  %46 = urem i64 20, %44
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %44, %46
  %49 = select i1 %47, i64 0, i64 %48
  %50 = add i64 %43, 20
  %51 = add i64 %50, %49
  %52 = urem i64 %51, %45
  %53 = icmp eq i64 %52, 0
  %54 = sub i64 %45, %52
  %55 = select i1 %53, i64 0, i64 %54
  %56 = add i64 %55, %51
  %result.i5 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %56) #49
  store ptr @_parameterization_i32, ptr %result.i5, align 8
  %57 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i1, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i5)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %60 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store i32 %31, ptr %60, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #44
  %62 = load ptr, ptr %result.i1, align 8
  %63 = getelementptr i8, ptr %62, i64 72
  %64 = load ptr, ptr %63, align 8
  %result.i.i8 = call { i64, i64 } %64(ptr nocapture nofree nonnull readonly align 8 %result.i1) #45
  %65 = extractvalue { i64, i64 } %result.i.i8, 1
  %66 = urem i64 20, %65
  %67 = icmp eq i64 %66, 0
  %68 = sub i64 %65, %66
  %69 = select i1 %67, i64 0, i64 %68
  %70 = getelementptr inbounds i8, ptr %result.i5, i64 20
  %71 = getelementptr i8, ptr %70, i64 %69
  %72 = getelementptr i8, ptr %62, i64 64
  %73 = load ptr, ptr %72, align 8
  call void %73({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly align 8 %result.i1, ptr nocapture nofree writeonly %71) #46
  %74 = ptrtoint ptr %result.i5 to i64
  %.sroa.351.8.insert.ext = zext i64 %74 to i160
  %.sroa.351.8.insert.insert = or disjoint i160 %.sroa.351.8.insert.ext, 3402823669209384634633746074317682114560
  br label %75

75:                                               ; preds = %26, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @Pair, %26 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.351.8.insert.insert, %26 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Enumerator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumerator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumeration_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumeration_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZippedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 29, i64 30
  %8 = getelementptr [124 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 34, i64 35
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 39, i64 38
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZippedCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 880335312586431241
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define i32 @ZippedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 880335312586431241
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract20, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract22) #43
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract7, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract9, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract11, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract5) #44
  %18 = sext i32 %.fca.3.extract11 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract5, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract20)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract22) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %.sroa.speculated = call i32 @llvm.smin.i32(i32 %22, i32 %38)
  ret i32 %.sroa.speculated
}

define { ptr, ptr, ptr, i32 } @ZippedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract129 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract131 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 880335312586431241
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract129, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract131) #43
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract90) #44
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i9 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i9({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract131) #43
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %result.i8 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %40 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #45
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #45
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %result.i13 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %46 = getelementptr inbounds i8, ptr %result.i13, i64 16
  store ptr %result.i2, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i13, i64 8
  store ptr %result.i3, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i13, i64 24
  store ptr null, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i13)
  store ptr @Pair, ptr %result.i13, align 8
  %result.i12 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #49
  store ptr %result.i3, ptr %result.i12, align 8
  %50 = getelementptr inbounds i8, ptr %result.i12, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i12, i64 16
  store ptr %result.i13, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i12)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr nonnull %.fca.1.extract131) #43
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %56, 3
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract42, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract44, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %.fca.3.extract46, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract40)
  %63 = sext i32 %.fca.3.extract46 to i64
  %64 = getelementptr ptr, ptr %.fca.0.extract40, i64 %63
  %65 = getelementptr i8, ptr %64, i64 24
  %66 = load ptr, ptr %65, align 8
  %result.i7 = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %67 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %69 = load ptr, ptr %24, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr, ptr, ptr, i32 } %70(ptr nonnull %.fca.1.extract131) #43
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %71, 3
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.1.extract20, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.2.extract21, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %.fca.3.extract22, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract19)
  %78 = sext i32 %.fca.3.extract22 to i64
  %79 = getelementptr ptr, ptr %.fca.0.extract19, i64 %78
  %80 = getelementptr i8, ptr %79, i64 24
  %81 = load ptr, ptr %80, align 8
  %result.i6 = call ptr %81({ ptr, ptr, ptr, i32 } %75, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %82 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 8673632051301757104
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %83 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i12, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr undef, 2
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #41
  %88 = getelementptr inbounds i8, ptr %result.i12, i64 24
  store ptr %.fca.0.extract28, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i12, i64 32
  store ptr %.fca.1.extract30, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i12, i64 40
  store ptr %.fca.2.extract32, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i12, i64 48
  store i32 %offset.i25, ptr %91, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #44
  %93 = getelementptr inbounds i8, ptr %result.i12, i64 56
  store ptr %.fca.0.extract, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i12, i64 64
  store ptr %.fca.1.extract, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i12, i64 72
  store ptr %.fca.2.extract, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %result.i12, i64 80
  store i32 %offset.i24.i, ptr %96, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterator_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -2141114445739585318
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 8673632051301757104
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define { ptr, i160 } @ZipIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -2141114445739585318
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract46) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract46, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract48) #43
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract18 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract12, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract14, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract16, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract18, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract12) #44
  %18 = sext i32 %.fca.3.extract18 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract12, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract5 = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract46)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract48) #43
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract4, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract3)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract3, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i6 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, i160 } %result.i6({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = icmp eq ptr %.fca.0.extract5, @nil_typ
  %40 = icmp eq ptr %.fca.0.extract5, null
  %41 = or i1 %39, %40
  br i1 %41, label %.critedge, label %42

42:                                               ; preds = %3
  %.fca.0.extract = extractvalue { ptr, i160 } %38, 0
  %43 = icmp eq ptr %.fca.0.extract, @nil_typ
  %44 = icmp eq ptr %.fca.0.extract, null
  %45 = or i1 %43, %44
  br i1 %45, label %.critedge, label %46

46:                                               ; preds = %42
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %48 = load ptr, ptr %7, align 8
  %result.i3 = call align 8 ptr %48(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #45
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %50 = getelementptr i8, ptr %7, i64 8
  %51 = load ptr, ptr %50, align 8
  %result.i2 = call align 8 ptr %51(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #45
  %52 = load ptr, ptr %result.i3, align 8, !alias.scope !8
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8, !alias.scope !8
  %result.i1.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45, !alias.scope !8
  %55 = extractvalue { i64, i64 } %result.i1.i, 0
  %56 = extractvalue { i64, i64 } %result.i1.i, 1
  %57 = urem i64 16, %56
  %58 = icmp eq i64 %57, 0
  %59 = sub i64 %56, %57
  %60 = select i1 %58, i64 0, i64 %59
  %61 = add i64 %55, 16
  %62 = add i64 %61, %60
  %63 = load ptr, ptr %result.i2, align 8, !alias.scope !8
  %64 = getelementptr i8, ptr %63, i64 72
  %65 = load ptr, ptr %64, align 8, !alias.scope !8
  %result.i.i = call { i64, i64 } %65(ptr nocapture nofree nonnull readonly align 8 %result.i2) #45, !alias.scope !8
  %66 = extractvalue { i64, i64 } %result.i.i, 0
  %67 = extractvalue { i64, i64 } %result.i.i, 1
  %68 = call i64 @llvm.umax.i64(i64 %56, i64 %67) #60
  %69 = call i64 @llvm.umax.i64(i64 %68, i64 noundef 8) #60, !range !4
  %70 = urem i64 %62, %67
  %71 = icmp eq i64 %70, 0
  %72 = sub i64 %67, %70
  %73 = select i1 %71, i64 0, i64 %72
  %74 = add i64 %66, %62
  %75 = add i64 %74, %73
  %76 = urem i64 %75, %69
  %77 = icmp eq i64 %76, 0
  %78 = sub i64 %69, %76
  %79 = select i1 %77, i64 0, i64 %78
  %80 = add i64 %79, %75
  %result.i8 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %80) #49
  store ptr %result.i3, ptr %result.i8, align 8
  %81 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i8)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %85 = load ptr, ptr %result.i3, align 8
  %86 = getelementptr i8, ptr %85, i64 72
  %87 = load ptr, ptr %86, align 8
  %result.i.i14 = call { i64, i64 } %87(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45
  %88 = extractvalue { i64, i64 } %result.i.i14, 1
  %89 = urem i64 16, %88
  %90 = icmp eq i64 %89, 0
  %reass.sub17 = sub i64 %88, %89
  %91 = add i64 %reass.sub17, 16
  %92 = select i1 %90, i64 16, i64 %91
  %93 = getelementptr i8, ptr %result.i8, i64 %92
  %94 = getelementptr i8, ptr %85, i64 64
  %95 = load ptr, ptr %94, align 8
  call void %95({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %93) #46
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #44
  %97 = load ptr, ptr %result.i8, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i1.i15 = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly align 8 %97) #45
  %101 = extractvalue { i64, i64 } %result.i1.i15, 0
  %102 = extractvalue { i64, i64 } %result.i1.i15, 1
  %103 = urem i64 16, %102
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %102, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %101, 16
  %108 = add i64 %107, %106
  %109 = load ptr, ptr %81, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i.i16 = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly align 8 %109) #45
  %113 = extractvalue { i64, i64 } %result.i.i16, 1
  %114 = urem i64 %108, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = getelementptr i8, ptr %result.i8, i64 %108
  %119 = getelementptr i8, ptr %118, i64 %117
  %120 = getelementptr i8, ptr %110, i64 64
  %121 = load ptr, ptr %120, align 8
  call void %121({ ptr, i160 } %38, ptr nocapture nofree nonnull readonly align 8 %109, ptr nocapture nofree writeonly %119) #46
  %122 = ptrtoint ptr %result.i8 to i64
  %.sroa.361.8.insert.ext = zext i64 %122 to i160
  %.sroa.361.8.insert.insert = or disjoint i160 %.sroa.361.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.critedge

.critedge:                                        ; preds = %46, %42, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @Pair, %46 ], [ @nil_typ, %42 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.361.8.insert.insert, %46 ], [ undef, %42 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #9

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 35232740166152944
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @ZipIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract129 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract131 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 35232740166152944
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract129, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract131) #43
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract90) #44
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i9 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i9({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract131) #43
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i8 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %40 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #45
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #45
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %result.i13 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %46 = getelementptr inbounds i8, ptr %result.i13, i64 16
  store ptr %result.i2, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i13, i64 8
  store ptr %result.i3, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i13, i64 24
  store ptr null, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i13)
  store ptr @Pair, ptr %result.i13, align 8
  %result.i12 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #49
  store ptr %result.i3, ptr %result.i12, align 8
  %50 = getelementptr inbounds i8, ptr %result.i12, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i12, i64 16
  store ptr %result.i13, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i12)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr nonnull %.fca.1.extract131) #43
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %56, 3
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract42, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract44, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %.fca.3.extract46, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract40)
  %63 = sext i32 %.fca.3.extract46 to i64
  %64 = getelementptr ptr, ptr %.fca.0.extract40, i64 %63
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %result.i7 = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %67 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %69 = load ptr, ptr %24, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr, ptr, ptr, i32 } %70(ptr nonnull %.fca.1.extract131) #43
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %71, 3
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.1.extract20, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.2.extract21, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %.fca.3.extract22, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract19)
  %78 = sext i32 %.fca.3.extract22 to i64
  %79 = getelementptr ptr, ptr %.fca.0.extract19, i64 %78
  %80 = getelementptr i8, ptr %79, i64 8
  %81 = load ptr, ptr %80, align 8
  %result.i6 = call ptr %81({ ptr, ptr, ptr, i32 } %75, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %82 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 8673632051301757104
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %83 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i12, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr undef, 2
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #41
  %88 = getelementptr inbounds i8, ptr %result.i12, i64 24
  store ptr %.fca.0.extract28, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i12, i64 32
  store ptr %.fca.1.extract30, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i12, i64 40
  store ptr %.fca.2.extract32, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i12, i64 48
  store i32 %offset.i25, ptr %91, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #44
  %93 = getelementptr inbounds i8, ptr %result.i12, i64 56
  store ptr %.fca.0.extract, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i12, i64 64
  store ptr %.fca.1.extract, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i12, i64 72
  store ptr %.fca.2.extract, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %result.i12, i64 80
  store i32 %offset.i24.i, ptr %96, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable_field_InterleaveIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4936782714255954462
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @InterleaveIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4936782714255954462
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #43
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract90) #44
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #43
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #45
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #49
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #41
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #44
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator_field_InterleaveIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -3924664358248524505
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract38, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract21, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract22, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 8673632051301757104
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %25) #42
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #44
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract39, i1 true) #42
  ret void
}

define { ptr, i160 } @InterleaveIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -3924664358248524505
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i1 %10(ptr %.fca.1.extract33) #43
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32) #44
  %13 = getelementptr i8, ptr %9, i64 8
  %14 = load ptr, ptr %13, align 8
  br i1 %11, label %15, label %35

15:                                               ; preds = %3
  call void %14(ptr %.fca.1.extract33, i1 false) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32) #44
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr, ptr, ptr, i32 } %19(ptr %.fca.1.extract33) #43
  %.fca.0.extract101 = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  %.fca.1.extract103 = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.2.extract105 = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %.fca.3.extract107 = extractvalue { ptr, ptr, ptr, i32 } %20, 3
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract101, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract103, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract105, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %.fca.3.extract107, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract101) #44
  %27 = sext i32 %.fca.3.extract107 to i64
  %28 = getelementptr ptr, ptr %.fca.0.extract101, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %31 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %4)
  %.fca.0.extract95 = extractvalue { ptr, i160 } %31, 0
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %33 = icmp eq ptr %.fca.0.extract95, @nil_typ
  %34 = icmp eq ptr %.fca.0.extract95, null
  %.not114.not = or i1 %33, %34
  br i1 %.not114.not, label %55, label %72

35:                                               ; preds = %3
  call void %14(ptr %.fca.1.extract33, i1 true) #42
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %37 = getelementptr i8, ptr %7, i64 16
  %38 = load ptr, ptr %37, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract33) #43
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract71, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract73, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract75, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract69)
  %47 = sext i32 %.fca.3.extract75 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract69, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i1 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %51 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract54 = extractvalue { ptr, i160 } %51, 0
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %53 = icmp eq ptr %.fca.0.extract54, @nil_typ
  %54 = icmp eq ptr %.fca.0.extract54, null
  %.not111.not = or i1 %53, %54
  br i1 %.not111.not, label %55, label %72

55:                                               ; preds = %35, %15
  %.sink145 = phi i64 [ 16, %15 ], [ 8, %35 ]
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %57 = getelementptr i8, ptr %7, i64 %.sink145
  %58 = load ptr, ptr %57, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract33) #43
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract40 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract41 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract38, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract39, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract40, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract41, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract38)
  %67 = sext i32 %.fca.3.extract41 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract38, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %71 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract34 = extractvalue { ptr, i160 } %71, 0
  br label %72

72:                                               ; preds = %55, %35, %15
  %.pn = phi { ptr, i160 } [ %71, %55 ], [ %51, %35 ], [ %31, %15 ]
  %73 = phi ptr [ %.fca.0.extract34, %55 ], [ %.fca.0.extract54, %35 ], [ %.fca.0.extract95, %15 ]
  %74 = extractvalue { ptr, i160 } %.pn, 1
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %73, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %74, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator_getter_on_first(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleavedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleavedCollection_field_InterleavedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 32, i64 33
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleavedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8589355597059143861
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define i32 @InterleavedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8589355597059143861
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract19) #43
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract3) #44
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract19) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = add i32 %38, %22
  ret i32 %39
}

define { ptr, ptr, ptr, i32 } @InterleavedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8589355597059143861
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #43
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract90) #44
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #43
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #45
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #49
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 24
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 24
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #41
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #44
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainedCollection_field_ChainedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 32, i64 33
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4136536984535342799
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define i32 @ChainedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4136536984535342799
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract19) #43
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract3) #44
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract19) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = add i32 %38, %22
  ret i32 %39
}

define { ptr, ptr, ptr, i32 } @ChainedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4136536984535342799
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #43
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract90) #44
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #43
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #45
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #49
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 24
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 24
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #41
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #44
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator_field_ChainIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6043157723929225452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract38, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract21, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract22, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 8673632051301757104
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %25) #42
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #44
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract39, i1 true) #42
  ret void
}

define { ptr, i160 } @ChainIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6043157723929225452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract18, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i1 %10(ptr %.fca.1.extract19) #43
  br i1 %11, label %12, label %37

12:                                               ; preds = %3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18) #44
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract19) #43
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract40 = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract42 = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract44 = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract38, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract40, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract42, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract44, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract38) #44
  %24 = sext i32 %.fca.3.extract44 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract38, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i1 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %28 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract32 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18)
  %30 = icmp ne ptr %.fca.0.extract32, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract32, null
  %.not47.not.not = and i1 %30, %31
  br i1 %.not47.not.not, label %54, label %32

32:                                               ; preds = %12
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18)
  %34 = load ptr, ptr %8, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr %.fca.1.extract19, i1 false) #42
  br label %37

37:                                               ; preds = %32, %3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18)
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract19) #43
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract26 = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract24, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract25, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract26, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract27, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract24)
  %49 = sext i32 %.fca.3.extract27 to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract24, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %53 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4)
  %.fca.0.extract20 = extractvalue { ptr, i160 } %53, 0
  br label %54

54:                                               ; preds = %37, %12
  %.reg2mem11.sroa.0.0 = phi ptr [ %.fca.0.extract20, %37 ], [ %.fca.0.extract32, %12 ]
  %.pn = phi { ptr, i160 } [ %53, %37 ], [ %28, %12 ]
  %.reg2mem11.sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reload12.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem11.sroa.0.0, 0
  %.reload12.fca.1.insert = insertvalue { ptr, i160 } %.reload12.fca.0.insert, i160 %.reg2mem11.sroa.3.0, 1
  ret { ptr, i160 } %.reload12.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator_getter_on_first(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable_field_ChainIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -2370247058431047815
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @ChainIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -2370247058431047815
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #43
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract90) #44
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #43
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #45
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #49
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #43
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #41
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #44
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable_field_FilterIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8498466713076104350
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @FilterIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract73, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract73, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract73, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8498466713076104350
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract73, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract75) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43) #44
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i6 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract75) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %29 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract75) #45
  %result.i9 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i2, ptr %result.i9, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i9)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr nonnull %.fca.1.extract75) #43
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract17, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract18, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract19, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract16)
  %41 = sext i32 %.fca.3.extract19 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract16, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i5 = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %45 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr nonnull %.fca.1.extract75) #43
  %hash_coef_ptr.i10 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i11 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i12 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i10, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i11, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i12, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 8673632051301757104
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %54 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %.fca.0.extract15, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %.fca.1.extract, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr %.fca.2.extract, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %result.i9, i64 32
  store i32 %offset.i21, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @FilterIterator) #44
  %59 = getelementptr inbounds i8, ptr %result.i9, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i, ptr %59, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %60
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator_field_FilterIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -1221365496900303883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #42
  ret void
}

define { ptr, i160 } @FilterIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -1221365496900303883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract25) #57
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract25, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract27) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract25)
  %24 = getelementptr i8, ptr %7, i64 16
  %.sroa.0.014 = extractvalue { ptr, i160 } %22, 0
  %25 = icmp ne ptr %.sroa.0.014, @nil_typ
  %26 = icmp ne ptr %.sroa.0.014, null
  %.not6316 = and i1 %25, %26
  br i1 %.not6316, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %28 = load ptr, ptr %24, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr } %29(ptr %.fca.1.extract27) #43
  %.fca.0.extract5024 = extractvalue { ptr } %30, 0
  %31 = call i1 %.fca.0.extract5024({ ptr, i160 } %22)
  br i1 %31, label %._crit_edge.loopexit, label %.lr.ph26.preheader

.lr.ph26.preheader:                               ; preds = %.lr.ph
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  br label %.lr.ph26

33:                                               ; preds = %.lr.ph26
  %34 = load ptr, ptr %24, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract27) #43
  %.fca.0.extract50 = extractvalue { ptr } %36, 0
  %37 = call i1 %.fca.0.extract50({ ptr, i160 } %51)
  br i1 %37, label %._crit_edge.loopexit, label %.lr.ph26

.lr.ph26:                                         ; preds = %33, %.lr.ph26.preheader
  %.pn1725 = phi { ptr, i160 } [ %51, %33 ], [ %22, %.lr.ph26.preheader ]
  %38 = load ptr, ptr %8, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract27) #43
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract47 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract43, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract45, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract47, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract41)
  %47 = sext i32 %.fca.3.extract47 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract41, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %51 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.sroa.0.0 = extractvalue { ptr, i160 } %51, 0
  %52 = icmp ne ptr %.sroa.0.0, @nil_typ
  %53 = icmp ne ptr %.sroa.0.0, null
  %.not63 = and i1 %52, %53
  br i1 %.not63, label %33, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph26, %33, %.lr.ph
  %.pn17.lcssa = phi { ptr, i160 } [ %22, %.lr.ph ], [ %51, %33 ], [ %.pn1725, %.lr.ph26 ]
  %.reg2mem22.0.ph.ph = phi ptr [ %.sroa.0.014, %.lr.ph ], [ %.sroa.0.0, %33 ], [ @nil_typ, %.lr.ph26 ]
  %.sroa.3.019.le = extractvalue { ptr, i160 } %.pn17.lcssa, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.reg2mem22.0.ph = phi ptr [ @nil_typ, %3 ], [ %.reg2mem22.0.ph.ph, %._crit_edge.loopexit ]
  %.1.ph = phi i160 [ undef, %3 ], [ %.sroa.3.019.le, %._crit_edge.loopexit ]
  %.reload19.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem22.0.ph, 0
  %.reload19.fca.1.insert = insertvalue { ptr, i160 } %.reload19.fca.0.insert, i160 %.1.ph, 1
  ret { ptr, i160 } %.reload19.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MappedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 29, i64 28
  %8 = getelementptr [123 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 32, i64 31
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 33, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 36, i64 35
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 38, i64 37
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MappedCollection_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5460697656559120915
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #44
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #42
  ret void
}

define i32 @MappedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5460697656559120915
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @MappedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract79 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract81 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5460697656559120915
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract79, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract81) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43) #44
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract81) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %29 = load ptr, ptr %7, align 8
  %result.i4 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #45
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #45
  %result.i11 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store ptr %result.i4, ptr %result.i11, align 8
  %33 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i11)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr nonnull %.fca.1.extract81) #43
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract17, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract18, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract19, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract16)
  %45 = sext i32 %.fca.3.extract19 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract16, i64 %45
  %47 = getelementptr i8, ptr %46, i64 24
  %48 = load ptr, ptr %47, align 8
  %result.i7 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %49 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr nonnull %.fca.1.extract81) #43
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %59 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.0.extract15, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.1.extract, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store ptr %.fca.2.extract, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store i32 %offset.i23, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @MapIterator) #44
  %64 = getelementptr inbounds i8, ptr %result.i11, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %64, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %65
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterator_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -146553482626734782
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #44
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #42
  ret void
}

define { ptr, i160 } @MapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -146553482626734782
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract21, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract23) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract21)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not46 = and i1 %24, %25
  br i1 %.not46, label %26, label %33

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract21)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %.fca.1.extract23) #43
  %.fca.0.extract38 = extractvalue { ptr } %31, 0
  %32 = call { ptr, i160 } %.fca.0.extract38({ ptr, i160 } %22)
  %.fca.0.extract32 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract34 = extractvalue { ptr, i160 } %32, 1
  br label %33

33:                                               ; preds = %26, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract32, %26 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract34, %26 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MappedCollection_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MappedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterable_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7488770571603291722
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #44
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @MapIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract79 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract81 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7488770571603291722
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract79, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract81) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43) #44
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract81) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %29 = load ptr, ptr %7, align 8
  %result.i4 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #45
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #45
  %result.i11 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store ptr %result.i4, ptr %result.i11, align 8
  %33 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i11)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr nonnull %.fca.1.extract81) #43
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract17, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract18, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract19, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract16)
  %45 = sext i32 %.fca.3.extract19 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract16, i64 %45
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %result.i7 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %49 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr nonnull %.fca.1.extract81) #43
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %59 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.0.extract15, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.1.extract, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store ptr %.fca.2.extract, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store i32 %offset.i23, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @MapIterator) #44
  %64 = getelementptr inbounds i8, ptr %result.i11, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %64, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %65
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_EnumeratedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 32, i64 33
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @EnumeratedCollection_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7081690788784801875
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

define i32 @EnumeratedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7081690788784801875
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @EnumeratedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7081690788784801875
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract63, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract65) #43
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract39) #44
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i5 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %24 = load ptr, ptr %7, align 8
  %result.i1 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #45
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %result.i8 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %26 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i1, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr null, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i8)
  store ptr @Pair, ptr %result.i8, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store ptr %result.i1, ptr %result.i7, align 8
  %30 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i8, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %33 = load ptr, ptr %8, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr nonnull %.fca.1.extract65) #43
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract15, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract16, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %.fca.3.extract17, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract14)
  %42 = sext i32 %.fca.3.extract17 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract14, i64 %42
  %44 = getelementptr i8, ptr %43, i64 24
  %45 = load ptr, ptr %44, align 8
  %result.i4 = call ptr %45({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %46 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 2
  %hash_coef_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i12 = load i64, ptr %hash_coef_ptr.i9, align 4
  %tbl_size.i13 = load i64, ptr %tbl_size_ptr.i10, align 4
  %offset_tbl.i14 = load ptr, ptr %offset_tbl_ptr.i11, align 8
  %product.i.i15 = mul i64 %hash_coef.i12, 8673632051301757104
  %shifted.i.i16 = lshr i64 %product.i.i15, 32
  %xored.i.i17 = xor i64 %shifted.i.i16, %product.i.i15
  %hash.i.i18 = and i64 %xored.i.i17, %tbl_size.i13
  %offset_ptr.i19 = getelementptr i32, ptr %offset_tbl.i14, i64 %hash.i.i18
  %offset.i20 = load i32, ptr %offset_ptr.i19, align 4
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %50 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i20, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator) #44
  %55 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store i32 0, ptr %55, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %56
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @EnumeratedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @EnumeratedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @StringIterator_field_StringIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7260570988945952630
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 6499063144389013426
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i12, 3
  call void %10(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %14) #42
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #44
  %16 = getelementptr i8, ptr %7, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract18, i32 0) #42
  ret void
}

define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7260570988945952630
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract33) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract33, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract35) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract33) #44
  %15 = load ptr, ptr %9, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract35) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract) #44
  %24 = sext i32 %.fca.3.extract to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 88
  %27 = load ptr, ptr %26, align 8
  %result.i3 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %28 = call i32 %result.i3({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.not = icmp slt i32 %13, %28
  br i1 %.not, label %29, label %62

29:                                               ; preds = %3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %31 = load ptr, ptr %10, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call i32 %32(ptr %.fca.1.extract35) #43
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %35 = load ptr, ptr %9, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call { ptr, ptr, ptr, i32 } %36(ptr %.fca.1.extract35) #43
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %37, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %37, 1
  %.fca.2.extract61 = extractvalue { ptr, ptr, ptr, i32 } %37, 2
  %.fca.3.extract63 = extractvalue { ptr, ptr, ptr, i32 } %37, 3
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.1.extract59, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.2.extract61, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %.fca.3.extract63, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract57)
  %44 = sext i32 %.fca.3.extract63 to i64
  %45 = getelementptr ptr, ptr %.fca.0.extract57, i64 %44
  %46 = getelementptr i8, ptr %45, i64 136
  %47 = load ptr, ptr %46, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i2 = call ptr %47({ ptr, ptr, ptr, i32 } %41, ptr nocapture nofree noundef nonnull readonly %6) #47
  %48 = call { ptr, i64 } %result.i2({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 dereferenceable(8) %5, i32 %33)
  %.fca.0.extract51 = extractvalue { ptr, i64 } %48, 0
  %49 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %50 = icmp ne ptr %.fca.0.extract51, null
  %.not70 = and i1 %49, %50
  br i1 %.not70, label %51, label %62

51:                                               ; preds = %29
  %.fca.1.extract53 = extractvalue { ptr, i64 } %48, 1
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %53 = load ptr, ptr %10, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call i32 %54(ptr %.fca.1.extract35) #43
  %extelt.offset = lshr i64 %.fca.1.extract53, 32
  %.4.vec.extract = trunc nuw i64 %extelt.offset to i32
  %56 = add i32 %55, %.4.vec.extract
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %58 = getelementptr i8, ptr %53, i64 8
  %59 = load ptr, ptr %58, align 8
  call void %59(ptr %.fca.1.extract35, i32 %56) #42
  %result.i4 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #49
  %.0.vec.extract = trunc i64 %.fca.1.extract53 to i32
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Character) #41
  store i32 %.0.vec.extract, ptr %result.i4, align 4
  %61 = ptrtoint ptr %result.i4 to i64
  %.sroa.3.8.insert.ext = zext i64 %61 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %62

62:                                               ; preds = %51, %29, %3
  %.reg2mem9.sroa.0.0 = phi ptr [ @nil_typ, %3 ], [ @Character, %51 ], [ @nil_typ, %29 ]
  %.reg2mem9.sroa.3.0 = phi i160 [ undef, %3 ], [ %.sroa.3.8.insert.insert, %51 ], [ undef, %29 ]
  %.reload10.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem9.sroa.0.0, 0
  %.reload10.fca.1.insert = insertvalue { ptr, i160 } %.reload10.fca.0.insert, i160 %.reg2mem9.sroa.3.0, 1
  ret { ptr, i160 } %.reload10.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_codepointi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_codepoint_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_to_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_n_bytes_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Character_init_codepointi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  call void %10(ptr %.fca.1.extract, i32 %3) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Character_codepoint_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #43
  ret i32 %9
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Character_to_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract14, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract15) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode) #44
  %result.i10.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #49
  %11 = icmp slt i32 %9, 128
  br i1 %11, label %12, label %14

12:                                               ; preds = %3
  %13 = trunc i32 %9 to i8
  store i8 %13, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

14:                                               ; preds = %3
  %15 = icmp ult i32 %9, 2048
  br i1 %15, label %16, label %24

16:                                               ; preds = %14
  %17 = lshr i32 %9, 6
  %18 = trunc nuw nsw i32 %17 to i8
  %19 = or disjoint i8 %18, -64
  store i8 %19, ptr %result.i10.i, align 1
  %20 = trunc i32 %9 to i8
  %21 = and i8 %20, 63
  %22 = or disjoint i8 %21, -128
  %23 = getelementptr i8, ptr %result.i10.i, i64 1
  store i8 %22, ptr %23, align 1
  %result.i8.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10.i, ptr %result.i8.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

24:                                               ; preds = %14
  %25 = icmp ult i32 %9, 1114112
  br i1 %25, label %26, label %44

26:                                               ; preds = %24
  %27 = lshr i32 %9, 18
  %28 = trunc nuw nsw i32 %27 to i8
  %29 = or disjoint i8 %28, -16
  store i8 %29, ptr %result.i10.i, align 1
  %30 = lshr i32 %9, 12
  %31 = trunc i32 %30 to i8
  %32 = and i8 %31, 63
  %33 = or disjoint i8 %32, -128
  %34 = getelementptr i8, ptr %result.i10.i, i64 1
  store i8 %33, ptr %34, align 1
  %35 = lshr i32 %9, 6
  %36 = trunc i32 %35 to i8
  %37 = and i8 %36, 63
  %38 = or disjoint i8 %37, -128
  %39 = getelementptr i8, ptr %result.i10.i, i64 2
  store i8 %38, ptr %39, align 1
  %40 = trunc i32 %9 to i8
  %41 = and i8 %40, 63
  %42 = or disjoint i8 %41, -128
  %43 = getelementptr i8, ptr %result.i10.i, i64 3
  store i8 %42, ptr %43, align 1
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10.i, ptr %result.i7.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

44:                                               ; preds = %24
  %result.i4.i.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %result.i.i51.i = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #49
  store i8 -17, ptr %result.i.i51.i, align 1
  %46 = getelementptr i8, ptr %result.i.i51.i, i64 1
  store i8 -65, ptr %46, align 1
  %47 = getelementptr i8, ptr %result.i.i51.i, i64 2
  store i8 -67, ptr %47, align 1
  store ptr %result.i.i51.i, ptr %result.i4.i.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

Unicode__Self_encode_one_cpi32.exit:              ; preds = %44, %26, %16, %12
  %result.i4.i.sink54.i = phi ptr [ %result.i4.i.i, %44 ], [ %result.i7.i, %26 ], [ %result.i8.i, %16 ], [ %result.i9.i, %12 ]
  %.sink.i = phi i32 [ 3, %44 ], [ 4, %26 ], [ 2, %16 ], [ 1, %12 ]
  %48 = getelementptr i8, ptr %result.i4.i.sink54.i, i64 8
  store i32 %.sink.i, ptr %48, align 8
  %49 = getelementptr i8, ptr %result.i4.i.sink54.i, i64 12
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  store <2 x i32> <i32 1, i32 4>, ptr %49, align 4
  %51 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i4.i.sink54.i, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %52
}

define i1 @Character__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 6681222582356018452
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract11, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract12) #43
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %18 = sext i32 %offset.i12 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 16
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %23 = icmp eq i32 %11, %22
  ret i1 %23
}

; Function Attrs: mustprogress nounwind willreturn
define noundef range(i32 1, 5) i32 @Character_n_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #43
  %10 = icmp slt i32 %9, 128
  %11 = icmp slt i32 %9, 2048
  %12 = icmp slt i32 %9, 1114112
  %13 = select i1 %12, i32 4, i32 3
  %.reg2mem22.0 = select i1 %11, i32 2, i32 %13
  %.reg2mem18.0 = select i1 %10, i32 1, i32 %.reg2mem22.0
  ret i32 %.reg2mem18.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_encode_one_cpi32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #41
  ret ptr @Unicode__Self_encode_one_cpi32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Unicode__Self_encode_one_cpi32(ptr nocapture nofree readnone %0, i32 %1) #35 {
  %result.i10 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #49
  %3 = icmp slt i32 %1, 128
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = trunc i32 %1 to i8
  store i8 %5, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10, ptr %result.i9, align 8
  br label %40

6:                                                ; preds = %2
  %7 = icmp ult i32 %1, 2048
  br i1 %7, label %8, label %16

8:                                                ; preds = %6
  %9 = lshr i32 %1, 6
  %10 = trunc nuw nsw i32 %9 to i8
  %11 = or disjoint i8 %10, -64
  store i8 %11, ptr %result.i10, align 1
  %12 = trunc i32 %1 to i8
  %13 = and i8 %12, 63
  %14 = or disjoint i8 %13, -128
  %15 = getelementptr i8, ptr %result.i10, i64 1
  store i8 %14, ptr %15, align 1
  %result.i8 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10, ptr %result.i8, align 8
  br label %40

16:                                               ; preds = %6
  %17 = icmp ult i32 %1, 1114112
  br i1 %17, label %18, label %36

18:                                               ; preds = %16
  %19 = lshr i32 %1, 18
  %20 = trunc nuw nsw i32 %19 to i8
  %21 = or disjoint i8 %20, -16
  store i8 %21, ptr %result.i10, align 1
  %22 = lshr i32 %1, 12
  %23 = trunc i32 %22 to i8
  %24 = and i8 %23, 63
  %25 = or disjoint i8 %24, -128
  %26 = getelementptr i8, ptr %result.i10, i64 1
  store i8 %25, ptr %26, align 1
  %27 = lshr i32 %1, 6
  %28 = trunc i32 %27 to i8
  %29 = and i8 %28, 63
  %30 = or disjoint i8 %29, -128
  %31 = getelementptr i8, ptr %result.i10, i64 2
  store i8 %30, ptr %31, align 1
  %32 = trunc i32 %1 to i8
  %33 = and i8 %32, 63
  %34 = or disjoint i8 %33, -128
  %35 = getelementptr i8, ptr %result.i10, i64 3
  store i8 %34, ptr %35, align 1
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10, ptr %result.i7, align 8
  br label %40

36:                                               ; preds = %16
  %result.i4.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %result.i.i51 = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #49
  store i8 -17, ptr %result.i.i51, align 1
  %38 = getelementptr i8, ptr %result.i.i51, i64 1
  store i8 -65, ptr %38, align 1
  %39 = getelementptr i8, ptr %result.i.i51, i64 2
  store i8 -67, ptr %39, align 1
  store ptr %result.i.i51, ptr %result.i4.i, align 8
  br label %40

40:                                               ; preds = %36, %18, %8, %4
  %result.i4.i.sink54 = phi ptr [ %result.i4.i, %36 ], [ %result.i7, %18 ], [ %result.i8, %8 ], [ %result.i9, %4 ]
  %.sink = phi i32 [ 3, %36 ], [ 4, %18 ], [ 2, %8 ], [ 1, %4 ]
  %41 = getelementptr i8, ptr %result.i4.i.sink54, i64 8
  store i32 %.sink, ptr %41, align 8
  %42 = getelementptr i8, ptr %result.i4.i.sink54, i64 12
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  store <2 x i32> <i32 1, i32 4>, ptr %42, align 4
  %.reload18.fca.1.insert = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr poison, ptr poison, i32 poison }, ptr %result.i4.i.sink54, 1
  %.reload18.fca.2.insert = insertvalue { ptr, ptr, ptr, i32 } %.reload18.fca.1.insert, ptr undef, 2
  %.reload18.fca.3.insert = insertvalue { ptr, ptr, ptr, i32 } %.reload18.fca.2.insert, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %.reload18.fca.3.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_str_(ptr nocapture nofree %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #41
  ret ptr @Unicode__Self_replacement_str_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Unicode__Self_replacement_str_(ptr nocapture nofree readnone %0) #35 {
  %result.i4 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %result.i.i5 = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #49
  store i8 -17, ptr %result.i.i5, align 1
  %3 = getelementptr i8, ptr %result.i.i5, i64 1
  store i8 -65, ptr %3, align 1
  %4 = getelementptr i8, ptr %result.i.i5, i64 2
  store i8 -67, ptr %4, align 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i4, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr undef, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 10, 3
  store ptr %result.i.i5, ptr %result.i4, align 8
  %8 = getelementptr i8, ptr %result.i4, i64 8
  store <2 x i32> <i32 3, i32 1>, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %10 = getelementptr i8, ptr %result.i4, i64 16
  store i32 4, ptr %10, align 8
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_buf_(ptr nocapture nofree %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #41
  ret ptr @Unicode__Self_replacement_buf_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr } @Unicode__Self_replacement_buf_(ptr nocapture nofree readnone %0) #35 {
  %result.i = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #49
  store i8 -17, ptr %result.i, align 1
  %2 = getelementptr i8, ptr %result.i, i64 1
  store i8 -65, ptr %2, align 1
  %3 = getelementptr i8, ptr %result.i, i64 2
  store i8 -67, ptr %3, align 1
  %4 = insertvalue { ptr } undef, ptr %result.i, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Unicode(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_codepoint_(ptr nocapture nofree %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #41
  ret ptr @Unicode__Self_replacement_codepoint_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #41
  ret ptr @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @Unicode__Self_replacement_codepoint_(ptr nocapture nofree readnone %0) #1 {
  ret i32 -3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i64 } @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2, i32 %3) #7 {
  %.fca.0.extract10 = extractvalue { ptr } %1, 0
  %.not = icmp slt i32 %2, %3
  br i1 %.not, label %._crit_edge, label %.loopexit

._crit_edge:                                      ; preds = %4
  %5 = sext i32 %2 to i64
  %6 = getelementptr i8, ptr %.fca.0.extract10, i64 %5
  %7 = load i8, ptr %6, align 1
  %8 = sext i8 %7 to i32
  %9 = icmp sgt i8 %7, -1
  %spec.select = zext i1 %9 to i32
  %10 = and i32 %8, -32
  %11 = icmp eq i32 %10, -64
  %.1149 = select i1 %11, i32 2, i32 %spec.select
  %12 = and i32 %8, -16
  %13 = icmp eq i32 %12, -32
  %.2150 = select i1 %13, i32 3, i32 %.1149
  %14 = and i32 %8, -8
  %15 = icmp eq i32 %14, -16
  %.3151 = select i1 %15, i32 4, i32 %.2150
  %16 = icmp eq i32 %.3151, 0
  %17 = add i32 %.3151, %2
  %18 = icmp sgt i32 %17, %3
  %.0152 = or i1 %16, %18
  br i1 %.0152, label %.loopexit, label %19

19:                                               ; preds = %._crit_edge
  %20 = and i32 %8, 7
  %21 = and i32 %8, 15
  %22 = and i32 %8, 31
  %spec.select171 = select i1 %9, i32 %8, i32 0
  %.1 = select i1 %11, i32 %22, i32 %spec.select171
  %.2 = select i1 %13, i32 %21, i32 %.1
  %.3 = select i1 %15, i32 %20, i32 %.2
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %.not48 = icmp ugt i32 %.3151, 1
  br i1 %.not48, label %25, label %._crit_edge5

25:                                               ; preds = %19
  %26 = getelementptr i8, ptr %6, i64 1
  %27 = load i8, ptr %26, align 1
  %28 = sext i8 %27 to i32
  %29 = and i32 %28, -64
  %.not15 = icmp eq i32 %29, -128
  %30 = shl nsw i32 %.3, 6
  %31 = and i32 %28, 63
  %32 = or disjoint i32 %31, %30
  br i1 %.not15, label %33, label %.loopexit

33:                                               ; preds = %25
  %.not48.1.not = icmp eq i32 %.3151, 2
  br i1 %.not48.1.not, label %._crit_edge4, label %34

34:                                               ; preds = %33
  %35 = add i32 %2, 2
  %36 = sext i32 %35 to i64
  %37 = getelementptr i8, ptr %.fca.0.extract10, i64 %36
  %38 = load i8, ptr %37, align 1
  %39 = sext i8 %38 to i32
  %40 = and i32 %39, -64
  %.not15.1 = icmp eq i32 %40, -128
  %41 = shl i32 %32, 6
  %42 = and i32 %39, 63
  %43 = or disjoint i32 %42, %41
  br i1 %.not15.1, label %44, label %.loopexit

44:                                               ; preds = %34
  br i1 %15, label %45, label %._crit_edge5

45:                                               ; preds = %44
  %46 = add i32 %2, 3
  %47 = sext i32 %46 to i64
  %48 = getelementptr i8, ptr %.fca.0.extract10, i64 %47
  %49 = load i8, ptr %48, align 1
  %50 = sext i8 %49 to i32
  %51 = and i32 %50, -64
  %.not15.2 = icmp eq i32 %51, -128
  br i1 %.not15.2, label %52, label %.loopexit

52:                                               ; preds = %45
  %53 = and i32 %50, 63
  %54 = shl i32 %43, 6
  %55 = or disjoint i32 %53, %54
  br label %._crit_edge5

._crit_edge4:                                     ; preds = %33
  %56 = icmp slt i32 %32, -128
  br i1 %56, label %.critedge175, label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge4, %52, %44, %19
  %.4.lcssa55 = phi i32 [ %32, %._crit_edge4 ], [ %55, %52 ], [ %43, %44 ], [ %.3, %19 ]
  %not. = xor i1 %15, true
  %57 = and i1 %13, %not.
  %58 = icmp slt i32 %.4.lcssa55, 2048
  %spec.select173 = select i1 %57, i1 %58, i1 false
  %59 = icmp slt i32 %.4.lcssa55, 65536
  %spec.select174 = select i1 %15, i1 %59, i1 false
  %or.cond = select i1 %spec.select173, i1 true, i1 %spec.select174
  br i1 %or.cond, label %.critedge175, label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5
  %60 = and i32 %.4.lcssa55, -2048
  %spec.select176 = icmp eq i32 %60, -10240
  br label %.critedge175

.critedge175:                                     ; preds = %._crit_edge7, %._crit_edge5, %._crit_edge4
  %.4.lcssa56 = phi i32 [ %.4.lcssa55, %._crit_edge7 ], [ %32, %._crit_edge4 ], [ %.4.lcssa55, %._crit_edge5 ]
  %.0158 = phi i1 [ %spec.select176, %._crit_edge7 ], [ true, %._crit_edge4 ], [ true, %._crit_edge5 ]
  %61 = icmp sgt i32 %.4.lcssa56, 1114111
  %spec.select177 = select i1 %.0158, i1 true, i1 %61
  %.0.vec.insert = insertelement <2 x i32> poison, i32 %.4.lcssa56, i64 0
  %.4.vec.insert = insertelement <2 x i32> %.0.vec.insert, i32 %.3151, i64 1
  %62 = bitcast <2 x i32> %.4.vec.insert to i64
  %63 = select i1 %spec.select177, ptr @nil_typ, ptr @tuple_typ
  br label %.loopexit

.loopexit:                                        ; preds = %.critedge175, %45, %34, %25, %._crit_edge, %4
  %.reg2mem55.0 = phi ptr [ @nil_typ, %4 ], [ @nil_typ, %._crit_edge ], [ %63, %.critedge175 ], [ @nil_typ, %45 ], [ @nil_typ, %34 ], [ @nil_typ, %25 ]
  %.reg2mem57.sroa.3.0 = phi i64 [ poison, %4 ], [ poison, %._crit_edge ], [ %62, %.critedge175 ], [ poison, %45 ], [ poison, %34 ], [ poison, %25 ]
  %.reload54.fca.0.insert = insertvalue { ptr, i64 } poison, ptr %.reg2mem55.0, 0
  %.reload54.fca.1.insert = insertvalue { ptr, i64 } %.reload54.fca.0.insert, i64 %.reg2mem57.sroa.3.0, 1
  ret { ptr, i64 } %.reload54.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define { ptr, i160 } @_box_tuple_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly align 4 %1) #38 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = getelementptr i8, ptr %1, i64 8
  %4 = load i64, ptr %3, align 4
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %.lr.ph.i, %2
  %.in.i = phi i64 [ %23, %.lr.ph.i ], [ %4, %2 ]
  %6 = phi i64 [ %21, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.i = phi i64 [ %20, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem20.010.i = phi i64 [ %14, %.lr.ph.i ], [ 1, %2 ]
  %7 = inttoptr i64 %.in.i to ptr
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %11 = call { i64, i64 } %10(ptr nonnull align 8 %7) #54
  %12 = extractvalue { i64, i64 } %11, 0
  %13 = extractvalue { i64, i64 } %11, 1
  %14 = call i64 @llvm.umax.i64(i64 %13, i64 %.reg2mem20.010.i)
  %15 = urem i64 %.reg2mem22.011.i, %13
  %16 = icmp eq i64 %15, 0
  %17 = sub nuw i64 %13, %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add nuw i64 %12, %.reg2mem22.011.i
  %20 = add nuw i64 %19, %18
  %21 = add nuw i64 %6, 1
  %22 = getelementptr ptr, ptr %1, i64 %21
  %23 = load i64, ptr %22, align 4
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %2
  %.reg2mem20.0.lcssa.i = phi i64 [ 1, %2 ], [ %14, %.lr.ph.i ]
  %.reg2mem22.0.lcssa.i = phi i64 [ 0, %2 ], [ %20, %.lr.ph.i ]
  %25 = urem i64 %.reg2mem22.0.lcssa.i, %.reg2mem20.0.lcssa.i
  %26 = icmp eq i64 %25, 0
  %27 = sub nuw i64 %.reg2mem20.0.lcssa.i, %25
  %28 = select i1 %26, i64 0, i64 %27
  %29 = add nuw i64 %28, %.reg2mem22.0.lcssa.i
  %30 = icmp slt i64 %29, 17
  br i1 %30, label %32, label %31

31:                                               ; preds = %_data_size_tuple_typ.exit
  %result.i1 = call noalias ptr @bump_malloc_wrapper(i64 noundef %29) #49
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i1, ptr nocapture nofree readonly align 1 %0, i64 %29, i1 noundef false) #41
  store ptr %result.i1, ptr %.sroa.2, align 8
  br label %33

32:                                               ; preds = %_data_size_tuple_typ.exit
  call void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %29, i1 noundef false) #41
  br label %33

33:                                               ; preds = %32, %31
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %34 = insertvalue { ptr, i160 } { ptr @tuple_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %34
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define void @_unbox_tuple_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %2) #38 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %.lr.ph.i, %3
  %.in.i = phi i64 [ %25, %.lr.ph.i ], [ %6, %3 ]
  %8 = phi i64 [ %23, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.i = phi i64 [ %22, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem20.010.i = phi i64 [ %16, %.lr.ph.i ], [ 1, %3 ]
  %9 = inttoptr i64 %.in.i to ptr
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 72
  %12 = load ptr, ptr %11, align 8
  %13 = call { i64, i64 } %12(ptr nonnull align 8 %9) #54
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = extractvalue { i64, i64 } %13, 1
  %16 = call i64 @llvm.umax.i64(i64 %15, i64 %.reg2mem20.010.i)
  %17 = urem i64 %.reg2mem22.011.i, %15
  %18 = icmp eq i64 %17, 0
  %19 = sub nuw i64 %15, %17
  %20 = select i1 %18, i64 0, i64 %19
  %21 = add nuw i64 %14, %.reg2mem22.011.i
  %22 = add nuw i64 %21, %20
  %23 = add nuw i64 %8, 1
  %24 = getelementptr ptr, ptr %1, i64 %23
  %25 = load i64, ptr %24, align 4
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %3
  %.reg2mem20.0.lcssa.i = phi i64 [ 1, %3 ], [ %16, %.lr.ph.i ]
  %.reg2mem22.0.lcssa.i = phi i64 [ 0, %3 ], [ %22, %.lr.ph.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %.reg2mem22.0.lcssa.i, %.reg2mem20.0.lcssa.i
  %30 = icmp eq i64 %29, 0
  %31 = sub nuw i64 %.reg2mem20.0.lcssa.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add nuw i64 %32, %.reg2mem22.0.lcssa.i
  %34 = icmp slt i64 %33, 17
  %35 = select i1 %34, ptr %.fca.1.gep, ptr %28
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %35, i64 %33, i1 noundef false) #41
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_RangeIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @RangeIterator_field_RangeIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @RangeIterator_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4, i32 %5) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -913562485944406675
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 %4) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 %5) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @RangeIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -913562485944406675
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract23, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract24) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #44
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract24) #43
  %15 = icmp sgt i32 %9, %14
  br i1 %15, label %30, label %16

16:                                               ; preds = %3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #44
  %18 = call i32 %8(ptr %.fca.1.extract24) #43
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #44
  %20 = call i32 %8(ptr %.fca.1.extract24) #43
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #44
  %22 = getelementptr i8, ptr %6, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call i32 %24(ptr %.fca.1.extract24) #43
  %26 = add i32 %25, %20
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #44
  %28 = getelementptr i8, ptr %7, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %.fca.1.extract24, i32 %26) #42
  %.sroa.026.0.insert.ext = zext i32 %18 to i160
  br label %30

30:                                               ; preds = %16, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @i32_typ, %16 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.026.0.insert.ext, %16 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_step(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_step(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_end(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_end(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_counter(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_counter(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Range(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @Range_field_Range_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_endi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_step_stepi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 33, i64 32
  %8 = getelementptr [127 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 36, i64 35
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 38
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 40, i64 39
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 42, i64 41
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Range_init_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #42
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %13 = load ptr, ptr %7, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 0) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 1) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Range_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #42
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 %4) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract, i32 1) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Range_step_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #42
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 5490049236840671069
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  ret { ptr, ptr, ptr, i32 } %15
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Range_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  %11 = icmp eq i32 %10, 1
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #43
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr %.fca.1.extract) #43
  %21 = sub i32 %16, %20
  br i1 %11, label %26, label %22

22:                                               ; preds = %3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %24 = call i32 %9(ptr %.fca.1.extract) #43
  %25 = sdiv i32 %21, %24
  br label %26

26:                                               ; preds = %22, %3
  %.reg2mem5.0.in = phi i32 [ %25, %22 ], [ %21, %3 ]
  %.reg2mem5.0 = add i32 %.reg2mem5.0.in, 1
  ret i32 %.reg2mem5.0
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Range_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract) #43
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %16 = getelementptr i8, ptr %6, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #43
  %result.i2 = call noalias align 4 dereferenceable_or_null(12) ptr @bump_malloc_wrapper(i64 noundef 12) #49
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call i32 %22(ptr %.fca.1.extract) #43
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %25 = load ptr, ptr %11, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr %.fca.1.extract) #43
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @RangeIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  store i32 %23, ptr %result.i2, align 4
  %34 = getelementptr i8, ptr %result.i2, i64 4
  store i32 %27, ptr %34, align 4
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %36 = getelementptr i8, ptr %result.i2, i64 8
  store i32 %31, ptr %36, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %37
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_step(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_step(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_end(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_end(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_start(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_start(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Character_getter_codepoint(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_codepoint(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_byte_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_byte_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ConstantTimeIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_List(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i8_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InvalidUTF8Error(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #18 {
  %.fca.0.extract56 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract56, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract56, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract56, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i7 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i8 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i7, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i8, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i9, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 6499063144389013426
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract56, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i18, 3
  call void %11(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56) #44
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract57, i32 0) #42
  %result.i6 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  store ptr %result.i6, ptr %result.i5, align 8
  %23 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> zeroinitializer, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %25 = getelementptr i8, ptr %result.i5, i64 16
  store i32 1, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56) #44
  %27 = getelementptr i8, ptr %7, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %22) #42
  %result.i4 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %31 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i4, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr undef, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  store ptr %result.i.i, ptr %result.i4, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #44
  %35 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %36 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %35)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %38 = getelementptr i8, ptr %result.i4, i64 8
  store i64 %36, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56)
  %40 = getelementptr i8, ptr %7, i64 24
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr i8, ptr %41, i64 8
  %43 = load ptr, ptr %42, align 8
  call void %43(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %33) #42
  ret void
}

define void @InvalidUTF8Error_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4104693287331019315
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i10 = call noalias dereferenceable_or_null(61) ptr @bump_malloc_wrapper(i64 noundef 61) #49
  store <60 x i8> <i8 73, i8 110, i8 118, i8 97, i8 108, i8 105, i8 100, i8 32, i8 85, i8 84, i8 70, i8 45, i8 56, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 99, i8 101, i8 32, i8 101, i8 110, i8 99, i8 111, i8 117, i8 110, i8 116, i8 101, i8 114, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 116, i8 114, i8 105, i8 110, i8 103, i8 32, i8 99, i8 111, i8 110, i8 118, i8 101, i8 114, i8 115, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i10, ptr %result.i9, align 8
  %7 = getelementptr i8, ptr %result.i9, i64 8
  store <2 x i32> <i32 60, i32 60>, ptr %7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #41
  %9 = getelementptr i8, ptr %result.i9, i64 16
  store i32 61, ptr %9, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract, i64 %11
  %13 = getelementptr i8, ptr %12, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %6) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %18 = load ptr, ptr %12, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #42
  %result.i8 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i8, ptr %result.i7, align 8
  %24 = getelementptr i8, ptr %result.i7, i64 8
  store <2 x i32> zeroinitializer, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %26 = getelementptr i8, ptr %result.i7, i64 16
  store i32 1, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %28 = getelementptr i8, ptr %12, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #42
  %result.i6 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  store ptr %result.i.i, ptr %result.i6, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #44
  %36 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %37 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %36)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %39 = getelementptr i8, ptr %result.i6, i64 8
  store i64 %37, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %41 = getelementptr i8, ptr %12, i64 24
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract17, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract18, i32 %3) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 6499063144389013426
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #44
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i12, 3
  call void %16(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %20) #42
  ret void
}

define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
._crit_edge.i.lr.ph:
  %3 = alloca [0 x ptr], align 8
  %result.i5.i130.h2s828 = alloca [10 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(10) %result.i5.i130.h2s828, i8 0, i64 10, i1 false)
  %result.i5.i109.h2s830 = alloca [13 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(13) %result.i5.i109.h2s830, i8 0, i64 13, i1 false)
  %result.i5.i88.h2s832 = alloca [13 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(13) %result.i5.i88.h2s832, i8 0, i64 13, i1 false)
  %result.i5.i67.h2s834 = alloca [8 x i8], align 8
  store i64 0, ptr %result.i5.i67.h2s834, align 8
  %result.i5.i46.h2s836 = alloca [27 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(27) %result.i5.i46.h2s836, i8 0, i64 27, i1 false)
  %result.i5.i.h2s838 = alloca [10 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(10) %result.i5.i.h2s838, i8 0, i64 10, i1 false)
  %.fca.0.extract180 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract182 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract180, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract180, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract180, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #41
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store i8 45, ptr %result.i5.i.h2s838, align 1
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s838, i64 1
  store i64 3255307777713450285, ptr %scevgep, align 1
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %16 = getelementptr inbounds i8, ptr %result.i5.i.h2s838, i64 9
  store i8 0, ptr %16, align 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #41
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(10) %result.i5.i.h2s838) #56
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #57
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store <16 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110>, ptr %result.i5.i46.h2s836, align 16
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %37 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 16
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store <8 x i8> <i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105>, ptr %37, align 16
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %46 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 24
  store i8 108, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %48 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 25
  store i8 101, ptr %48, align 1
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #57
  %52 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 26
  store i8 0, ptr %52, align 2
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #57
  %puts189 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(27) %result.i5.i46.h2s836) #56
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180) #57
  %54 = sext i32 %offset.i to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract180, i64 %54
  %56 = getelementptr i8, ptr %55, i64 8
  %57 = load ptr, ptr %56, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, ptr, ptr, i32 } %58(ptr %.fca.1.extract182) #43
  %.fca.0.extract104 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %.fca.1.extract106 = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  %.fca.2.extract108 = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  %.fca.3.extract110 = extractvalue { ptr, ptr, ptr, i32 } %59, 3
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract104, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract106, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract108, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %.fca.3.extract110, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract104)
  %66 = sext i32 %.fca.3.extract110 to i64
  %67 = getelementptr ptr, ptr %.fca.0.extract104, i64 %66
  %68 = getelementptr i8, ptr %67, i64 104
  %69 = load ptr, ptr %68, align 8
  %result.i16 = call ptr %69({ ptr, ptr, ptr, i32 } %63, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  %70 = call { ptr } %result.i16({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull align 8 %3)
  %.fca.0.extract101 = extractvalue { ptr } %70, 0
  %puts190 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract101) #54
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store <8 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101, i8 0>, ptr %result.i5.i67.h2s834, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts191 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(8) %result.i5.i67.h2s834) #54
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180)
  %85 = load ptr, ptr %55, align 8
  %86 = load ptr, ptr %85, align 8
  %87 = call i32 %86(ptr %.fca.1.extract182) #43
  %88 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %87) #54
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store <8 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115>, ptr %result.i5.i88.h2s832, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %101 = getelementptr inbounds i8, ptr %result.i5.i88.h2s832, i64 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store <4 x i8> <i8 115, i8 97, i8 103, i8 101>, ptr %101, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %.fca.2.extract184 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %108 = getelementptr inbounds i8, ptr %result.i5.i88.h2s832, i64 12
  store i8 0, ptr %108, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts192 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(13) %result.i5.i88.h2s832) #54
  %109 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract180, 0
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %.fca.1.extract182, 1
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %.fca.2.extract184, 2
  %112 = insertvalue { ptr, ptr, ptr, i32 } %111, i32 %offset.i, 3
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180)
  %115 = getelementptr i8, ptr %55, i64 64
  %116 = load ptr, ptr %115, align 8
  %result.i11 = call ptr %116({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  call void %result.i11({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 %3)
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store <8 x i8> <i8 83, i8 116, i8 97, i8 99, i8 107, i8 32, i8 116, i8 114>, ptr %result.i5.i109.h2s830, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %129 = getelementptr inbounds i8, ptr %result.i5.i109.h2s830, i64 8
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store <4 x i8> <i8 97, i8 99, i8 101, i8 58>, ptr %129, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %136 = getelementptr inbounds i8, ptr %result.i5.i109.h2s830, i64 12
  store i8 0, ptr %136, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts193 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(13) %result.i5.i109.h2s830) #54
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180)
  %138 = getelementptr i8, ptr %55, i64 24
  %139 = load ptr, ptr %138, align 8
  %140 = load ptr, ptr %139, align 8
  %141 = call { ptr, ptr, ptr, i32 } %140(ptr %.fca.1.extract182) #43
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %141, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 3
  %142 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %143 = insertvalue { ptr, ptr, ptr, i32 } %142, ptr %.fca.1.extract, 1
  %144 = insertvalue { ptr, ptr, ptr, i32 } %143, ptr %.fca.2.extract, 2
  %145 = insertvalue { ptr, ptr, ptr, i32 } %144, i32 %.fca.3.extract, 3
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract18)
  %148 = sext i32 %.fca.3.extract to i64
  %149 = getelementptr ptr, ptr %.fca.0.extract18, i64 %148
  %150 = getelementptr i8, ptr %149, i64 24
  %151 = load ptr, ptr %150, align 8
  %result.i8 = call ptr %151({ ptr, ptr, ptr, i32 } %145, ptr nocapture nofree noundef nonnull readonly align 8 %3) #47
  call void %result.i8({ ptr, ptr, ptr, i32 } %145, { ptr, ptr, ptr, i32 } %145, ptr nonnull align 8 %3)
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  store <8 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i5.i130.h2s828, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %164 = getelementptr inbounds i8, ptr %result.i5.i130.h2s828, i64 8
  store i8 45, ptr %164, align 8
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #41
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %168 = getelementptr inbounds i8, ptr %result.i5.i130.h2s828, i64 9
  store i8 0, ptr %168, align 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts194 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(10) %result.i5.i130.h2s828) #54
  ret void
}

define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract7) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract1) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 104
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #54
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  call void %9(ptr %.fca.1.extract, i32 0) #42
  %result.i10 = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #49
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  store ptr %result.i10, ptr %result.i9, align 8
  %13 = getelementptr i8, ptr %result.i9, i64 8
  store <2 x i32> <i32 6, i32 6>, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %15 = getelementptr i8, ptr %result.i9, i64 16
  store i32 7, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %17 = getelementptr i8, ptr %6, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %12) #42
  %result.i8 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i8, ptr %result.i7, align 8
  %24 = getelementptr i8, ptr %result.i7, i64 8
  store <2 x i32> zeroinitializer, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %26 = getelementptr i8, ptr %result.i7, i64 16
  store i32 1, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %28 = getelementptr i8, ptr %6, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #42
  %result.i6 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  store ptr %result.i.i, ptr %result.i6, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #44
  %36 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %37 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %36)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %39 = getelementptr i8, ptr %result.i6, i64 8
  store i64 %37, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %41 = getelementptr i8, ptr %6, i64 24
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #42
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Stacktrace(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Stacktrace_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Stacktrace_B_print_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Stacktrace_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -59384212523717097
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract15, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %9(ptr %.fca.1.extract, { ptr } %10) #42
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #44
  %12 = load ptr, ptr %6, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call { ptr } %13(ptr %.fca.1.extract) #43
  %15 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %14)
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract15)
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i64 %15) #42
  ret void
}

define void @Stacktrace_print_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -59384212523717097
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract8, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call { ptr } %8(ptr %.fca.1.extract) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #44
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i64 %13(ptr %.fca.1.extract) #43
  call void @print_backtrace({ ptr } %9, i64 %14)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @Stacktrace_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Stacktrace_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Stacktrace_getter_stacktrace(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Stacktrace_setter_stacktrace(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #3 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @InvalidUTF8Error_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_char_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_char_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_byte_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_byte_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #3 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #35 {
  %result.i3 = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #49
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %result.i3, align 1
  %result.i2 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i3, ptr %result.i2, align 8
  %7 = getelementptr i8, ptr %result.i2, i64 8
  store <2 x i32> <i32 6, i32 6>, ptr %7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %9 = getelementptr i8, ptr %result.i2, i64 16
  store i32 7, ptr %9, align 8
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_f64_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i64_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @Array_field_Array_2(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_bounds_check_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_insert_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_empty_(ptr nocapture nofree %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #41
  ret ptr @Array__Self_empty_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterableT(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #41
  ret ptr @Array__Self_from_iterable_iterableIterableT
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_last_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_extend_otherIterableT_extend_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 56, i64 55
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_indices_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_values_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__set_index_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 616
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 624
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 632
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 72, i64 71
  %8 = getelementptr [529 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 664
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 75, i64 74
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 76, i64 77
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 79, i64 78
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 81, i64 80
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 736
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %8 = load ptr, ptr %result.i, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %result.i1 = call { i64, i64 } %10(ptr nocapture nofree nonnull readonly align 8 %result.i) #45
  %11 = extractvalue { i64, i64 } %result.i1, 0
  %result.i2 = call noalias ptr @bump_malloc_wrapper(i64 noundef %11) #49
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %16(ptr nonnull %.fca.1.extract, { ptr } %17) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %19 = getelementptr i8, ptr %6, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr nonnull %.fca.1.extract, i32 0) #42
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %24 = getelementptr i8, ptr %6, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr nonnull %.fca.1.extract, i32 1) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr nonnull %.fca.1.extract, i32 %3) #42
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr nonnull %.fca.1.extract) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %17 = load ptr, ptr %7, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %18 = sext i32 %15 to i64
  %19 = load ptr, ptr %result.i, align 8
  %20 = getelementptr i8, ptr %19, i64 72
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call { i64, i64 } %21(ptr nocapture nofree nonnull readonly align 8 %result.i) #45
  %22 = extractvalue { i64, i64 } %result.i1, 0
  %23 = mul i64 %22, %18
  %result.i2 = call noalias ptr @bump_malloc_wrapper(i64 noundef %23) #49
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %25 = getelementptr i8, ptr %7, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %28(ptr nonnull %.fca.1.extract, { ptr } %29) #42
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %31 = getelementptr i8, ptr %7, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr nonnull %.fca.1.extract, i32 0) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #5 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract12, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #44
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, i32 %4) #42
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #44
  %20 = getelementptr i8, ptr %9, i64 24
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #43
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %.loopexit

12:                                               ; preds = %4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr nonnull %.fca.1.extract, i32 %3) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr } %19(ptr nonnull %.fca.1.extract) #43
  %.fca.0.extract56 = extractvalue { ptr } %20, 0
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %22 = load ptr, ptr %8, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = call i32 %23(ptr nonnull %.fca.1.extract) #43
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %26 = load ptr, ptr %7, align 8
  %result.i3 = call nonnull align 8 dereferenceable(8) ptr %26(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %27 = sext i32 %24 to i64
  %28 = load ptr, ptr %result.i3, align 8
  %29 = getelementptr i8, ptr %28, i64 72
  %30 = load ptr, ptr %29, align 8
  %result.i6 = call { i64, i64 } %30(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45
  %31 = extractvalue { i64, i64 } %result.i6, 0
  %32 = mul i64 %31, %27
  %result.i8 = call noalias ptr @bump_malloc_wrapper(i64 noundef %32) #49
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %34 = load ptr, ptr %17, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %result.i8, 0
  call void %36(ptr nonnull %.fca.1.extract, { ptr } %37) #42
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr nonnull %.fca.1.extract) #43
  %43 = icmp sgt i32 %42, 0
  br i1 %43, label %._crit_edge.lr.ph, label %.loopexit

._crit_edge.lr.ph:                                ; preds = %12
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %46 = load ptr, ptr %7, align 8
  %result.i2 = call nonnull align 8 dereferenceable(8) ptr %46(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %47 = load ptr, ptr %result.i2, align 8
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i5 = call { i64, i64 } %49(ptr nocapture nofree nonnull readonly align 8 %result.i2) #45
  %50 = extractvalue { i64, i64 } %result.i5, 0
  %51 = mul i64 %50, %indvars.iv
  %52 = getelementptr i8, ptr %.fca.0.extract56, i64 %51
  %53 = getelementptr i8, ptr %47, i64 56
  %54 = load ptr, ptr %53, align 8
  %result.i7 = call { ptr, i160 } %54(ptr nocapture nofree readonly %52, ptr nocapture nofree nonnull readonly align 8 %result.i2) #45
  %55 = load ptr, ptr %17, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = call { ptr } %56(ptr nonnull %.fca.1.extract) #43
  %.fca.0.extract39 = extractvalue { ptr } %57, 0
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #44
  %59 = getelementptr i8, ptr %.fca.0.extract39, i64 %51
  %60 = getelementptr i8, ptr %47, i64 64
  %61 = load ptr, ptr %60, align 8
  call void %61({ ptr, i160 } %result.i7, ptr nocapture nofree nonnull readonly align 8 %result.i2, ptr nocapture nofree writeonly %59) #46
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %62 = load ptr, ptr %39, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call i32 %63(ptr nonnull %.fca.1.extract) #43
  %65 = sext i32 %64 to i64
  %66 = icmp slt i64 %indvars.iv.next, %65
  br i1 %66, label %._crit_edge, label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %12, %4
  ret void
}

define void @Array_bounds_check_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #18 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca [4 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %14 = sext i32 %offset.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract, i64 %14
  %16 = getelementptr i8, ptr %15, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #43
  %20 = add i32 %19, -1
  %21 = icmp sgt i32 %3, %20
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %23 = call i32 %18(ptr %.fca.1.extract) #43
  %24 = add i32 %23, %3
  %25 = icmp slt i32 %24, 0
  %.0 = select i1 %21, i1 true, i1 %25
  br i1 %.0, label %codeRepl, label %._crit_edge

codeRepl:                                         ; preds = %4
  call fastcc void @Array_bounds_check_indexi32.cold.1(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract, ptr %.fca.1.extract, ptr nocapture nofree noundef nonnull readonly %18, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %5, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7, i32 %3, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %12) #59
  br label %._crit_edge

._crit_edge:                                      ; preds = %codeRepl, %4
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Array_unchecked_index_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract12, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr nonnull %.fca.1.extract13) #43
  %.fca.0.extract2 = extractvalue { ptr } %11, 0
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #44
  %13 = load ptr, ptr %7, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract13) #45
  %14 = sext i32 %3 to i64
  %15 = load ptr, ptr %result.i, align 8
  %16 = getelementptr i8, ptr %15, i64 72
  %17 = load ptr, ptr %16, align 8
  %result.i1 = call { i64, i64 } %17(ptr nocapture nofree nonnull readonly align 8 %result.i) #45
  %18 = extractvalue { i64, i64 } %result.i1, 0
  %19 = mul i64 %18, %14
  %20 = getelementptr i8, ptr %.fca.0.extract2, i64 %19
  %21 = getelementptr i8, ptr %15, i64 56
  %22 = load ptr, ptr %21, align 8
  %result.i2 = call { ptr, i160 } %22(ptr nocapture nofree readonly %20, ptr nocapture nofree nonnull readonly align 8 %result.i) #45
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_unchecked_insert_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #6 {
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract14, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr nonnull %.fca.1.extract15) #43
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #44
  %14 = load ptr, ptr %8, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %14(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract15) #45
  %15 = sext i32 %3 to i64
  %16 = load ptr, ptr %result.i, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %result.i) #45
  %19 = extractvalue { i64, i64 } %result.i1, 0
  %20 = mul i64 %19, %15
  %21 = getelementptr i8, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %16, i64 64
  %23 = load ptr, ptr %22, align 8
  call void %23({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %result.i, ptr nocapture nofree writeonly %21) #46
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array__Self_empty_(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #36 {
  %2 = load ptr, ptr %0, align 8
  %result.i2 = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %2, ptr %result.i2, align 8
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i2) #41
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %result.i1.i = call { i64, i64 } %9(ptr nocapture nofree nonnull readonly align 8 %2) #45
  %10 = extractvalue { i64, i64 } %result.i1.i, 0
  %result.i2.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %10) #49
  %11 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr %result.i2.i, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i2, i64 16
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  store <2 x i32> <i32 0, i32 1>, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 93, 3
  ret { ptr, ptr, ptr, i32 } %14
}

define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterableT(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #18 {
  %.fca.0.extract47 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract47, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract48, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract49, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i, 3
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract47) #41
  %8 = sext i32 %.fca.3.extract32 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract47, i64 %8
  %10 = load ptr, ptr %9, align 8
  %result.i1 = call align 8 ptr %10(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #45
  %result.i2.i = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i1, ptr %result.i2.i, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i2.i) #41
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i2.i, 1
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  %14 = load ptr, ptr %result.i1, align 8
  %15 = getelementptr i8, ptr %14, i64 72
  %16 = load ptr, ptr %15, align 8
  %result.i1.i = call { i64, i64 } %16(ptr nocapture nofree nonnull readonly align 8 %result.i1) #45
  %17 = extractvalue { i64, i64 } %result.i1.i, 0
  %result.i2.i29 = call noalias ptr @bump_malloc_wrapper(i64 noundef %17) #49
  %18 = getelementptr inbounds i8, ptr %result.i2.i, i64 8
  store ptr %result.i2.i29, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i2.i, i64 16
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  store <2 x i32> <i32 0, i32 1>, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 10, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract47) #41
  %23 = load ptr, ptr %9, align 8
  %result.i = call ptr %23(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #45
  %result.i4 = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %24 = getelementptr inbounds i8, ptr %result.i4, i64 8
  store ptr %result.i, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %result.i4, i64 16
  store ptr null, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i4) #41
  store ptr @Iterable, ptr %result.i4, align 8
  %27 = alloca [1 x ptr], align 8
  store ptr %result.i4, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27) #41
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #41
  %30 = getelementptr i8, ptr %.fca.0.extract47, i64 24
  %31 = getelementptr i8, ptr %.fca.0.extract47, i64 32
  %32 = load i64, ptr %hash_coef_ptr.i, align 4
  %33 = load i64, ptr %tbl_size_ptr.i, align 4
  %34 = load ptr, ptr %30, align 8
  %35 = load ptr, ptr %31, align 8
  %result.i.i30 = call i1 %34(i64 %33, i64 %32, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %35) #45
  %36 = select i1 %result.i.i30, i64 56, i64 55
  %37 = getelementptr [529 x ptr], ptr @Array, i64 0, i64 %36
  %38 = getelementptr i8, ptr %37, i64 80
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 dereferenceable(8) %27, { ptr, ptr, ptr, i32 } %6)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %hash_coef_ptr.i17 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i18 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i19 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i20 = load i64, ptr %hash_coef_ptr.i17, align 4
  %tbl_size.i21 = load i64, ptr %tbl_size_ptr.i18, align 4
  %offset_tbl.i22 = load ptr, ptr %offset_tbl_ptr.i19, align 8
  %product.i.i23 = mul i64 %hash_coef.i20, -83120161364696977
  %shifted.i.i24 = lshr i64 %product.i.i23, 32
  %xored.i.i25 = xor i64 %shifted.i.i24, %product.i.i23
  %hash.i.i26 = and i64 %xored.i.i25, %tbl_size.i21
  %offset_ptr.i27 = getelementptr i32, ptr %offset_tbl.i22, i64 %hash.i.i26
  %offset.i28 = load i32, ptr %offset_ptr.i27, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %offset.i28, 3
  ret { ptr, ptr, ptr, i32 } %44
}

define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract37, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract38) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #44
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %.fca.1.extract38) #43
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract37, 0
  %.pre17 = insertvalue { ptr, ptr, ptr, i32 } %.pre16, ptr %.fca.1.extract38, 1
  %.pre19 = insertvalue { ptr, ptr, ptr, i32 } %.pre17, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #44
  %21 = call i32 %17(ptr %.fca.1.extract38) #43
  %22 = shl i32 %21, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract37, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract38, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #44
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #44
  %29 = getelementptr i8, ptr %9, i64 72
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  call void %result.i2({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %22)
  %.pre = load ptr, ptr %10, align 8
  %.pre15 = load ptr, ptr %.pre, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %19, %.._crit_edge_crit_edge
  %.pre-phi20 = phi { ptr, ptr, ptr, i32 } [ %.pre19, %.._crit_edge_crit_edge ], [ %25, %19 ]
  %31 = phi ptr [ %12, %.._crit_edge_crit_edge ], [ %.pre15, %19 ]
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %33 = call i32 %31(ptr nonnull %.fca.1.extract38) #43
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %35 = getelementptr i8, ptr %9, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr nonnull %.fca.1.extract38) #43
  %.fca.0.extract52 = extractvalue { ptr } %38, 0
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %40 = load ptr, ptr %9, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract38) #45
  %41 = sext i32 %33 to i64
  %42 = load ptr, ptr %result.i, align 8
  %43 = getelementptr i8, ptr %42, i64 72
  %44 = load ptr, ptr %43, align 8
  %result.i1 = call { i64, i64 } %44(ptr nocapture nofree nonnull readonly align 8 %result.i) #45
  %45 = extractvalue { i64, i64 } %result.i1, 0
  %46 = mul i64 %45, %41
  %47 = getelementptr i8, ptr %.fca.0.extract52, i64 %46
  %48 = getelementptr i8, ptr %42, i64 64
  %49 = load ptr, ptr %48, align 8
  call void %49({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i, ptr nocapture nofree writeonly %47) #46
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %51 = load ptr, ptr %10, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr nonnull %.fca.1.extract38) #43
  %54 = add i32 %53, 1
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %56 = getelementptr i8, ptr %51, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr nonnull %.fca.1.extract38, i32 %54) #42
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, -83120161364696977
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %58 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi20, i32 %offset.i14, 3
  ret { ptr, ptr, ptr, i32 } %58
}

define { ptr, ptr, ptr, i32 } @Array_extend_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract60 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i6 = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i7 = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i8 = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i6, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i7, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i8, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, 1375598993350293883
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract58) #57
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract58, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract59) #43
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract25, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract26, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract27, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %offset.i17, 3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract25)
  %21 = sext i32 %offset.i17 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract25, i64 %21
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %result.i5 = call ptr %24({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %25 = call i32 %result.i5({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %5)
  %26 = add i32 %25, %14
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract58, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract59, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract60, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %offset.i, 3
  %31 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract58)
  %34 = getelementptr i8, ptr %10, i64 72
  %35 = load ptr, ptr %34, align 8
  %36 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %36, align 8
  %result.i4 = call ptr %35({ ptr, ptr, ptr, i32 } %30, ptr nocapture nofree noundef nonnull readonly align 8 %36) #47
  call void %result.i4({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 dereferenceable(8) %31, i32 %26)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract25)
  %39 = getelementptr i8, ptr %22, i64 24
  %40 = load ptr, ptr %39, align 8
  %result.i3 = call ptr %40({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %41 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i18 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i19 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i18, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i19, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i20, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 8673632051301757104
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.1.extract, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.2.extract, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %offset.i29, 3
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %48 = sext i32 %offset.i29 to i64
  %49 = getelementptr ptr, ptr %.fca.0.extract, i64 %48
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = getelementptr inbounds i8, ptr %6, i64 8
  %52 = getelementptr i8, ptr %10, i64 96
  %53 = getelementptr inbounds i8, ptr %7, i64 8
  %54 = load ptr, ptr %50, align 8
  %result.i243 = call ptr %54({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %55 = call { ptr, i160 } %result.i243({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %5)
  %.fca.0.extract8144 = extractvalue { ptr, i160 } %55, 0
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %57 = icmp ne ptr %.fca.0.extract8144, @nil_typ
  %58 = icmp ne ptr %.fca.0.extract8144, null
  %.not8745 = and i1 %57, %58
  br i1 %.not8745, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %4
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.fca.0.extract8147 = phi ptr [ %.fca.0.extract8144, %._crit_edge.lr.ph ], [ %.fca.0.extract81, %._crit_edge ]
  %60 = phi { ptr, i160 } [ %55, %._crit_edge.lr.ph ], [ %68, %._crit_edge ]
  %.046 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %66, %._crit_edge ]
  %61 = load ptr, ptr %10, align 8
  %62 = add i32 %.046, %14
  %result.i = call ptr %61(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract59) #45
  store ptr @_parameterization_i32, ptr %6, align 8
  store ptr %result.i, ptr %51, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %65 = load ptr, ptr %52, align 8
  store ptr @i32_typ, ptr %7, align 8
  store ptr %.fca.0.extract8147, ptr %53, align 8
  %result.i1 = call ptr %65({ ptr, ptr, ptr, i32 } %30, ptr nocapture nofree noundef nonnull readonly %7) #47
  call void %result.i1({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 dereferenceable(16) %6, i32 %62, { ptr, i160 } %60)
  %66 = add i32 %.046, 1
  %67 = load ptr, ptr %50, align 8
  %result.i2 = call ptr %67({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly %5) #47
  %68 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %5)
  %.fca.0.extract81 = extractvalue { ptr, i160 } %68, 0
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %70 = icmp ne ptr %.fca.0.extract81, @nil_typ
  %71 = icmp ne ptr %.fca.0.extract81, null
  %.not87 = and i1 %70, %71
  br i1 %.not87, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %73 = load ptr, ptr %11, align 8
  %74 = getelementptr i8, ptr %73, i64 8
  %75 = load ptr, ptr %74, align 8
  call void %75(ptr %.fca.1.extract59, i32 %26) #42
  %hash_coef.i33 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i34 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i35 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i36 = mul i64 %hash_coef.i33, -83120161364696977
  %shifted.i.i37 = lshr i64 %product.i.i36, 32
  %xored.i.i38 = xor i64 %shifted.i.i37, %product.i.i36
  %hash.i.i39 = and i64 %xored.i.i38, %tbl_size.i34
  %offset_ptr.i40 = getelementptr i32, ptr %offset_tbl.i35, i64 %hash.i.i39
  %offset.i41 = load i32, ptr %offset_ptr.i40, align 4
  %76 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %offset.i41, 3
  ret { ptr, ptr, ptr, i32 } %76
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Array_indices_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  %result.i2 = call noalias align 4 dereferenceable_or_null(12) ptr @bump_malloc_wrapper(i64 noundef 12) #49
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %12 = load ptr, ptr %7, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract) #43
  %15 = add i32 %14, -1
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  store i32 0, ptr %result.i2, align 4
  %18 = getelementptr i8, ptr %result.i2, i64 4
  store i32 %15, ptr %18, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  %20 = getelementptr i8, ptr %result.i2, i64 8
  store i32 1, ptr %20, align 4
  %21 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 53, 3
  ret { ptr, ptr, ptr, i32 } %21
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_values_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i, 3
  ret { ptr, ptr, ptr, i32 } %7
}

define { ptr, i160 } @Array__index_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.1.extract = extractvalue { ptr, i160 } %3, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract18, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i, 3
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11) #41
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %14 = sext i32 %offset.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract17, i64 %14
  %16 = getelementptr i8, ptr %15, i64 80
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %18, align 8
  %result.i1 = call ptr %17({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %18) #47
  call void %result.i1({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %11, i32 %.sroa.1.8.extract.trunc)
  %19 = icmp slt i32 %.sroa.1.8.extract.trunc, 0
  br i1 %19, label %20, label %._crit_edge

20:                                               ; preds = %4
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract17)
  %22 = getelementptr i8, ptr %15, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call i32 %24(ptr %.fca.1.extract18) #43
  %26 = add i32 %25, %.sroa.1.8.extract.trunc
  br label %._crit_edge

._crit_edge:                                      ; preds = %20, %4
  %.0 = phi i32 [ %26, %20 ], [ %.sroa.1.8.extract.trunc, %4 ]
  store ptr @_parameterization_i32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract17)
  %29 = getelementptr i8, ptr %15, i64 88
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %6) #47
  %31 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %5, i32 %.0)
  ret { ptr, i160 } %31
}

define void @Array__set_index_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #18 {
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.1.extract8 = extractvalue { ptr, i160 } %3, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract8 to i32
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract25, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract26, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i, 3
  %12 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract25) #41
  %15 = sext i32 %offset.i to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract25, i64 %15
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  %19 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %19, align 8
  %result.i2 = call ptr %18({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly align 8 %19) #47
  call void %result.i2({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 dereferenceable(8) %12, i32 %.sroa.1.8.extract.trunc)
  %20 = icmp slt i32 %.sroa.1.8.extract.trunc, 0
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %5
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %23 = getelementptr i8, ptr %16, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr nonnull %.fca.1.extract26) #43
  %27 = add i32 %26, %.sroa.1.8.extract.trunc
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %5
  %.0 = phi i32 [ %27, %21 ], [ %.sroa.1.8.extract.trunc, %5 ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %29 = load ptr, ptr %16, align 8
  %result.i = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract26) #45
  store ptr @_parameterization_i32, ptr %6, align 8
  %30 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %result.i, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %33 = getelementptr i8, ptr %16, i64 96
  %34 = load ptr, ptr %33, align 8
  store ptr @i32_typ, ptr %7, align 8
  %35 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.0.extract, ptr %35, align 8
  %result.i1 = call ptr %34({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly %7) #47
  call void %result.i1({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 dereferenceable(16) %6, i32 %.0, { ptr, i160 } %4)
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i1, ptr %result.i5, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #41
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, -5261542750394134544
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %12 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %.fca.0.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.1.extract, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.2.extract, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store i32 %offset.i17, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 16 dereferenceable(208) @ArrayIterator) #41
  %17 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 0, ptr %17, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 23, 3
  ret { ptr, ptr, ptr, i32 } %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #35 {
  %result.i3 = call noalias dereferenceable_or_null(6) ptr @bump_malloc_wrapper(i64 noundef 6) #49
  store <5 x i8> <i8 65, i8 114, i8 114, i8 97, i8 121>, ptr %result.i3, align 1
  %result.i2 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i3, ptr %result.i2, align 8
  %7 = getelementptr i8, ptr %result.i2, i64 8
  store <2 x i32> <i32 5, i32 5>, ptr %7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %9 = getelementptr i8, ptr %result.i2, i64 16
  store i32 6, ptr %9, align 8
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3447345754186651411
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, -5261542750394134544
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #44
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract18, i32 0) #42
  ret void
}

define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3447345754186651411
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract29, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract31) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #44
  %15 = getelementptr i8, ptr %9, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract31) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract) #44
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 128
  %28 = load ptr, ptr %27, align 8
  %result.i1 = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %29 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4)
  %.not = icmp slt i32 %13, %29
  br i1 %.not, label %30, label %56

30:                                               ; preds = %3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %32 = load ptr, ptr %10, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract31) #43
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %36 = call i32 %33(ptr %.fca.1.extract31) #43
  %37 = add i32 %36, 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %39 = getelementptr i8, ptr %32, i64 8
  %40 = load ptr, ptr %39, align 8
  call void %40(ptr %.fca.1.extract31, i32 %37) #42
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %42 = load ptr, ptr %15, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr, ptr, ptr, i32 } %43(ptr %.fca.1.extract31) #43
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %.fca.3.extract51 = extractvalue { ptr, ptr, ptr, i32 } %44, 3
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.1.extract47, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.2.extract49, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %.fca.3.extract51, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract45)
  %51 = sext i32 %.fca.3.extract51 to i64
  %52 = getelementptr ptr, ptr %.fca.0.extract45, i64 %51
  %53 = getelementptr i8, ptr %52, i64 88
  %54 = load ptr, ptr %53, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %54({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %6) #47
  %55 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(8) %5, i32 %34)
  %.fca.0.extract39 = extractvalue { ptr, i160 } %55, 0
  %.fca.1.extract41 = extractvalue { ptr, i160 } %55, 1
  br label %56

56:                                               ; preds = %30, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract39, %30 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract41, %30 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBounds(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 136, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @OutOfBounds_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #18 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5348403617834207535
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i13 = call noalias align 4 dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #49
  store i32 %3, ptr %result.i13, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails) #41
  %7 = getelementptr i8, ptr %result.i13, i64 4
  store i32 %4, ptr %7, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = ptrtoint ptr %result.i13 to i64
  %.sroa.3.8.insert.ext = zext i64 %14 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %15 = insertvalue { ptr, i160 } { ptr @OutOfBoundsDetails, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  call void %13(ptr %.fca.1.extract, { ptr, i160 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %17 = getelementptr i8, ptr %10, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #42
  %result.i12 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %result.i11 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i12, ptr %result.i11, align 8
  %24 = getelementptr i8, ptr %result.i11, i64 8
  store <2 x i32> zeroinitializer, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %26 = getelementptr i8, ptr %result.i11, i64 16
  store i32 1, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %28 = getelementptr i8, ptr %10, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #42
  %result.i10 = call noalias dereferenceable_or_null(66) ptr @bump_malloc_wrapper(i64 noundef 66) #49
  store <65 x i8> <i8 65, i8 110, i8 32, i8 111, i8 117, i8 116, i8 45, i8 111, i8 102, i8 45, i8 98, i8 111, i8 117, i8 110, i8 100, i8 115, i8 32, i8 101, i8 114, i8 114, i8 111, i8 114, i8 32, i8 111, i8 99, i8 99, i8 117, i8 114, i8 114, i8 101, i8 100, i8 32, i8 119, i8 104, i8 105, i8 108, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 116, i8 111, i8 32, i8 97, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  store ptr %result.i10, ptr %result.i9, align 8
  %35 = getelementptr i8, ptr %result.i9, i64 8
  store <2 x i32> <i32 65, i32 65>, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %37 = getelementptr i8, ptr %result.i9, i64 16
  store i32 66, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %39 = getelementptr i8, ptr %10, i64 24
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  call void %42(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #42
  %result.i8 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %43 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr undef, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  store ptr %result.i.i, ptr %result.i8, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #44
  %47 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %48 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %47)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %50 = getelementptr i8, ptr %result.i8, i64 8
  store i64 %48, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %52 = getelementptr i8, ptr %10, i64 32
  %53 = load ptr, ptr %52, align 8
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  call void %55(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %45) #42
  ret void
}

define void @OutOfBounds_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5348403617834207535
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract16) #43
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract6, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract5) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract5, i64 %18
  %20 = getelementptr i8, ptr %19, i64 104
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract3 = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract3) #54
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract14)
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr, i160 } %25(ptr %.fca.1.extract16) #43
  %.fca.0.extract = extractvalue { ptr, i160 } %26, 0
  %27 = icmp ne ptr %.fca.0.extract, @nil_typ
  %28 = icmp ne ptr %.fca.0.extract, null
  %.not41 = and i1 %27, %28
  br i1 %.not41, label %29, label %._crit_edge

29:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %26, 1
  %.sroa.3.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.0.extract.shift to i64
  %.sroa.039.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %30 = inttoptr i64 %.sroa.039.0.extract.trunc to ptr
  %31 = inttoptr i64 %.sroa.3.0.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 4650630525701360429
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %30, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %31, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %offset.i13, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %38 = sext i32 %offset.i13 to i64
  %39 = getelementptr ptr, ptr %.fca.0.extract, i64 %38
  %40 = getelementptr i8, ptr %39, i64 24
  %41 = load ptr, ptr %40, align 8
  %result.i = call ptr %41({ ptr, ptr, ptr, i32 } %35, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  call void %result.i({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull align 8 %4)
  br label %._crit_edge

._crit_edge:                                      ; preds = %29, %3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBoundsDetails(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @OutOfBoundsDetails_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4650630525701360429
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #42
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 %4) #42
  ret void
}

; Function Attrs: nounwind
define void @OutOfBoundsDetails_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
RangeIterator_next_.exit52.i.preheader:
  %result.i5.i49.h2s60 = alloca [26 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i5.i49.h2s60, i8 0, i64 26, i1 false)
  %result.i5.i.h2s62 = alloca [45 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(45) %result.i5.i.h2s62, i8 0, i64 45, i1 false)
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4650630525701360429
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #41
  store i8 84, ptr %result.i5.i.h2s62, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s62, i64 1
  store <43 x i8> <i8 104, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 32, i8 111, i8 102, i8 32, i8 116, i8 104, i8 101, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 32, i8 98, i8 101, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 101, i8 100, i8 32, i8 119, i8 97, i8 115>, ptr %scevgep, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #41
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #41
  %6 = getelementptr inbounds i8, ptr %result.i5.i.h2s62, i64 44
  store i8 0, ptr %6, align 1
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(45) %result.i5.i.h2s62) #56
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #57
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract49, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call i32 %11(ptr %.fca.1.extract) #43
  %13 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %12) #54
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #44
  store i8 84, ptr %result.i5.i49.h2s60, align 1
  %scevgep57 = getelementptr inbounds i8, ptr %result.i5.i49.h2s60, i64 1
  store <24 x i8> <i8 104, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 97, i8 114, i8 103, i8 117, i8 109, i8 101, i8 110, i8 116, i8 32, i8 119, i8 97, i8 115>, ptr %scevgep57, align 1
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %17 = getelementptr inbounds i8, ptr %result.i5.i49.h2s60, i64 25
  store i8 0, ptr %17, align 1
  %puts51 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(26) %result.i5.i49.h2s60) #54
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract49)
  %19 = getelementptr i8, ptr %9, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i32 %21(ptr %.fca.1.extract) #43
  %23 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %22) #54
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_bounds(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_bounds(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 104
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 112
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 120
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 128
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 104
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 112
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 120
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 128
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBounds_getter_line_number(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_line_number(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @OutOfBounds_getter_details(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, i160 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load i160, ptr %4, align 8
  %6 = insertvalue { ptr, i160 } %3, i160 %5, 1
  ret { ptr, i160 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_details(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, i160 } %1) #3 {
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store i160 %.fca.1.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Indexable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IndexableCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_8(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @CuckooMap_B__Self_max_displacements_(ptr nocapture nofree %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #41
  ret ptr @CuckooMap__Self_max_displacements_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash1_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_resize_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_keys_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_indices_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_values_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 616
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 624
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 632
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 648
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 656
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 74, i64 73
  %8 = getelementptr [1144 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 680
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 77, i64 76
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1144 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 78, i64 79
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1144 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 81, i64 80
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1144 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 83, i64 82
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1144 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @CuckooMap__Self_max_displacements_(ptr nocapture nofree readnone %0) #1 {
  ret i32 100
}

define i32 @CuckooMap_hash1_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = getelementptr i8, ptr %7, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract11) #43
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = call i32 %.fca.0.extract({ ptr, i160 } %3)
  ret i32 %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @CuckooMap_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #1 {
  %5 = add i32 %3, 2127912214
  %6 = shl i32 %3, 12
  %7 = add i32 %5, %6
  %8 = ashr i32 %7, 19
  %9 = xor i32 %7, %8
  %10 = xor i32 %9, -949894596
  %11 = add i32 %10, 374761393
  %12 = shl i32 %10, 5
  %13 = add i32 %11, %12
  %14 = add i32 %13, -744332180
  %15 = shl i32 %13, 9
  %16 = xor i32 %14, %15
  %17 = add i32 %16, -42973499
  %18 = shl i32 %16, 3
  %19 = add i32 %17, %18
  %20 = ashr i32 %19, 16
  %21 = xor i32 %19, %20
  %22 = xor i32 %21, -1252372727
  ret i32 %22
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @CuckooMap_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #43
  %12 = add i32 %11, -1
  %13 = and i32 %12, %3
  ret i32 %13
}

define i32 @CuckooMap_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #18 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %9, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9) #41
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 88
  %15 = load ptr, ptr %14, align 8
  %16 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %16, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %16) #47
  %17 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 dereferenceable(8) %9, i32 %3)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %19 = getelementptr i8, ptr %13, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i32 %21(ptr %.fca.1.extract) #43
  %23 = add i32 %22, -1
  %24 = and i32 %23, %17
  ret i32 %24
}

define { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #18 {
.lr.ph:
  %4 = alloca {}, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i7 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i8 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i7, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i8, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i9, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 4015701072841558310
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46) #41
  %10 = sext i32 %offset.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract46, i64 %10
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract46, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract47, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract48, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i, 3
  %16 = getelementptr i8, ptr %11, i64 104
  %17 = getelementptr i8, ptr %11, i64 32
  %18 = getelementptr i8, ptr %11, i64 96
  %19 = getelementptr i8, ptr %11, i64 24
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46) #41
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #41
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %4) #41
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  br label %24

24:                                               ; preds = %88, %.lr.ph
  %.096 = phi i32 [ 0, %.lr.ph ], [ %25, %88 ]
  %.022895 = phi i1 [ true, %.lr.ph ], [ %.2, %88 ]
  %.sroa.5207.094 = phi ptr [ undef, %.lr.ph ], [ %.sroa.5207.2, %88 ]
  %.sroa.3206.093 = phi ptr [ undef, %.lr.ph ], [ %.sroa.3206.2, %88 ]
  %.sroa.0.091 = phi ptr [ %.fca.0.extract, %.lr.ph ], [ %.sroa.0.1, %88 ]
  %.sroa.6.090 = phi ptr [ %.fca.1.extract, %.lr.ph ], [ %.sroa.6.1, %88 ]
  %.sroa.12.089 = phi ptr [ %.fca.2.extract, %.lr.ph ], [ %.sroa.12.1, %88 ]
  %.sroa.17.088 = phi i32 [ %offset.i18, %.lr.ph ], [ %.sroa.17.1, %88 ]
  %.sroa.0275.087 = phi ptr [ undef, %.lr.ph ], [ %.sroa.0275.0..sroa.speculated315, %88 ]
  %.sroa.3.sroa.0.086 = phi i64 [ undef, %.lr.ph ], [ %.sroa.3.sroa.0.1, %88 ]
  %.sroa.3.sroa.3.085 = phi i64 [ undef, %.lr.ph ], [ %.sroa.3.sroa.3.1, %88 ]
  %.sroa.0316.084 = phi ptr [ undef, %.lr.ph ], [ %.sroa.speculated315..sroa.0316.0, %88 ]
  %.sroa.6318.083 = phi i64 [ undef, %.lr.ph ], [ %.sroa.6318.1, %88 ]
  %.sroa.3.032082 = phi i64 [ undef, %.lr.ph ], [ %.sroa.3.1, %88 ]
  %.sroa.1.sroa.3.sroa.0.081 = phi i64 [ undef, %.lr.ph ], [ %.sroa.1.sroa.3.sroa.0.3, %88 ]
  %.sroa.1.sroa.0.sroa.0.080 = phi i64 [ undef, %.lr.ph ], [ %.sroa.1.sroa.0.sroa.0.3, %88 ]
  %25 = add nuw nsw i32 %.096, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.091, 0
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %.sroa.6.090, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.sroa.12.089, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %.sroa.17.088, 3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.091) #41
  %31 = sext i32 %.sroa.17.088 to i64
  %32 = getelementptr ptr, ptr %.sroa.0.091, i64 %31
  %33 = getelementptr i8, ptr %32, i64 64
  %34 = load ptr, ptr %33, align 8
  %result.i4 = call ptr %34({ ptr, ptr, ptr, i32 } %29, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %35 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull align 8 %4)
  br i1 %.022895, label %36, label %51

36:                                               ; preds = %24
  store ptr @_parameterization_i32, ptr %5, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %39 = load ptr, ptr %18, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i3 = call ptr %39({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %6) #47
  %40 = call i32 %result.i3({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 dereferenceable(8) %5, i32 %35)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %42 = load ptr, ptr %19, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr nonnull %.fca.1.extract47) #43
  %.fca.0.extract218 = extractvalue { ptr } %44, 0
  %45 = sext i32 %40 to i64
  %46 = shl nsw i64 %45, 5
  %47 = getelementptr i8, ptr %.fca.0.extract218, i64 %46
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr i8, ptr %47, i64 8
  %50 = load i160, ptr %49, align 4
  %.sroa.3.8.extract.trunc = trunc i160 %50 to i64
  %.sroa.6318.8.extract.shift = lshr i160 %50, 64
  %.sroa.6318.8.extract.trunc = trunc i160 %.sroa.6318.8.extract.shift to i64
  br label %66

51:                                               ; preds = %24
  store ptr @_parameterization_i32, ptr %7, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %54 = load ptr, ptr %16, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i2 = call ptr %54({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %8) #47
  %55 = call i32 %result.i2({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 dereferenceable(8) %7, i32 %35)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %57 = load ptr, ptr %17, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr } %58(ptr nonnull %.fca.1.extract47) #43
  %.fca.0.extract199 = extractvalue { ptr } %59, 0
  %60 = sext i32 %55 to i64
  %61 = shl nsw i64 %60, 5
  %62 = getelementptr i8, ptr %.fca.0.extract199, i64 %61
  %63 = load ptr, ptr %62, align 8
  %64 = getelementptr i8, ptr %62, i64 8
  %65 = load i160, ptr %64, align 4
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %65 to i64
  %.sroa.3.sroa.3.0.extract.shift = lshr i160 %65, 64
  %.sroa.3.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.sroa.3.0.extract.shift to i64
  br label %66

66:                                               ; preds = %51, %36
  %.sink332 = phi ptr [ %58, %51 ], [ %43, %36 ]
  %.sink331 = phi i64 [ %61, %51 ], [ %46, %36 ]
  %.sink324 = phi ptr [ %63, %51 ], [ %48, %36 ]
  %.sroa.0275.0..sroa.speculated315 = phi ptr [ %63, %51 ], [ %.sroa.0275.087, %36 ]
  %.sroa.speculated315..sroa.0316.0 = phi ptr [ %.sroa.0316.084, %51 ], [ %48, %36 ]
  %.sroa.3.1 = phi i64 [ %.sroa.3.032082, %51 ], [ %.sroa.3.8.extract.trunc, %36 ]
  %.sroa.6318.1 = phi i64 [ %.sroa.6318.083, %51 ], [ %.sroa.6318.8.extract.trunc, %36 ]
  %.sroa.3.sroa.3.1 = phi i64 [ %.sroa.3.sroa.3.0.extract.trunc, %51 ], [ %.sroa.3.sroa.3.085, %36 ]
  %.sroa.3.sroa.0.1 = phi i64 [ %.sroa.3.sroa.0.0.extract.trunc, %51 ], [ %.sroa.3.sroa.0.086, %36 ]
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %68 = call { ptr } %.sink332(ptr nonnull %.fca.1.extract47) #43
  %.fca.0.extract196 = extractvalue { ptr } %68, 0
  %69 = getelementptr i8, ptr %.fca.0.extract196, i64 %.sink331
  store ptr %.sroa.0.091, ptr %69, align 8
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = ptrtoint ptr %.sroa.6.090 to i64
  %72 = ptrtoint ptr %.sroa.12.089 to i64
  store i64 %71, ptr %70, align 4
  %.sroa_idx256 = getelementptr i8, ptr %69, i64 16
  store i64 %72, ptr %.sroa_idx256, align 4
  %.sroa_idx257 = getelementptr i8, ptr %69, i64 24
  store i32 %.sroa.17.088, ptr %.sroa_idx257, align 4
  %73 = icmp ne ptr %.sink324, @nil_typ
  %74 = icmp ne ptr %.sink324, null
  %.not248 = and i1 %73, %74
  br i1 %.not248, label %.cont190, label %91

.cont190:                                         ; preds = %66
  br i1 %.022895, label %.cont190.then, label %.cont190.cont

.cont190.then:                                    ; preds = %.cont190
  %75 = inttoptr i64 %.sroa.3.1 to ptr
  %76 = inttoptr i64 %.sroa.6318.1 to ptr
  br label %.cont190.cont

.cont190.cont:                                    ; preds = %.cont190.then, %.cont190
  %.sroa.1.sroa.0.sroa.0.3 = phi i64 [ %.sroa.1.sroa.0.sroa.0.080, %.cont190.then ], [ %.sroa.3.sroa.0.1, %.cont190 ]
  %.sroa.1.sroa.3.sroa.0.3 = phi i64 [ %.sroa.1.sroa.3.sroa.0.081, %.cont190.then ], [ %.sroa.3.sroa.3.1, %.cont190 ]
  %.sroa.5207.4 = phi ptr [ %76, %.cont190.then ], [ %.sroa.5207.094, %.cont190 ]
  %.sroa.3206.4 = phi ptr [ %75, %.cont190.then ], [ %.sroa.3206.093, %.cont190 ]
  %.sroa.speculated293 = phi ptr [ %.sroa.speculated315..sroa.0316.0, %.cont190.then ], [ %.sroa.0275.0..sroa.speculated315, %.cont190 ]
  %77 = getelementptr i8, ptr %.sroa.speculated293, i64 8
  %78 = getelementptr i8, ptr %.sroa.speculated293, i64 16
  %79 = getelementptr i8, ptr %.sroa.speculated293, i64 24
  %80 = getelementptr i8, ptr %.sroa.speculated293, i64 32
  %81 = load i64, ptr %77, align 4
  %82 = load i64, ptr %78, align 4
  %83 = load ptr, ptr %79, align 8
  %84 = load ptr, ptr %80, align 8
  %result.i6 = call i1 %83(i64 %82, i64 %81, i64 4015701072841558310, i64 ptrtoint (ptr @Entry to i64), ptr readonly %84) #45
  br i1 %result.i6, label %.cont175, label %88

.cont175:                                         ; preds = %.cont190.cont
  %85 = xor i1 %.022895, true
  %86 = inttoptr i64 %.sroa.1.sroa.0.sroa.0.3 to ptr
  %87 = inttoptr i64 %.sroa.1.sroa.3.sroa.0.3 to ptr
  %offset_tbl_ptr.i21 = getelementptr i8, ptr %.sroa.speculated293, i64 40
  %offset_tbl.i24 = load ptr, ptr %offset_tbl_ptr.i21, align 8
  %product.i.i25 = mul i64 %81, 4015701072841558310
  %shifted.i.i26 = lshr i64 %product.i.i25, 32
  %xored.i.i27 = xor i64 %shifted.i.i26, %product.i.i25
  %hash.i.i28 = and i64 %xored.i.i27, %82
  %offset_ptr.i29 = getelementptr i32, ptr %offset_tbl.i24, i64 %hash.i.i28
  %offset.i30 = load i32, ptr %offset_ptr.i29, align 4
  %.sroa.speculated118 = select i1 %.022895, ptr %.sroa.5207.4, ptr %87
  %.sroa.speculated124 = select i1 %.022895, ptr %.sroa.3206.4, ptr %86
  br label %88

88:                                               ; preds = %.cont175, %.cont190.cont
  %.sroa.17.1 = phi i32 [ %.sroa.17.088, %.cont190.cont ], [ %offset.i30, %.cont175 ]
  %.sroa.12.1 = phi ptr [ %.sroa.12.089, %.cont190.cont ], [ %.sroa.speculated118, %.cont175 ]
  %.sroa.6.1 = phi ptr [ %.sroa.6.090, %.cont190.cont ], [ %.sroa.speculated124, %.cont175 ]
  %.sroa.0.1 = phi ptr [ %.sroa.0.091, %.cont190.cont ], [ %.sroa.speculated293, %.cont175 ]
  %.sroa.3206.2 = phi ptr [ %.sroa.3206.093, %.cont190.cont ], [ %.sroa.3206.4, %.cont175 ]
  %.sroa.5207.2 = phi ptr [ %.sroa.5207.094, %.cont190.cont ], [ %.sroa.5207.4, %.cont175 ]
  %.2 = phi i1 [ %.022895, %.cont190.cont ], [ %85, %.cont175 ]
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap) #57
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %4) #41
  %exitcond.not = icmp eq i32 %25, 100
  br i1 %exitcond.not, label %._crit_edge, label %24

91:                                               ; preds = %66
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %93 = getelementptr i8, ptr %11, i64 48
  %94 = load ptr, ptr %93, align 8
  %95 = load ptr, ptr %94, align 8
  %96 = call i32 %95(ptr nonnull %.fca.1.extract47) #43
  %97 = add i32 %96, 1
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %99 = getelementptr i8, ptr %94, i64 8
  %100 = load ptr, ptr %99, align 8
  call void %100(ptr nonnull %.fca.1.extract47, i32 %97) #42
  br label %103

._crit_edge:                                      ; preds = %88
  %101 = ptrtoint ptr %.sroa.6.1 to i64
  %102 = ptrtoint ptr %.sroa.12.1 to i64
  %.sroa.17.8.insert.ext = zext i32 %.sroa.17.1 to i160
  %.sroa.17.8.insert.shift = shl nuw i160 %.sroa.17.8.insert.ext, 128
  %.sroa.12.8.insert.ext = zext i64 %102 to i160
  %.sroa.12.8.insert.shift = shl nuw nsw i160 %.sroa.12.8.insert.ext, 64
  %.sroa.12.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.shift, %.sroa.17.8.insert.shift
  %.sroa.6.8.insert.ext = zext i64 %101 to i160
  %.sroa.6.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.insert, %.sroa.6.8.insert.ext
  br label %103

103:                                              ; preds = %._crit_edge, %91
  %.reg2mem123.sroa.3.0 = phi i160 [ undef, %91 ], [ %.sroa.6.8.insert.insert, %._crit_edge ]
  %.reg2mem123.sroa.0.0 = phi ptr [ @nil_typ, %91 ], [ %.sroa.0.1, %._crit_edge ]
  %.reload124.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem123.sroa.0.0, 0
  %.reload124.fca.1.insert = insertvalue { ptr, i160 } %.reload124.fca.0.insert, i160 %.reg2mem123.sroa.3.0, 1
  ret { ptr, i160 } %.reload124.fca.1.insert
}

define void @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4) #18 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i, 3
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract13, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = getelementptr i8, ptr %13, i64 112
  %16 = icmp sgt i32 %4, 0
  br i1 %16, label %.lr.ph.preheader, label %._crit_edge2._crit_edge

.lr.ph.preheader:                                 ; preds = %5
  %wide.trip.count = zext nneg i32 %4 to i64
  br label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge, %.lr.ph.preheader
  %indvars.iv = phi i64 [ 0, %.lr.ph.preheader ], [ %indvars.iv.next, %._crit_edge ]
  %17 = shl nuw nsw i64 %indvars.iv, 5
  %18 = getelementptr i8, ptr %.fca.0.extract, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = icmp ne ptr %19, @nil_typ
  %21 = icmp ne ptr %19, null
  %.not43 = and i1 %20, %21
  br i1 %.not43, label %22, label %._crit_edge

22:                                               ; preds = %.lr.ph
  %23 = getelementptr i8, ptr %18, i64 8
  %24 = load i160, ptr %23, align 4
  %.sroa.3.0.extract.shift = lshr i160 %24, 64
  %.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.0.extract.shift to i64
  %.sroa.039.0.extract.trunc = trunc i160 %24 to i64
  %25 = inttoptr i64 %.sroa.039.0.extract.trunc to ptr
  %26 = inttoptr i64 %.sroa.3.0.extract.trunc to ptr
  %hash_coef_ptr.i5 = getelementptr i8, ptr %19, i64 8
  %tbl_size_ptr.i6 = getelementptr i8, ptr %19, i64 16
  %offset_tbl_ptr.i7 = getelementptr i8, ptr %19, i64 40
  %hash_coef.i8 = load i64, ptr %hash_coef_ptr.i5, align 4
  %tbl_size.i9 = load i64, ptr %tbl_size_ptr.i6, align 4
  %offset_tbl.i10 = load ptr, ptr %offset_tbl_ptr.i7, align 8
  %product.i.i11 = mul i64 %hash_coef.i8, 4015701072841558310
  %shifted.i.i12 = lshr i64 %product.i.i11, 32
  %xored.i.i13 = xor i64 %shifted.i.i12, %product.i.i11
  %hash.i.i14 = and i64 %xored.i.i13, %tbl_size.i9
  %offset_ptr.i15 = getelementptr i32, ptr %offset_tbl.i10, i64 %hash.i.i14
  %offset.i16 = load i32, ptr %offset_ptr.i15, align 4
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %19, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %25, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %26, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %offset.i16, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %32 = load ptr, ptr %13, align 8
  %result.i2 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %34 = load ptr, ptr %14, align 8
  %result.i = call ptr %34(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %result.i4 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %35 = getelementptr inbounds i8, ptr %result.i4, i64 16
  store ptr %result.i, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i4, i64 8
  store ptr %result.i2, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i4, i64 24
  store ptr null, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i4) #41
  store ptr @Entry, ptr %result.i4, align 8
  store ptr %result.i4, ptr %6, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #41
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %41 = load ptr, ptr %15, align 8
  store ptr %19, ptr %7, align 8
  %result.i3 = call ptr %41({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly %7) #47
  %42 = call { ptr, i160 } %result.i3({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 dereferenceable(8) %6, { ptr, ptr, ptr, i32 } %30)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %.lr.ph
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge2._crit_edge, label %.lr.ph

._crit_edge2._crit_edge:                          ; preds = %._crit_edge, %5
  ret void
}

define void @CuckooMap_resize_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
._crit_edge:
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract45, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call { ptr } %12(ptr %.fca.1.extract) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #44
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr } %17(ptr %.fca.1.extract) #43
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #44
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call i32 %22(ptr %.fca.1.extract) #43
  %24 = shl i32 %23, 1
  %spec.select = call i32 @llvm.smax.i32(i32 %24, i32 noundef 16) #44
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #44
  %26 = getelementptr i8, ptr %21, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr %.fca.1.extract, i32 %spec.select) #42
  %28 = zext nneg i32 %spec.select to i64
  %29 = shl nuw nsw i64 %28, 5
  %result.i5 = call noalias ptr @bump_malloc_wrapper(i64 noundef %29) #49
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #44
  %31 = load ptr, ptr %10, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i5, 0
  call void %33(ptr %.fca.1.extract, { ptr } %34) #42
  %result.i4 = call noalias ptr @bump_malloc_wrapper(i64 noundef %29) #49
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #44
  %36 = load ptr, ptr %15, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %39 = insertvalue { ptr } undef, ptr %result.i4, 0
  call void %38(ptr %.fca.1.extract, { ptr } %39) #42
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #44
  %41 = getelementptr i8, ptr %9, i64 48
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %.fca.1.extract, i32 0) #42
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.1.extract, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.2.extract, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %offset.i, 3
  %result.i3 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %49 = getelementptr inbounds i8, ptr %result.i3, i64 8
  store ptr null, ptr %49, align 8
  store ptr @buffer_typ, ptr %result.i3, align 8
  store ptr %result.i3, ptr %3, align 8
  %50 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3) #44
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #44
  %53 = getelementptr i8, ptr %9, i64 120
  %54 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %4, align 8
  %55 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %result.i1 = call ptr %54({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  call void %result.i1({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %3, { ptr } %13, i32 %23)
  %result.i2 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %56 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr null, ptr %56, align 8
  store ptr @buffer_typ, ptr %result.i2, align 8
  store ptr %result.i2, ptr %5, align 8
  %57 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract45)
  %60 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %6, align 8
  %61 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %61, align 8
  %result.i = call ptr %60({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %6) #47
  call void %result.i({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %5, { ptr } %18, i32 %23)
  ret void
}

define noundef i1 @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5, i32 %6, { ptr } %7) #18 {
  %9 = alloca [0 x ptr], align 8
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %7, 0
  %10 = sext i32 %6 to i64
  %11 = shl nsw i64 %10, 5
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %12, i64 8
  %15 = icmp ne ptr %13, @nil_typ
  %16 = icmp ne ptr %13, null
  %.not81 = and i1 %15, %16
  br i1 %.not81, label %17, label %.critedge

17:                                               ; preds = %8
  %18 = load i64, ptr %14, align 4
  %.sroa_idx = getelementptr i8, ptr %12, i64 16
  %19 = load i64, ptr %.sroa_idx, align 4
  %20 = inttoptr i64 %18 to ptr
  %21 = inttoptr i64 %19 to ptr
  %hash_coef_ptr.i10 = getelementptr i8, ptr %13, i64 8
  %tbl_size_ptr.i11 = getelementptr i8, ptr %13, i64 16
  %offset_tbl_ptr.i12 = getelementptr i8, ptr %13, i64 40
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i10, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i11, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i12, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 4015701072841558310
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %21, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i21, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9) #41
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %13) #41
  %28 = sext i32 %offset.i21 to i64
  %29 = getelementptr ptr, ptr %13, i64 %28
  %30 = getelementptr i8, ptr %29, i64 64
  %31 = load ptr, ptr %30, align 8
  %result.i8 = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly align 8 %9) #47
  %32 = call i32 %result.i8({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9)
  %33 = icmp eq i32 %32, %5
  br i1 %33, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %17
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %13)
  %36 = getelementptr i8, ptr %29, i64 48
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly align 8 %9) #47
  %38 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %40 = sext i32 %offset.i to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract37, i64 %40
  %42 = getelementptr i8, ptr %41, i64 64
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr } %44(ptr %.fca.1.extract38) #43
  %.fca.0.extract64 = extractvalue { ptr } %45, 0
  %46 = call i1 %.fca.0.extract64({ ptr, i160 } %38, { ptr, i160 } %3)
  br i1 %46, label %47, label %.critedge

47:                                               ; preds = %._crit_edge
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %49 = load ptr, ptr %41, align 8
  %result.i4 = call align 8 ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract38) #45
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %51 = getelementptr i8, ptr %41, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i3 = call align 8 ptr %52(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract38) #45
  %53 = load ptr, ptr %result.i4, align 8, !alias.scope !11
  %54 = getelementptr i8, ptr %53, i64 72
  %55 = load ptr, ptr %54, align 8, !alias.scope !11
  %result.i1.i = call { i64, i64 } %55(ptr nocapture nofree nonnull readonly align 8 %result.i4) #45, !alias.scope !11
  %56 = extractvalue { i64, i64 } %result.i1.i, 0
  %57 = extractvalue { i64, i64 } %result.i1.i, 1
  %58 = urem i64 20, %57
  %59 = icmp eq i64 %58, 0
  %60 = sub i64 %57, %58
  %61 = select i1 %59, i64 0, i64 %60
  %62 = add i64 %56, 20
  %63 = add i64 %62, %61
  %64 = load ptr, ptr %result.i3, align 8, !alias.scope !11
  %65 = getelementptr i8, ptr %64, i64 72
  %66 = load ptr, ptr %65, align 8, !alias.scope !11
  %result.i.i = call { i64, i64 } %66(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45, !alias.scope !11
  %67 = extractvalue { i64, i64 } %result.i.i, 0
  %68 = extractvalue { i64, i64 } %result.i.i, 1
  %69 = call i64 @llvm.umax.i64(i64 %57, i64 %68) #60
  %70 = call i64 @llvm.umax.i64(i64 %69, i64 noundef 8) #60, !range !4
  %71 = urem i64 %63, %68
  %72 = icmp eq i64 %71, 0
  %73 = sub i64 %68, %71
  %74 = select i1 %72, i64 0, i64 %73
  %75 = add i64 %67, %63
  %76 = add i64 %75, %74
  %77 = urem i64 %76, %70
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %70, %77
  %80 = select i1 %78, i64 0, i64 %79
  %81 = add i64 %80, %76
  %result.i9 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %81) #49
  store ptr %result.i4, ptr %result.i9, align 8
  %82 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %86 = load ptr, ptr %result.i4, align 8
  %87 = getelementptr i8, ptr %86, i64 72
  %88 = load ptr, ptr %87, align 8
  %result.i.i22 = call { i64, i64 } %88(ptr nocapture nofree nonnull readonly align 8 %result.i4) #45
  %89 = extractvalue { i64, i64 } %result.i.i22, 1
  %90 = urem i64 20, %89
  %91 = icmp eq i64 %90, 0
  %reass.sub26 = sub i64 %89, %90
  %92 = add i64 %reass.sub26, 20
  %93 = select i1 %91, i64 20, i64 %92
  %94 = getelementptr i8, ptr %result.i9, i64 %93
  %95 = getelementptr i8, ptr %86, i64 64
  %96 = load ptr, ptr %95, align 8
  call void %96({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i4, ptr nocapture nofree writeonly %94) #46
  %97 = load ptr, ptr %result.i9, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i1.i23 = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly align 8 %97) #45
  %101 = extractvalue { i64, i64 } %result.i1.i23, 0
  %102 = extractvalue { i64, i64 } %result.i1.i23, 1
  %103 = urem i64 20, %102
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %102, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %101, 20
  %108 = add i64 %107, %106
  %109 = load ptr, ptr %82, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i.i24 = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly align 8 %109) #45
  %113 = extractvalue { i64, i64 } %result.i.i24, 1
  %114 = urem i64 %108, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = getelementptr i8, ptr %result.i9, i64 %108
  %119 = getelementptr i8, ptr %118, i64 %117
  %120 = getelementptr i8, ptr %110, i64 64
  %121 = load ptr, ptr %120, align 8
  call void %121({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %109, ptr nocapture nofree writeonly %119) #46
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #44
  %123 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store i32 %5, ptr %123, align 8
  store ptr @Entry, ptr %12, align 8
  %124 = ptrtoint ptr %result.i9 to i64
  store i64 %124, ptr %14, align 4
  %.sroa_idx46 = getelementptr i8, ptr %12, i64 24
  store i32 10, ptr %.sroa_idx46, align 4
  br label %.critedge

.critedge:                                        ; preds = %47, %._crit_edge, %17, %8
  %.reg2mem32.0 = phi i1 [ false, %._crit_edge ], [ true, %47 ], [ false, %8 ], [ false, %17 ]
  ret i1 %.reg2mem32.0
}

define { ptr, i160 } @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #18 {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not48 = and i1 %13, %14
  br i1 %.not48, label %15, label %.critedge

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i3 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i4 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i5 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i3, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i4, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i5, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, 4015701072841558310
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i14, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #41
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12) #41
  %27 = sext i32 %offset.i14 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #47
  %31 = call i32 %result.i2({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8)
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i1 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #47
  %37 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18)
  %39 = sext i32 %offset.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract18, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract19) #43
  %.fca.0.extract31 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract31({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.critedge

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #47
  %51 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8)
  %.fca.0.extract26 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract27 = extractvalue { ptr, i160 } %51, 1
  br label %.critedge

.critedge:                                        ; preds = %46, %._crit_edge, %15, %7
  %.reg2mem38.sroa.3.0 = phi i160 [ %.fca.1.extract27, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %.reg2mem36.0 = phi ptr [ %.fca.0.extract26, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload35.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem36.0, 0
  %.reload35.fca.1.insert = insertvalue { ptr, i160 } %.reload35.fca.0.insert, i160 %.reg2mem38.sroa.3.0, 1
  ret { ptr, i160 } %.reload35.fca.1.insert
}

define { ptr, i160 } @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #18 {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not62 = and i1 %13, %14
  br i1 %.not62, label %15, label %.critedge

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i3 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i4 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i5 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i3, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i4, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i5, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, 4015701072841558310
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i14, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #41
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12) #41
  %27 = sext i32 %offset.i14 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #47
  %31 = call i32 %result.i2({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8)
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i1 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #47
  %37 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract26)
  %39 = sext i32 %offset.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract26, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract27) #43
  %.fca.0.extract45 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract45({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.critedge

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #47
  %51 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8)
  %.fca.0.extract40 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract41 = extractvalue { ptr, i160 } %51, 1
  store ptr @nil_typ, ptr %11, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract26)
  %53 = getelementptr i8, ptr %40, i64 48
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 %55(ptr %.fca.1.extract27) #43
  %57 = add i32 %56, -1
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract26)
  %59 = getelementptr i8, ptr %54, i64 8
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %.fca.1.extract27, i32 %57) #42
  br label %.critedge

.critedge:                                        ; preds = %46, %._crit_edge, %15, %7
  %.reg2mem38.sroa.3.0 = phi i160 [ %.fca.1.extract41, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %.reg2mem36.0 = phi ptr [ %.fca.0.extract40, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload35.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem36.0, 0
  %.reload35.fca.1.insert = insertvalue { ptr, i160 } %.reload35.fca.0.insert, i160 %.reg2mem38.sroa.3.0, 1
  ret { ptr, i160 } %.reload35.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #5 {
  %.fca.0.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #41
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract29, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, { ptr } %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #44
  %14 = getelementptr i8, ptr %8, i64 64
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, { ptr } %4) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #44
  %19 = getelementptr i8, ptr %8, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 8) #42
  %result.i1 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #44
  %24 = getelementptr i8, ptr %8, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr } undef, ptr %result.i1, 0
  call void %27(ptr %.fca.1.extract, { ptr } %28) #42
  %result.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #44
  %30 = getelementptr i8, ptr %8, i64 32
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %33(ptr %.fca.1.extract, { ptr } %34) #42
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #44
  %36 = getelementptr i8, ptr %8, i64 48
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  call void %39(ptr %.fca.1.extract, i32 0) #42
  ret void
}

define { ptr, i160 } @CuckooMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract67 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract67, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract67, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract67, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract67, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract68, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i, 3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67) #41
  %14 = sext i32 %offset.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract67, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i2 = call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i2, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #41
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67) #41
  %20 = getelementptr i8, ptr %15, i64 80
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %22) #47
  %23 = call i32 %result.i7({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3)
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %27 = getelementptr i8, ptr %15, i64 96
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i6 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %29) #47
  %30 = call i32 %result.i6({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr nonnull %.fca.1.extract68) #43
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %37 = load ptr, ptr %15, align 8
  %result.i1 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %result.i9 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %38 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr null, ptr %38, align 8
  store ptr @buffer_typ, ptr %result.i9, align 8
  %39 = alloca [4 x ptr], align 8
  store ptr %result.i1, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr %result.i9, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %39)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %45 = getelementptr i8, ptr %15, i64 144
  %46 = load ptr, ptr %45, align 8
  %47 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %47, i64 16
  store ptr @i32_typ, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %47, i64 24
  store ptr @buffer_typ, ptr %50, align 8
  %result.i5 = call ptr %46({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %47) #47
  %51 = call { ptr, i160 } %result.i5({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %39, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35)
  %.fca.0.extract = extractvalue { ptr, i160 } %51, 0
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %53 = icmp ne ptr %.fca.0.extract, @nil_typ
  %54 = icmp ne ptr %.fca.0.extract, null
  %.not99 = and i1 %53, %54
  br i1 %.not99, label %81, label %55

55:                                               ; preds = %4
  store ptr @_parameterization_i32, ptr %5, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %58 = getelementptr i8, ptr %15, i64 104
  %59 = load ptr, ptr %58, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i4 = call ptr %59({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #47
  %60 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %62 = getelementptr i8, ptr %15, i64 32
  %63 = load ptr, ptr %62, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = call { ptr } %64(ptr nonnull %.fca.1.extract68) #43
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %67 = load ptr, ptr %15, align 8
  %result.i = call ptr %67(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %result.i8 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %68 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr null, ptr %68, align 8
  store ptr @buffer_typ, ptr %result.i8, align 8
  store ptr %result.i, ptr %7, align 8
  %69 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %result.i8, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %74 = load ptr, ptr %45, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %75 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %77, align 8
  %result.i3 = call ptr %74({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #47
  %78 = call { ptr, i160 } %result.i3({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %60, { ptr } %65)
  %.fca.0.extract87 = extractvalue { ptr, i160 } %78, 0
  %.fca.1.extract88 = extractvalue { ptr, i160 } %78, 1
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %.not = icmp eq ptr %.fca.0.extract87, null
  %80 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract87
  br label %81

81:                                               ; preds = %55, %4
  %.reg2mem17.0 = phi ptr [ %80, %55 ], [ %.fca.0.extract, %4 ]
  %.sroa.390.0 = phi i160 [ %.fca.1.extract88, %55 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %51, 1
  %.fca.1.extract..sroa.390.0 = select i1 %.not99, i160 %.fca.1.extract, i160 %.sroa.390.0
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem17.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.fca.1.extract..sroa.390.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

define void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #18 {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [5 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %.fca.0.extract104 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract104, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract104, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract104, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract29 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract20 = extractvalue { ptr, i160 } %4, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract104, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract105, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract104) #41
  %18 = sext i32 %offset.i to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract104, i64 %18
  %20 = load ptr, ptr %19, align 8
  %result.i10 = call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %21 = alloca [1 x ptr], align 8
  store ptr %result.i10, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21) #41
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract104) #41
  %24 = getelementptr i8, ptr %19, i64 80
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr }, align 8
  store ptr %.fca.0.extract29, ptr %26, align 8
  %result.i20 = call ptr %25({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %26) #47
  %27 = call i32 %result.i20({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %21, { ptr, i160 } %3)
  %28 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract104)
  %31 = getelementptr i8, ptr %19, i64 96
  %32 = load ptr, ptr %31, align 8
  %33 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %33, align 8
  %result.i19 = call ptr %32({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %33) #47
  %34 = call i32 %result.i19({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %28, i32 %27)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract104)
  %36 = getelementptr i8, ptr %19, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr nonnull %.fca.1.extract105) #43
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract104)
  %41 = load ptr, ptr %19, align 8
  %result.i9 = call ptr %41(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract104)
  %43 = getelementptr i8, ptr %19, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i8 = call ptr %44(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %result.i24 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %45 = getelementptr inbounds i8, ptr %result.i24, i64 8
  store ptr null, ptr %45, align 8
  store ptr @buffer_typ, ptr %result.i24, align 8
  %46 = alloca [5 x ptr], align 8
  store ptr %result.i9, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr %result.i8, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr @_parameterization_i32, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %46, i64 32
  store ptr %result.i24, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %46)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract104)
  %53 = getelementptr i8, ptr %19, i64 136
  %54 = load ptr, ptr %53, align 8
  %55 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract29, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %55, i64 8
  store ptr %.fca.0.extract20, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %55, i64 16
  store ptr @i32_typ, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %55, i64 24
  store ptr @i32_typ, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %55, i64 32
  store ptr @buffer_typ, ptr %59, align 8
  %result.i18 = call ptr %54({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %55) #47
  %60 = call i1 %result.i18({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %46, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %34, { ptr } %39)
  br i1 %60, label %.loopexit, label %61

61:                                               ; preds = %5
  store ptr @_parameterization_i32, ptr %7, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %64 = getelementptr i8, ptr %19, i64 104
  %65 = load ptr, ptr %64, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i17 = call ptr %65({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %8) #47
  %66 = call i32 %result.i17({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %7, i32 %27)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %68 = getelementptr i8, ptr %19, i64 32
  %69 = load ptr, ptr %68, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr } %70(ptr nonnull %.fca.1.extract105) #43
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %73 = load ptr, ptr %19, align 8
  %result.i7 = call ptr %73(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %75 = load ptr, ptr %43, align 8
  %result.i6 = call ptr %75(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %result.i23 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %76 = getelementptr inbounds i8, ptr %result.i23, i64 8
  store ptr null, ptr %76, align 8
  store ptr @buffer_typ, ptr %result.i23, align 8
  store ptr %result.i7, ptr %9, align 8
  %77 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %result.i6, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_i32, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @_parameterization_i32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %9, i64 32
  store ptr %result.i23, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %9)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %83 = load ptr, ptr %53, align 8
  store ptr %.fca.0.extract29, ptr %10, align 8
  %84 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.0.extract20, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %10, i64 24
  store ptr @i32_typ, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %10, i64 32
  store ptr @buffer_typ, ptr %87, align 8
  %result.i16 = call ptr %83({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %10) #47
  %88 = call i1 %result.i16({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %9, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %66, { ptr } %71)
  br i1 %88, label %.loopexit, label %89

89:                                               ; preds = %61
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %91 = getelementptr i8, ptr %19, i64 48
  %92 = load ptr, ptr %91, align 8
  %93 = load ptr, ptr %92, align 8
  %94 = call i32 %93(ptr nonnull %.fca.1.extract105) #43
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %96 = getelementptr i8, ptr %19, i64 40
  %97 = load ptr, ptr %96, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = call i32 %98(ptr nonnull %.fca.1.extract105) #43
  %.not = icmp slt i32 %94, %99
  br i1 %.not, label %._crit_edge, label %100

100:                                              ; preds = %89
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %103 = getelementptr i8, ptr %19, i64 128
  %104 = load ptr, ptr %103, align 8
  %result.i15 = call ptr %104({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  call void %result.i15({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6)
  br label %._crit_edge

._crit_edge:                                      ; preds = %100, %89
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %106 = load ptr, ptr %19, align 8
  %result.i5 = call align 8 ptr %106(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %108 = load ptr, ptr %43, align 8
  %result.i4 = call align 8 ptr %108(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %109 = load ptr, ptr %result.i5, align 8, !alias.scope !14
  %110 = getelementptr i8, ptr %109, i64 72
  %111 = load ptr, ptr %110, align 8, !alias.scope !14
  %result.i1.i = call { i64, i64 } %111(ptr nocapture nofree nonnull readonly align 8 %result.i5) #45, !alias.scope !14
  %112 = extractvalue { i64, i64 } %result.i1.i, 0
  %113 = extractvalue { i64, i64 } %result.i1.i, 1
  %114 = urem i64 20, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = add i64 %112, 20
  %119 = add i64 %118, %117
  %120 = load ptr, ptr %result.i4, align 8, !alias.scope !14
  %121 = getelementptr i8, ptr %120, i64 72
  %122 = load ptr, ptr %121, align 8, !alias.scope !14
  %result.i.i = call { i64, i64 } %122(ptr nocapture nofree nonnull readonly align 8 %result.i4) #45, !alias.scope !14
  %123 = extractvalue { i64, i64 } %result.i.i, 0
  %124 = extractvalue { i64, i64 } %result.i.i, 1
  %125 = call i64 @llvm.umax.i64(i64 %113, i64 %124) #60
  %126 = call i64 @llvm.umax.i64(i64 %125, i64 noundef 8) #60, !range !4
  %127 = urem i64 %119, %124
  %128 = icmp eq i64 %127, 0
  %129 = sub i64 %124, %127
  %130 = select i1 %128, i64 0, i64 %129
  %131 = add i64 %123, %119
  %132 = add i64 %131, %130
  %133 = urem i64 %132, %126
  %134 = icmp eq i64 %133, 0
  %135 = sub i64 %126, %133
  %136 = select i1 %134, i64 0, i64 %135
  %137 = add i64 %136, %132
  %result.i22 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %137) #49
  store ptr %result.i5, ptr %result.i22, align 8
  %138 = getelementptr inbounds i8, ptr %result.i22, i64 8
  store ptr %result.i4, ptr %138, align 8
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22)
  %140 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i22, 1
  %141 = insertvalue { ptr, ptr, ptr, i32 } %140, ptr undef, 2
  %142 = insertvalue { ptr, ptr, ptr, i32 } %141, i32 10, 3
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %145 = load ptr, ptr %result.i5, align 8
  %146 = getelementptr i8, ptr %145, i64 72
  %147 = load ptr, ptr %146, align 8
  %result.i.i47 = call { i64, i64 } %147(ptr nocapture nofree nonnull readonly align 8 %result.i5) #45
  %148 = extractvalue { i64, i64 } %result.i.i47, 1
  %149 = urem i64 20, %148
  %150 = icmp eq i64 %149, 0
  %reass.sub50 = sub i64 %148, %149
  %151 = add i64 %reass.sub50, 20
  %152 = select i1 %150, i64 20, i64 %151
  %153 = getelementptr i8, ptr %result.i22, i64 %152
  %154 = getelementptr i8, ptr %145, i64 64
  %155 = load ptr, ptr %154, align 8
  call void %155({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i5, ptr nocapture nofree writeonly %153) #46
  %156 = load ptr, ptr %result.i22, align 8
  %157 = load ptr, ptr %156, align 8
  %158 = getelementptr i8, ptr %157, i64 72
  %159 = load ptr, ptr %158, align 8
  %result.i1.i48 = call { i64, i64 } %159(ptr nocapture nofree nonnull readonly align 8 %156) #45
  %160 = extractvalue { i64, i64 } %result.i1.i48, 0
  %161 = extractvalue { i64, i64 } %result.i1.i48, 1
  %162 = urem i64 20, %161
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %161, %162
  %165 = select i1 %163, i64 0, i64 %164
  %166 = add i64 %160, 20
  %167 = add i64 %166, %165
  %168 = load ptr, ptr %138, align 8
  %169 = load ptr, ptr %168, align 8
  %170 = getelementptr i8, ptr %169, i64 72
  %171 = load ptr, ptr %170, align 8
  %result.i.i49 = call { i64, i64 } %171(ptr nocapture nofree nonnull readonly align 8 %168) #45
  %172 = extractvalue { i64, i64 } %result.i.i49, 1
  %173 = urem i64 %167, %172
  %174 = icmp eq i64 %173, 0
  %175 = sub i64 %172, %173
  %176 = select i1 %174, i64 0, i64 %175
  %177 = getelementptr i8, ptr %result.i22, i64 %167
  %178 = getelementptr i8, ptr %177, i64 %176
  %179 = getelementptr i8, ptr %169, i64 64
  %180 = load ptr, ptr %179, align 8
  call void %180({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %168, ptr nocapture nofree writeonly %178) #46
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #44
  %182 = getelementptr inbounds i8, ptr %result.i22, i64 16
  store i32 %27, ptr %182, align 8
  %183 = getelementptr i8, ptr %19, i64 112
  %184 = getelementptr i8, ptr %19, i64 128
  %185 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %186 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %187 = load ptr, ptr %19, align 8
  %result.i1 = call ptr %187(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %188 = load ptr, ptr %43, align 8
  %result.i = call ptr %188(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %result.i21 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %189 = getelementptr inbounds i8, ptr %result.i21, i64 16
  store ptr %result.i, ptr %189, align 8
  %190 = getelementptr inbounds i8, ptr %result.i21, i64 8
  store ptr %result.i1, ptr %190, align 8
  %191 = getelementptr inbounds i8, ptr %result.i21, i64 24
  store ptr null, ptr %191, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i21)
  store ptr @Entry, ptr %result.i21, align 8
  store ptr %result.i21, ptr %11, align 8
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %195 = load ptr, ptr %183, align 8
  store ptr @Entry, ptr %12, align 8
  %result.i13 = call ptr %195({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #47
  %196 = call { ptr, i160 } %result.i13({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %142)
  %.fca.0.extract131 = extractvalue { ptr, i160 } %196, 0
  %197 = icmp ne ptr %.fca.0.extract131, @nil_typ
  %198 = icmp ne ptr %.fca.0.extract131, null
  %.not192 = and i1 %197, %198
  br i1 %.not192, label %199, label %.loopexit

199:                                              ; preds = %._crit_edge
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %202 = load ptr, ptr %184, align 8
  %result.i12 = call ptr %202({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  call void %result.i12({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6)
  %203 = getelementptr i8, ptr %.fca.0.extract131, i64 8
  %204 = getelementptr i8, ptr %.fca.0.extract131, i64 16
  %205 = getelementptr i8, ptr %.fca.0.extract131, i64 24
  %206 = getelementptr i8, ptr %.fca.0.extract131, i64 32
  %207 = load i64, ptr %203, align 4
  %208 = load i64, ptr %204, align 4
  %209 = load ptr, ptr %205, align 8
  %210 = load ptr, ptr %206, align 8
  %result.i25 = call i1 %209(i64 %208, i64 %207, i64 4015701072841558310, i64 ptrtoint (ptr @Entry to i64), ptr readonly %210) #45
  %.fca.1.extract132 = extractvalue { ptr, i160 } %196, 1
  %.sroa.7.8.extract.shift = lshr i160 %.fca.1.extract132, 64
  %.sroa.7.8.extract.trunc = trunc i160 %.sroa.7.8.extract.shift to i64
  %211 = inttoptr i64 %.sroa.7.8.extract.trunc to ptr
  %.sroa.4.8.extract.trunc = trunc i160 %.fca.1.extract132 to i64
  %212 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %.1183 = select i1 %result.i25, ptr %.fca.0.extract131, ptr @Entry
  %.1179 = select i1 %result.i25, ptr %212, ptr %result.i22
  %hash_coef_ptr.i26.1 = getelementptr i8, ptr %.1183, i64 8
  %tbl_size_ptr.i27.1 = getelementptr i8, ptr %.1183, i64 16
  %offset_tbl_ptr.i28.1 = getelementptr i8, ptr %.1183, i64 40
  %hash_coef.i29.1 = load i64, ptr %hash_coef_ptr.i26.1, align 4
  %tbl_size.i30.1 = load i64, ptr %tbl_size_ptr.i27.1, align 4
  %offset_tbl.i31.1 = load ptr, ptr %offset_tbl_ptr.i28.1, align 8
  %product.i.i32.1 = mul i64 %hash_coef.i29.1, 4015701072841558310
  %shifted.i.i33.1 = lshr i64 %product.i.i32.1, 32
  %xored.i.i34.1 = xor i64 %shifted.i.i33.1, %product.i.i32.1
  %hash.i.i35.1 = and i64 %xored.i.i34.1, %tbl_size.i30.1
  %offset_ptr.i36.1 = getelementptr i32, ptr %offset_tbl.i31.1, i64 %hash.i.i35.1
  %offset.i37.1 = load i32, ptr %offset_ptr.i36.1, align 4
  %213 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.1183, 0
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr %.1179, 1
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %211, 2
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, i32 %offset.i37.1, 3
  %217 = load ptr, ptr %19, align 8
  %result.i1.1 = call ptr %217(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %218 = load ptr, ptr %43, align 8
  %result.i.1 = call ptr %218(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #45
  %result.i21.1 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %219 = getelementptr inbounds i8, ptr %result.i21.1, i64 16
  store ptr %result.i.1, ptr %219, align 8
  %220 = getelementptr inbounds i8, ptr %result.i21.1, i64 8
  store ptr %result.i1.1, ptr %220, align 8
  %221 = getelementptr inbounds i8, ptr %result.i21.1, i64 24
  store ptr null, ptr %221, align 8
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i21.1)
  store ptr @Entry, ptr %result.i21.1, align 8
  store ptr %result.i21.1, ptr %11, align 8
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %225 = load ptr, ptr %183, align 8
  store ptr %.1183, ptr %12, align 8
  %result.i13.1 = call ptr %225({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #47
  %226 = call { ptr, i160 } %result.i13.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %216)
  %.fca.0.extract131.1 = extractvalue { ptr, i160 } %226, 0
  %227 = icmp ne ptr %.fca.0.extract131.1, @nil_typ
  %228 = icmp ne ptr %.fca.0.extract131.1, null
  %.not192.1 = and i1 %227, %228
  br i1 %.not192.1, label %229, label %.loopexit

229:                                              ; preds = %199
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract104)
  %232 = load ptr, ptr %184, align 8
  %result.i12.1 = call ptr %232({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %6) #47
  call void %result.i12.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6)
  br label %.loopexit

.loopexit:                                        ; preds = %229, %199, %._crit_edge, %61, %5
  ret void
}

define { ptr, i160 } @CuckooMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract67 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract67, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract67, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract67, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract67, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract68, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i, 3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67) #41
  %14 = sext i32 %offset.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract67, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i2 = call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i2, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #41
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67) #41
  %20 = getelementptr i8, ptr %15, i64 80
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %22) #47
  %23 = call i32 %result.i7({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3)
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %27 = getelementptr i8, ptr %15, i64 96
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i6 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %29) #47
  %30 = call i32 %result.i6({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr nonnull %.fca.1.extract68) #43
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %37 = load ptr, ptr %15, align 8
  %result.i1 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %result.i9 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %38 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr null, ptr %38, align 8
  store ptr @buffer_typ, ptr %result.i9, align 8
  %39 = alloca [4 x ptr], align 8
  store ptr %result.i1, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr %result.i9, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %39)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %45 = getelementptr i8, ptr %15, i64 152
  %46 = load ptr, ptr %45, align 8
  %47 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %47, i64 16
  store ptr @i32_typ, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %47, i64 24
  store ptr @buffer_typ, ptr %50, align 8
  %result.i5 = call ptr %46({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %47) #47
  %51 = call { ptr, i160 } %result.i5({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %39, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35)
  %.fca.0.extract = extractvalue { ptr, i160 } %51, 0
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %53 = icmp ne ptr %.fca.0.extract, @nil_typ
  %54 = icmp ne ptr %.fca.0.extract, null
  %.not99 = and i1 %53, %54
  br i1 %.not99, label %81, label %55

55:                                               ; preds = %4
  store ptr @_parameterization_i32, ptr %5, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %58 = getelementptr i8, ptr %15, i64 104
  %59 = load ptr, ptr %58, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i4 = call ptr %59({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #47
  %60 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %62 = getelementptr i8, ptr %15, i64 32
  %63 = load ptr, ptr %62, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = call { ptr } %64(ptr nonnull %.fca.1.extract68) #43
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %67 = load ptr, ptr %15, align 8
  %result.i = call ptr %67(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %result.i8 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %68 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr null, ptr %68, align 8
  store ptr @buffer_typ, ptr %result.i8, align 8
  store ptr %result.i, ptr %7, align 8
  %69 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %result.i8, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %74 = load ptr, ptr %45, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %75 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %77, align 8
  %result.i3 = call ptr %74({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #47
  %78 = call { ptr, i160 } %result.i3({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %60, { ptr } %65)
  %.fca.0.extract87 = extractvalue { ptr, i160 } %78, 0
  %.fca.1.extract88 = extractvalue { ptr, i160 } %78, 1
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract67)
  %.not = icmp eq ptr %.fca.0.extract87, null
  %80 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract87
  br label %81

81:                                               ; preds = %55, %4
  %.reg2mem17.0 = phi ptr [ %80, %55 ], [ %.fca.0.extract, %4 ]
  %.sroa.390.0 = phi i160 [ %.fca.1.extract88, %55 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %51, 1
  %.fca.1.extract..sroa.390.0 = select i1 %.not99, i160 %.fca.1.extract, i160 %.sroa.390.0
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem17.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.fca.1.extract..sroa.390.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Map_keys_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %10 = load ptr, ptr %6, align 8
  %result.i2 = call ptr %10(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %result.i7 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i3, ptr %result.i7, align 8
  %11 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i2, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, -5249855671126779970
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapKeys, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr undef, 2
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @MapKeys) #41
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 48, 3
  ret { ptr, ptr, ptr, i32 } %22
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 40
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  call void %10(ptr %.fca.1.extract, i32 8) #42
  %result.i1 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %12 = getelementptr i8, ptr %6, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr } undef, ptr %result.i1, 0
  call void %15(ptr %.fca.1.extract, { ptr } %16) #42
  %result.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #49
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %18 = getelementptr i8, ptr %6, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %21(ptr %.fca.1.extract, { ptr } %22) #42
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract) #44
  %24 = getelementptr i8, ptr %6, i64 48
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr %.fca.1.extract, i32 0) #42
  ret void
}

define { ptr, ptr, ptr, i32 } @Map_indices_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract15, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract16, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #41
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract14, i64 %11
  %13 = getelementptr i8, ptr %12, i64 48
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %15 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i12, 3
  ret { ptr, ptr, ptr, i32 } %19
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Map_values_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i3 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %9 = getelementptr i8, ptr %6, i64 8
  %10 = load ptr, ptr %9, align 8
  %result.i2 = call ptr %10(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %result.i7 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i3, ptr %result.i7, align 8
  %11 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i2, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i7) #41
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, -5249855671126779970
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapValues, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr undef, 2
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @MapValues) #41
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 48, 3
  ret { ptr, ptr, ptr, i32 } %22
}

define { ptr, i160 } @Map__index_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %10 = alloca [2 x ptr], align 8
  %11 = alloca { ptr, ptr }, align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract4 = extractvalue { ptr, i160 } %3, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract23, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #41
  %17 = sext i32 %offset.i to i64
  %18 = getelementptr ptr, ptr %.fca.0.extract21, i64 %17
  %19 = load ptr, ptr %18, align 8
  %result.i = call ptr %19(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract23) #45
  %20 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20) #41
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #41
  %23 = getelementptr i8, ptr %18, i64 24
  %24 = load ptr, ptr %23, align 8
  %25 = alloca { ptr }, align 8
  store ptr %.fca.0.extract4, ptr %25, align 8
  %result.i1 = call ptr %24({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %25) #47
  %26 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 dereferenceable(8) %20, { ptr, i160 } %3)
  %.fca.0.extract = extractvalue { ptr, i160 } %26, 0
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract21)
  %28 = icmp ne ptr %.fca.0.extract, @nil_typ
  %29 = icmp ne ptr %.fca.0.extract, null
  %.not67 = and i1 %28, %29
  br i1 %.not67, label %30, label %codeRepl

30:                                               ; preds = %4
  ret { ptr, i160 } %26

codeRepl:                                         ; preds = %4
  call fastcc void @Map__index_keyK.cold.1(ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %9, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %10, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %11, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr noalias nocapture nofree noundef nonnull align 8 %5, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %7) #61
  unreachable
}

define void @CuckooMap__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #18 {
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract7 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract21, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #41
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract20, i64 %11
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #45
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #41
  %15 = getelementptr i8, ptr %12, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i = call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #45
  %17 = alloca [2 x ptr], align 8
  store ptr %result.i1, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %result.i, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %17) #41
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #41
  %21 = getelementptr i8, ptr %12, i64 176
  %22 = load ptr, ptr %21, align 8
  %23 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract7, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %23, i64 8
  store ptr %.fca.0.extract, ptr %24, align 8
  %result.i2 = call ptr %22({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %23) #47
  call void %result.i2({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 dereferenceable(16) %17, { ptr, i160 } %3, { ptr, i160 } %4)
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @CuckooMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 48
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @CuckooMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3547150501766965522
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract49, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr nonnull %.fca.1.extract) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr } %14(ptr nonnull %.fca.1.extract) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %17 = getelementptr i8, ptr %6, i64 40
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr nonnull %.fca.1.extract) #43
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %22 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %22(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %24 = getelementptr i8, ptr %6, i64 8
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #45
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %result.i7 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #49
  %28 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %result.i, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i1, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr null, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i7) #44
  store ptr @Pair, ptr %result.i7, align 8
  %result.i6 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store ptr %result.i1, ptr %result.i6, align 8
  %32 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr %result.i, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i7, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i6) #44
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %36 = load ptr, ptr %7, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr nonnull %.fca.1.extract) #43
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %40 = load ptr, ptr %12, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr } %41(ptr nonnull %.fca.1.extract) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #44
  %44 = load ptr, ptr %17, align 8
  %45 = load ptr, ptr %44, align 8
  %46 = call i32 %45(ptr nonnull %.fca.1.extract) #43
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = getelementptr inbounds i8, ptr %result.i6, i64 24
  %.fca.0.extract.i = extractvalue { ptr } %38, 0
  store ptr %.fca.0.extract.i, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i6, i64 32
  %.fca.0.extract.i8 = extractvalue { ptr } %42, 0
  store ptr %.fca.0.extract.i8, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i6, i64 40
  store i32 %46, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i6, i64 44
  store i32 0, ptr %52, align 4
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator) #44
  %54 = getelementptr inbounds i8, ptr %result.i6, i64 48
  store i1 false, ptr %54, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 24, 3
  ret { ptr, ptr, ptr, i32 } %55
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4, i32 %5) #5 {
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -1975748647346050920
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract21, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #44
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, { ptr } %4) #42
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #44
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #42
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #44
  %25 = getelementptr i8, ptr %9, i64 48
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %.fca.1.extract, i32 0) #42
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #44
  %30 = getelementptr i8, ptr %9, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  call void %33(ptr %.fca.1.extract, i1 false) #42
  ret void
}

define { ptr, i160 } @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -1975748647346050920
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract20) #57
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract20, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = getelementptr i8, ptr %8, i64 40
  br label %11

11:                                               ; preds = %20, %4
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract21) #43
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract20)
  %16 = load ptr, ptr %10, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %.fca.1.extract21) #43
  %19 = icmp slt i32 %14, %18
  br i1 %19, label %20, label %.thread34

20:                                               ; preds = %11
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract20)
  %22 = call i32 %13(ptr %.fca.1.extract21) #43
  %23 = sext i32 %22 to i64
  %24 = shl nsw i64 %23, 5
  %25 = getelementptr i8, ptr %.fca.0.extract, i64 %24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %25, i64 8
  %28 = load i160, ptr %27, align 4
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract20)
  %30 = call i32 %13(ptr %.fca.1.extract21) #43
  %31 = add i32 %30, 1
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract20)
  %33 = getelementptr i8, ptr %12, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %.fca.1.extract21, i32 %31) #42
  %35 = icmp eq ptr %26, @nil_typ
  %36 = icmp eq ptr %26, null
  %.not57.not = or i1 %35, %36
  br i1 %.not57.not, label %11, label %37

37:                                               ; preds = %20
  %.sroa.048.0.extract.trunc.le = trunc i160 %28 to i64
  %.sroa.249.0.extract.shift.le = lshr i160 %28, 64
  %.sroa.249.0.extract.trunc.le = trunc i160 %.sroa.249.0.extract.shift.le to i64
  %38 = inttoptr i64 %.sroa.048.0.extract.trunc.le to ptr
  %39 = inttoptr i64 %.sroa.249.0.extract.trunc.le to ptr
  %hash_coef_ptr.i1 = getelementptr i8, ptr %26, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %26, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %26, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 4015701072841558310
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %26, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %38, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %39, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %offset.i12, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %26)
  %46 = sext i32 %offset.i12 to i64
  %47 = getelementptr ptr, ptr %26, i64 %46
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i = call ptr %49({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %50 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %5)
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %50, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %50, 1
  %.fca.2.extract29 = extractvalue { ptr, ptr, ptr, i32 } %50, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract27, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 9197944775169318296
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %51 = ptrtoint ptr %.fca.1.extract28 to i64
  %52 = ptrtoint ptr %.fca.2.extract29 to i64
  %.sroa.626.8.insert.ext = zext i32 %offset.i24 to i160
  %.sroa.626.8.insert.shift = shl nuw i160 %.sroa.626.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %52 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.626.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext = zext i64 %51 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext
  br label %.thread34

.thread34:                                        ; preds = %37, %11
  %.reg2mem12.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %37 ], [ undef, %11 ]
  %.reg2mem12.sroa.0.0 = phi ptr [ %.fca.0.extract27, %37 ], [ @nil_typ, %11 ]
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem12.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.reg2mem12.sroa.3.0, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

define { ptr, i160 } @CuckooMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -1975748647346050920
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28) #41
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract28, i64 %9
  %11 = getelementptr i8, ptr %10, i64 56
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i1 %13(ptr %.fca.1.extract29) #43
  br i1 %14, label %._crit_edge, label %15

._crit_edge:                                      ; preds = %3
  %.pre = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %.pre19 = insertvalue { ptr, ptr, ptr, i32 } %.pre, ptr %.fca.1.extract29, 1
  %.pre21 = insertvalue { ptr, ptr, ptr, i32 } %.pre19, ptr %.fca.2.extract, 2
  %.pre23 = insertvalue { ptr, ptr, ptr, i32 } %.pre21, i32 %offset.i, 3
  br label %44

15:                                               ; preds = %3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28) #44
  %17 = getelementptr i8, ptr %10, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr } %19(ptr %.fca.1.extract29) #43
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract29, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i, 3
  %result.i3 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %25 = getelementptr inbounds i8, ptr %result.i3, i64 8
  store ptr null, ptr %25, align 8
  store ptr @buffer_typ, ptr %result.i3, align 8
  store ptr %result.i3, ptr %4, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4) #44
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28) #44
  %28 = getelementptr i8, ptr %10, i64 72
  %29 = load ptr, ptr %28, align 8
  store ptr @buffer_typ, ptr %5, align 8
  %result.i1 = call ptr %29({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %5) #47
  %30 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 dereferenceable(8) %4, { ptr } %20)
  %.fca.0.extract41 = extractvalue { ptr, i160 } %30, 0
  %31 = icmp ne ptr %.fca.0.extract41, @nil_typ
  %32 = icmp ne ptr %.fca.0.extract41, null
  %.not48.not.not = and i1 %31, %32
  br i1 %.not48.not.not, label %43, label %33

33:                                               ; preds = %15
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %35 = getelementptr i8, ptr %10, i64 48
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract29, i32 0) #42
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %40 = load ptr, ptr %11, align 8
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  call void %42(ptr %.fca.1.extract29, i1 true) #42
  br label %44

43:                                               ; preds = %15
  %.fca.1.extract42 = extractvalue { ptr, i160 } %30, 1
  %hash_coef_ptr.i4 = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i5 = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i6 = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i7 = load i64, ptr %hash_coef_ptr.i4, align 4
  %tbl_size.i8 = load i64, ptr %tbl_size_ptr.i5, align 4
  %offset_tbl.i9 = load ptr, ptr %offset_tbl_ptr.i6, align 8
  %product.i.i10 = mul i64 %hash_coef.i7, 9197944775169318296
  %shifted.i.i11 = lshr i64 %product.i.i10, 32
  %xored.i.i12 = xor i64 %shifted.i.i11, %product.i.i10
  %hash.i.i13 = and i64 %xored.i.i12, %tbl_size.i8
  %offset_ptr.i14 = getelementptr i32, ptr %offset_tbl.i9, i64 %hash.i.i13
  %offset.i15 = load i32, ptr %offset_ptr.i14, align 4
  %.sroa.5.8.insert.ext = zext i32 %offset.i15 to i160
  %.sroa.5.8.insert.shift = shl nuw i160 %.sroa.5.8.insert.ext, 128
  %.sroa.3.8.insert.ext = and i160 %.fca.1.extract42, 340282366920938463463374607431768211455
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.shift, %.sroa.3.8.insert.ext
  br label %56

44:                                               ; preds = %33, %._crit_edge
  %.pre-phi24 = phi { ptr, ptr, ptr, i32 } [ %.pre23, %._crit_edge ], [ %24, %33 ]
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %46 = getelementptr i8, ptr %10, i64 32
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract29) #43
  %result.i2 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %50 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr null, ptr %50, align 8
  store ptr @buffer_typ, ptr %result.i2, align 8
  store ptr %result.i2, ptr %6, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %53 = getelementptr i8, ptr %10, i64 72
  %54 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %7, align 8
  %result.i = call ptr %54({ ptr, ptr, ptr, i32 } %.pre-phi24, ptr nocapture nofree noundef nonnull readonly align 8 %7) #47
  %55 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %.pre-phi24, { ptr, ptr, ptr, i32 } %.pre-phi24, ptr nonnull align 8 dereferenceable(8) %6, { ptr } %49)
  %.fca.0.extract30 = extractvalue { ptr, i160 } %55, 0
  %.fca.1.extract31 = extractvalue { ptr, i160 } %55, 1
  br label %56

56:                                               ; preds = %44, %43
  %.reg2mem11.sroa.0.0 = phi ptr [ %.fca.0.extract30, %44 ], [ %.fca.0.extract41, %43 ]
  %.reg2mem11.sroa.3.0 = phi i160 [ %.fca.1.extract31, %44 ], [ %.sroa.3.8.insert.insert, %43 ]
  %.reload12.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem11.sroa.0.0, 0
  %.reload12.fca.1.insert = insertvalue { ptr, i160 } %.reload12.fca.0.insert, i160 %.reg2mem11.sroa.3.0, 1
  ret { ptr, i160 } %.reload12.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #37 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #45
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #45
  %20 = extractvalue { i64, i64 } %result.i, 0
  %21 = extractvalue { i64, i64 } %result.i, 1
  %22 = call i64 @llvm.umax.i64(i64 %8, i64 %21) #60
  %23 = call i64 @llvm.umax.i64(i64 %22, i64 noundef 8) #60, !range !4
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %33, %29
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_primary_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_to_pair_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #5 {
  %.fca.0.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract22, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract22, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract22, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract22) #41
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract22, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract23, { ptr, i160 } %3) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract22) #44
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract23, { ptr, i160 } %4) #42
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract22) #44
  %20 = getelementptr i8, ptr %9, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract23, i32 %5) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 32
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Entry_primary_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Entry_to_pair_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract57, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract57, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract57, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #41
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract57, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr nonnull %.fca.1.extract58) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #44
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr, i160 } %14(ptr nonnull %.fca.1.extract58) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #44
  %17 = load ptr, ptr %6, align 8
  %result.i3 = call align 8 ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract58) #45
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #44
  %19 = getelementptr i8, ptr %6, i64 8
  %20 = load ptr, ptr %19, align 8
  %result.i2 = call align 8 ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract58) #45
  %21 = load ptr, ptr %result.i3, align 8, !alias.scope !17
  %22 = getelementptr i8, ptr %21, i64 72
  %23 = load ptr, ptr %22, align 8, !alias.scope !17
  %result.i1.i = call { i64, i64 } %23(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45, !alias.scope !17
  %24 = extractvalue { i64, i64 } %result.i1.i, 0
  %25 = extractvalue { i64, i64 } %result.i1.i, 1
  %26 = urem i64 16, %25
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %25, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %24, 16
  %31 = add i64 %30, %29
  %32 = load ptr, ptr %result.i2, align 8, !alias.scope !17
  %33 = getelementptr i8, ptr %32, i64 72
  %34 = load ptr, ptr %33, align 8, !alias.scope !17
  %result.i.i = call { i64, i64 } %34(ptr nocapture nofree nonnull readonly align 8 %result.i2) #45, !alias.scope !17
  %35 = extractvalue { i64, i64 } %result.i.i, 0
  %36 = extractvalue { i64, i64 } %result.i.i, 1
  %37 = call i64 @llvm.umax.i64(i64 %25, i64 %36) #60
  %38 = call i64 @llvm.umax.i64(i64 %37, i64 noundef 8) #60, !range !4
  %39 = urem i64 %31, %36
  %40 = icmp eq i64 %39, 0
  %41 = sub i64 %36, %39
  %42 = select i1 %40, i64 0, i64 %41
  %43 = add i64 %35, %31
  %44 = add i64 %43, %42
  %45 = urem i64 %44, %38
  %46 = icmp eq i64 %45, 0
  %47 = sub i64 %38, %45
  %48 = select i1 %46, i64 0, i64 %47
  %49 = add i64 %48, %44
  %result.i6 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %49) #49
  store ptr %result.i3, ptr %result.i6, align 8
  %50 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i6) #44
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #44
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr, i160 } %54(ptr nonnull %.fca.1.extract58) #43
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #44
  %57 = load ptr, ptr %12, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, i160 } %58(ptr nonnull %.fca.1.extract58) #43
  %60 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr undef, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 10, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #44
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #44
  %65 = load ptr, ptr %result.i3, align 8
  %66 = getelementptr i8, ptr %65, i64 72
  %67 = load ptr, ptr %66, align 8
  %result.i.i7 = call { i64, i64 } %67(ptr nocapture nofree nonnull readonly align 8 %result.i3) #45
  %68 = extractvalue { i64, i64 } %result.i.i7, 1
  %69 = urem i64 16, %68
  %70 = icmp eq i64 %69, 0
  %reass.sub10 = sub i64 %68, %69
  %71 = add i64 %reass.sub10, 16
  %72 = select i1 %70, i64 16, i64 %71
  %73 = getelementptr i8, ptr %result.i6, i64 %72
  %74 = getelementptr i8, ptr %65, i64 64
  %75 = load ptr, ptr %74, align 8
  call void %75({ ptr, i160 } %55, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %73) #46
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #44
  %77 = load ptr, ptr %result.i6, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr i8, ptr %78, i64 72
  %80 = load ptr, ptr %79, align 8
  %result.i1.i8 = call { i64, i64 } %80(ptr nocapture nofree nonnull readonly align 8 %77) #45
  %81 = extractvalue { i64, i64 } %result.i1.i8, 0
  %82 = extractvalue { i64, i64 } %result.i1.i8, 1
  %83 = urem i64 16, %82
  %84 = icmp eq i64 %83, 0
  %85 = sub i64 %82, %83
  %86 = select i1 %84, i64 0, i64 %85
  %87 = add i64 %81, 16
  %88 = add i64 %87, %86
  %89 = load ptr, ptr %50, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = getelementptr i8, ptr %90, i64 72
  %92 = load ptr, ptr %91, align 8
  %result.i.i9 = call { i64, i64 } %92(ptr nocapture nofree nonnull readonly align 8 %89) #45
  %93 = extractvalue { i64, i64 } %result.i.i9, 1
  %94 = urem i64 %88, %93
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %93, %94
  %97 = select i1 %95, i64 0, i64 %96
  %98 = getelementptr i8, ptr %result.i6, i64 %88
  %99 = getelementptr i8, ptr %98, i64 %97
  %100 = getelementptr i8, ptr %90, i64 64
  %101 = load ptr, ptr %100, align 8
  call void %101({ ptr, i160 } %59, ptr nocapture nofree nonnull readonly align 8 %89, ptr nocapture nofree writeonly %99) #46
  ret { ptr, ptr, ptr, i32 } %62
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_value(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i1 = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #45
  %6 = extractvalue { i64, i64 } %result.i1, 0
  %7 = extractvalue { i64, i64 } %result.i1, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 20
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %15) #45
  %19 = extractvalue { i64, i64 } %result.i, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly align 8 %15) #45
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_value(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #45
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #45
  %20 = extractvalue { i64, i64 } %result.i, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %16, ptr nocapture nofree writeonly %26) #46
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_key(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #45
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 20, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 20
  %10 = select i1 %8, i64 20, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly align 8 %2) #45
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_key(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #45
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %3, ptr nocapture nofree writeonly %12) #46
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_primary_hash(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_primary_hash(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @CuckooMapIterator_getter_on_second(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_on_second(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_table_len(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_KeyNotFound(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @KeyNotFound_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Map(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapValues(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValues_field_MapValues_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValues_field_MapValues_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 32, i64 33
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapValues_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 2074062704914054732
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, -5249855671126779970
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

define i32 @MapValues_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 2074062704914054732
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 96
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @MapValues_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 2074062704914054732
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract66, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract68) #43
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract39) #44
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %24 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %26 = getelementptr i8, ptr %7, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call ptr %27(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %result.i10 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i3, ptr %result.i10, align 8
  %28 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i10)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, ptr, ptr, i32 } %32(ptr nonnull %.fca.1.extract68) #43
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract15, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract16, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %.fca.3.extract17, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract14)
  %40 = sext i32 %.fca.3.extract17 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract14, i64 %40
  %42 = getelementptr i8, ptr %41, i64 112
  %43 = load ptr, ptr %42, align 8
  %result.i6 = call ptr %43({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %44 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %hash_coef_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i12 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i14 = load i64, ptr %hash_coef_ptr.i11, align 4
  %tbl_size.i15 = load i64, ptr %tbl_size_ptr.i12, align 4
  %offset_tbl.i16 = load ptr, ptr %offset_tbl_ptr.i13, align 8
  %product.i.i17 = mul i64 %hash_coef.i14, 8673632051301757104
  %shifted.i.i18 = lshr i64 %product.i.i17, 32
  %xored.i.i19 = xor i64 %shifted.i.i18, %product.i.i17
  %hash.i.i20 = and i64 %xored.i.i19, %tbl_size.i15
  %offset_ptr.i21 = getelementptr i32, ptr %offset_tbl.i16, i64 %hash.i.i20
  %offset.i22 = load i32, ptr %offset_ptr.i21, align 4
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapValueIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @MapValueIterator) #41
  %50 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store i32 %offset.i22, ptr %53, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %54
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapValueIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValueIterator_B_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValueIterator_field_MapValueIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValueIterator_field_MapValueIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValueIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapValueIterator_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4981803053484113385
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

define { ptr, i160 } @MapValueIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4981803053484113385
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract15, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract17) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = icmp ne ptr %.fca.0.extract, @nil_typ
  %24 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %23, %24
  br i1 %.not43, label %25, label %39

25:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %22, 1
  %.sroa.3.sroa.2.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.sroa.2.0.extract.trunc = trunc i160 %.sroa.3.sroa.2.0.extract.shift to i64
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %26 = inttoptr i64 %.sroa.3.sroa.0.0.extract.trunc to ptr
  %27 = inttoptr i64 %.sroa.3.sroa.2.0.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 9197944775169318296
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %26, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %27, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %offset.i13, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %34 = sext i32 %offset.i13 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 48
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %38, 0
  %.fca.1.extract30 = extractvalue { ptr, i160 } %38, 1
  br label %39

39:                                               ; preds = %25, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract28, %25 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract30, %25 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapValueIterator_getter_map_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapValueIterator_setter_map_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapValues_getter_map(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapValues_setter_map(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapKeys(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeys_field_MapKeys_1(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeys_field_MapKeys_0(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 32, i64 33
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #45
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapKeys_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -6755415596079746205
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, -5249855671126779970
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

define i32 @MapKeys_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -6755415596079746205
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 96
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @MapKeys_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -6755415596079746205
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract66, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract68) #43
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract39) #44
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %24 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %26 = getelementptr i8, ptr %7, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call ptr %27(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #45
  %result.i10 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #49
  store ptr %result.i3, ptr %result.i10, align 8
  %28 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i10)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, ptr, ptr, i32 } %32(ptr nonnull %.fca.1.extract68) #43
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract15, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract16, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %.fca.3.extract17, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract14)
  %40 = sext i32 %.fca.3.extract17 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract14, i64 %40
  %42 = getelementptr i8, ptr %41, i64 112
  %43 = load ptr, ptr %42, align 8
  %result.i6 = call ptr %43({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %44 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %hash_coef_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i12 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i14 = load i64, ptr %hash_coef_ptr.i11, align 4
  %tbl_size.i15 = load i64, ptr %tbl_size_ptr.i12, align 4
  %offset_tbl.i16 = load ptr, ptr %offset_tbl_ptr.i13, align 8
  %product.i.i17 = mul i64 %hash_coef.i14, 8673632051301757104
  %shifted.i.i18 = lshr i64 %product.i.i17, 32
  %xored.i.i19 = xor i64 %shifted.i.i18, %product.i.i17
  %hash.i.i20 = and i64 %xored.i.i19, %tbl_size.i15
  %offset_ptr.i21 = getelementptr i32, ptr %offset_tbl.i16, i64 %hash.i.i20
  %offset.i22 = load i32, ptr %offset_ptr.i21, align 4
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapKeyIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @MapKeyIterator) #41
  %50 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store i32 %offset.i22, ptr %53, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %54
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapKeyIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeyIterator_B_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeyIterator_field_MapKeyIterator_1(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeyIterator_field_MapKeyIterator_0(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeyIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #41
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapKeyIterator_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7211362081012783701
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

define { ptr, i160 } @MapKeyIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7211362081012783701
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #41
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract15, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract17) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #44
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %22 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = icmp ne ptr %.fca.0.extract, @nil_typ
  %24 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %23, %24
  br i1 %.not43, label %25, label %39

25:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %22, 1
  %.sroa.3.sroa.2.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.sroa.2.0.extract.trunc = trunc i160 %.sroa.3.sroa.2.0.extract.shift to i64
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %26 = inttoptr i64 %.sroa.3.sroa.0.0.extract.trunc to ptr
  %27 = inttoptr i64 %.sroa.3.sroa.2.0.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 9197944775169318296
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %26, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %27, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %offset.i13, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %34 = sext i32 %offset.i13 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 40
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #47
  %38 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %38, 0
  %.fca.1.extract30 = extractvalue { ptr, i160 } %38, 1
  br label %39

39:                                               ; preds = %25, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract28, %25 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract30, %25 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapKeyIterator_getter_map_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapKeyIterator_setter_map_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapKeys_getter_map(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapKeys_setter_map(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #1 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_eq(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_eq(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_hasher(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_hasher(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_size(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_size(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_table_len(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

define void @report_exception({ ptr } %0) local_unnamed_addr #18 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 9027164862567808692, i64 ptrtoint (ptr @Exception to i64), ptr readonly %12) #45
  br i1 %result.i1, label %13, label %._crit_edge

13:                                               ; preds = %1
  %14 = getelementptr i8, ptr %.fca.0.extract2, i64 56
  %15 = load i160, ptr %14, align 4
  %.sroa.4.sroa.3.0.extract.shift = lshr i160 %15, 64
  %.sroa.4.sroa.3.0.extract.trunc = trunc i160 %.sroa.4.sroa.3.0.extract.shift to i64
  %.sroa.4.sroa.0.0.extract.trunc = trunc i160 %15 to i64
  %16 = inttoptr i64 %.sroa.4.sroa.0.0.extract.trunc to ptr
  %17 = inttoptr i64 %.sroa.4.sroa.3.0.extract.trunc to ptr
  %offset_tbl_ptr.i = getelementptr i8, ptr %4, i64 40
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %9, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %10
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %4, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %16, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %17, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #41
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %24 = sext i32 %offset.i to i64
  %25 = getelementptr ptr, ptr %4, i64 %24
  %26 = getelementptr i8, ptr %25, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %2) #47
  call void %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %2)
  br label %._crit_edge

._crit_edge:                                      ; preds = %13, %1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #1 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

; Function Attrs: cold minsize
define internal fastcc void @String__Self_from_bytes_source_bytesBufferi8_source_leni32.cold.1(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, ptr noalias nocapture nofree noundef nonnull align 8 %1, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %3, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %4, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %5, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %8, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %9, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %13, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %14) unnamed_addr #39 section "__llvm_cold" {
newFuncRoot:
  store ptr @InvalidUTF8Error, ptr %0, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(104) ptr @bump_malloc_wrapper(i64 noundef 104) #49
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %1) #62
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %1) #62
  %result.i10.i = call noalias dereferenceable_or_null(61) ptr @bump_malloc_wrapper(i64 noundef 61) #49
  store <60 x i8> <i8 73, i8 110, i8 118, i8 97, i8 108, i8 105, i8 100, i8 32, i8 85, i8 84, i8 70, i8 45, i8 56, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 99, i8 101, i8 32, i8 101, i8 110, i8 99, i8 111, i8 117, i8 110, i8 116, i8 101, i8 114, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 116, i8 114, i8 105, i8 110, i8 103, i8 32, i8 99, i8 111, i8 110, i8 118, i8 101, i8 114, i8 115, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  %17 = getelementptr i8, ptr %result.i9.i, i64 8
  store <2 x i32> <i32 60, i32 60>, ptr %17, align 8
  %18 = getelementptr i8, ptr %result.i9.i, i64 16
  store i32 61, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i7, i64 40
  store ptr @String, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i7, i64 48
  store ptr %result.i9.i, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i7, i64 64
  store i32 10, ptr %21, align 8
  store i32 0, ptr %result.i7, align 8
  %result.i8.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i8.i, ptr %result.i7.i, align 8
  %22 = getelementptr i8, ptr %result.i7.i, i64 8
  store <2 x i32> zeroinitializer, ptr %22, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #62
  %24 = getelementptr i8, ptr %result.i7.i, i64 16
  store i32 1, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error) #62
  %26 = getelementptr i8, ptr %result.i7, i64 8
  store ptr @String, ptr %26, align 8
  %27 = getelementptr i8, ptr %result.i7, i64 16
  store ptr %result.i7.i, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i7, i64 32
  store i32 10, ptr %28, align 8
  %result.i6.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  store ptr %result.i.i, ptr %result.i6.i, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #62
  %30 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %31 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %30)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %33 = getelementptr i8, ptr %result.i6.i, i64 8
  store i64 %31, ptr %33, align 8
  %34 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @Stacktrace, ptr %34, align 8
  %35 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i6.i, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %36, align 8
  %result.i6 = call noalias dereferenceable_or_null(56) ptr @bump_malloc_wrapper(i64 noundef 56) #49
  store <55 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 99, i8 111, i8 114, i8 101, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i6, align 1
  store ptr @String, ptr %2, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr @_parameterization_Bufferi8, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %4, align 8
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %6, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %3)
  store ptr @buffer_typ, ptr %7, align 8
  store ptr @i32_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr @i32_typ, ptr %10, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %7) #41
  store ptr %result.i6, ptr %result.i5, align 8
  %39 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> <i32 55, i32 55>, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %41 = getelementptr i8, ptr %result.i5, i64 16
  store i32 56, ptr %41, align 8
  store ptr @_parameterization_i32, ptr %11, align 8
  store ptr @_parameterization_String, ptr %12, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error)
  store ptr @i32_typ, ptr %13, align 8
  store ptr @String, ptr %14, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %13) #41
  store i32 139, ptr %result.i7, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error) #44
  store ptr @String, ptr %26, align 8
  store ptr %result.i5, ptr %27, align 8
  store i32 10, ptr %28, align 8
  %46 = ptrtoint ptr %result.i7 to i64
  %.sroa.475.8.insert.ext = zext i64 %46 to i160
  %.sroa.475.8.insert.insert = or disjoint i160 %.sroa.475.8.insert.ext, 3402823669209384634633746074317682114560
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %47 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @InvalidUTF8Error, ptr %47, align 8
  %48 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i160 %.sroa.475.8.insert.insert, ptr %48, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #54
  ret void
}

; Function Attrs: cold minsize
define internal fastcc void @Array_bounds_check_indexi32.cold.1(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract, ptr %.fca.1.extract, ptr nocapture nofree noundef nonnull readonly %0, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %4, i32 %5, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %10) unnamed_addr #39 section "__llvm_cold" {
newFuncRoot:
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract) #62
  %12 = call i32 %0(ptr %.fca.1.extract) #63
  store ptr @OutOfBounds, ptr %1, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(136) ptr @bump_malloc_wrapper(i64 noundef 136) #49
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract) #44
  %14 = load ptr, ptr %2, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #63
  store ptr @_parameterization_i32, ptr %3, align 8
  %17 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3) #44
  store ptr @i32_typ, ptr %4, align 8
  %19 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %4) #41
  %result.i13.i = call noalias align 4 dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #49
  store i32 %16, ptr %result.i13.i, align 4
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails) #44
  %22 = getelementptr i8, ptr %result.i13.i, i64 4
  store i32 %5, ptr %22, align 4
  %23 = ptrtoint ptr %result.i13.i to i64
  %.sroa.3.8.insert.ext.i = zext i64 %23 to i160
  %.sroa.3.8.insert.insert.i = or disjoint i160 %.sroa.3.8.insert.ext.i, 3402823669209384634633746074317682114560
  store ptr @OutOfBoundsDetails, ptr %result.i7, align 8
  %24 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store i160 %.sroa.3.8.insert.insert.i, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i7, i64 32
  store i32 0, ptr %25, align 8
  %result.i12.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %result.i11.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i12.i, ptr %result.i11.i, align 8
  %26 = getelementptr i8, ptr %result.i11.i, i64 8
  store <2 x i32> zeroinitializer, ptr %26, align 8
  %27 = getelementptr i8, ptr %result.i11.i, i64 16
  store i32 1, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i7, i64 40
  store ptr @String, ptr %28, align 8
  %29 = getelementptr i8, ptr %result.i7, i64 48
  store ptr %result.i11.i, ptr %29, align 8
  %30 = getelementptr i8, ptr %result.i7, i64 64
  store i32 10, ptr %30, align 8
  %result.i10.i = call noalias dereferenceable_or_null(66) ptr @bump_malloc_wrapper(i64 noundef 66) #49
  store <65 x i8> <i8 65, i8 110, i8 32, i8 111, i8 117, i8 116, i8 45, i8 111, i8 102, i8 45, i8 98, i8 111, i8 117, i8 110, i8 100, i8 115, i8 32, i8 101, i8 114, i8 114, i8 111, i8 114, i8 32, i8 111, i8 99, i8 99, i8 117, i8 114, i8 114, i8 101, i8 100, i8 32, i8 119, i8 104, i8 105, i8 108, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 116, i8 111, i8 32, i8 97, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  %31 = getelementptr i8, ptr %result.i9.i, i64 8
  store <2 x i32> <i32 65, i32 65>, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %33 = getelementptr i8, ptr %result.i9.i, i64 16
  store i32 66, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef nonnull align 16 dereferenceable(328) @OutOfBounds) #44
  %35 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @String, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i9.i, ptr %36, align 8
  %37 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %37, align 8
  %result.i8.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %result.i.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  store ptr %result.i.i.i, ptr %result.i8.i, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #44
  %39 = insertvalue { ptr } undef, ptr %result.i.i.i, 0
  %40 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %39)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %42 = getelementptr i8, ptr %result.i8.i, i64 8
  store i64 %40, ptr %42, align 8
  %43 = getelementptr i8, ptr %result.i7, i64 104
  store ptr @Stacktrace, ptr %43, align 8
  %44 = getelementptr i8, ptr %result.i7, i64 112
  store ptr %result.i8.i, ptr %44, align 8
  %45 = getelementptr i8, ptr %result.i7, i64 128
  store i32 10, ptr %45, align 8
  %result.i6 = call noalias dereferenceable_or_null(57) ptr @bump_malloc_wrapper(i64 noundef 57) #49
  store <56 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 97, i8 114, i8 114, i8 97, i8 121, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i6, align 1
  store ptr @String, ptr %6, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr @_parameterization_Bufferi8, ptr %7, align 8
  %46 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  store ptr @buffer_typ, ptr %8, align 8
  %50 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @i32_typ, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %8) #41
  store ptr %result.i6, ptr %result.i5, align 8
  %54 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> <i32 56, i32 56>, ptr %54, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %56 = getelementptr i8, ptr %result.i5, i64 16
  store i32 57, ptr %56, align 8
  store ptr @_parameterization_i32, ptr %9, align 8
  %57 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @_parameterization_String, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef nonnull align 16 dereferenceable(328) @OutOfBounds)
  store ptr @i32_typ, ptr %10, align 8
  %60 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr @String, ptr %60, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %10) #41
  store i32 101, ptr %25, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(328) @OutOfBounds) #44
  store ptr @String, ptr %28, align 8
  store ptr %result.i5, ptr %29, align 8
  store i32 10, ptr %30, align 8
  %63 = ptrtoint ptr %result.i7 to i64
  %.sroa.460.8.insert.ext = zext i64 %63 to i160
  %.sroa.460.8.insert.insert = or disjoint i160 %.sroa.460.8.insert.ext, 3402823669209384634633746074317682114560
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %64 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @OutOfBounds, ptr %64, align 8
  %65 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i160 %.sroa.460.8.insert.insert, ptr %65, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #54
  ret void
}

; Function Attrs: cold minsize noreturn
define internal fastcc void @Map__index_keyK.cold.1(ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %0, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %1, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %2, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %3, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %4, ptr noalias nocapture nofree noundef nonnull align 8 %5, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6) unnamed_addr #40 section "__llvm_cold" {
newFuncRoot:
  %7 = getelementptr inbounds i8, ptr %0, i64 8
  %8 = getelementptr inbounds i8, ptr %0, i64 16
  %9 = getelementptr inbounds i8, ptr %0, i64 24
  %10 = getelementptr inbounds i8, ptr %1, i64 8
  %11 = getelementptr inbounds i8, ptr %1, i64 16
  %12 = getelementptr inbounds i8, ptr %1, i64 24
  %13 = getelementptr inbounds i8, ptr %2, i64 8
  %14 = getelementptr inbounds i8, ptr %3, i64 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %newFuncRoot
  store ptr @KeyNotFound, ptr %4, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(104) ptr @bump_malloc_wrapper(i64 noundef 104) #49
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %5) #64
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound) #64
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %5) #62
  store i32 0, ptr %result.i7, align 8
  %result.i10.i = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #49
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  %18 = getelementptr i8, ptr %result.i9.i, i64 8
  store <2 x i32> <i32 6, i32 6>, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i9.i, i64 16
  store i32 7, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i7, i64 40
  store ptr @String, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i7, i64 48
  store ptr %result.i9.i, ptr %21, align 8
  %22 = getelementptr i8, ptr %result.i7, i64 64
  store i32 10, ptr %22, align 8
  %result.i8.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #49
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr %result.i8.i, ptr %result.i7.i, align 8
  %23 = getelementptr i8, ptr %result.i7.i, i64 8
  store <2 x i32> zeroinitializer, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #62
  %25 = getelementptr i8, ptr %result.i7.i, i64 16
  store i32 1, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound) #64
  %27 = getelementptr i8, ptr %result.i7, i64 8
  store ptr @String, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i7, i64 16
  store ptr %result.i7.i, ptr %28, align 8
  %29 = getelementptr i8, ptr %result.i7, i64 32
  store i32 10, ptr %29, align 8
  %result.i6.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #49
  %result.i.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #49
  store ptr %result.i.i.i, ptr %result.i6.i, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #62
  %31 = insertvalue { ptr } undef, ptr %result.i.i.i, 0
  %32 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %31)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %34 = getelementptr i8, ptr %result.i6.i, i64 8
  store i64 %32, ptr %34, align 8
  %35 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @Stacktrace, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i6.i, ptr %36, align 8
  %37 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %37, align 8
  %result.i6 = call noalias dereferenceable_or_null(55) ptr @bump_malloc_wrapper(i64 noundef 55) #49
  store <54 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 109, i8 97, i8 112, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i6, align 1
  store ptr @String, ptr %6, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #49
  store ptr @_parameterization_Bufferi8, ptr %0, align 8
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr @_parameterization_i32, ptr %9, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %0)
  store ptr @buffer_typ, ptr %1, align 8
  store ptr @i32_typ, ptr %10, align 8
  store ptr @i32_typ, ptr %11, align 8
  store ptr @i32_typ, ptr %12, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr noalias nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %1) #41
  store ptr %result.i6, ptr %result.i5, align 8
  %40 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> <i32 54, i32 54>, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #44
  %42 = getelementptr i8, ptr %result.i5, i64 16
  store i32 55, ptr %42, align 8
  store ptr @_parameterization_i32, ptr %2, align 8
  store ptr @_parameterization_String, ptr %13, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %2)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound)
  store ptr @i32_typ, ptr %3, align 8
  store ptr @String, ptr %14, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %3) #41
  store i32 26, ptr %result.i7, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound) #44
  store ptr @String, ptr %27, align 8
  store ptr %result.i5, ptr %28, align 8
  store i32 10, ptr %29, align 8
  %47 = ptrtoint ptr %result.i7 to i64
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %48 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @KeyNotFound, ptr %48, align 8
  %49 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i64 %47, ptr %49, align 4
  %.sroa_idx68 = getelementptr i8, ptr %current_coroutine.i, i64 64
  store i96 184467440737095516160, ptr %.sroa_idx68, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #54
  br label %._crit_edge
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #19

attributes #0 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "disable-tail-calls"="true" }
attributes #2 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #3 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "disable-tail-calls"="true" }
attributes #4 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #5 = { mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #6 = { mustprogress nounwind willreturn "disable-tail-calls"="true" }
attributes #7 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #8 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #10 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #11 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #12 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #13 = { alwaysinline mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #14 = { nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #15 = { alwaysinline mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, inaccessiblemem: none) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #16 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #17 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #18 = { "disable-tail-calls"="true" }
attributes #19 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #20 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #21 = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #22 = { noreturn nounwind }
attributes #23 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #24 = { nocallback nofree nosync nounwind willreturn }
attributes #25 = { nofree nounwind "disable-tail-calls"="true" }
attributes #26 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #27 = { noinline nounwind memory(readwrite) "disable-tail-calls"="true" }
attributes #28 = { nounwind "disable-tail-calls"="true" }
attributes #29 = { cold minsize noinline nounwind "disable-tail-calls"="true" }
attributes #30 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #31 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #32 = { mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #33 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #34 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #35 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #36 = { mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #37 = { mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #38 = { mustprogress nofree nosync nounwind willreturn "disable-tail-calls"="true" }
attributes #39 = { cold minsize "disable-tail-calls"="true" }
attributes #40 = { cold minsize noreturn "disable-tail-calls"="true" }
attributes #41 = { nofree willreturn }
attributes #42 = { nounwind willreturn memory(argmem: readwrite) }
attributes #43 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #44 = { willreturn }
attributes #45 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #46 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #47 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #48 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #49 = { mustprogress nofree nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #50 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #51 = { nofree nosync nounwind willreturn memory(read) }
attributes #52 = { mustprogress nofree nosync nounwind willreturn }
attributes #53 = { nounwind memory(read) }
attributes #54 = { nounwind }
attributes #55 = { nounwind memory(readwrite) }
attributes #56 = { nofree nounwind }
attributes #57 = { nofree }
attributes #58 = { nofree nounwind willreturn }
attributes #59 = { noinline }
attributes #60 = { nofree nosync willreturn }
attributes #61 = { noinline noreturn }
attributes #62 = { nofree willreturn memory(readwrite) }
attributes #63 = { nounwind willreturn memory(readwrite) }
attributes #64 = { nofree memory(readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{!2}
!2 = distinct !{!2, !3, !"size_wrapper: argument 0"}
!3 = distinct !{!3, !"size_wrapper"}
!4 = !{i64 8, i64 0}
!5 = !{!6}
!6 = distinct !{!6, !7, !"size_wrapper: argument 0"}
!7 = distinct !{!7, !"size_wrapper"}
!8 = !{!9}
!9 = distinct !{!9, !10, !"size_wrapper: argument 0"}
!10 = distinct !{!10, !"size_wrapper"}
!11 = !{!12}
!12 = distinct !{!12, !13, !"size_wrapper: argument 0"}
!13 = distinct !{!13, !"size_wrapper"}
!14 = !{!15}
!15 = distinct !{!15, !16, !"size_wrapper: argument 0"}
!16 = distinct !{!16, !"size_wrapper"}
!17 = !{!18}
!18 = distinct !{!18, !19, !"size_wrapper: argument 0"}
!19 = distinct !{!19, !"size_wrapper"}
