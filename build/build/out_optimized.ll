; ModuleID = 'C:\Users\PaulK\OneDrive\Documents\PL\PyPL\build\build\out_optimized.dbg.ll'
source_filename = "llvm-link"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "aarch64-windows-msvc"

%struct._EXCEPTION_RECORD = type { i32, i32, ptr, ptr, i32, [15 x i64] }
%struct._CONTEXT = type { i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i16, i16, i16, i16, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %union.anon, [26 x %struct._M128A], i64, i64, i64, i64, i64, i64 }
%union.anon = type { %struct._XSAVE_FORMAT }
%struct._XSAVE_FORMAT = type { i16, i16, i8, i8, i16, i32, i16, i16, i32, i16, i16, i32, i32, [8 x %struct._M128A], [16 x %struct._M128A], [96 x i8] }
%struct._M128A = type { i64, i64 }

@string_string = internal constant [4 x i8] c"%s\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local local_unnamed_addr global ptr null
@always_one = linkonce thread_local local_unnamed_addr global i1 true
@current_ptr = thread_local global ptr null
@backtrace_string = constant [16 x i8] c"%i: %s - 0x%0X\0A\00"
@last_fault_addr = internal unnamed_addr global ptr null
@_parameterization_Pairi32._Bool = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_Bool, ptr null]
@_parameterization_Pairi32._i32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedi32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedi32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@tuple_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @tuple_typ]
@tuple_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@_parameterization_Bool = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 24, i32 10, i32 10, i32 0]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Iterator]
@Iterator_offset_tbl = constant [4 x i32] [i32 13, i32 0, i32 10, i32 10]
@Iterable_hashtbl = constant [4 x ptr] [ptr null, ptr @Iterable, ptr @any_typ, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 35]
@ConstantTimeIterator_hashtbl = constant [4 x ptr] [ptr @Object, ptr @ConstantTimeIterator, ptr @any_typ, ptr @Iterator]
@ConstantTimeIterator_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 10, i32 13]
@Enumerated_hashtbl = constant [4 x ptr] [ptr @Enumerated, ptr @Iterable, ptr @any_typ, ptr @Object]
@Enumerated_offset_tbl = constant [4 x i32] [i32 10, i32 39, i32 10, i32 64]
@Enumerated = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 6044713360068526275, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Enumerated_hashtbl, ptr @Enumerated_offset_tbl, ptr @_data_size_Enumerated, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Enumerated_field_Enumerated_0, ptr @Enumerated_field_Enumerated_1, ptr @Enumerated_field_iterable, ptr @Enumerated_B_init_iterableIterableT, ptr @Enumerated_B_iterator_, ptr @Enumerated_B_each_fFunctionT_to_Nothing, ptr @Enumerated_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumerated_B_all_fFunctionT_to_Bool, ptr @Enumerated_B_any_fFunctionT_to_Bool, ptr @Enumerated_B_enumerate_, ptr @Enumerated_B_map_fFunctionT_to_U, ptr @Enumerated_B_filter_fFunctionT_to_Bool, ptr @Enumerated_B_chain_otherIterableT, ptr @Enumerated_B_interleave_otherIterableT, ptr @Enumerated_B_zip_otherIterableU, ptr @Enumerated_B_product_otherIterableU, ptr @Enumerated_init_iterableIterableT, ptr @Enumerated_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Enumerated_field_Enumerated_1, ptr @Enumerated_B_iterator_, ptr @Enumerated_B_each_fFunctionT_to_Nothing, ptr @Enumerated_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumerated_B_all_fFunctionT_to_Bool, ptr @Enumerated_B_any_fFunctionT_to_Bool, ptr @Enumerated_B_enumerate_, ptr @Enumerated_B_map_fFunctionT_to_U, ptr @Enumerated_B_filter_fFunctionT_to_Bool, ptr @Enumerated_B_chain_otherIterableT, ptr @Enumerated_B_interleave_otherIterableT, ptr @Enumerated_B_zip_otherIterableU, ptr @Enumerated_B_product_otherIterableU, ptr @Enumerated_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Enumerator_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @Iterator, ptr @Enumerator]
@Enumerator_offset_tbl = constant [4 x i32] [i32 10, i32 21, i32 18, i32 10]
@Mapped_hashtbl = constant [4 x ptr] [ptr @Mapped, ptr @Iterable, ptr @any_typ, ptr @Object]
@Mapped_offset_tbl = constant [4 x i32] [i32 10, i32 40, i32 10, i32 65]
@Mapped = constant { [3 x i64], [7 x ptr], [55 x ptr] } { [3 x i64] [i64 638460123129944711, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Mapped_hashtbl, ptr @Mapped_offset_tbl, ptr @_data_size_Mapped, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [55 x ptr] [ptr @Mapped_field_Mapped_0, ptr @Mapped_field_Mapped_1, ptr @Mapped_field_iterable, ptr @Mapped_field_f, ptr @Mapped_B_init_iterableIterableT_fFunctionT_to_U, ptr @Mapped_B_iterator_, ptr @Mapped_B_each_fFunctionT_to_Nothing, ptr @Mapped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Mapped_B_all_fFunctionT_to_Bool, ptr @Mapped_B_any_fFunctionT_to_Bool, ptr @Mapped_B_enumerate_, ptr @Mapped_B_map_fFunctionT_to_U, ptr @Mapped_B_filter_fFunctionT_to_Bool, ptr @Mapped_B_chain_otherIterableT, ptr @Mapped_B_interleave_otherIterableT, ptr @Mapped_B_zip_otherIterableU, ptr @Mapped_B_product_otherIterableU, ptr @Mapped_init_iterableIterableT_fFunctionT_to_U, ptr @Mapped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Mapped_field_Mapped_1, ptr @Mapped_B_iterator_, ptr @Mapped_B_each_fFunctionT_to_Nothing, ptr @Mapped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Mapped_B_all_fFunctionT_to_Bool, ptr @Mapped_B_any_fFunctionT_to_Bool, ptr @Mapped_B_enumerate_, ptr @Mapped_B_map_fFunctionT_to_U, ptr @Mapped_B_filter_fFunctionT_to_Bool, ptr @Mapped_B_chain_otherIterableT, ptr @Mapped_B_interleave_otherIterableT, ptr @Mapped_B_zip_otherIterableU, ptr @Mapped_B_product_otherIterableU, ptr @Mapped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Mapper_hashtbl = constant [4 x ptr] [ptr @Mapper, ptr @Object, ptr @any_typ, ptr @Iterator]
@Mapper_offset_tbl = constant [4 x i32] [i32 10, i32 21, i32 10, i32 18]
@Filtered_hashtbl = constant [4 x ptr] [ptr @Filtered, ptr @Iterable, ptr @any_typ, ptr @Object]
@Filtered_offset_tbl = constant [4 x i32] [i32 10, i32 39, i32 10, i32 64]
@Filtered = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -1080024301579294453, i64 4611686018427389201, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Filtered_hashtbl, ptr @Filtered_offset_tbl, ptr @_data_size_Filtered, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Filtered_field_Filtered_0, ptr @Filtered_field_iterable, ptr @Filtered_field_f, ptr @Filtered_B_init_iterableIterableT_fFunctionT_to_Bool, ptr @Filtered_B_iterator_, ptr @Filtered_B_each_fFunctionT_to_Nothing, ptr @Filtered_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Filtered_B_all_fFunctionT_to_Bool, ptr @Filtered_B_any_fFunctionT_to_Bool, ptr @Filtered_B_enumerate_, ptr @Filtered_B_map_fFunctionT_to_U, ptr @Filtered_B_filter_fFunctionT_to_Bool, ptr @Filtered_B_chain_otherIterableT, ptr @Filtered_B_interleave_otherIterableT, ptr @Filtered_B_zip_otherIterableU, ptr @Filtered_B_product_otherIterableU, ptr @Filtered_init_iterableIterableT_fFunctionT_to_Bool, ptr @Filtered_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Filtered_field_Filtered_0, ptr @Filtered_B_iterator_, ptr @Filtered_B_each_fFunctionT_to_Nothing, ptr @Filtered_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Filtered_B_all_fFunctionT_to_Bool, ptr @Filtered_B_any_fFunctionT_to_Bool, ptr @Filtered_B_enumerate_, ptr @Filtered_B_map_fFunctionT_to_U, ptr @Filtered_B_filter_fFunctionT_to_Bool, ptr @Filtered_B_chain_otherIterableT, ptr @Filtered_B_interleave_otherIterableT, ptr @Filtered_B_zip_otherIterableU, ptr @Filtered_B_product_otherIterableU, ptr @Filtered_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Filterer_hashtbl = constant [4 x ptr] [ptr @Filterer, ptr @Iterator, ptr @any_typ, ptr @Object]
@Filterer_offset_tbl = constant [4 x i32] [i32 10, i32 17, i32 10, i32 20]
@Filterer = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 3681499794063910215, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Filterer_hashtbl, ptr @Filterer_offset_tbl, ptr @_data_size_Filterer, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Filterer_field_Filterer_0, ptr @Filterer_field_iterator, ptr @Filterer_field_f, ptr @Filterer_B_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @Filterer_B_next_, ptr @Filterer_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @Filterer_next_, ptr @Filterer_field_Filterer_0, ptr @Filterer_B_next_, ptr @Filterer_next_] }
@Chained_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @Object, ptr @any_typ, ptr @Chained]
@Chained_offset_tbl = constant [4 x i32] [i32 39, i32 64, i32 10, i32 10]
@Chained = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -4211902305383154752, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Chained_hashtbl, ptr @Chained_offset_tbl, ptr @_data_size_Chained, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Chained_field_Chained_0, ptr @Chained_field_first, ptr @Chained_field_second, ptr @Chained_B_init_firstIterableT_secondIterableT, ptr @Chained_B_iterator_, ptr @Chained_B_each_fFunctionT_to_Nothing, ptr @Chained_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Chained_B_all_fFunctionT_to_Bool, ptr @Chained_B_any_fFunctionT_to_Bool, ptr @Chained_B_enumerate_, ptr @Chained_B_map_fFunctionT_to_U, ptr @Chained_B_filter_fFunctionT_to_Bool, ptr @Chained_B_chain_otherIterableT, ptr @Chained_B_interleave_otherIterableT, ptr @Chained_B_zip_otherIterableU, ptr @Chained_B_product_otherIterableU, ptr @Chained_init_firstIterableT_secondIterableT, ptr @Chained_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Chained_field_Chained_0, ptr @Chained_B_iterator_, ptr @Chained_B_each_fFunctionT_to_Nothing, ptr @Chained_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Chained_B_all_fFunctionT_to_Bool, ptr @Chained_B_any_fFunctionT_to_Bool, ptr @Chained_B_enumerate_, ptr @Chained_B_map_fFunctionT_to_U, ptr @Chained_B_filter_fFunctionT_to_Bool, ptr @Chained_B_chain_otherIterableT, ptr @Chained_B_interleave_otherIterableT, ptr @Chained_B_zip_otherIterableU, ptr @Chained_B_product_otherIterableU, ptr @Chained_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Chainer_hashtbl = constant [4 x ptr] [ptr @Object, ptr @Chainer, ptr @any_typ, ptr @Iterator]
@Chainer_offset_tbl = constant [4 x i32] [i32 21, i32 10, i32 10, i32 18]
@Interleaved_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @Interleaved, ptr @Iterable]
@Interleaved_offset_tbl = constant [4 x i32] [i32 10, i32 64, i32 10, i32 39]
@Interleaved = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 1225269988638598324, i64 4611686018427388429, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Interleaved_hashtbl, ptr @Interleaved_offset_tbl, ptr @_data_size_Interleaved, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Interleaved_field_Interleaved_0, ptr @Interleaved_field_first, ptr @Interleaved_field_second, ptr @Interleaved_B_init_firstIterableT_secondIterableT, ptr @Interleaved_B_iterator_, ptr @Interleaved_B_each_fFunctionT_to_Nothing, ptr @Interleaved_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Interleaved_B_all_fFunctionT_to_Bool, ptr @Interleaved_B_any_fFunctionT_to_Bool, ptr @Interleaved_B_enumerate_, ptr @Interleaved_B_map_fFunctionT_to_U, ptr @Interleaved_B_filter_fFunctionT_to_Bool, ptr @Interleaved_B_chain_otherIterableT, ptr @Interleaved_B_interleave_otherIterableT, ptr @Interleaved_B_zip_otherIterableU, ptr @Interleaved_B_product_otherIterableU, ptr @Interleaved_init_firstIterableT_secondIterableT, ptr @Interleaved_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Interleaved_field_Interleaved_0, ptr @Interleaved_B_iterator_, ptr @Interleaved_B_each_fFunctionT_to_Nothing, ptr @Interleaved_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Interleaved_B_all_fFunctionT_to_Bool, ptr @Interleaved_B_any_fFunctionT_to_Bool, ptr @Interleaved_B_enumerate_, ptr @Interleaved_B_map_fFunctionT_to_U, ptr @Interleaved_B_filter_fFunctionT_to_Bool, ptr @Interleaved_B_chain_otherIterableT, ptr @Interleaved_B_interleave_otherIterableT, ptr @Interleaved_B_zip_otherIterableU, ptr @Interleaved_B_product_otherIterableU, ptr @Interleaved_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Interleaver_hashtbl = constant [4 x ptr] [ptr @Interleaver, ptr @Object, ptr @any_typ, ptr @Iterator]
@Interleaver_offset_tbl = constant [4 x i32] [i32 10, i32 21, i32 10, i32 18]
@Zipped_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @Zipped, ptr @Iterable]
@Zipped_offset_tbl = constant [4 x i32] [i32 10, i32 66, i32 10, i32 41]
@Zipped = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 7357168971761641759, i64 4611686018427388429, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Zipped_hashtbl, ptr @Zipped_offset_tbl, ptr @_data_size_Zipped, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @Zipped_field_Zipped_0, ptr @Zipped_field_Zipped_1, ptr @Zipped_field_Zipped_2, ptr @Zipped_field_first, ptr @Zipped_field_second, ptr @Zipped_B_init_firstIterableT_secondIterableU, ptr @Zipped_B_iterator_, ptr @Zipped_B_each_fFunctionT_to_Nothing, ptr @Zipped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Zipped_B_all_fFunctionT_to_Bool, ptr @Zipped_B_any_fFunctionT_to_Bool, ptr @Zipped_B_enumerate_, ptr @Zipped_B_map_fFunctionT_to_U, ptr @Zipped_B_filter_fFunctionT_to_Bool, ptr @Zipped_B_chain_otherIterableT, ptr @Zipped_B_interleave_otherIterableT, ptr @Zipped_B_zip_otherIterableU, ptr @Zipped_B_product_otherIterableU, ptr @Zipped_init_firstIterableT_secondIterableU, ptr @Zipped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Zipped_field_Zipped_2, ptr @Zipped_B_iterator_, ptr @Zipped_B_each_fFunctionT_to_Nothing, ptr @Zipped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Zipped_B_all_fFunctionT_to_Bool, ptr @Zipped_B_any_fFunctionT_to_Bool, ptr @Zipped_B_enumerate_, ptr @Zipped_B_map_fFunctionT_to_U, ptr @Zipped_B_filter_fFunctionT_to_Bool, ptr @Zipped_B_chain_otherIterableT, ptr @Zipped_B_interleave_otherIterableT, ptr @Zipped_B_zip_otherIterableU, ptr @Zipped_B_product_otherIterableU, ptr @Zipped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Zipper_hashtbl = constant [4 x ptr] [ptr @Object, ptr @Zipper, ptr @any_typ, ptr @Iterator]
@Zipper_offset_tbl = constant [4 x i32] [i32 22, i32 10, i32 10, i32 19]
@Products_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @any_typ, ptr @Products, ptr @Object]
@Products_offset_tbl = constant [4 x i32] [i32 41, i32 10, i32 10, i32 66]
@Products = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 3952308882273721422, i64 4611686018427388477, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Products_hashtbl, ptr @Products_offset_tbl, ptr @_data_size_Products, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @Products_field_Products_0, ptr @Products_field_Products_1, ptr @Products_field_Products_2, ptr @Products_field_first, ptr @Products_field_second, ptr @Products_B_init_firstIterableT_secondIterableU, ptr @Products_B_iterator_, ptr @Products_B_each_fFunctionT_to_Nothing, ptr @Products_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Products_B_all_fFunctionT_to_Bool, ptr @Products_B_any_fFunctionT_to_Bool, ptr @Products_B_enumerate_, ptr @Products_B_map_fFunctionT_to_U, ptr @Products_B_filter_fFunctionT_to_Bool, ptr @Products_B_chain_otherIterableT, ptr @Products_B_interleave_otherIterableT, ptr @Products_B_zip_otherIterableU, ptr @Products_B_product_otherIterableU, ptr @Products_init_firstIterableT_secondIterableU, ptr @Products_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Products_field_Products_2, ptr @Products_B_iterator_, ptr @Products_B_each_fFunctionT_to_Nothing, ptr @Products_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Products_B_all_fFunctionT_to_Bool, ptr @Products_B_any_fFunctionT_to_Bool, ptr @Products_B_enumerate_, ptr @Products_B_map_fFunctionT_to_U, ptr @Products_B_filter_fFunctionT_to_Bool, ptr @Products_B_chain_otherIterableT, ptr @Products_B_interleave_otherIterableT, ptr @Products_B_zip_otherIterableU, ptr @Products_B_product_otherIterableU, ptr @Products_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Productizer_hashtbl = constant [4 x ptr] [ptr @Productizer, ptr @Object, ptr @any_typ, ptr @Iterator]
@Productizer_offset_tbl = constant [4 x i32] [i32 10, i32 24, i32 10, i32 21]
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Enumerated_field_iterable = internal constant { ptr, ptr } { ptr @Enumerated_getter_iterable, ptr @Enumerated_setter_iterable }
@Enumerator_field_iterator = internal constant { ptr, ptr } { ptr @Enumerator_getter_iterator, ptr @Enumerator_setter_iterator }
@Enumerator_field_index = internal constant { ptr, ptr } { ptr @Enumerator_getter_index, ptr @Enumerator_setter_index }
@Mapped_field_iterable = internal constant { ptr, ptr } { ptr @Mapped_getter_iterable, ptr @Mapped_setter_iterable }
@Mapped_field_f = internal constant { ptr, ptr } { ptr @Mapped_getter_f, ptr @Mapped_setter_f }
@Mapper_field_iterator = internal constant { ptr, ptr } { ptr @Mapper_getter_iterator, ptr @Mapper_setter_iterator }
@Mapper_field_f = internal constant { ptr, ptr } { ptr @Mapper_getter_f, ptr @Mapper_setter_f }
@Filtered_field_iterable = internal constant { ptr, ptr } { ptr @Filtered_getter_iterable, ptr @Filtered_setter_iterable }
@Filtered_field_f = internal constant { ptr, ptr } { ptr @Filtered_getter_f, ptr @Filtered_setter_f }
@Filterer_field_iterator = internal constant { ptr, ptr } { ptr @Filterer_getter_iterator, ptr @Filterer_setter_iterator }
@Filterer_field_f = internal constant { ptr, ptr } { ptr @Filterer_getter_f, ptr @Filterer_setter_f }
@Chained_field_first = internal constant { ptr, ptr } { ptr @Chained_getter_first, ptr @Chained_setter_first }
@Chained_field_second = internal constant { ptr, ptr } { ptr @Chained_getter_second, ptr @Chained_setter_second }
@Chainer_field_first = internal constant { ptr, ptr } { ptr @Chainer_getter_first, ptr @Chainer_setter_first }
@Chainer_field_second = internal constant { ptr, ptr } { ptr @Chainer_getter_second, ptr @Chainer_setter_second }
@Chainer_field_on_first = internal constant { ptr, ptr } { ptr @Chainer_getter_on_first, ptr @Chainer_setter_on_first }
@Interleaved_field_first = internal constant { ptr, ptr } { ptr @Interleaved_getter_first, ptr @Interleaved_setter_first }
@Interleaved_field_second = internal constant { ptr, ptr } { ptr @Interleaved_getter_second, ptr @Interleaved_setter_second }
@Interleaver_field_first = internal constant { ptr, ptr } { ptr @Interleaver_getter_first, ptr @Interleaver_setter_first }
@Interleaver_field_second = internal constant { ptr, ptr } { ptr @Interleaver_getter_second, ptr @Interleaver_setter_second }
@Interleaver_field_on_first = internal constant { ptr, ptr } { ptr @Interleaver_getter_on_first, ptr @Interleaver_setter_on_first }
@Zipped_field_first = internal constant { ptr, ptr } { ptr @Zipped_getter_first, ptr @Zipped_setter_first }
@Zipped_field_second = internal constant { ptr, ptr } { ptr @Zipped_getter_second, ptr @Zipped_setter_second }
@Zipper_field_first = internal constant { ptr, ptr } { ptr @Zipper_getter_first, ptr @Zipper_setter_first }
@Zipper_field_second = internal constant { ptr, ptr } { ptr @Zipper_getter_second, ptr @Zipper_setter_second }
@Products_field_first = internal constant { ptr, ptr } { ptr @Products_getter_first, ptr @Products_setter_first }
@Products_field_second = internal constant { ptr, ptr } { ptr @Products_getter_second, ptr @Products_setter_second }
@Productizer_field_first_iterator = internal constant { ptr, ptr } { ptr @Productizer_getter_first_iterator, ptr @Productizer_setter_first_iterator }
@Productizer_field_second_iterator = internal constant { ptr, ptr } { ptr @Productizer_getter_second_iterator, ptr @Productizer_setter_second_iterator }
@Productizer_field_second = internal constant { ptr, ptr } { ptr @Productizer_getter_second, ptr @Productizer_setter_second }
@Productizer_field_current_first = internal constant { ptr, ptr } { ptr @Productizer_getter_current_first, ptr @Productizer_setter_current_first }
@Enumerator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3435222131909153872, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Enumerator_hashtbl, ptr @Enumerator_offset_tbl, ptr @_data_size_Enumerator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Enumerator_field_Enumerator_0, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_field_iterator, ptr @Enumerator_field_index, ptr @Enumerator_B_init_iteratorIteratorT, ptr @Enumerator_B_next_, ptr @Enumerator_init_iteratorIteratorT, ptr @Enumerator_next_, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_B_next_, ptr @Enumerator_next_] }
@Mapper = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -7249237032859699974, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Mapper_hashtbl, ptr @Mapper_offset_tbl, ptr @_data_size_Mapper, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Mapper_field_Mapper_0, ptr @Mapper_field_Mapper_1, ptr @Mapper_field_iterator, ptr @Mapper_field_f, ptr @Mapper_B_init_iteratorIteratorT_fFunctionT_to_U, ptr @Mapper_B_next_, ptr @Mapper_init_iteratorIteratorT_fFunctionT_to_U, ptr @Mapper_next_, ptr @Mapper_field_Mapper_1, ptr @Mapper_B_next_, ptr @Mapper_next_] }
@Chainer = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 1602305534081450710, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Chainer_hashtbl, ptr @Chainer_offset_tbl, ptr @_data_size_Chainer, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Chainer_field_Chainer_0, ptr @Chainer_field_first, ptr @Chainer_field_second, ptr @Chainer_field_on_first, ptr @Chainer_B_init_firstIteratorT_secondIteratorT, ptr @Chainer_B_next_, ptr @Chainer_init_firstIteratorT_secondIteratorT, ptr @Chainer_next_, ptr @Chainer_field_Chainer_0, ptr @Chainer_B_next_, ptr @Chainer_next_] }
@Interleaver = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -325516585209011365, i64 4611686018427388361, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Interleaver_hashtbl, ptr @Interleaver_offset_tbl, ptr @_data_size_Interleaver, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Interleaver_field_Interleaver_0, ptr @Interleaver_field_first, ptr @Interleaver_field_second, ptr @Interleaver_field_on_first, ptr @Interleaver_B_init_firstIteratorT_secondIteratorT, ptr @Interleaver_B_next_, ptr @Interleaver_init_firstIteratorT_secondIteratorT, ptr @Interleaver_next_, ptr @Interleaver_field_Interleaver_0, ptr @Interleaver_B_next_, ptr @Interleaver_next_] }
@Zipper = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 -502732402311247874, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Zipper_hashtbl, ptr @Zipper_offset_tbl, ptr @_data_size_Zipper, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @Zipper_field_Zipper_0, ptr @Zipper_field_Zipper_1, ptr @Zipper_field_Zipper_2, ptr @Zipper_field_first, ptr @Zipper_field_second, ptr @Zipper_B_init_firstIteratorT_secondIteratorU, ptr @Zipper_B_next_, ptr @Zipper_init_firstIteratorT_secondIteratorU, ptr @Zipper_next_, ptr @Zipper_field_Zipper_2, ptr @Zipper_B_next_, ptr @Zipper_next_] }
@Productizer = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 -4237829454682536209, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Productizer_hashtbl, ptr @Productizer_offset_tbl, ptr @_data_size_Productizer, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Productizer_field_Productizer_0, ptr @Productizer_field_Productizer_1, ptr @Productizer_field_Productizer_2, ptr @Productizer_field_first_iterator, ptr @Productizer_field_second_iterator, ptr @Productizer_field_second, ptr @Productizer_field_current_first, ptr @Productizer_B_init_first_iteratorIteratorT_secondIterableU, ptr @Productizer_B_next_, ptr @Productizer_init_first_iteratorIteratorT_secondIterableU, ptr @Productizer_next_, ptr @Productizer_field_Productizer_2, ptr @Productizer_B_next_, ptr @Productizer_next_] }
@Collection_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Iterable, ptr @Collection, ptr @Object]
@Collection_offset_tbl = constant [4 x i32] [i32 10, i32 44, i32 10, i32 69]
@EnumeratedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr @EnumeratedCollection, ptr null, ptr null, ptr null, ptr @Collection, ptr @Object]
@EnumeratedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 107, i32 10, i32 0, i32 0, i32 0, i32 48, i32 132]
@EnumeratedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 7081690788784801875, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @EnumeratedCollection_hashtbl, ptr @EnumeratedCollection_offset_tbl, ptr @_data_size_EnumeratedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @EnumeratedCollection_field_EnumeratedCollection_0, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_field_iterable, ptr @EnumeratedCollection_B_init_iterableCollectionT, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_init_iterableCollectionT, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MappedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr null, ptr null, ptr @Iterable, ptr @MappedCollection, ptr @Collection]
@MappedCollection_offset_tbl = constant [8 x i32] [i32 133, i32 10, i32 0, i32 0, i32 0, i32 108, i32 10, i32 49]
@MappedCollection = constant { [3 x i64], [7 x ptr], [123 x ptr] } { [3 x i64] [i64 5460697656559120915, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MappedCollection_hashtbl, ptr @MappedCollection_offset_tbl, ptr @_data_size_MappedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [123 x ptr] [ptr @MappedCollection_field_MappedCollection_0, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_field_iterable, ptr @MappedCollection_field_f, ptr @MappedCollection_B_init_iterableCollectionT_fFunctionT_to_U, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_init_iterableCollectionT_fFunctionT_to_U, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainedCollection_hashtbl = constant [8 x ptr] [ptr @Iterable, ptr @Object, ptr @any_typ, ptr @ChainedCollection, ptr null, ptr null, ptr @Collection, ptr null]
@ChainedCollection_offset_tbl = constant [8 x i32] [i32 107, i32 132, i32 10, i32 10, i32 0, i32 0, i32 48, i32 0]
@ChainedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 -4136536984535342799, i64 4611686018427388097, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainedCollection_hashtbl, ptr @ChainedCollection_offset_tbl, ptr @_data_size_ChainedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_field_first, ptr @ChainedCollection_field_second, ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleavedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @InterleavedCollection, ptr @Iterable, ptr null, ptr @Collection]
@InterleavedCollection_offset_tbl = constant [8 x i32] [i32 132, i32 10, i32 0, i32 0, i32 10, i32 107, i32 0, i32 48]
@InterleavedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 8589355597059143861, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleavedCollection_hashtbl, ptr @InterleavedCollection_offset_tbl, ptr @_data_size_InterleavedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_field_first, ptr @InterleavedCollection_field_second, ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZippedCollection_hashtbl = constant [8 x ptr] [ptr @Iterable, ptr @Object, ptr @any_typ, ptr null, ptr @ZippedCollection, ptr null, ptr @Collection, ptr null]
@ZippedCollection_offset_tbl = constant [8 x i32] [i32 109, i32 134, i32 10, i32 0, i32 10, i32 0, i32 50, i32 0]
@ZippedCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 880335312586431241, i64 4611686018427388097, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZippedCollection_hashtbl, ptr @ZippedCollection_offset_tbl, ptr @_data_size_ZippedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ZippedCollection_field_ZippedCollection_0, ptr @ZippedCollection_field_ZippedCollection_1, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_field_first, ptr @ZippedCollection_field_second, ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductCollection_hashtbl = constant [8 x ptr] [ptr @ProductCollection, ptr @Object, ptr @any_typ, ptr null, ptr @Collection, ptr @Iterable, ptr null, ptr null]
@ProductCollection_offset_tbl = constant [8 x i32] [i32 10, i32 134, i32 10, i32 0, i32 50, i32 109, i32 0, i32 0]
@ProductCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 -310975631771072937, i64 4611686018427388181, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductCollection_hashtbl, ptr @ProductCollection_offset_tbl, ptr @_data_size_ProductCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ProductCollection_field_ProductCollection_0, ptr @ProductCollection_field_ProductCollection_1, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_field_first, ptr @ProductCollection_field_second, ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@EnumeratedCollection_field_iterable = internal constant { ptr, ptr } { ptr @EnumeratedCollection_getter_iterable, ptr @EnumeratedCollection_setter_iterable }
@MappedCollection_field_iterable = internal constant { ptr, ptr } { ptr @MappedCollection_getter_iterable, ptr @MappedCollection_setter_iterable }
@MappedCollection_field_f = internal constant { ptr, ptr } { ptr @MappedCollection_getter_f, ptr @MappedCollection_setter_f }
@ChainedCollection_field_first = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_first, ptr @ChainedCollection_setter_first }
@ChainedCollection_field_second = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_second, ptr @ChainedCollection_setter_second }
@InterleavedCollection_field_first = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_first, ptr @InterleavedCollection_setter_first }
@InterleavedCollection_field_second = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_second, ptr @InterleavedCollection_setter_second }
@ZippedCollection_field_first = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_first, ptr @ZippedCollection_setter_first }
@ZippedCollection_field_second = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_second, ptr @ZippedCollection_setter_second }
@ProductCollection_field_first = internal constant { ptr, ptr } { ptr @ProductCollection_getter_first, ptr @ProductCollection_setter_first }
@ProductCollection_field_second = internal constant { ptr, ptr } { ptr @ProductCollection_getter_second, ptr @ProductCollection_setter_second }
@List_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr null, ptr null, ptr @Iterable, ptr @List, ptr @Collection]
@List_offset_tbl = constant [8 x i32] [i32 146, i32 10, i32 0, i32 0, i32 0, i32 121, i32 10, i32 62]
@Indexable_hashtbl = constant [4 x ptr] [ptr @Object, ptr @Indexable, ptr @any_typ, ptr null]
@Indexable_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 10, i32 0]
@IndexableCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @IndexableCollection, ptr @Indexable, ptr @Collection, ptr @Object, ptr null, ptr @Iterable]
@IndexableCollection_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 10, i32 54, i32 60, i32 60, i32 0, i32 119]
@Range_hashtbl = constant [8 x ptr] [ptr @Iterable, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr null, ptr @Collection, ptr @Range]
@Range_offset_tbl = constant [8 x i32] [i32 112, i32 137, i32 10, i32 0, i32 0, i32 0, i32 53, i32 10]
@RangeIterator_hashtbl = constant [4 x ptr] [ptr @RangeIterator, ptr @Iterator, ptr @any_typ, ptr @Object]
@RangeIterator_offset_tbl = constant [4 x i32] [i32 10, i32 18, i32 10, i32 21]
@Range_field_start = internal constant { ptr, ptr } { ptr @Range_getter_start, ptr @Range_setter_start }
@Range_field_end = internal constant { ptr, ptr } { ptr @Range_getter_end, ptr @Range_setter_end }
@Range_field_step = internal constant { ptr, ptr } { ptr @Range_getter_step, ptr @Range_setter_step }
@RangeIterator_field_counter = internal constant { ptr, ptr } { ptr @RangeIterator_getter_counter, ptr @RangeIterator_setter_counter }
@RangeIterator_field_end = internal constant { ptr, ptr } { ptr @RangeIterator_getter_end, ptr @RangeIterator_setter_end }
@RangeIterator_field_step = internal constant { ptr, ptr } { ptr @RangeIterator_getter_step, ptr @RangeIterator_setter_step }
@_parameterization_i8 = linkonce_odr constant [2 x ptr] [ptr @i8_typ, ptr null]
@_parameterization_Character = linkonce_odr constant [2 x ptr] [ptr @Character, ptr null]
@_parameterization_IterableCharacter = linkonce_odr constant [3 x ptr] [ptr @Iterable, ptr @_parameterization_Character, ptr null]
@tuple_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3422634369532007740, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @tuple_typ_hashtbl, ptr @tuple_typ_offset_tbl, ptr @_data_size_tuple_typ, ptr @_box_tuple_typ, ptr @_unbox_tuple_typ, ptr @_data_size_tuple_typ], [0 x ptr] undef }
@Unicode_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Unicode]
@Unicode_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 0, i32 10]
@Unicode = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -7454226071548845319, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Unicode_hashtbl, ptr @Unicode_offset_tbl, ptr @_data_size_Unicode, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Unicode_B__Self_replacement_codepoint_, ptr @Unicode_B__Self_replacement_str_, ptr @Unicode_B__Self_replacement_buf_, ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode_B__Self_encode_one_cpi32, ptr @Unicode__Self_replacement_codepoint_, ptr @Unicode__Self_replacement_str_, ptr @Unicode__Self_replacement_buf_, ptr @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode__Self_encode_one_cpi32] }
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [16 x ptr] [ptr @any_typ, ptr null, ptr null, ptr @List, ptr @Iterable, ptr null, ptr null, ptr @Object, ptr @String, ptr @Representable, ptr null, ptr null, ptr null, ptr @Collection, ptr null, ptr null]
@String_offset_tbl = constant [16 x i32] [i32 10, i32 0, i32 0, i32 102, i32 297, i32 0, i32 0, i32 322, i32 10, i32 322, i32 0, i32 0, i32 0, i32 238, i32 0, i32 0]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 21, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [8 x ptr] [ptr @StringIterator, ptr null, ptr null, ptr @Iterator, ptr @Object, ptr @ConstantTimeIterator, ptr @any_typ, ptr null]
@StringIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 0, i32 23, i32 26, i32 17, i32 10, i32 0]
@StringIterator = constant { [3 x i64], [7 x ptr], [16 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [16 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_byte_index, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_] }
@Stacktrace_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Stacktrace]
@Stacktrace_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 0, i32 10]
@Stacktrace = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 -59384212523717097, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Stacktrace_hashtbl, ptr @Stacktrace_offset_tbl, ptr @_data_size_Stacktrace, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @Stacktrace_field_stacktrace, ptr @Stacktrace_field_n_frames, ptr @Stacktrace_B_init_, ptr @Stacktrace_B_print_, ptr @Stacktrace_init_, ptr @Stacktrace_print_] }
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 24, i32 0, i32 10, i32 10]
@InvalidUTF8Error_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @InvalidUTF8Error, ptr @Object]
@InvalidUTF8Error_offset_tbl = constant [4 x i32] [i32 10, i32 24, i32 10, i32 38]
@InvalidUTF8Error = constant { [3 x i64], [7 x ptr], [28 x ptr] } { [3 x i64] [i64 4104693287331019315, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @InvalidUTF8Error_hashtbl, ptr @InvalidUTF8Error_offset_tbl, ptr @_data_size_InvalidUTF8Error, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [28 x ptr] [ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@OutOfBounds_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @OutOfBounds, ptr @Object]
@OutOfBounds_offset_tbl = constant [4 x i32] [i32 10, i32 27, i32 10, i32 41]
@OutOfBoundsDetails_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @OutOfBoundsDetails]
@OutOfBoundsDetails_offset_tbl = constant [4 x i32] [i32 16, i32 0, i32 10, i32 10]
@OutOfBoundsDetails = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 4650630525701360429, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBoundsDetails_hashtbl, ptr @OutOfBoundsDetails_offset_tbl, ptr @_data_size_OutOfBoundsDetails, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @OutOfBoundsDetails_field_bounds, ptr @OutOfBoundsDetails_field_index, ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_B_report_, ptr @OutOfBoundsDetails_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_report_] }
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_byte_length = internal constant { ptr, ptr } { ptr @String_getter_byte_length, ptr @String_setter_byte_length }
@String_field_char_length = internal constant { ptr, ptr } { ptr @String_getter_char_length, ptr @String_setter_char_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_codepoint = internal constant { ptr, ptr } { ptr @Character_getter_codepoint, ptr @Character_setter_codepoint }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_byte_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_byte_index, ptr @StringIterator_setter_byte_index }
@Stacktrace_field_stacktrace = internal constant { ptr, ptr } { ptr @Stacktrace_getter_stacktrace, ptr @Stacktrace_setter_stacktrace }
@Stacktrace_field_n_frames = internal constant { ptr, ptr } { ptr @Stacktrace_getter_n_frames, ptr @Stacktrace_setter_n_frames }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@Exception_field_stacktrace = internal constant { ptr, ptr } { ptr @Exception_getter_stacktrace, ptr @Exception_setter_stacktrace }
@InvalidUTF8Error_field_line_number = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_line_number, ptr @InvalidUTF8Error_setter_line_number }
@InvalidUTF8Error_field_file_name = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_file_name, ptr @InvalidUTF8Error_setter_file_name }
@InvalidUTF8Error_field_message = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_message, ptr @InvalidUTF8Error_setter_message }
@InvalidUTF8Error_field_stacktrace = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_stacktrace, ptr @InvalidUTF8Error_setter_stacktrace }
@OutOfBounds_field_details = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_details, ptr @OutOfBounds_setter_details }
@OutOfBounds_field_line_number = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_line_number, ptr @OutOfBounds_setter_line_number }
@OutOfBounds_field_file_name = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_file_name, ptr @OutOfBounds_setter_file_name }
@OutOfBounds_field_message = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_message, ptr @OutOfBounds_setter_message }
@OutOfBounds_field_stacktrace = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_stacktrace, ptr @OutOfBounds_setter_stacktrace }
@OutOfBoundsDetails_field_bounds = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_bounds, ptr @OutOfBoundsDetails_setter_bounds }
@OutOfBoundsDetails_field_index = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_index, ptr @OutOfBoundsDetails_setter_index }
@KeyNotFound_hashtbl = constant [4 x ptr] [ptr @Object, ptr @KeyNotFound, ptr @any_typ, ptr @Exception]
@KeyNotFound_offset_tbl = constant [4 x i32] [i32 38, i32 10, i32 10, i32 24]
@KeyNotFound = constant { [3 x i64], [7 x ptr], [28 x ptr] } { [3 x i64] [i64 2946564862774055400, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @KeyNotFound_hashtbl, ptr @KeyNotFound_offset_tbl, ptr @_data_size_KeyNotFound, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [28 x ptr] [ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@Map_hashtbl = constant [8 x ptr] [ptr @Indexable, ptr @Map, ptr @IndexableCollection, ptr null, ptr @Collection, ptr @Iterable, ptr @any_typ, ptr @Object]
@Map_offset_tbl = constant [8 x i32] [i32 198, i32 10, i32 64, i32 0, i32 204, i32 263, i32 10, i32 204]
@MapKeys_hashtbl = constant [8 x ptr] [ptr @Iterable, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr null, ptr @Collection, ptr @MapKeys]
@MapKeys_offset_tbl = constant [8 x i32] [i32 107, i32 132, i32 10, i32 0, i32 0, i32 0, i32 48, i32 10]
@MapKeys = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 -6755415596079746205, i64 4611686018427388097, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapKeys_hashtbl, ptr @MapKeys_offset_tbl, ptr @_data_size_MapKeys, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @MapKeys_field_MapKeys_1, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_field_map, ptr @MapKeys_B_init_mapMapK._V, ptr @MapKeys_B_size_, ptr @MapKeys_B_is_empty_, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_init_mapMapK._V, ptr @MapKeys_size_, ptr @Collection_is_empty_, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_size_, ptr @MapKeys_B_is_empty_, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_size_, ptr @Collection_is_empty_, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapValues_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @MapValues, ptr null, ptr null, ptr @Collection, ptr @Object]
@MapValues_offset_tbl = constant [8 x i32] [i32 10, i32 107, i32 0, i32 10, i32 0, i32 0, i32 48, i32 132]
@MapValues = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 2074062704914054732, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapValues_hashtbl, ptr @MapValues_offset_tbl, ptr @_data_size_MapValues, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @MapValues_field_MapValues_0, ptr @MapValues_field_MapValues_1, ptr @MapValues_field_map, ptr @MapValues_B_init_mapMapK._V, ptr @MapValues_B_size_, ptr @MapValues_B_is_empty_, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_init_mapMapK._V, ptr @MapValues_size_, ptr @Collection_is_empty_, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_size_, ptr @MapValues_B_is_empty_, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_size_, ptr @Collection_is_empty_, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapKeyIterator_hashtbl = constant [4 x ptr] [ptr @Object, ptr @MapKeyIterator, ptr @any_typ, ptr @Iterator]
@MapKeyIterator_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 17]
@MapKeyIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 7211362081012783701, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @MapKeyIterator_hashtbl, ptr @MapKeyIterator_offset_tbl, ptr @_data_size_MapKeyIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @MapKeyIterator_field_MapKeyIterator_1, ptr @MapKeyIterator_field_MapKeyIterator_0, ptr @MapKeyIterator_field_map_iterator, ptr @MapKeyIterator_B_init_map_iteratorIteratorPairK._V, ptr @MapKeyIterator_B_next_, ptr @MapKeyIterator_init_map_iteratorIteratorPairK._V, ptr @MapKeyIterator_next_, ptr @MapKeyIterator_field_MapKeyIterator_0, ptr @MapKeyIterator_B_next_, ptr @MapKeyIterator_next_] }
@MapValueIterator_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Iterator, ptr @MapValueIterator, ptr @Object]
@MapValueIterator_offset_tbl = constant [4 x i32] [i32 10, i32 17, i32 10, i32 20]
@MapValueIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -4981803053484113385, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @MapValueIterator_hashtbl, ptr @MapValueIterator_offset_tbl, ptr @_data_size_MapValueIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @MapValueIterator_field_MapValueIterator_0, ptr @MapValueIterator_field_MapValueIterator_1, ptr @MapValueIterator_field_map_iterator, ptr @MapValueIterator_B_init_map_iteratorIteratorPairK._V, ptr @MapValueIterator_B_next_, ptr @MapValueIterator_init_map_iteratorIteratorPairK._V, ptr @MapValueIterator_next_, ptr @MapValueIterator_field_MapValueIterator_1, ptr @MapValueIterator_B_next_, ptr @MapValueIterator_next_] }
@HashMap_hashtbl = constant [16 x ptr] [ptr @Map, ptr @any_typ, ptr null, ptr @Collection, ptr null, ptr @Indexable, ptr null, ptr null, ptr @Iterable, ptr @IndexableCollection, ptr null, ptr null, ptr @HashMap, ptr null, ptr @Object, ptr null]
@HashMap_offset_tbl = constant [16 x i32] [i32 66, i32 10, i32 0, i32 484, i32 0, i32 478, i32 0, i32 0, i32 543, i32 344, i32 0, i32 0, i32 10, i32 0, i32 484, i32 0]
@KeyNotFound_field_line_number = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_line_number, ptr @KeyNotFound_setter_line_number }
@KeyNotFound_field_file_name = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_file_name, ptr @KeyNotFound_setter_file_name }
@KeyNotFound_field_message = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_message, ptr @KeyNotFound_setter_message }
@KeyNotFound_field_stacktrace = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_stacktrace, ptr @KeyNotFound_setter_stacktrace }
@MapKeys_field_map = internal constant { ptr, ptr } { ptr @MapKeys_getter_map, ptr @MapKeys_setter_map }
@MapValues_field_map = internal constant { ptr, ptr } { ptr @MapValues_getter_map, ptr @MapValues_setter_map }
@MapKeyIterator_field_map_iterator = internal constant { ptr, ptr } { ptr @MapKeyIterator_getter_map_iterator, ptr @MapKeyIterator_setter_map_iterator }
@MapValueIterator_field_map_iterator = internal constant { ptr, ptr } { ptr @MapValueIterator_getter_map_iterator, ptr @MapValueIterator_setter_map_iterator }
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@Character = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Character_field_codepoint, ptr @Character_B_codepoint_, ptr @Character_B_init_codepointi32, ptr @Character_B_to_string_, ptr @Character_B__EQ_otherCharacter, ptr @Character_B_n_bytes_, ptr @Character_codepoint_, ptr @Character_init_codepointi32, ptr @Character_to_string_, ptr @Character__EQ_otherCharacter, ptr @Character_n_bytes_] }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter, ptr @IO__Self_print_xi32, ptr @IO__Self_print_xString, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xi8, ptr @IO__Self_print_xf64, ptr @IO__Self_print_xBool, ptr @IO__Self_print_xi64, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xCharacter] }
@Pair = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_B__set_first_valueT, ptr @Pair_B__set_second_valueU, ptr @Pair_B_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_, ptr @Pair__set_first_valueT, ptr @Pair__set_second_valueU, ptr @Pair_init_firstT_secondU] }
@RangeIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -913562485944406675, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @RangeIterator_hashtbl, ptr @RangeIterator_offset_tbl, ptr @_data_size_RangeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @RangeIterator_field_counter, ptr @RangeIterator_field_end, ptr @RangeIterator_field_step, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_init_counteri32_endi32_stepi32, ptr @RangeIterator_B_next_, ptr @RangeIterator_init_counteri32_endi32_stepi32, ptr @RangeIterator_next_, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_next_, ptr @RangeIterator_next_] }
@Map = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5249855671126779970, i64 4611686018427389201, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Map_hashtbl, ptr @Map_offset_tbl, ptr @_data_size_Map, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@HashMap = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427390107, i64 15], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 25, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [15 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [15 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_hash_, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_init_keyK_valueV_hashi32, ptr @Entry_B_to_pair_, ptr @Entry_hash_, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_init_keyK_valueV_hashi32, ptr @Entry_to_pair_] }
@SwissTable_hashtbl = constant [16 x ptr] [ptr @Indexable, ptr @Object, ptr @any_typ, ptr null, ptr @Collection, ptr @Iterable, ptr null, ptr null, ptr null, ptr @IndexableCollection, ptr null, ptr null, ptr @HashMap, ptr @SwissTable, ptr null, ptr @Map]
@SwissTable_offset_tbl = constant [16 x i32] [i32 1050, i32 1056, i32 10, i32 0, i32 1056, i32 1115, i32 0, i32 0, i32 0, i32 916, i32 0, i32 0, i32 80, i32 10, i32 0, i32 638]
@SwissTable = constant { [3 x i64], [7 x ptr], [1130 x ptr] } { [3 x i64] [i64 4490338885899135281, i64 4611686018427388181, i64 15], [7 x ptr] [ptr @subtype_test, ptr @SwissTable_hashtbl, ptr @SwissTable_offset_tbl, ptr @_data_size_SwissTable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [1130 x ptr] [ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_field_entries, ptr @SwissTable_field_metadata, ptr @SwissTable_field_entries_len, ptr @SwissTable_field_size, ptr @SwissTable_field_hasher, ptr @SwissTable_field_eq, ptr @SwissTable_B_hash_to_metadata_hashi32, ptr @SwissTable_B_find_slot_keyK_hashi32, ptr @SwissTable_B_resize_new_capacityi32, ptr @SwissTable_B_ensure_capacity_required_sizei32, ptr @SwissTable_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @SwissTable_B_get_keyK, ptr @SwissTable_B_insert_keyK_valueV, ptr @SwissTable_B_remove_keyK, ptr @SwissTable_B_keys_, ptr @SwissTable_B_clear_, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_hash_to_metadata_hashi32, ptr @SwissTable_find_slot_keyK_hashi32, ptr @SwissTable_resize_new_capacityi32, ptr @SwissTable_ensure_capacity_required_sizei32, ptr @SwissTable_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @SwissTable_get_keyK, ptr @SwissTable_insert_keyK_valueV, ptr @SwissTable_remove_keyK, ptr @Map_keys_, ptr @SwissTable_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @SwissTable_B_get_keyK, ptr @SwissTable_B_insert_keyK_valueV, ptr @SwissTable_B_remove_keyK, ptr @SwissTable_B_keys_, ptr @SwissTable_B_clear_, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @SwissTable_get_keyK, ptr @SwissTable_insert_keyK_valueV, ptr @SwissTable_remove_keyK, ptr @Map_keys_, ptr @SwissTable_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_get_keyK, ptr @SwissTable_B_insert_keyK_valueV, ptr @SwissTable_B_remove_keyK, ptr @SwissTable_B_keys_, ptr @SwissTable_B_clear_, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_get_keyK, ptr @SwissTable_insert_keyK_valueV, ptr @SwissTable_remove_keyK, ptr @Map_keys_, ptr @SwissTable_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_get_keyK, ptr @SwissTable_B_insert_keyK_valueV, ptr @SwissTable_B_remove_keyK, ptr @SwissTable_B_keys_, ptr @SwissTable_B_clear_, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_get_keyK, ptr @SwissTable_insert_keyK_valueV, ptr @SwissTable_remove_keyK, ptr @Map_keys_, ptr @SwissTable_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_indices_, ptr @SwissTable_B_values_, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_0, ptr @SwissTable_field_SwissTable_1, ptr @SwissTable_B__index_keyK, ptr @SwissTable_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @Map__set_index_keyK_valueV, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_size_, ptr @SwissTable_B_is_empty_, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_size_, ptr @Collection_is_empty_, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @SwissTable_field_SwissTable_8, ptr @SwissTable_B_iterator_, ptr @SwissTable_B_each_fFunctionT_to_Nothing, ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @SwissTable_B_all_fFunctionT_to_Bool, ptr @SwissTable_B_any_fFunctionT_to_Bool, ptr @SwissTable_B_enumerate_, ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @SwissTable_B_filter_fFunctionT_to_Bool, ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT, ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU, ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU, ptr @SwissTable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@SwissTableIterator_hashtbl = constant [4 x ptr] [ptr @Object, ptr @SwissTableIterator, ptr @any_typ, ptr @Iterator]
@SwissTableIterator_offset_tbl = constant [4 x i32] [i32 24, i32 10, i32 10, i32 21]
@SwissTableIterator = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 7015872805459348650, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @SwissTableIterator_hashtbl, ptr @SwissTableIterator_offset_tbl, ptr @_data_size_SwissTableIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @SwissTableIterator_field_SwissTableIterator_0, ptr @SwissTableIterator_field_SwissTableIterator_1, ptr @SwissTableIterator_field_SwissTableIterator_2, ptr @SwissTableIterator_field_map_entries, ptr @SwissTableIterator_field_map_metadata, ptr @SwissTableIterator_field_index, ptr @SwissTableIterator_field_length, ptr @SwissTableIterator_B_init_map_entriesBufferEntryK._V_or_Nil_map_metadataBufferi8_lengthi32, ptr @SwissTableIterator_B_next_, ptr @SwissTableIterator_init_map_entriesBufferEntryK._V_or_Nil_map_metadataBufferi8_lengthi32, ptr @SwissTableIterator_next_, ptr @SwissTableIterator_field_SwissTableIterator_2, ptr @SwissTableIterator_B_next_, ptr @SwissTableIterator_next_] }
@Entry_field_hash = internal constant { ptr, ptr } { ptr @Entry_getter_hash, ptr @Entry_setter_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@SwissTable_field_entries = internal constant { ptr, ptr } { ptr @SwissTable_getter_entries, ptr @SwissTable_setter_entries }
@SwissTable_field_metadata = internal constant { ptr, ptr } { ptr @SwissTable_getter_metadata, ptr @SwissTable_setter_metadata }
@SwissTable_field_entries_len = internal constant { ptr, ptr } { ptr @SwissTable_getter_entries_len, ptr @SwissTable_setter_entries_len }
@SwissTable_field_size = internal constant { ptr, ptr } { ptr @SwissTable_getter_size, ptr @SwissTable_setter_size }
@SwissTable_field_hasher = internal constant { ptr, ptr } { ptr @SwissTable_getter_hasher, ptr @SwissTable_setter_hasher }
@SwissTable_field_eq = internal constant { ptr, ptr } { ptr @SwissTable_getter_eq, ptr @SwissTable_setter_eq }
@SwissTableIterator_field_map_entries = internal constant { ptr, ptr } { ptr @SwissTableIterator_getter_map_entries, ptr @SwissTableIterator_setter_map_entries }
@SwissTableIterator_field_map_metadata = internal constant { ptr, ptr } { ptr @SwissTableIterator_getter_map_metadata, ptr @SwissTableIterator_setter_map_metadata }
@SwissTableIterator_field_index = internal constant { ptr, ptr } { ptr @SwissTableIterator_getter_index, ptr @SwissTableIterator_setter_index }
@SwissTableIterator_field_length = internal constant { ptr, ptr } { ptr @SwissTableIterator_getter_length, ptr @SwissTableIterator_setter_length }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@ConstantTimeIterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7049076106841707882, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @ConstantTimeIterator_hashtbl, ptr @ConstantTimeIterator_offset_tbl, ptr @_data_size_ConstantTimeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Collection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 1375598993350293883, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Collection_hashtbl, ptr @Collection_offset_tbl, ptr @_data_size_Collection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@List = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -83120161364696977, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @List_hashtbl, ptr @List_offset_tbl, ptr @_data_size_List, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Indexable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8246772220324864030, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Indexable_hashtbl, ptr @Indexable_offset_tbl, ptr @_data_size_Indexable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@IndexableCollection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -307435881317861917, i64 4611686018427388429, i64 7], [7 x ptr] [ptr @subtype_test, ptr @IndexableCollection_hashtbl, ptr @IndexableCollection_offset_tbl, ptr @_data_size_IndexableCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Range = constant { [3 x i64], [7 x ptr], [127 x ptr] } { [3 x i64] [i64 5490049236840671069, i64 4611686018427388097, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Range_hashtbl, ptr @Range_offset_tbl, ptr @_data_size_Range, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [127 x ptr] [ptr @Range_field_start, ptr @Range_field_end, ptr @Range_field_step, ptr @Range_field_Range_0, ptr @Range_B_init_endi32, ptr @Range_B_init_starti32_endi32, ptr @Range_B_step_stepi32, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_init_endi32, ptr @Range_init_starti32_endi32, ptr @Range_step_stepi32, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@OutOfBounds = constant { [3 x i64], [7 x ptr], [31 x ptr] } { [3 x i64] [i64 5348403617834207535, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBounds_hashtbl, ptr @OutOfBounds_offset_tbl, ptr @_data_size_OutOfBounds, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [31 x ptr] [ptr @OutOfBounds_field_details, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_boundsi32_indexi32, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @OutOfBounds_init_boundsi32_indexi32, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_] }
@Array_hashtbl = constant [32 x ptr] [ptr null, ptr @Representable, ptr @List, ptr null, ptr null, ptr null, ptr @Array, ptr null, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @IndexableCollection, ptr null, ptr @Collection, ptr @any_typ, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @Indexable, ptr null, ptr null, ptr null, ptr null]
@Array_offset_tbl = constant [32 x i32] [i32 0, i32 537, i32 93, i32 0, i32 0, i32 0, i32 10, i32 0, i32 0, i32 288, i32 313, i32 0, i32 0, i32 0, i32 0, i32 0, i32 313, i32 0, i32 229, i32 10, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 447, i32 0, i32 0, i32 0, i32 0]
@Array = constant { [3 x i64], [7 x ptr], [529 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427389773, i64 31], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [529 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_field_Array_2, ptr @Array_B_capacity_, ptr @Array_B_init_, ptr @Array_B_init_capacityi32, ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_B_reserve_new_capacityi32, ptr @Array_B_bounds_check_indexi32, ptr @Array_B_unchecked_index_indexi32, ptr @Array_B_unchecked_insert_indexi32_valueT, ptr @Array_B__Self_empty_, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_append_xT, ptr @Array_B_length_, ptr @Array_B_first_, ptr @Array_B_last_, ptr @Array_B_extend_otherCollectionT_extend_otherIterableT, ptr @Array_B_get_indexi32, ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_B_indices_, ptr @Array_B_values_, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_capacity_, ptr @Array_init_, ptr @Array_init_capacityi32, ptr @Array_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_reserve_new_capacityi32, ptr @Array_bounds_check_indexi32, ptr @Array_unchecked_index_indexi32, ptr @Array_unchecked_insert_indexi32_valueT, ptr @Array__Self_empty_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_append_xT, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @Array_extend_otherCollectionT, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_indices_, ptr @Array_values_, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_repr_, ptr @Array_field_Array_0, ptr @Array_B__Self_empty_, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_append_xT, ptr @Array_B_length_, ptr @Array_B_first_, ptr @Array_B_last_, ptr @Array_B_extend_otherCollectionT_extend_otherIterableT, ptr @Array_B_get_indexi32, ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array__Self_empty_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_append_xT, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_field_Array_0, ptr @Array_B_indices_, ptr @Array_B_values_, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_indices_, ptr @Array_values_, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_repr_] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @ArrayIterator, ptr @Iterator, ptr @ConstantTimeIterator, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 26, i32 10, i32 0, i32 0, i32 10, i32 23, i32 17, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [16 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [16 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@_parameterization_Bufferi8 = linkonce_odr constant [2 x ptr] [ptr @buffer_typ, ptr null]
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@String = constant { [3 x i64], [7 x ptr], [314 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427389917, i64 15], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [314 x ptr] [ptr @String_field_bytes, ptr @String_field_byte_length, ptr @String_field_char_length, ptr @String_field_capacity, ptr @String_field_String_0, ptr @String_B_byte_length_, ptr @String_B_capacity_, ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_c_string_c_stringBufferi8, ptr @String_B_init_, ptr @String_B_init_capacityi32, ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_B_c_string_, ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_B_reserve_new_capacityi32, ptr @String_B__EQ_otherString, ptr @String_B_decode_at_byte_indexi32, ptr @String_B_unchecked_index_xi32, ptr @String_B_unchecked_insert_xi32_valuei8, ptr @String_B_copy_, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_B_repr_, ptr @String_byte_length_, ptr @String_capacity_, ptr @String__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String__Self_from_c_string_c_stringBufferi8, ptr @String_init_, ptr @String_init_capacityi32, ptr @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_c_string_, ptr @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_reserve_new_capacityi32, ptr @String__EQ_otherString, ptr @String_decode_at_byte_indexi32, ptr @String_unchecked_index_xi32, ptr @String_unchecked_insert_xi32_valuei8, ptr @String_copy_, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @String_extend_otherCollectionCharacter, ptr @List_extend_otherIterableT, ptr @String_extend_otherString, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_repr_, ptr @String_field_String_0, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_B_repr_, ptr @String_repr_] }
@Exception = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_field_stacktrace, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberi32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nocapture nofree readonly %supertype_tbl) #0 {
  %product.i = mul i64 %cand_id, %hash_coef
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash.i
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_Default(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %fat_ptr, ptr nocapture nofree readnone %parameterization) #2 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr inbounds i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr nocapture nofree readnone %parameterization, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %destination) #3 {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr inbounds i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Default(ptr nocapture nofree readnone %parameterization) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @PRNG_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4401938362882229211
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %. = call i32 @llvm.smax.i32(i32 %3, i32 noundef 1) #43
  call void %10(ptr %.fca.1.extract, i32 %.) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4401938362882229211
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #45
  %10 = mul i32 %9, 1103515245
  %11 = add i32 %10, 12345
  %12 = and i32 %11, 2147483647
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 %12) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %17 = load ptr, ptr %6, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #45
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define i32 @get_offset(ptr nocapture nofree readonly align 8 %vptr, ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(8) %id_ptr) local_unnamed_addr #7 {
  %id = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr = getelementptr i8, ptr %vptr, i64 40
  %hash_coef = load i64, ptr %hash_coef_ptr, align 8
  %tbl_size = load i64, ptr %tbl_size_ptr, align 8
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %product.i = mul i64 %hash_coef, %id
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %hash.i
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) local_unnamed_addr #1 {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %shifted, %product
  %hash = and i64 %xored, %tbl_size
  ret i64 %hash
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #9

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #10 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #47
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0) local_unnamed_addr #10 {
  %result = call { i64, i64 } %f(ptr nocapture nofree readonly %0) #47
  ret { i64, i64 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) local_unnamed_addr #10 {
  %result = call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #47
  ret { ptr, i160 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @unbox_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) local_unnamed_addr #11 {
  call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #48
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull readonly %1) local_unnamed_addr #12 {
  %result = call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #49
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #12 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull %0) #49
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @adjust_trampoline(ptr nofree readonly %tramp) local_unnamed_addr #13 {
  %ret = call ptr @llvm.adjust.trampoline(ptr nofree readonly %tramp) #50
  ret ptr %ret
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #14

; Function Attrs: alwaysinline mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc(i64 noundef %size) local_unnamed_addr #15 {
  %result = call noalias ptr @bump_malloc_wrapper(i64 noundef %size) #51
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc_wrapper(i64 noundef %size) local_unnamed_addr #16 {
  %result = call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #51
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %current_ptr) local_unnamed_addr #16 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  %page_or_more.i = icmp sgt i64 %aligned_size, 4095
  br i1 %page_or_more.i, label %commit.i, label %commit_additional_pages.exit

commit.i:                                         ; preds = %0
  %base_i64.i = ptrtoint ptr %current to i64
  %1 = and i64 %base_i64.i, -4096
  %next_page_i64.i = add i64 %1, 4096
  %next_page.i = inttoptr i64 %next_page_i64.i to ptr
  %left_in_page.neg.i = add nsw i64 %aligned_size, -4096
  %reass.sub.i = add i64 %left_in_page.neg.i, %base_i64.i
  %commit_size.i = sub i64 %reass.sub.i, %1
  call void @virtual_commit(ptr %next_page.i, i64 %commit_size.i) #52
  br label %commit_additional_pages.exit

commit_additional_pages.exit:                     ; preds = %commit.i, %0
  ret ptr %current
}

define void @commit_additional_pages(ptr %base, i64 %size) local_unnamed_addr #17 {
  %page_or_more = icmp sgt i64 %size, 4095
  br i1 %page_or_more, label %commit, label %return

commit:                                           ; preds = %0
  %base_i64 = ptrtoint ptr %base to i64
  %1 = and i64 %base_i64, -4096
  %next_page_i64 = add i64 %1, 4096
  %next_page = inttoptr i64 %next_page_i64 to ptr
  %left_in_page.neg = add i64 %base_i64, -4096
  %reass.sub = add i64 %left_in_page.neg, %size
  %commit_size = sub i64 %reass.sub, %1
  call void @virtual_commit(ptr %next_page, i64 %commit_size)
  br label %return

return:                                           ; preds = %commit, %0
  ret void
}

; Function Attrs: noinline optnone
define void @virtual_commit(ptr %allocation, i64 %size) local_unnamed_addr #18 {
  %allocation1 = alloca ptr, align 8
  store ptr %allocation, ptr %allocation1, align 8
  %size2 = alloca i64, align 8
  store i64 %size, ptr %size2, align 8
  %result = call ptr @VirtualAlloc(ptr nofree %allocation, i64 %size, i32 noundef 4096, i32 noundef 4)
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare ptr @VirtualAlloc(ptr, i64, i32, i32) local_unnamed_addr #19

define { i64, i64 } @_data_size_tuple_typ(ptr nocapture nofree readonly align 4 %0) #17 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull align 8 %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add nuw i64 %11, %.reg2mem22.011
  %19 = add nuw i64 %18, %17
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem20.0.lcssa = phi i64 [ 1, %1 ], [ %13, %.lr.ph ]
  %.reg2mem22.0.lcssa = phi i64 [ 0, %1 ], [ %19, %.lr.ph ]
  %24 = urem i64 %.reg2mem22.0.lcssa, %.reg2mem20.0.lcssa
  %25 = icmp eq i64 %24, 0
  %26 = sub nuw i64 %.reg2mem20.0.lcssa, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add nuw i64 %27, %.reg2mem22.0.lcssa
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa, 1
  ret { i64, i64 } %30
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #9

define { i64, i64 } @_data_size_union_typ(ptr nocapture nofree readonly align 4 %0) local_unnamed_addr #17 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge.thread, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull align 8 %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 noundef %12, i64 noundef %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = call i64 @llvm.umax.i64(i64 noundef %11, i64 noundef %.reg2mem22.011)
  %19 = call i64 @llvm.umax.i64(i64 noundef %18, i64 noundef %17)
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph
  %right_size = icmp eq i64 %19, 32
  %spec.select6 = select i1 %right_size, i64 0, i64 8
  %24 = add i64 %spec.select6, %19
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %1
  %.reg2mem20.0.lcssa4 = phi i64 [ 1, %1 ], [ %13, %._crit_edge ]
  %final_size = phi i64 [ 8, %1 ], [ %24, %._crit_edge ]
  %25 = urem i64 %final_size, %.reg2mem20.0.lcssa4
  %26 = icmp eq i64 %25, 0
  %27 = sub nuw i64 %.reg2mem20.0.lcssa4, %25
  %28 = select i1 %26, i64 0, i64 %27
  %29 = add nuw i64 %28, %final_size
  %30 = insertvalue { i64, i64 } undef, i64 %29, 0
  %31 = insertvalue { i64, i64 } %30, i64 %.reg2mem20.0.lcssa4, 1
  ret { i64, i64 } %31
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %dest) local_unnamed_addr #17 {
  %3 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %3, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %4 = getelementptr i8, ptr %1, i64 8
  %5 = load i64, ptr %4, align 4
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %.lr.ph.i, %2
  %.in.i = phi i64 [ %24, %.lr.ph.i ], [ %5, %2 ]
  %7 = phi i64 [ %22, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem20.010.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %2 ]
  %8 = inttoptr i64 %.in.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = call { i64, i64 } %11(ptr nonnull align 8 %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = call i64 @llvm.umax.i64(i64 noundef %14, i64 noundef %.reg2mem20.010.i)
  %16 = urem i64 %.reg2mem22.011.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub nuw i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = call i64 @llvm.umax.i64(i64 noundef %13, i64 noundef %.reg2mem22.011.i)
  %21 = call i64 @llvm.umax.i64(i64 noundef %20, i64 noundef %19)
  %22 = add nuw i64 %7, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %21, 32
  %spec.select6.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select6.i, %21
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %._crit_edge.i, %2
  %.reg2mem20.0.lcssa4.i = phi i64 [ 1, %2 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %2 ], [ %26, %._crit_edge.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %final_size.i, %.reg2mem20.0.lcssa4.i
  %30 = icmp eq i64 %29, 0
  %31 = sub nuw i64 %.reg2mem20.0.lcssa4.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add nuw i64 %32, %final_size.i
  %34 = icmp slt i64 %33, 17
  %35 = icmp eq i64 %33, 32
  %36 = select i1 %34, ptr %.fca.1.gep, ptr %28
  %source = select i1 %35, ptr %3, ptr %36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %dest, ptr nocapture nofree readonly align 1 %source, i64 %33, i1 noundef false)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #20

define noundef nonnull dereferenceable(8388608) ptr @coroutine_create(ptr nofree %func, ptr nofree %arg_passer) local_unnamed_addr #17 {
  %result.i = call noalias noundef dereferenceable_or_null(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 8192, i32 noundef 4) #53
  call void @virtual_commit(ptr noundef dereferenceable_or_null(8388608) %result.i, i64 noundef 8388608)
  store ptr %func, ptr %result.i, align 8
  %stack_top = getelementptr i8, ptr %result.i, i64 8388512
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr i8, ptr %result.i, i64 8
  %arg_passer_slot = getelementptr i8, ptr %result.i, i64 32
  %into_callee_second_word = getelementptr i8, ptr %result.i, i64 16
  %into_callee_third_word = getelementptr i8, ptr %result.i, i64 24
  store i64 %stack_top_aligned, ptr %into_callee_buf, align 8
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 4
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr i8, ptr %result.i, i64 40
  store i1 false, ptr %is_finished, align 1
  call void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8388592) %into_callee_second_word)
  ret ptr %result.i
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @virtual_reserve(i64 %size) local_unnamed_addr #21 {
  %result = call noalias ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 %size, i32 noundef 8192, i32 noundef 4) #53
  ret ptr %result
}

define void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %into_callee_second_word) #17 {
  store ptr blockaddress(@coroutine_trampoline, %trampoline), ptr %into_callee_second_word, align 8
  %result = call i1 @returns_one() #54
  br i1 %result, label %exit, label %trampoline

trampoline:                                       ; preds = %0
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  %arg_passer_ptr = getelementptr i8, ptr %current_coroutine, i64 32
  %arg_passer = load ptr, ptr %arg_passer_ptr, align 8
  call void %arg_passer(ptr %current_coroutine)
  %current_coroutine2 = load ptr, ptr @current_coroutine, align 8
  %is_finished_ptr = getelementptr i8, ptr %current_coroutine2, i64 40
  store i1 true, ptr %is_finished_ptr, align 1
  call void @llvm.eh.sjlj.longjmp(ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #23
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define i1 @returns_one() local_unnamed_addr #22 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #23

define void @setup_landing_pad() #17 {
  %1 = call ptr @AddVectoredExceptionHandler(i32 noundef 1, ptr noundef nonnull @PageFaultHandler)
  %result.i = call noalias dereferenceable_or_null(5368709120) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 5368709120, i32 noundef 8192, i32 noundef 4) #53
  store ptr %result.i, ptr @current_ptr, align 8
  %sp = call ptr @llvm.stacksave.p0() #55
  store ptr %sp, ptr @into_caller_buf, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %sp, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %result.i.i = call noalias dereferenceable_or_null(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 8192, i32 noundef 4) #53
  call void @virtual_commit(ptr noundef dereferenceable_or_null(8388608) %result.i.i, i64 noundef 8388608)
  store ptr @setup_landing_pad, ptr %result.i.i, align 8
  %stack_top.i = getelementptr i8, ptr %result.i.i, i64 8388512
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr i8, ptr %result.i.i, i64 8
  %arg_passer_slot.i = getelementptr i8, ptr %result.i.i, i64 32
  %into_callee_second_word.i = getelementptr i8, ptr %result.i.i, i64 16
  %into_callee_third_word.i = getelementptr i8, ptr %result.i.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 4
  store ptr @arg_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr i8, ptr %result.i.i, i64 40
  store i1 false, ptr %is_finished.i, align 1
  call void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8388592) %into_callee_second_word.i)
  store ptr %result.i.i, ptr @current_coroutine, align 8
  %result = call i1 @returns_one() #56
  br i1 %result, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = call i32 @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @string_string, ptr nofree noundef nonnull align 16 dereferenceable(45) @exception_message) #52
  %cc.unpack = load ptr, ptr @current_coroutine, align 8
  %cc1 = insertvalue { ptr } poison, ptr %cc.unpack, 0
  call void @report_exception({ ptr } %cc1)
  call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

define void @os_specific_setup() local_unnamed_addr #17 {
  %1 = call ptr @AddVectoredExceptionHandler(i32 noundef 1, ptr noundef nonnull @PageFaultHandler)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #24

define void @arg_passer(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %current_coroutine) #17 {
  %func = load ptr, ptr %current_coroutine, align 8
  call void %func()
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #25

declare void @exit() local_unnamed_addr #17

; Function Attrs: mustprogress noinline optnone uwtable
define range(i32 -1, 1) i32 @PageFaultHandler(ptr noundef %0) #26 {
entry:
  %1 = load ptr, ptr %0, align 8
  %2 = load i32, ptr %1, align 8
  %.not = icmp eq i32 %2, -1073741819
  br i1 %.not, label %get_fault_info, label %fail

get_fault_info:                                   ; preds = %entry
  %fault_addr_ptr_ptr = getelementptr inbounds %struct._EXCEPTION_RECORD, ptr %1, i32 0, i32 5, i32 1
  %fault_addr_ptr = load ptr, ptr %fault_addr_ptr_ptr, align 8
  %fault_addr_int = ptrtoint ptr %fault_addr_ptr to i64
  %last_fault_addr = load ptr, ptr @last_fault_addr, align 8
  %same_addr = icmp eq ptr %fault_addr_ptr, %last_fault_addr
  br i1 %same_addr, label %fail, label %commit

commit:                                           ; preds = %get_fault_info
  store ptr %fault_addr_ptr, ptr @last_fault_addr, align 8
  %commit_result = call ptr @VirtualAlloc(ptr nofree %fault_addr_ptr, i64 noundef 4096, i32 noundef 4096, i32 noundef 4)
  %is_null = icmp eq ptr %commit_result, null
  br i1 %is_null, label %fail, label %return

fail:                                             ; preds = %commit, %get_fault_info, %entry
  br label %return

return:                                           ; preds = %fail, %commit
  %.0 = phi i32 [ -1, %commit ], [ 0, %fail ]
  ret i32 %.0
}

declare ptr @AddVectoredExceptionHandler(i32 noundef, ptr noundef) local_unnamed_addr #17

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @assume_offset(ptr nocapture nofree noundef nonnull readnone align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readnone align 4 %id_ptr) local_unnamed_addr #1 {
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr nocapture nofree noundef nonnull readonly %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nofree readonly %supertype_tbl) local_unnamed_addr #10 {
  %result = call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #47
  ret i1 %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @arg_buffer_filler(ptr nocapture nofree readnone %coroutine) local_unnamed_addr #1 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define ptr @get_current_coroutine() local_unnamed_addr #27 {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %from_buf, ptr %to_buf) #28 {
  %from_buf_second_word = getelementptr inbounds i8, ptr %from_buf, i64 8
  %from_buf_third_word = getelementptr inbounds i8, ptr %from_buf, i64 16
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = call ptr @llvm.stacksave.p0() #55
  store ptr %sp, ptr %from_buf, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %is_first_time = call i1 @returns_one() #54
  br i1 %is_first_time, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #23
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

; Function Attrs: nounwind
define void @coroutine_yield(ptr nocapture nofree nonnull writeonly align 8 dereferenceable(24) %current_coroutine) local_unnamed_addr #29 {
  %into_callee_buf = getelementptr inbounds i8, ptr %current_coroutine, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %into_callee_buf, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #57
  ret void
}

; Function Attrs: cold minsize noinline nounwind
define void @coroutine_yield_cold(ptr nocapture nofree nonnull writeonly align 8 dereferenceable(24) %current_coroutine) local_unnamed_addr #30 {
  %into_callee_buf.i = getelementptr inbounds i8, ptr %current_coroutine, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #57
  ret void
}

; Function Attrs: nounwind
define void @coroutine_call(ptr %coroutine) local_unnamed_addr #29 {
  %old_into_caller.unpack2 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr i8, ptr %coroutine, i64 8
  %1 = load <2 x ptr>, ptr @into_caller_buf, align 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr %into_callee_buf) #57
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store <2 x ptr> %1, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack2, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr nofree %tramp) local_unnamed_addr #31 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr nofree %tramp, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect) #52
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) local_unnamed_addr #31

; Function Attrs: mustprogress nounwind willreturn memory(argmem: readwrite, inaccessiblemem: readwrite)
define void @virtual_reset(ptr nocapture noundef %addr, i64 %size) local_unnamed_addr #32 {
  %result = call i32 @VirtualFree(ptr nocapture noundef %addr, i64 %size, i32 noundef 16384) #58
  ret void
}

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare i32 @VirtualFree(ptr allocptr nocapture noundef, i64, i32) local_unnamed_addr #33

define void @print_backtrace(ptr nocapture nofree readonly %backtrace, i64 %n_frames) local_unnamed_addr #17 {
  %handle = tail call ptr @GetCurrentProcess()
  %1 = tail call i32 @SymInitialize(ptr noundef %handle, ptr noundef align 4294967296 null, i32 noundef 1)
  %2 = alloca [344 x i8], align 1
  %3 = getelementptr inbounds i8, ptr %2, i64 4
  call void @llvm.memset.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(344) %3, i8 noundef 0, i64 noundef 340, i1 noundef false)
  %4 = getelementptr inbounds i8, ptr %2, i64 80
  store i32 255, ptr %4, align 4
  store i32 88, ptr %2, align 4
  %.not = icmp eq i64 %n_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %0
  %5 = getelementptr inbounds i8, ptr %2, i64 56
  %6 = getelementptr inbounds i8, ptr %2, i64 84
  br label %7

7:                                                ; preds = %7, %.lr.ph
  %indvars.iv.in = phi i64 [ %n_frames, %.lr.ph ], [ %indvars.iv, %7 ]
  %indvars.iv = add i64 %indvars.iv.in, -1
  %8 = getelementptr inbounds [100 x ptr], ptr %backtrace, i64 0, i64 %indvars.iv
  %9 = load ptr, ptr %8, align 8
  %10 = ptrtoint ptr %9 to i64
  %11 = call i32 @SymFromAddr(ptr noundef %handle, i64 noundef %10, ptr noundef align 4294967296 null, ptr noundef nonnull align 4 dereferenceable(344) %2)
  %12 = load i64, ptr %5, align 8
  %13 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(16) @backtrace_string, i64 noundef %indvars.iv, ptr nofree nonnull dereferenceable(260) %6, i64 %12) #52
  %exitcond.not = icmp slt i64 %indvars.iv, 1
  br i1 %exitcond.not, label %._crit_edge, label %7

._crit_edge:                                      ; preds = %7, %0
  %14 = call i32 @SymCleanup(ptr noundef %handle)
  ret void
}

declare ptr @GetCurrentProcess() local_unnamed_addr #17

declare i32 @SymInitialize(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #17

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #34

declare i32 @SymFromAddr(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #17

declare i32 @SymCleanup(ptr) local_unnamed_addr #17

define i64 @capture_backtrace(i64 %max_frames, ptr nocapture nofree writeonly %backtrace) local_unnamed_addr #17 {
entry:
  %context = alloca %struct._CONTEXT, align 16
  call void @RtlCaptureContext(ptr noundef nonnull align 16 dereferenceable(1232) %context)
  %rip = getelementptr inbounds i8, ptr %context, i64 248
  %img_base_ptr = alloca i64, align 8
  %0 = alloca ptr, align 8
  %1 = alloca i64, align 8
  %.not = icmp eq i64 %max_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %entry
  %.pre = load i64, ptr %rip, align 8
  br label %.lr.ph

.lr.ph:                                           ; preds = %3, %.lr.ph.preheader
  %2 = phi i64 [ %.pre, %.lr.ph.preheader ], [ %6, %3 ]
  %indvars.iv = phi i64 [ 0, %.lr.ph.preheader ], [ %indvars.iv.next, %3 ]
  %fentry = call ptr @RtlLookupFunctionEntry(i64 %2, ptr noundef nonnull align 8 dereferenceable(8) %img_base_ptr, ptr noundef align 4294967296 null)
  %img_base = load i64, ptr %img_base_ptr, align 8
  %fentry_null = icmp eq ptr %fentry, null
  %img_base_null = icmp eq i64 %img_base, 0
  %either = or i1 %fentry_null, %img_base_null
  br i1 %either, label %._crit_edge.loopexit.split.loop.exit, label %3

3:                                                ; preds = %.lr.ph
  %4 = load i64, ptr %rip, align 8
  %5 = call ptr @RtlVirtualUnwind(i32 noundef 0, i64 %img_base, i64 %4, ptr nonnull %fentry, ptr noundef nonnull align 16 dereferenceable(1232) %context, ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1, ptr noundef align 4294967296 null)
  %6 = load i64, ptr %rip, align 8
  %7 = inttoptr i64 %6 to ptr
  %8 = getelementptr inbounds ptr, ptr %backtrace, i64 %indvars.iv
  store ptr %7, ptr %8, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %max_frames
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge.loopexit.split.loop.exit:             ; preds = %.lr.ph
  %n_captured.le = add nsw i64 %indvars.iv, -4
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit.split.loop.exit, %3, %entry
  %.0.lcssa = phi i64 [ 0, %entry ], [ %n_captured.le, %._crit_edge.loopexit.split.loop.exit ], [ %max_frames, %3 ]
  ret i64 %.0.lcssa
}

declare void @RtlCaptureContext(ptr) local_unnamed_addr #17

declare ptr @RtlLookupFunctionEntry(i64, ptr, ptr) local_unnamed_addr #17

declare ptr @RtlVirtualUnwind(i32, i64, i64, ptr, ptr, ptr, ptr, ptr) local_unnamed_addr #17

define i1 @rhxjymbtkk(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @yvhtirisyp(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @wmeuadletf(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ziplyfqyzr(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @yfgrqyuxdb(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @vncryakffn(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @enhzrnpgee(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @zhsmkwsjzt(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @eoisxijnjo(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @yyrxzjdgkt(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @xfosmqkvur(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @slwynonqqw(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @lgazvjztvp(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @akkyvmuyai(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @hdfhtpkgsg(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @divaxowbuf(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @cwxmmotuoi(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @iuwstrhywa(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @xzqkptokak(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #17 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @dhfplvxlkm(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #17 {
  %result.i5.i309.h2s330 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i5.i309.h2s330, align 4
  %result.i5.i289.h2s332 = alloca [16 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(16) %result.i5.i289.h2s332, i8 0, i64 16, i1 false)
  %result.i5.i269.h2s334 = alloca [4 x i8], align 4
  store i32 7564576, ptr %result.i5.i269.h2s334, align 4
  %result.i5.i249.h2s336 = alloca [15 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i5.i249.h2s336, i8 0, i64 15, i1 false)
  %result.i5.i.h2s338 = alloca [15 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i5.i.h2s338, i8 0, i64 15, i1 false)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %5 = ptrtoint ptr %.fca.1.extract to i64
  %6 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.667.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.667.8.insert.shift = shl nuw i160 %.sroa.667.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %6 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.667.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.366.8.insert.ext = zext i64 %5 to i160
  %.sroa.366.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.366.8.insert.ext
  %7 = insertvalue { ptr, i160 } %4, i160 %.sroa.366.8.insert.insert, 1
  %8 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #43
  %11 = icmp eq ptr %.fca.0.extract, @i8_typ
  br i1 %11, label %RangeIterator_next_.exit52.i.preheader, label %12

12:                                               ; preds = %3
  %13 = icmp eq ptr %.fca.0.extract, @f64_typ
  br i1 %13, label %RangeIterator_next_.exit52.i.preheader, label %14

14:                                               ; preds = %12
  %15 = icmp eq ptr %.fca.0.extract, @i32_typ
  br i1 %15, label %RangeIterator_next_.exit52.i.preheader, label %16

16:                                               ; preds = %14
  %17 = icmp eq ptr %.fca.0.extract, @bool_typ
  br i1 %17, label %RangeIterator_next_.exit52.i.preheader, label %18

18:                                               ; preds = %16
  %19 = icmp eq ptr %.fca.0.extract, @i64_typ
  br i1 %19, label %RangeIterator_next_.exit52.i.preheader, label %20

20:                                               ; preds = %18
  %21 = icmp eq ptr %.fca.0.extract, @nil_typ
  %22 = icmp eq ptr %.fca.0.extract, null
  %23 = or i1 %21, %22
  br i1 %23, label %RangeIterator_next_.exit52.i.preheader, label %24

24:                                               ; preds = %20
  %25 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %26 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %27 = load i64, ptr %hash_coef_ptr.i, align 4
  %28 = load i64, ptr %tbl_size_ptr.i, align 4
  %29 = load ptr, ptr %25, align 8
  %30 = load ptr, ptr %26, align 8
  %result.i4.i = call i1 %29(i64 %28, i64 %27, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %30) #47
  br i1 %result.i4.i, label %31, label %.critedge.i

31:                                               ; preds = %24
  %result.i3.i = call i1 %29(i64 %28, i64 %27, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %30) #47
  br i1 %result.i3.i, label %.critedge.i, label %32

32:                                               ; preds = %31
  %result.i2.i = call i1 %29(i64 %28, i64 %27, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %30) #47
  br i1 %result.i2.i, label %.critedge.i, label %RangeIterator_next_.exit52.i.preheader

.critedge.i:                                      ; preds = %32, %31, %24
  %result.i1.i = call i1 %29(i64 %28, i64 %27, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %30) #47
  br i1 %result.i1.i, label %33, label %.critedge14.i

33:                                               ; preds = %.critedge.i
  %result.i.i = call i1 %29(i64 %28, i64 %27, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %30) #47
  br i1 %result.i.i, label %.critedge14.i, label %RangeIterator_next_.exit52.i.preheader

.critedge14.i:                                    ; preds = %33, %.critedge.i
  br label %RangeIterator_next_.exit52.i.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %.critedge14.i, %33, %32, %20, %18, %16, %14, %12, %3
  %.reg2mem25.0.i = phi i64 [ 4, %3 ], [ 5, %12 ], [ 1, %14 ], [ 6, %16 ], [ 7, %18 ], [ 8, %20 ], [ 9, %33 ], [ 3, %32 ], [ 2, %.critedge14.i ]
  %34 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %.reg2mem25.0.i
  %35 = getelementptr i8, ptr %34, i64 80
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %7)
  store i8 32, ptr %result.i5.i.h2s338, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s338, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep, align 1
  %37 = getelementptr inbounds i8, ptr %result.i5.i.h2s338, i64 14
  store i8 0, ptr %37, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338) #59
  %38 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1) #59
  store i8 32, ptr %result.i5.i249.h2s336, align 1
  %scevgep318 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318, align 1
  %39 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336, i64 14
  store i8 0, ptr %39, align 1
  %puts.i174 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336) #59
  %40 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2) #59
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #60
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %puts.i194 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334) #59
  %45 = icmp sgt i32 %1, 0
  br i1 %45, label %RangeIterator_next_.exit52.i292.preheader, label %._crit_edge

RangeIterator_next_.exit52.i292.preheader:        ; preds = %RangeIterator_next_.exit52.i.preheader
  %46 = zext nneg i32 %1 to i64
  store i8 32, ptr %result.i5.i289.h2s332, align 1
  %scevgep324 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324, align 1
  %47 = mul i64 %2, 1000000
  %48 = sdiv i64 %47, %46
  %49 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332, i64 15
  store i8 0, ptr %49, align 1
  %puts.i214 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332) #59
  %50 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %48) #59
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #60
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  store i8 32, ptr %result.i5.i309.h2s330, align 4
  %scevgep327 = getelementptr inbounds i8, ptr %result.i5.i309.h2s330, i64 1
  store i16 29550, ptr %scevgep327, align 1
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %55 = getelementptr inbounds i8, ptr %result.i5.i309.h2s330, i64 3
  store i8 0, ptr %55, align 1
  %puts.i234 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330) #59
  br label %._crit_edge

._crit_edge:                                      ; preds = %RangeIterator_next_.exit52.i292.preheader, %RangeIterator_next_.exit52.i.preheader
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr #17 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %oldProtect.i26 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %3 = alloca [4 x ptr], align 8
  %4 = alloca { ptr, ptr, ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %result.i24 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #51
  store ptr @_parameterization_i32, ptr %result.i24, align 8
  %11 = getelementptr inbounds i8, ptr %result.i24, i64 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i24, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i24) #60
  %result.i23 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  %result.i25 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i23, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i23, ptr noalias nofree noundef nonnull readnone @dhfplvxlkm, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i15 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i23) #50
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i23) #60
  %result.i22 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i26) #60
  %result.i27 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i22, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i26) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i26) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i22, ptr noalias nofree noundef nonnull readnone @xzqkptokak, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i22) #50
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i22) #60
  %16 = getelementptr inbounds i8, ptr %result.i24, i64 48
  store ptr %ret.i15, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i24, i64 56
  store ptr %ret.i, ptr %17, align 8
  %result.i1.i61 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  %18 = getelementptr inbounds i8, ptr %result.i24, i64 24
  store ptr %result.i1.i61, ptr %18, align 8
  %result.i.i62 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %19 = getelementptr inbounds i8, ptr %result.i24, i64 32
  store ptr %result.i.i62, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i24, i64 40
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %22 = getelementptr inbounds i8, ptr %result.i24, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %20, align 8
  %23 = call i64 @clock()
  %24 = icmp sgt i32 %0, 0
  br i1 %24, label %._crit_edge.preheader, label %288

._crit_edge.preheader:                            ; preds = %SwissTable_insert_keyK_valueV.exit, %1
  %25 = phi ptr [ %.pre357, %SwissTable_insert_keyK_valueV.exit ], [ %result.i.i62, %1 ]
  %26 = phi ptr [ %125, %SwissTable_insert_keyK_valueV.exit ], [ %result.i1.i61, %1 ]
  %.lcssa561 = phi i32 [ %203, %SwissTable_insert_keyK_valueV.exit ], [ 0, %1 ]
  %27 = phi i32 [ %126, %SwissTable_insert_keyK_valueV.exit ], [ 8, %1 ]
  %.042 = phi i32 [ %28, %SwissTable_insert_keyK_valueV.exit ], [ 0, %1 ]
  %28 = add nuw nsw i32 %.042, 1
  %.sroa.0283.0.insert.ext = zext nneg i32 %.042 to i160
  %29 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0283.0.insert.ext, 1
  %30 = add i32 %.lcssa561, 1
  %31 = mul i32 %27, 7
  %32 = sdiv i32 %31, 10
  %.not.i = icmp slt i32 %30, %32
  br i1 %.not.i, label %SwissTable_ensure_capacity_required_sizei32.exit, label %._crit_edge1.i

._crit_edge1.i:                                   ; preds = %._crit_edge.preheader
  %33 = shl i32 %27, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %33, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %34 = zext nneg i32 %spec.select.i to i64
  %35 = shl nuw nsw i64 %34, 5
  %result.i10.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %35) #51
  %result.i9.i370 = call noalias ptr @bump_malloc_wrapper(i64 noundef %34) #51
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %37 = add i32 %27, -1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %42 = icmp slt i32 %37, 0
  br i1 %42, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i.preheader

.lr.ph.i.preheader:                               ; preds = %._crit_edge1.i
  %43 = load ptr, ptr %16, align 8
  %44 = add nsw i32 %spec.select.i, -1
  %45 = load ptr, ptr %17, align 8
  br label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge2.backedge.i, %.lr.ph.i.preheader
  %46 = phi i32 [ %120, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %storemerge.i = phi i32 [ %124, %._crit_edge2.backedge.i ], [ 1, %.lr.ph.i.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i = phi i32 [ %storemerge.i, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %.sroa.0.8.extract.trunc.i = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i to i64
  %sext.i = shl nuw i64 %.sroa.0.8.extract.trunc.i, 32
  %47 = ashr exact i64 %sext.i, 27
  %48 = getelementptr i8, ptr %26, i64 %47
  %49 = load ptr, ptr %48, align 8
  %50 = icmp ne ptr %49, @nil_typ
  %51 = icmp ne ptr %49, null
  %.not158.i = and i1 %50, %51
  br i1 %.not158.i, label %52, label %._crit_edge2.backedge.i

52:                                               ; preds = %.lr.ph.i
  %53 = getelementptr i8, ptr %48, i64 8
  %54 = load i160, ptr %53, align 4
  %.sroa.3.0.extract.shift.i = lshr i160 %54, 64
  %.sroa.3.0.extract.trunc.i = trunc i160 %.sroa.3.0.extract.shift.i to i64
  %.sroa.0146.0.extract.trunc.i = trunc i160 %54 to i64
  %55 = inttoptr i64 %.sroa.0146.0.extract.trunc.i to ptr
  %56 = inttoptr i64 %.sroa.3.0.extract.trunc.i to ptr
  %hash_coef_ptr.i23.i = getelementptr i8, ptr %49, i64 8
  %tbl_size_ptr.i24.i = getelementptr i8, ptr %49, i64 16
  %offset_tbl_ptr.i25.i = getelementptr i8, ptr %49, i64 40
  %hash_coef.i26.i = load i64, ptr %hash_coef_ptr.i23.i, align 4
  %tbl_size.i27.i = load i64, ptr %tbl_size_ptr.i24.i, align 4
  %offset_tbl.i28.i = load ptr, ptr %offset_tbl_ptr.i25.i, align 8
  %product.i.i29.i = mul i64 %hash_coef.i26.i, 4015701072841558310
  %shifted.i.i30.i = lshr i64 %product.i.i29.i, 32
  %xored.i.i31.i = xor i64 %shifted.i.i30.i, %product.i.i29.i
  %hash.i.i32.i = and i64 %xored.i.i31.i, %tbl_size.i27.i
  %offset_ptr.i33.i = getelementptr i32, ptr %offset_tbl.i28.i, i64 %hash.i.i32.i
  %offset.i34.i = load i32, ptr %offset_ptr.i33.i, align 4
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %49, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %55, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %56, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %offset.i34.i, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %49)
  %63 = sext i32 %offset.i34.i to i64
  %64 = getelementptr ptr, ptr %49, i64 %63
  %65 = getelementptr i8, ptr %64, i64 48
  %66 = load ptr, ptr %65, align 8
  %result.i4.i = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %67 = call { ptr, i160 } %result.i4.i({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %2)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %69 = call i32 %43({ ptr, i160 } %67)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %49)
  %72 = load ptr, ptr %65, align 8
  %result.i3.i = call ptr %72({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %73 = call { ptr, i160 } %result.i3.i({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %74

74:                                               ; preds = %112, %52
  %.pn = phi i32 [ %69, %52 ], [ %113, %112 ]
  %.0485 = phi i32 [ -1, %52 ], [ %.1486, %112 ]
  %.0..0..0..0..0..0.84.i460 = phi i32 [ -1, %52 ], [ %spec.store.select9216.i463, %112 ]
  %.0487 = and i32 %.pn, %44
  %75 = zext nneg i32 %.0487 to i64
  %76 = getelementptr i8, ptr %result.i9.i370, i64 %75
  %77 = load i8, ptr %76, align 1
  switch i8 %77, label %._crit_edge.i466 [
    i8 0, label %114
    i8 -128, label %._crit_edge.thread.i461
  ]

._crit_edge.thread.i461:                          ; preds = %74
  %78 = icmp eq i32 %.0..0..0..0..0..0.84.i460, -1
  %spec.store.select.i462 = select i1 %78, i32 %.0487, i32 %.0..0..0..0..0..0.84.i460
  br label %112

._crit_edge.i466:                                 ; preds = %74
  %79 = icmp sgt i8 %77, 0
  br i1 %79, label %80, label %112

80:                                               ; preds = %._crit_edge.i466
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %82 = shl nuw nsw i64 %75, 5
  %83 = getelementptr i8, ptr %result.i10.i, i64 %82
  %84 = load ptr, ptr %83, align 8
  %85 = icmp ne ptr %84, @nil_typ
  %86 = icmp ne ptr %84, null
  %.not82.i467 = and i1 %85, %86
  br i1 %.not82.i467, label %87, label %112

87:                                               ; preds = %80
  %88 = getelementptr i8, ptr %83, i64 8
  %89 = load i64, ptr %88, align 4
  %.sroa_idx.i468 = getelementptr i8, ptr %83, i64 16
  %90 = load i64, ptr %.sroa_idx.i468, align 4
  %91 = inttoptr i64 %89 to ptr
  %92 = inttoptr i64 %90 to ptr
  %hash_coef_ptr.i3.i469 = getelementptr i8, ptr %84, i64 8
  %tbl_size_ptr.i4.i470 = getelementptr i8, ptr %84, i64 16
  %offset_tbl_ptr.i5.i471 = getelementptr i8, ptr %84, i64 40
  %hash_coef.i6.i472 = load i64, ptr %hash_coef_ptr.i3.i469, align 4
  %tbl_size.i7.i473 = load i64, ptr %tbl_size_ptr.i4.i470, align 4
  %offset_tbl.i8.i474 = load ptr, ptr %offset_tbl_ptr.i5.i471, align 8
  %product.i.i9.i475 = mul i64 %hash_coef.i6.i472, 4015701072841558310
  %shifted.i.i10.i476 = lshr i64 %product.i.i9.i475, 32
  %xored.i.i11.i477 = xor i64 %shifted.i.i10.i476, %product.i.i9.i475
  %hash.i.i12.i478 = and i64 %xored.i.i11.i477, %tbl_size.i7.i473
  %offset_ptr.i13.i479 = getelementptr i32, ptr %offset_tbl.i8.i474, i64 %hash.i.i12.i478
  %offset.i14.i480 = load i32, ptr %offset_ptr.i13.i479, align 4
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %84, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %91, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %92, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %offset.i14.i480, 3
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %84)
  %99 = sext i32 %offset.i14.i480 to i64
  %100 = getelementptr ptr, ptr %84, i64 %99
  %101 = getelementptr i8, ptr %100, i64 40
  %102 = load ptr, ptr %101, align 8
  %result.i1.i481 = call ptr %102({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %103 = call i32 %result.i1.i481({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2)
  %104 = icmp eq i32 %103, %69
  br i1 %104, label %._crit_edge2.i482, label %112

._crit_edge2.i482:                                ; preds = %87
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %84)
  %107 = getelementptr i8, ptr %100, i64 48
  %108 = load ptr, ptr %107, align 8
  %result.i.i = call ptr %108({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %109 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2)
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %111 = call i1 %45({ ptr, i160 } %109, { ptr, i160 } %73)
  br i1 %111, label %SwissTable_find_slot_keyK_hashi32.exit483, label %112

112:                                              ; preds = %._crit_edge2.i482, %87, %80, %._crit_edge.i466, %._crit_edge.thread.i461
  %.1486 = phi i32 [ %.0485, %._crit_edge2.i482 ], [ %.0485, %87 ], [ %.0485, %80 ], [ %.0485, %._crit_edge.i466 ], [ %spec.store.select.i462, %._crit_edge.thread.i461 ]
  %spec.store.select9216.i463 = phi i32 [ %.0..0..0..0..0..0.84.i460, %._crit_edge2.i482 ], [ %.0..0..0..0..0..0.84.i460, %87 ], [ %.0..0..0..0..0..0.84.i460, %80 ], [ %.0..0..0..0..0..0.84.i460, %._crit_edge.i466 ], [ %spec.store.select.i462, %._crit_edge.thread.i461 ]
  %113 = add nuw nsw i32 %.0487, 1
  br label %74

114:                                              ; preds = %74
  %.not.i464 = icmp eq i32 %.0..0..0..0..0..0.84.i460, -1
  %.pre.i465 = select i1 %.not.i464, i32 %.0487, i32 %.0485
  %.pre518 = sext i32 %.pre.i465 to i64
  %.pre520 = shl nsw i64 %.pre518, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit483

SwissTable_find_slot_keyK_hashi32.exit483:        ; preds = %114, %._crit_edge2.i482
  %.pre-phi521 = phi i64 [ %.pre520, %114 ], [ %82, %._crit_edge2.i482 ]
  %.pre-phi519 = phi i64 [ %.pre518, %114 ], [ %75, %._crit_edge2.i482 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %115 = getelementptr i8, ptr %result.i10.i, i64 %.pre-phi521
  store ptr %49, ptr %115, align 8
  %116 = getelementptr i8, ptr %115, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i, ptr %116, align 4
  %.sroa_idx120.i = getelementptr i8, ptr %115, i64 16
  store i64 %.sroa.3.0.extract.trunc.i, ptr %.sroa_idx120.i, align 4
  %.sroa_idx121.i = getelementptr i8, ptr %115, i64 24
  store i32 %offset.i34.i, ptr %.sroa_idx121.i, align 4
  %117 = getelementptr i8, ptr %result.i9.i370, i64 %.pre-phi519
  store i8 1, ptr %117, align 1
  %118 = add i32 %46, 1
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i

._crit_edge2.backedge.i:                          ; preds = %SwissTable_find_slot_keyK_hashi32.exit483, %.lr.ph.i
  %120 = phi i32 [ %118, %SwissTable_find_slot_keyK_hashi32.exit483 ], [ %46, %.lr.ph.i ]
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %123 = icmp sgt i32 %storemerge.i, %37
  %124 = add i32 %storemerge.i, 1
  br i1 %123, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i

SwissTable_resize_new_capacityi32.exit:           ; preds = %._crit_edge2.backedge.i, %._crit_edge1.i
  %.lcssa562 = phi i32 [ 0, %._crit_edge1.i ], [ %120, %._crit_edge2.backedge.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %SwissTable_ensure_capacity_required_sizei32.exit

SwissTable_ensure_capacity_required_sizei32.exit: ; preds = %SwissTable_resize_new_capacityi32.exit, %._crit_edge.preheader
  %.pre357 = phi ptr [ %25, %._crit_edge.preheader ], [ %result.i9.i370, %SwissTable_resize_new_capacityi32.exit ]
  %125 = phi ptr [ %26, %._crit_edge.preheader ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %.lcssa560 = phi i32 [ %.lcssa561, %._crit_edge.preheader ], [ %.lcssa562, %SwissTable_resize_new_capacityi32.exit ]
  %126 = phi i32 [ %27, %._crit_edge.preheader ], [ %spec.select.i, %SwissTable_resize_new_capacityi32.exit ]
  %127 = add nuw i32 %.042, 2127912214
  %128 = shl i32 %.042, 12
  %129 = add i32 %127, %128
  %130 = ashr i32 %129, 19
  %131 = xor i32 %129, %130
  %132 = xor i32 %131, -949894596
  %133 = add i32 %132, 374761393
  %134 = shl i32 %132, 5
  %135 = add i32 %133, %134
  %136 = add i32 %135, -744332180
  %137 = shl i32 %135, 9
  %138 = xor i32 %136, %137
  %139 = add i32 %138, -42973499
  %140 = shl i32 %138, 3
  %141 = add i32 %139, %140
  %142 = ashr i32 %141, 16
  %143 = xor i32 %141, %142
  %144 = xor i32 %143, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %145 = add i32 %126, -1
  %146 = and i32 %145, %144
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %148 = load ptr, ptr %17, align 8
  br label %149

149:                                              ; preds = %187, %SwissTable_ensure_capacity_required_sizei32.exit
  %.0278 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %.1279, %187 ]
  %.0277 = phi i32 [ %146, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %189, %187 ]
  %.0..0..0..0..0..0.84.i = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %spec.store.select9216.i, %187 ]
  %150 = sext i32 %.0277 to i64
  %151 = getelementptr i8, ptr %.pre357, i64 %150
  %152 = load i8, ptr %151, align 1
  switch i8 %152, label %._crit_edge.i [
    i8 0, label %190
    i8 -128, label %._crit_edge.thread.i
  ]

._crit_edge.thread.i:                             ; preds = %149
  %153 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %spec.store.select.i = select i1 %153, i32 %.0277, i32 %.0..0..0..0..0..0.84.i
  br label %187

._crit_edge.i:                                    ; preds = %149
  %154 = icmp sgt i8 %152, 0
  br i1 %154, label %155, label %187

155:                                              ; preds = %._crit_edge.i
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %157 = shl nsw i64 %150, 5
  %158 = getelementptr i8, ptr %125, i64 %157
  %159 = load ptr, ptr %158, align 8
  %160 = icmp ne ptr %159, @nil_typ
  %161 = icmp ne ptr %159, null
  %.not82.i = and i1 %160, %161
  br i1 %.not82.i, label %162, label %187

162:                                              ; preds = %155
  %163 = getelementptr i8, ptr %158, i64 8
  %164 = load i64, ptr %163, align 4
  %.sroa_idx.i = getelementptr i8, ptr %158, i64 16
  %165 = load i64, ptr %.sroa_idx.i, align 4
  %166 = inttoptr i64 %164 to ptr
  %167 = inttoptr i64 %165 to ptr
  %hash_coef_ptr.i3.i215 = getelementptr i8, ptr %159, i64 8
  %tbl_size_ptr.i4.i216 = getelementptr i8, ptr %159, i64 16
  %offset_tbl_ptr.i5.i217 = getelementptr i8, ptr %159, i64 40
  %hash_coef.i6.i218 = load i64, ptr %hash_coef_ptr.i3.i215, align 4
  %tbl_size.i7.i219 = load i64, ptr %tbl_size_ptr.i4.i216, align 4
  %offset_tbl.i8.i220 = load ptr, ptr %offset_tbl_ptr.i5.i217, align 8
  %product.i.i9.i221 = mul i64 %hash_coef.i6.i218, 4015701072841558310
  %shifted.i.i10.i222 = lshr i64 %product.i.i9.i221, 32
  %xored.i.i11.i223 = xor i64 %shifted.i.i10.i222, %product.i.i9.i221
  %hash.i.i12.i224 = and i64 %xored.i.i11.i223, %tbl_size.i7.i219
  %offset_ptr.i13.i225 = getelementptr i32, ptr %offset_tbl.i8.i220, i64 %hash.i.i12.i224
  %offset.i14.i226 = load i32, ptr %offset_ptr.i13.i225, align 4
  %168 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %159, 0
  %169 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %166, 1
  %170 = insertvalue { ptr, ptr, ptr, i32 } %169, ptr %167, 2
  %171 = insertvalue { ptr, ptr, ptr, i32 } %170, i32 %offset.i14.i226, 3
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %159)
  %174 = sext i32 %offset.i14.i226 to i64
  %175 = getelementptr ptr, ptr %159, i64 %174
  %176 = getelementptr i8, ptr %175, i64 40
  %177 = load ptr, ptr %176, align 8
  %result.i1.i = call ptr %177({ ptr, ptr, ptr, i32 } %171, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %178 = call i32 %result.i1.i({ ptr, ptr, ptr, i32 } %171, { ptr, ptr, ptr, i32 } %171, ptr nonnull align 8 %2)
  %179 = icmp eq i32 %178, %144
  br i1 %179, label %._crit_edge2.i, label %187

._crit_edge2.i:                                   ; preds = %162
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %159)
  %182 = getelementptr i8, ptr %175, i64 48
  %183 = load ptr, ptr %182, align 8
  %result.i.i227 = call ptr %183({ ptr, ptr, ptr, i32 } %171, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %184 = call { ptr, i160 } %result.i.i227({ ptr, ptr, ptr, i32 } %171, { ptr, ptr, ptr, i32 } %171, ptr nonnull align 8 %2)
  %185 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %186 = call i1 %148({ ptr, i160 } %184, { ptr, i160 } %29)
  br i1 %186, label %SwissTable_find_slot_keyK_hashi32.exit, label %187

187:                                              ; preds = %._crit_edge2.i, %162, %155, %._crit_edge.i, %._crit_edge.thread.i
  %.1279 = phi i32 [ %.0278, %._crit_edge2.i ], [ %.0278, %162 ], [ %.0278, %155 ], [ %.0278, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %spec.store.select9216.i = phi i32 [ %.0..0..0..0..0..0.84.i, %._crit_edge2.i ], [ %.0..0..0..0..0..0.84.i, %162 ], [ %.0..0..0..0..0..0.84.i, %155 ], [ %.0..0..0..0..0..0.84.i, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %188 = add i32 %.0277, 1
  %189 = and i32 %188, %145
  br label %149

190:                                              ; preds = %149
  %.not.i214 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %.pre.i = select i1 %.not.i214, i32 %.0277, i32 %.0278
  %.pre = sext i32 %.pre.i to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit

SwissTable_find_slot_keyK_hashi32.exit:           ; preds = %190, %._crit_edge2.i
  %.pre-phi = phi i64 [ %.pre, %190 ], [ %150, %._crit_edge2.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %192 = getelementptr i8, ptr %.pre357, i64 %.pre-phi
  %193 = load i8, ptr %192, align 1
  %result.i9.i = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  store ptr @_parameterization_i32, ptr %result.i9.i, align 8
  %194 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr @_parameterization_i32, ptr %194, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9.i)
  %196 = getelementptr inbounds i8, ptr %result.i9.i, i64 20
  store i32 %.042, ptr %196, align 4
  %197 = getelementptr inbounds i8, ptr %result.i9.i, i64 24
  store i32 %28, ptr %197, align 8
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %199 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %144, ptr %199, align 8
  %200 = icmp eq i8 %193, 0
  br i1 %200, label %201, label %SwissTable_insert_keyK_valueV.exit

201:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit
  store i8 1, ptr %192, align 1
  %202 = add i32 %.lcssa560, 1
  br label %SwissTable_insert_keyK_valueV.exit

SwissTable_insert_keyK_valueV.exit:               ; preds = %201, %SwissTable_find_slot_keyK_hashi32.exit
  %203 = phi i32 [ %.lcssa560, %SwissTable_find_slot_keyK_hashi32.exit ], [ %202, %201 ]
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %205 = shl nsw i64 %.pre-phi, 5
  %206 = getelementptr i8, ptr %125, i64 %205
  store ptr @Entry, ptr %206, align 8
  %207 = getelementptr i8, ptr %206, i64 8
  %208 = ptrtoint ptr %result.i9.i to i64
  store i64 %208, ptr %207, align 4
  %.sroa_idx3.i = getelementptr i8, ptr %206, i64 24
  store i32 10, ptr %.sroa_idx3.i, align 4
  %exitcond.not = icmp eq i32 %28, %0
  br i1 %exitcond.not, label %._crit_edge2, label %._crit_edge.preheader

._crit_edge2:                                     ; preds = %SwissTable_insert_keyK_valueV.exit
  store i32 %126, ptr %20, align 8
  store i32 %203, ptr %22, align 4
  store ptr %125, ptr %18, align 8
  store ptr %.pre357, ptr %19, align 8
  %.sroa.gep306 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep309 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep312 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep315 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep318 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep321 = getelementptr inbounds i8, ptr %3, i64 24
  %209 = call i64 @clock()
  %210 = add nsw i32 %0, -1
  %.sroa.0269.0.insert.ext = zext nneg i32 %210 to i160
  %211 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0269.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %213 = load ptr, ptr %16, align 8
  %214 = call i32 %213({ ptr, i160 } %211)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %216 = load ptr, ptr %17, align 8
  br label %217

217:                                              ; preds = %255, %._crit_edge2
  %.0276 = phi i32 [ -1, %._crit_edge2 ], [ %.1, %255 ]
  %.pn620 = phi i32 [ %214, %._crit_edge2 ], [ %256, %255 ]
  %.0..0..0..0..0..0.84.i243 = phi i32 [ -1, %._crit_edge2 ], [ %spec.store.select9216.i247, %255 ]
  %.0 = and i32 %.pn620, %145
  %218 = sext i32 %.0 to i64
  %219 = getelementptr i8, ptr %.pre357, i64 %218
  %220 = load i8, ptr %219, align 1
  switch i8 %220, label %._crit_edge.i252 [
    i8 0, label %257
    i8 -128, label %._crit_edge.thread.i245
  ]

._crit_edge.thread.i245:                          ; preds = %217
  %221 = icmp eq i32 %.0..0..0..0..0..0.84.i243, -1
  %spec.store.select.i246 = select i1 %221, i32 %.0, i32 %.0..0..0..0..0..0.84.i243
  br label %255

._crit_edge.i252:                                 ; preds = %217
  %222 = icmp sgt i8 %220, 0
  br i1 %222, label %223, label %255

223:                                              ; preds = %._crit_edge.i252
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %225 = shl nsw i64 %218, 5
  %226 = getelementptr i8, ptr %125, i64 %225
  %227 = load ptr, ptr %226, align 8
  %228 = icmp ne ptr %227, @nil_typ
  %229 = icmp ne ptr %227, null
  %.not82.i254 = and i1 %228, %229
  br i1 %.not82.i254, label %230, label %255

230:                                              ; preds = %223
  %231 = getelementptr i8, ptr %226, i64 8
  %232 = load i64, ptr %231, align 4
  %.sroa_idx.i255 = getelementptr i8, ptr %226, i64 16
  %233 = load i64, ptr %.sroa_idx.i255, align 4
  %234 = inttoptr i64 %232 to ptr
  %235 = inttoptr i64 %233 to ptr
  %hash_coef_ptr.i3.i256 = getelementptr i8, ptr %227, i64 8
  %tbl_size_ptr.i4.i257 = getelementptr i8, ptr %227, i64 16
  %offset_tbl_ptr.i5.i258 = getelementptr i8, ptr %227, i64 40
  %hash_coef.i6.i259 = load i64, ptr %hash_coef_ptr.i3.i256, align 4
  %tbl_size.i7.i260 = load i64, ptr %tbl_size_ptr.i4.i257, align 4
  %offset_tbl.i8.i261 = load ptr, ptr %offset_tbl_ptr.i5.i258, align 8
  %product.i.i9.i262 = mul i64 %hash_coef.i6.i259, 4015701072841558310
  %shifted.i.i10.i263 = lshr i64 %product.i.i9.i262, 32
  %xored.i.i11.i264 = xor i64 %shifted.i.i10.i263, %product.i.i9.i262
  %hash.i.i12.i265 = and i64 %xored.i.i11.i264, %tbl_size.i7.i260
  %offset_ptr.i13.i266 = getelementptr i32, ptr %offset_tbl.i8.i261, i64 %hash.i.i12.i265
  %offset.i14.i267 = load i32, ptr %offset_ptr.i13.i266, align 4
  %236 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %227, 0
  %237 = insertvalue { ptr, ptr, ptr, i32 } %236, ptr %234, 1
  %238 = insertvalue { ptr, ptr, ptr, i32 } %237, ptr %235, 2
  %239 = insertvalue { ptr, ptr, ptr, i32 } %238, i32 %offset.i14.i267, 3
  %240 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %241 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %227)
  %242 = sext i32 %offset.i14.i267 to i64
  %243 = getelementptr ptr, ptr %227, i64 %242
  %244 = getelementptr i8, ptr %243, i64 40
  %245 = load ptr, ptr %244, align 8
  %result.i1.i268 = call ptr %245({ ptr, ptr, ptr, i32 } %239, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %246 = call i32 %result.i1.i268({ ptr, ptr, ptr, i32 } %239, { ptr, ptr, ptr, i32 } %239, ptr nonnull align 8 %2)
  %247 = icmp eq i32 %246, %214
  br i1 %247, label %._crit_edge2.i269, label %255

._crit_edge2.i269:                                ; preds = %230
  %248 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %249 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %227)
  %250 = getelementptr i8, ptr %243, i64 48
  %251 = load ptr, ptr %250, align 8
  %result.i.i270 = call ptr %251({ ptr, ptr, ptr, i32 } %239, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %252 = call { ptr, i160 } %result.i.i270({ ptr, ptr, ptr, i32 } %239, { ptr, ptr, ptr, i32 } %239, ptr nonnull align 8 %2)
  %253 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %254 = call i1 %216({ ptr, i160 } %252, { ptr, i160 } %211)
  br i1 %254, label %SwissTable_find_slot_keyK_hashi32.exit272, label %255

255:                                              ; preds = %._crit_edge2.i269, %230, %223, %._crit_edge.i252, %._crit_edge.thread.i245
  %.1 = phi i32 [ %.0276, %._crit_edge2.i269 ], [ %.0276, %230 ], [ %.0276, %223 ], [ %.0276, %._crit_edge.i252 ], [ %spec.store.select.i246, %._crit_edge.thread.i245 ]
  %spec.store.select9216.i247 = phi i32 [ %.0..0..0..0..0..0.84.i243, %._crit_edge2.i269 ], [ %.0..0..0..0..0..0.84.i243, %230 ], [ %.0..0..0..0..0..0.84.i243, %223 ], [ %.0..0..0..0..0..0.84.i243, %._crit_edge.i252 ], [ %spec.store.select.i246, %._crit_edge.thread.i245 ]
  %256 = add i32 %.0, 1
  br label %217

257:                                              ; preds = %217
  %.not.i248 = icmp eq i32 %.0..0..0..0..0..0.84.i243, -1
  %.pre.i251 = select i1 %.not.i248, i32 %.0, i32 %.0276
  %.pre306 = sext i32 %.pre.i251 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit272

SwissTable_find_slot_keyK_hashi32.exit272:        ; preds = %257, %._crit_edge2.i269
  %.pre-phi307 = phi i64 [ %.pre306, %257 ], [ %218, %._crit_edge2.i269 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %258 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %259 = getelementptr i8, ptr %.pre357, i64 %.pre-phi307
  %260 = load i8, ptr %259, align 1
  switch i8 %260, label %261 [
    i8 -128, label %SwissTable_get_keyK.exit.thread
    i8 0, label %SwissTable_get_keyK.exit.thread
  ]

261:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit272
  %262 = shl nsw i64 %.pre-phi307, 5
  %263 = getelementptr i8, ptr %125, i64 %262
  %264 = load ptr, ptr %263, align 8
  %265 = icmp ne ptr %264, @nil_typ
  %266 = icmp ne ptr %264, null
  %.not74.i = and i1 %265, %266
  br i1 %.not74.i, label %SwissTable_get_keyK.exit, label %SwissTable_get_keyK.exit.thread

SwissTable_get_keyK.exit.thread:                  ; preds = %261, %SwissTable_find_slot_keyK_hashi32.exit272, %SwissTable_find_slot_keyK_hashi32.exit272
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge3

SwissTable_get_keyK.exit:                         ; preds = %261
  %267 = getelementptr i8, ptr %263, i64 8
  %268 = load i160, ptr %267, align 4
  %.sroa.262.0.extract.shift.i = lshr i160 %268, 64
  %.sroa.262.0.extract.trunc.i = trunc i160 %.sroa.262.0.extract.shift.i to i64
  %.sroa.061.0.extract.trunc.i = trunc i160 %268 to i64
  %269 = inttoptr i64 %.sroa.061.0.extract.trunc.i to ptr
  %270 = inttoptr i64 %.sroa.262.0.extract.trunc.i to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %264, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %264, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %264, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %271 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %264, 0
  %272 = insertvalue { ptr, ptr, ptr, i32 } %271, ptr %269, 1
  %273 = insertvalue { ptr, ptr, ptr, i32 } %272, ptr %270, 2
  %274 = insertvalue { ptr, ptr, ptr, i32 } %273, i32 %offset.i14.i, 3
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %264)
  %277 = sext i32 %offset.i14.i to i64
  %278 = getelementptr ptr, ptr %264, i64 %277
  %279 = getelementptr i8, ptr %278, i64 56
  %280 = load ptr, ptr %279, align 8
  %result.i1.i93 = call ptr %280({ ptr, ptr, ptr, i32 } %274, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %281 = call { ptr, i160 } %result.i1.i93({ ptr, ptr, ptr, i32 } %274, { ptr, ptr, ptr, i32 } %274, ptr nonnull align 8 %2)
  %.fca.0.extract49.i = extractvalue { ptr, i160 } %281, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %282 = icmp ne ptr %.fca.0.extract49.i, @nil_typ
  %283 = icmp ne ptr %.fca.0.extract49.i, null
  %.not299 = and i1 %282, %283
  br i1 %.not299, label %._crit_edge4, label %._crit_edge3

._crit_edge4:                                     ; preds = %SwissTable_get_keyK.exit
  %.fca.1.extract50.i = extractvalue { ptr, i160 } %281, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract50.i to i32
  %.not303 = icmp eq i32 %0, %.sroa.2.8.extract.trunc
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge4, %SwissTable_get_keyK.exit, %SwissTable_get_keyK.exit.thread
  %.2 = phi i1 [ %.not303, %._crit_edge4 ], [ false, %SwissTable_get_keyK.exit ], [ false, %SwissTable_get_keyK.exit.thread ]
  %284 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %.not304 = icmp eq i32 %203, %0
  %286 = select i1 %.not304, i1 %.2, i1 false
  %287 = freeze i1 %286
  br label %RangeIterator_next_.exit52.i.preheader

288:                                              ; preds = %1
  %.sroa.gep30643 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep30944 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep31245 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep31546 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep31847 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep32148 = getelementptr inbounds i8, ptr %3, i64 24
  %289 = call i64 @clock()
  %290 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %291 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  br label %RangeIterator_next_.exit52.i.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %288, %._crit_edge3
  %292 = phi i64 [ %209, %._crit_edge3 ], [ %289, %288 ]
  %.sroa.gep32159 = phi ptr [ %.sroa.gep321, %._crit_edge3 ], [ %.sroa.gep32148, %288 ]
  %.sroa.gep31857 = phi ptr [ %.sroa.gep318, %._crit_edge3 ], [ %.sroa.gep31847, %288 ]
  %.sroa.gep31555 = phi ptr [ %.sroa.gep315, %._crit_edge3 ], [ %.sroa.gep31546, %288 ]
  %.sroa.gep31253 = phi ptr [ %.sroa.gep312, %._crit_edge3 ], [ %.sroa.gep31245, %288 ]
  %.sroa.gep30951 = phi ptr [ %.sroa.gep309, %._crit_edge3 ], [ %.sroa.gep30944, %288 ]
  %.sroa.gep30649 = phi ptr [ %.sroa.gep306, %._crit_edge3 ], [ %.sroa.gep30643, %288 ]
  %.reg2mem15.0.in = phi i1 [ %287, %._crit_edge3 ], [ true, %288 ]
  %.sroa.gep320 = getelementptr inbounds i8, ptr %7, i64 24
  %.sroa.gep314 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep308 = getelementptr inbounds i8, ptr %8, i64 16
  %result.i21 = call noalias dereferenceable_or_null(18) ptr @bump_malloc_wrapper(i64 noundef 18) #51
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i21, align 1
  %293 = sub i64 %292, %23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %294 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #43
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %295 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %296 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #43
  %result.i5.i992 = call noalias dereferenceable_or_null(18) ptr @bump_malloc_wrapper(i64 noundef 18) #51
  %297 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %298 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %299 = load i8, ptr %result.i21, align 1
  store i8 %299, ptr %result.i5.i992, align 1
  %300 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %301 = getelementptr i8, ptr %result.i21, i64 1
  %wide.load = load <16 x i8>, ptr %301, align 1
  %302 = getelementptr i8, ptr %result.i5.i992, i64 1
  store <16 x i8> %wide.load, ptr %302, align 1
  %303 = getelementptr i8, ptr %result.i5.i992, i64 17
  store i8 0, ptr %303, align 1
  %puts.i883 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i992) #52
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %304 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %304, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #59
  %305 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #59
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %306 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %306, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #59
  %307 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %293) #59
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #59
  br i1 %24, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader
  %308 = zext nneg i32 %0 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %309 = mul i64 %293, 1000000
  %310 = sdiv i64 %309, %308
  %311 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %311, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #59
  %312 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %310) #59
  %313 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #60
  %314 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %315 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %316 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #59
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  %result.i19 = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i19, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %317 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %318 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  store i8 32, ptr %result.i5.i, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i, i64 1
  %scevgep396 = getelementptr inbounds i8, ptr %result.i19, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(18) %scevgep, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(18) %scevgep396, i64 noundef 17, i1 noundef false)
  %.sroa.gep317 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep311 = getelementptr inbounds i8, ptr %8, i64 24
  %.sroa.gep = getelementptr inbounds i8, ptr %8, i64 8
  %319 = getelementptr inbounds i8, ptr %result.i5.i, i64 18
  store i8 0, ptr %319, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %result.i17 = call noalias nonnull dereferenceable(5) ptr @bump_malloc_wrapper(i64 noundef 5) #51
  br i1 %.reg2mem15.0.in, label %320, label %321

320:                                              ; preds = %print_benchmark_result.exit
  br label %321

321:                                              ; preds = %320, %print_benchmark_result.exit
  %322 = phi ptr [ %.sroa.gep32159, %320 ], [ %.sroa.gep320, %print_benchmark_result.exit ]
  %323 = phi ptr [ %.sroa.gep31555, %320 ], [ %.sroa.gep314, %print_benchmark_result.exit ]
  %324 = phi ptr [ %.sroa.gep31253, %320 ], [ %.sroa.gep311, %print_benchmark_result.exit ]
  %325 = phi ptr [ %.sroa.gep30649, %320 ], [ %.sroa.gep, %print_benchmark_result.exit ]
  %326 = phi ptr [ %6, %320 ], [ %10, %print_benchmark_result.exit ]
  %327 = phi i32 [ 1397965136, %320 ], [ 1279869254, %print_benchmark_result.exit ]
  %328 = phi ptr [ %5, %320 ], [ %9, %print_benchmark_result.exit ]
  %329 = phi ptr [ %.sroa.gep30951, %320 ], [ %.sroa.gep308, %print_benchmark_result.exit ]
  %330 = phi ptr [ %4, %320 ], [ %8, %print_benchmark_result.exit ]
  %331 = phi ptr [ %.sroa.gep31857, %320 ], [ %.sroa.gep317, %print_benchmark_result.exit ]
  %332 = phi ptr [ %3, %320 ], [ %7, %print_benchmark_result.exit ]
  store i32 %327, ptr %result.i17, align 1
  store ptr @_parameterization_Bufferi8, ptr %332, align 8
  store ptr @_parameterization_i32, ptr %323, align 8
  store ptr @_parameterization_i32, ptr %331, align 8
  store ptr @_parameterization_i32, ptr %322, align 8
  %333 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %332)
  store ptr @buffer_typ, ptr %330, align 8
  store ptr @i32_typ, ptr %325, align 8
  store ptr @i32_typ, ptr %329, align 8
  store ptr @i32_typ, ptr %324, align 8
  %334 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %330) #43
  store ptr @_parameterization_String, ptr %328, align 8
  %335 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %328)
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %326, align 8
  %337 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %326) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %338 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %339 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i333 = call noalias nonnull dereferenceable(5) ptr @bump_malloc_wrapper(i64 noundef 5) #51
  %340 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %341 = trunc i32 %327 to i8
  store i8 %341, ptr %result.i5.i333, align 1
  %scevgep398 = getelementptr inbounds i8, ptr %result.i5.i333, i64 1
  %scevgep399 = getelementptr inbounds i8, ptr %result.i17, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(4) %scevgep398, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(4) %scevgep399, i64 noundef 3, i1 noundef false)
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %343 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %344 = getelementptr inbounds i8, ptr %result.i5.i333, i64 4
  store i8 0, ptr %344, align 1
  %puts.i189 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i333) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #8

declare i64 @clock() local_unnamed_addr #17

define void @benchmark_insert_random(i32 %0) local_unnamed_addr #17 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %oldProtect.i59 = alloca i32, align 4
  %oldProtect.i57 = alloca i32, align 4
  %oldProtect.i55 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0393.sroa.0 = alloca i8, align 8
  %3 = alloca [4 x ptr], align 8
  %4 = alloca { ptr, ptr, ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %result.i53 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #51
  store ptr @_parameterization_i32, ptr %result.i53, align 8
  %11 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i53) #60
  %result.i52 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  %result.i54 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i52, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i52, ptr noalias nofree noundef nonnull readnone @iuwstrhywa, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i35 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i52) #50
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i52) #60
  %result.i51 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i55) #60
  %result.i56 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i51, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i55) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i55) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i51, ptr noalias nofree noundef nonnull readnone @cwxmmotuoi, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i34 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i51) #50
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i51) #60
  %16 = getelementptr inbounds i8, ptr %result.i53, i64 48
  store ptr %ret.i35, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i53, i64 56
  store ptr %ret.i34, ptr %17, align 8
  %result.i1.i134 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  %18 = getelementptr inbounds i8, ptr %result.i53, i64 24
  store ptr %result.i1.i134, ptr %18, align 8
  %result.i.i135 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %19 = getelementptr inbounds i8, ptr %result.i53, i64 32
  store ptr %result.i.i135, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i53, i64 40
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %22 = getelementptr inbounds i8, ptr %result.i53, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %20, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #43
  %24 = sext i32 %0 to i64
  %25 = shl nsw i64 %24, 2
  %result.i2.i163 = call noalias ptr @bump_malloc_wrapper(i64 noundef %25) #51
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  %result.i48 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #51
  store ptr @_parameterization_i32, ptr %result.i48, align 8
  %27 = getelementptr inbounds i8, ptr %result.i48, i64 8
  store ptr @_parameterization_Bool, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i48, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i48) #60
  %result.i47 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i57) #60
  %result.i58 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i47, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i57) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i57) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i47, ptr noalias nofree noundef nonnull readnone @divaxowbuf, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i33 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i47) #50
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i47) #60
  %result.i46 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i59) #60
  %result.i60 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i46, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i59) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i59) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i46, ptr noalias nofree noundef nonnull readnone @hdfhtpkgsg, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i46) #50
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i46) #60
  %32 = getelementptr inbounds i8, ptr %result.i48, i64 48
  store ptr %ret.i33, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i48, i64 56
  store ptr %ret.i, ptr %33, align 8
  %result.i1.i177 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  %34 = getelementptr inbounds i8, ptr %result.i48, i64 24
  store ptr %result.i1.i177, ptr %34, align 8
  %result.i.i178 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %35 = getelementptr inbounds i8, ptr %result.i48, i64 32
  store ptr %result.i.i178, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i48, i64 40
  %37 = getelementptr inbounds i8, ptr %result.i48, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %36, align 8
  %38 = icmp sgt i32 %0, 0
  br i1 %38, label %._crit_edge.lr.ph, label %._crit_edge2._crit_edge.thread

._crit_edge2._crit_edge.thread:                   ; preds = %1
  %.sroa.gep434461 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep440462 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep446463 = getelementptr inbounds i8, ptr %3, i64 16
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %41 = call i64 @clock()
  %.sroa.gep437125 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep443126 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep449127 = getelementptr inbounds i8, ptr %3, i64 24
  %42 = call i64 @clock()
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  br label %RangeIterator_next_.exit52.i.preheader

._crit_edge.lr.ph:                                ; preds = %1
  %45 = add nsw i32 %0, -1
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %47 = zext nneg i32 %45 to i64
  %48 = zext nneg i32 %0 to i64
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #46
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  br label %51

51:                                               ; preds = %SwissTable_insert_keyK_valueV.exit, %._crit_edge.lr.ph
  %52 = phi ptr [ %result.i.i178, %._crit_edge.lr.ph ], [ %159, %SwissTable_insert_keyK_valueV.exit ]
  %53 = phi ptr [ %result.i1.i177, %._crit_edge.lr.ph ], [ %160, %SwissTable_insert_keyK_valueV.exit ]
  %.lcssa1188 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %.lcssa1186, %SwissTable_insert_keyK_valueV.exit ]
  %54 = phi i32 [ 8, %._crit_edge.lr.ph ], [ %161, %SwissTable_insert_keyK_valueV.exit ]
  %55 = phi i32 [ 123, %._crit_edge.lr.ph ], [ %58, %SwissTable_insert_keyK_valueV.exit ]
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %SwissTable_insert_keyK_valueV.exit ]
  %.0116 = phi i32 [ -1, %._crit_edge.lr.ph ], [ %spec.select, %SwissTable_insert_keyK_valueV.exit ]
  %56 = mul i32 %55, 1103515245
  %57 = add i32 %56, 12345
  %58 = and i32 %57, 2147483647
  %.sroa.0403.0.insert.ext = zext nneg i32 %58 to i160
  %59 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0403.0.insert.ext, 1
  %60 = shl i64 %indvars.iv, 2
  %61 = getelementptr i8, ptr %result.i2.i163, i64 %60
  store i32 %58, ptr %61, align 1
  %62 = icmp eq i64 %indvars.iv, %47
  %spec.select = select i1 %62, i32 %58, i32 %.0116
  store i1 true, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. = load i8, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.0.insert.ext = zext i8 %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. to i160
  %63 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0393.0.insert.ext, 1
  %64 = add i32 %.lcssa1188, 1
  %65 = mul i32 %54, 7
  %66 = sdiv i32 %65, 10
  %.not.i = icmp slt i32 %64, %66
  br i1 %.not.i, label %SwissTable_ensure_capacity_required_sizei32.exit, label %._crit_edge1.i

._crit_edge1.i:                                   ; preds = %51
  %67 = shl i32 %54, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %67, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %68 = zext nneg i32 %spec.select.i to i64
  %69 = shl nuw nsw i64 %68, 5
  %result.i10.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %69) #51
  %result.i9.i794 = call noalias ptr @bump_malloc_wrapper(i64 noundef %68) #51
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %71 = add i32 %54, -1
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %76 = icmp slt i32 %71, 0
  br i1 %76, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i.preheader

.lr.ph.i.preheader:                               ; preds = %._crit_edge1.i
  %77 = load ptr, ptr %32, align 8
  %78 = add nsw i32 %spec.select.i, -1
  %79 = load ptr, ptr %33, align 8
  br label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge2.backedge.i, %.lr.ph.i.preheader
  %80 = phi i32 [ %154, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %storemerge.i = phi i32 [ %158, %._crit_edge2.backedge.i ], [ 1, %.lr.ph.i.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i = phi i32 [ %storemerge.i, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %.sroa.0.8.extract.trunc.i = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i to i64
  %sext.i = shl nuw i64 %.sroa.0.8.extract.trunc.i, 32
  %81 = ashr exact i64 %sext.i, 27
  %82 = getelementptr i8, ptr %53, i64 %81
  %83 = load ptr, ptr %82, align 8
  %84 = icmp ne ptr %83, @nil_typ
  %85 = icmp ne ptr %83, null
  %.not158.i = and i1 %84, %85
  br i1 %.not158.i, label %86, label %._crit_edge2.backedge.i

86:                                               ; preds = %.lr.ph.i
  %87 = getelementptr i8, ptr %82, i64 8
  %88 = load i160, ptr %87, align 4
  %.sroa.3.0.extract.shift.i = lshr i160 %88, 64
  %.sroa.3.0.extract.trunc.i = trunc i160 %.sroa.3.0.extract.shift.i to i64
  %.sroa.0146.0.extract.trunc.i = trunc i160 %88 to i64
  %89 = inttoptr i64 %.sroa.0146.0.extract.trunc.i to ptr
  %90 = inttoptr i64 %.sroa.3.0.extract.trunc.i to ptr
  %hash_coef_ptr.i23.i = getelementptr i8, ptr %83, i64 8
  %tbl_size_ptr.i24.i = getelementptr i8, ptr %83, i64 16
  %offset_tbl_ptr.i25.i = getelementptr i8, ptr %83, i64 40
  %hash_coef.i26.i = load i64, ptr %hash_coef_ptr.i23.i, align 4
  %tbl_size.i27.i = load i64, ptr %tbl_size_ptr.i24.i, align 4
  %offset_tbl.i28.i = load ptr, ptr %offset_tbl_ptr.i25.i, align 8
  %product.i.i29.i = mul i64 %hash_coef.i26.i, 4015701072841558310
  %shifted.i.i30.i = lshr i64 %product.i.i29.i, 32
  %xored.i.i31.i = xor i64 %shifted.i.i30.i, %product.i.i29.i
  %hash.i.i32.i = and i64 %xored.i.i31.i, %tbl_size.i27.i
  %offset_ptr.i33.i = getelementptr i32, ptr %offset_tbl.i28.i, i64 %hash.i.i32.i
  %offset.i34.i = load i32, ptr %offset_ptr.i33.i, align 4
  %91 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %92 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %89, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %90, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 %offset.i34.i, 3
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %83)
  %97 = sext i32 %offset.i34.i to i64
  %98 = getelementptr ptr, ptr %83, i64 %97
  %99 = getelementptr i8, ptr %98, i64 48
  %100 = load ptr, ptr %99, align 8
  %result.i4.i = call ptr %100({ ptr, ptr, ptr, i32 } %94, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %101 = call { ptr, i160 } %result.i4.i({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull align 8 %2)
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %103 = call i32 %77({ ptr, i160 } %101)
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %83)
  %106 = load ptr, ptr %99, align 8
  %result.i3.i = call ptr %106({ ptr, ptr, ptr, i32 } %94, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %107 = call { ptr, i160 } %result.i3.i({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %108

108:                                              ; preds = %146, %86
  %.pn = phi i32 [ %103, %86 ], [ %147, %146 ]
  %.01062 = phi i32 [ -1, %86 ], [ %.11063, %146 ]
  %.0..0..0..0..0..0.84.i990 = phi i32 [ -1, %86 ], [ %spec.store.select9216.i993, %146 ]
  %.01064 = and i32 %.pn, %78
  %109 = zext nneg i32 %.01064 to i64
  %110 = getelementptr i8, ptr %result.i9.i794, i64 %109
  %111 = load i8, ptr %110, align 1
  switch i8 %111, label %._crit_edge.i996 [
    i8 0, label %148
    i8 -128, label %._crit_edge.thread.i991
  ]

._crit_edge.thread.i991:                          ; preds = %108
  %112 = icmp eq i32 %.0..0..0..0..0..0.84.i990, -1
  %spec.store.select.i992 = select i1 %112, i32 %.01064, i32 %.0..0..0..0..0..0.84.i990
  br label %146

._crit_edge.i996:                                 ; preds = %108
  %113 = icmp sgt i8 %111, 0
  br i1 %113, label %114, label %146

114:                                              ; preds = %._crit_edge.i996
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %116 = shl nuw nsw i64 %109, 5
  %117 = getelementptr i8, ptr %result.i10.i, i64 %116
  %118 = load ptr, ptr %117, align 8
  %119 = icmp ne ptr %118, @nil_typ
  %120 = icmp ne ptr %118, null
  %.not82.i997 = and i1 %119, %120
  br i1 %.not82.i997, label %121, label %146

121:                                              ; preds = %114
  %122 = getelementptr i8, ptr %117, i64 8
  %123 = load i64, ptr %122, align 4
  %.sroa_idx.i998 = getelementptr i8, ptr %117, i64 16
  %124 = load i64, ptr %.sroa_idx.i998, align 4
  %125 = inttoptr i64 %123 to ptr
  %126 = inttoptr i64 %124 to ptr
  %hash_coef_ptr.i3.i999 = getelementptr i8, ptr %118, i64 8
  %tbl_size_ptr.i4.i1000 = getelementptr i8, ptr %118, i64 16
  %offset_tbl_ptr.i5.i1001 = getelementptr i8, ptr %118, i64 40
  %hash_coef.i6.i1002 = load i64, ptr %hash_coef_ptr.i3.i999, align 4
  %tbl_size.i7.i1003 = load i64, ptr %tbl_size_ptr.i4.i1000, align 4
  %offset_tbl.i8.i1004 = load ptr, ptr %offset_tbl_ptr.i5.i1001, align 8
  %product.i.i9.i1005 = mul i64 %hash_coef.i6.i1002, 4015701072841558310
  %shifted.i.i10.i1006 = lshr i64 %product.i.i9.i1005, 32
  %xored.i.i11.i1007 = xor i64 %shifted.i.i10.i1006, %product.i.i9.i1005
  %hash.i.i12.i1008 = and i64 %xored.i.i11.i1007, %tbl_size.i7.i1003
  %offset_ptr.i13.i1009 = getelementptr i32, ptr %offset_tbl.i8.i1004, i64 %hash.i.i12.i1008
  %offset.i14.i1010 = load i32, ptr %offset_ptr.i13.i1009, align 4
  %127 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %118, 0
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, ptr %125, 1
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %126, 2
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 %offset.i14.i1010, 3
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %118)
  %133 = sext i32 %offset.i14.i1010 to i64
  %134 = getelementptr ptr, ptr %118, i64 %133
  %135 = getelementptr i8, ptr %134, i64 40
  %136 = load ptr, ptr %135, align 8
  %result.i1.i1011 = call ptr %136({ ptr, ptr, ptr, i32 } %130, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %137 = call i32 %result.i1.i1011({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull align 8 %2)
  %138 = icmp eq i32 %137, %103
  br i1 %138, label %._crit_edge2.i1012, label %146

._crit_edge2.i1012:                               ; preds = %121
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %118)
  %141 = getelementptr i8, ptr %134, i64 48
  %142 = load ptr, ptr %141, align 8
  %result.i.i = call ptr %142({ ptr, ptr, ptr, i32 } %130, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %143 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull align 8 %2)
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %145 = call i1 %79({ ptr, i160 } %143, { ptr, i160 } %107)
  br i1 %145, label %SwissTable_find_slot_keyK_hashi32.exit1013, label %146

146:                                              ; preds = %._crit_edge2.i1012, %121, %114, %._crit_edge.i996, %._crit_edge.thread.i991
  %.11063 = phi i32 [ %.01062, %._crit_edge2.i1012 ], [ %.01062, %121 ], [ %.01062, %114 ], [ %.01062, %._crit_edge.i996 ], [ %spec.store.select.i992, %._crit_edge.thread.i991 ]
  %spec.store.select9216.i993 = phi i32 [ %.0..0..0..0..0..0.84.i990, %._crit_edge2.i1012 ], [ %.0..0..0..0..0..0.84.i990, %121 ], [ %.0..0..0..0..0..0.84.i990, %114 ], [ %.0..0..0..0..0..0.84.i990, %._crit_edge.i996 ], [ %spec.store.select.i992, %._crit_edge.thread.i991 ]
  %147 = add nuw nsw i32 %.01064, 1
  br label %108

148:                                              ; preds = %108
  %.not.i994 = icmp eq i32 %.0..0..0..0..0..0.84.i990, -1
  %.pre.i995 = select i1 %.not.i994, i32 %.01064, i32 %.01062
  %.pre1122 = sext i32 %.pre.i995 to i64
  %.pre1124 = shl nsw i64 %.pre1122, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1013

SwissTable_find_slot_keyK_hashi32.exit1013:       ; preds = %148, %._crit_edge2.i1012
  %.pre-phi1125 = phi i64 [ %.pre1124, %148 ], [ %116, %._crit_edge2.i1012 ]
  %.pre-phi1123 = phi i64 [ %.pre1122, %148 ], [ %109, %._crit_edge2.i1012 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %149 = getelementptr i8, ptr %result.i10.i, i64 %.pre-phi1125
  store ptr %83, ptr %149, align 8
  %150 = getelementptr i8, ptr %149, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i, ptr %150, align 4
  %.sroa_idx120.i = getelementptr i8, ptr %149, i64 16
  store i64 %.sroa.3.0.extract.trunc.i, ptr %.sroa_idx120.i, align 4
  %.sroa_idx121.i = getelementptr i8, ptr %149, i64 24
  store i32 %offset.i34.i, ptr %.sroa_idx121.i, align 4
  %151 = getelementptr i8, ptr %result.i9.i794, i64 %.pre-phi1123
  store i8 1, ptr %151, align 1
  %152 = add i32 %80, 1
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i

._crit_edge2.backedge.i:                          ; preds = %SwissTable_find_slot_keyK_hashi32.exit1013, %.lr.ph.i
  %154 = phi i32 [ %152, %SwissTable_find_slot_keyK_hashi32.exit1013 ], [ %80, %.lr.ph.i ]
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %157 = icmp sgt i32 %storemerge.i, %71
  %158 = add i32 %storemerge.i, 1
  br i1 %157, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i

SwissTable_resize_new_capacityi32.exit:           ; preds = %._crit_edge2.backedge.i, %._crit_edge1.i
  %.lcssa1189 = phi i32 [ 0, %._crit_edge1.i ], [ %154, %._crit_edge2.backedge.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %SwissTable_ensure_capacity_required_sizei32.exit

SwissTable_ensure_capacity_required_sizei32.exit: ; preds = %SwissTable_resize_new_capacityi32.exit, %51
  %159 = phi ptr [ %52, %51 ], [ %result.i9.i794, %SwissTable_resize_new_capacityi32.exit ]
  %160 = phi ptr [ %53, %51 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %.lcssa1187 = phi i32 [ %.lcssa1188, %51 ], [ %.lcssa1189, %SwissTable_resize_new_capacityi32.exit ]
  %161 = phi i32 [ %54, %51 ], [ %spec.select.i, %SwissTable_resize_new_capacityi32.exit ]
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %163 = load ptr, ptr %32, align 8
  %164 = call i32 %163({ ptr, i160 } %59)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %165 = add i32 %161, -1
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %167 = load ptr, ptr %33, align 8
  br label %168

168:                                              ; preds = %206, %SwissTable_ensure_capacity_required_sizei32.exit
  %.0633 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %.1634, %206 ]
  %.pn1421 = phi i32 [ %164, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %207, %206 ]
  %.0..0..0..0..0..0.84.i = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %spec.store.select9216.i, %206 ]
  %.0632 = and i32 %.pn1421, %165
  %169 = sext i32 %.0632 to i64
  %170 = getelementptr i8, ptr %159, i64 %169
  %171 = load i8, ptr %170, align 1
  switch i8 %171, label %._crit_edge.i [
    i8 0, label %208
    i8 -128, label %._crit_edge.thread.i
  ]

._crit_edge.thread.i:                             ; preds = %168
  %172 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %spec.store.select.i = select i1 %172, i32 %.0632, i32 %.0..0..0..0..0..0.84.i
  br label %206

._crit_edge.i:                                    ; preds = %168
  %173 = icmp sgt i8 %171, 0
  br i1 %173, label %174, label %206

174:                                              ; preds = %._crit_edge.i
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %176 = shl nsw i64 %169, 5
  %177 = getelementptr i8, ptr %160, i64 %176
  %178 = load ptr, ptr %177, align 8
  %179 = icmp ne ptr %178, @nil_typ
  %180 = icmp ne ptr %178, null
  %.not82.i = and i1 %179, %180
  br i1 %.not82.i, label %181, label %206

181:                                              ; preds = %174
  %182 = getelementptr i8, ptr %177, i64 8
  %183 = load i64, ptr %182, align 4
  %.sroa_idx.i = getelementptr i8, ptr %177, i64 16
  %184 = load i64, ptr %.sroa_idx.i, align 4
  %185 = inttoptr i64 %183 to ptr
  %186 = inttoptr i64 %184 to ptr
  %hash_coef_ptr.i3.i498 = getelementptr i8, ptr %178, i64 8
  %tbl_size_ptr.i4.i499 = getelementptr i8, ptr %178, i64 16
  %offset_tbl_ptr.i5.i500 = getelementptr i8, ptr %178, i64 40
  %hash_coef.i6.i501 = load i64, ptr %hash_coef_ptr.i3.i498, align 4
  %tbl_size.i7.i502 = load i64, ptr %tbl_size_ptr.i4.i499, align 4
  %offset_tbl.i8.i503 = load ptr, ptr %offset_tbl_ptr.i5.i500, align 8
  %product.i.i9.i504 = mul i64 %hash_coef.i6.i501, 4015701072841558310
  %shifted.i.i10.i505 = lshr i64 %product.i.i9.i504, 32
  %xored.i.i11.i506 = xor i64 %shifted.i.i10.i505, %product.i.i9.i504
  %hash.i.i12.i507 = and i64 %xored.i.i11.i506, %tbl_size.i7.i502
  %offset_ptr.i13.i508 = getelementptr i32, ptr %offset_tbl.i8.i503, i64 %hash.i.i12.i507
  %offset.i14.i509 = load i32, ptr %offset_ptr.i13.i508, align 4
  %187 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %178, 0
  %188 = insertvalue { ptr, ptr, ptr, i32 } %187, ptr %185, 1
  %189 = insertvalue { ptr, ptr, ptr, i32 } %188, ptr %186, 2
  %190 = insertvalue { ptr, ptr, ptr, i32 } %189, i32 %offset.i14.i509, 3
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %178)
  %193 = sext i32 %offset.i14.i509 to i64
  %194 = getelementptr ptr, ptr %178, i64 %193
  %195 = getelementptr i8, ptr %194, i64 40
  %196 = load ptr, ptr %195, align 8
  %result.i1.i = call ptr %196({ ptr, ptr, ptr, i32 } %190, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %197 = call i32 %result.i1.i({ ptr, ptr, ptr, i32 } %190, { ptr, ptr, ptr, i32 } %190, ptr nonnull align 8 %2)
  %198 = icmp eq i32 %197, %164
  br i1 %198, label %._crit_edge2.i, label %206

._crit_edge2.i:                                   ; preds = %181
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %178)
  %201 = getelementptr i8, ptr %194, i64 48
  %202 = load ptr, ptr %201, align 8
  %result.i.i510 = call ptr %202({ ptr, ptr, ptr, i32 } %190, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %203 = call { ptr, i160 } %result.i.i510({ ptr, ptr, ptr, i32 } %190, { ptr, ptr, ptr, i32 } %190, ptr nonnull align 8 %2)
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %205 = call i1 %167({ ptr, i160 } %203, { ptr, i160 } %59)
  br i1 %205, label %SwissTable_find_slot_keyK_hashi32.exit, label %206

206:                                              ; preds = %._crit_edge2.i, %181, %174, %._crit_edge.i, %._crit_edge.thread.i
  %.1634 = phi i32 [ %.0633, %._crit_edge2.i ], [ %.0633, %181 ], [ %.0633, %174 ], [ %.0633, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %spec.store.select9216.i = phi i32 [ %.0..0..0..0..0..0.84.i, %._crit_edge2.i ], [ %.0..0..0..0..0..0.84.i, %181 ], [ %.0..0..0..0..0..0.84.i, %174 ], [ %.0..0..0..0..0..0.84.i, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %207 = add i32 %.0632, 1
  br label %168

208:                                              ; preds = %168
  %.not.i497 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %.pre.i = select i1 %.not.i497, i32 %.0632, i32 %.0633
  %.pre = sext i32 %.pre.i to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit

SwissTable_find_slot_keyK_hashi32.exit:           ; preds = %208, %._crit_edge2.i
  %.pre-phi = phi i64 [ %.pre, %208 ], [ %169, %._crit_edge2.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %210 = getelementptr i8, ptr %159, i64 %.pre-phi
  %211 = load i8, ptr %210, align 1
  %212 = load ptr, ptr %result.i48, align 8
  %213 = load ptr, ptr %27, align 8
  %214 = load ptr, ptr %212, align 8, !alias.scope !2
  %215 = getelementptr i8, ptr %214, i64 72
  %216 = load ptr, ptr %215, align 8, !alias.scope !2
  %result.i1.i.i = call { i64, i64 } %216(ptr nocapture nofree nonnull readonly align 8 %212) #47, !alias.scope !2
  %217 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %218 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %219 = urem i64 20, %218
  %220 = icmp eq i64 %219, 0
  %221 = sub i64 %218, %219
  %222 = select i1 %220, i64 0, i64 %221
  %223 = add i64 %217, 20
  %224 = add i64 %223, %222
  %225 = load ptr, ptr %213, align 8, !alias.scope !2
  %226 = getelementptr i8, ptr %225, i64 72
  %227 = load ptr, ptr %226, align 8, !alias.scope !2
  %result.i.i.i = call { i64, i64 } %227(ptr nocapture nofree nonnull readonly align 8 %213) #47, !alias.scope !2
  %228 = extractvalue { i64, i64 } %result.i.i.i, 0
  %229 = extractvalue { i64, i64 } %result.i.i.i, 1
  %230 = call i64 @llvm.umax.i64(i64 %218, i64 %229) #61
  %231 = call i64 @llvm.umax.i64(i64 %230, i64 noundef 8) #61, !range !5
  %232 = urem i64 %224, %229
  %233 = icmp eq i64 %232, 0
  %234 = sub i64 %229, %232
  %235 = select i1 %233, i64 0, i64 %234
  %236 = add i64 %228, %224
  %237 = add i64 %236, %235
  %238 = urem i64 %237, %231
  %239 = icmp eq i64 %238, 0
  %240 = sub i64 %231, %238
  %241 = select i1 %239, i64 0, i64 %240
  %242 = add i64 %241, %237
  %result.i9.i = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %242) #51
  store ptr %212, ptr %result.i9.i, align 8
  %243 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr %213, ptr %243, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i)
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %246 = load ptr, ptr %212, align 8
  %247 = getelementptr i8, ptr %246, i64 72
  %248 = load ptr, ptr %247, align 8
  %result.i.i10.i = call { i64, i64 } %248(ptr nocapture nofree nonnull readonly align 8 %212) #47
  %249 = extractvalue { i64, i64 } %result.i.i10.i, 1
  %250 = urem i64 20, %249
  %251 = icmp eq i64 %250, 0
  %reass.sub1935 = sub i64 %249, %250
  %252 = add i64 %reass.sub1935, 20
  %253 = select i1 %251, i64 20, i64 %252
  %254 = getelementptr i8, ptr %result.i9.i, i64 %253
  %255 = getelementptr i8, ptr %246, i64 64
  %256 = load ptr, ptr %255, align 8
  call void %256({ ptr, i160 } %59, ptr nocapture nofree nonnull readonly align 8 %212, ptr nocapture nofree writeonly %254) #48
  %257 = load ptr, ptr %result.i9.i, align 8
  %258 = load ptr, ptr %257, align 8
  %259 = getelementptr i8, ptr %258, i64 72
  %260 = load ptr, ptr %259, align 8
  %result.i1.i11.i = call { i64, i64 } %260(ptr nocapture nofree nonnull readonly align 8 %257) #47
  %261 = extractvalue { i64, i64 } %result.i1.i11.i, 0
  %262 = extractvalue { i64, i64 } %result.i1.i11.i, 1
  %263 = urem i64 20, %262
  %264 = icmp eq i64 %263, 0
  %265 = sub i64 %262, %263
  %266 = select i1 %264, i64 0, i64 %265
  %267 = add i64 %261, 20
  %268 = add i64 %267, %266
  %269 = load ptr, ptr %243, align 8
  %270 = load ptr, ptr %269, align 8
  %271 = getelementptr i8, ptr %270, i64 72
  %272 = load ptr, ptr %271, align 8
  %result.i.i12.i = call { i64, i64 } %272(ptr nocapture nofree nonnull readonly align 8 %269) #47
  %273 = extractvalue { i64, i64 } %result.i.i12.i, 1
  %274 = urem i64 %268, %273
  %275 = icmp eq i64 %274, 0
  %276 = sub i64 %273, %274
  %277 = select i1 %275, i64 0, i64 %276
  %278 = getelementptr i8, ptr %result.i9.i, i64 %268
  %279 = getelementptr i8, ptr %278, i64 %277
  %280 = getelementptr i8, ptr %270, i64 64
  %281 = load ptr, ptr %280, align 8
  call void %281({ ptr, i160 } %63, ptr nocapture nofree nonnull readonly align 8 %269, ptr nocapture nofree writeonly %279) #48
  %282 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %283 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %164, ptr %283, align 8
  %284 = icmp eq i8 %211, 0
  br i1 %284, label %285, label %SwissTable_insert_keyK_valueV.exit

285:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit
  store i8 1, ptr %210, align 1
  %286 = add i32 %.lcssa1187, 1
  br label %SwissTable_insert_keyK_valueV.exit

SwissTable_insert_keyK_valueV.exit:               ; preds = %285, %SwissTable_find_slot_keyK_hashi32.exit
  %.lcssa1186 = phi i32 [ %.lcssa1187, %SwissTable_find_slot_keyK_hashi32.exit ], [ %286, %285 ]
  %287 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %288 = shl nsw i64 %.pre-phi, 5
  %289 = getelementptr i8, ptr %160, i64 %288
  store ptr @Entry, ptr %289, align 8
  %290 = getelementptr i8, ptr %289, i64 8
  %291 = ptrtoint ptr %result.i9.i to i64
  store i64 %291, ptr %290, align 4
  %.sroa_idx3.i = getelementptr i8, ptr %289, i64 24
  store i32 10, ptr %.sroa_idx3.i, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %48
  br i1 %exitcond.not, label %._crit_edge2._crit_edge, label %51

._crit_edge2._crit_edge:                          ; preds = %SwissTable_insert_keyK_valueV.exit
  store i32 %161, ptr %36, align 8
  store i32 %.lcssa1186, ptr %37, align 4
  store ptr %160, ptr %34, align 8
  store ptr %159, ptr %35, align 8
  %292 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %294 = call i64 @clock()
  %295 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %.promoted1195 = load i32, ptr %20, align 8
  %.promoted1197 = load i32, ptr %22, align 4
  %.promoted1202 = load ptr, ptr %18, align 8
  %.promoted1204 = load ptr, ptr %19, align 8
  %296 = load ptr, ptr %16, align 8
  %297 = load ptr, ptr %result.i53, align 8
  %298 = load ptr, ptr %11, align 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %SwissTable_insert_keyK_valueV.exit282, %._crit_edge2._crit_edge
  %299 = phi ptr [ %.promoted1204, %._crit_edge2._crit_edge ], [ %.pre775, %SwissTable_insert_keyK_valueV.exit282 ]
  %300 = phi ptr [ %.promoted1202, %._crit_edge2._crit_edge ], [ %405, %SwissTable_insert_keyK_valueV.exit282 ]
  %.lcssa11941200 = phi i32 [ %.promoted1197, %._crit_edge2._crit_edge ], [ %529, %SwissTable_insert_keyK_valueV.exit282 ]
  %301 = phi i32 [ %.promoted1195, %._crit_edge2._crit_edge ], [ %406, %SwissTable_insert_keyK_valueV.exit282 ]
  %indvars.iv397 = phi i64 [ 0, %._crit_edge2._crit_edge ], [ %indvars.iv.next398, %SwissTable_insert_keyK_valueV.exit282 ]
  %302 = shl i64 %indvars.iv397, 2
  %303 = getelementptr i8, ptr %result.i2.i163, i64 %302
  %304 = load i32, ptr %303, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %304 to i160
  %305 = add i32 %304, 1
  %306 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %.sroa.0373.0.insert.ext = zext i32 %305 to i160
  %307 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0373.0.insert.ext, 1
  %308 = icmp eq i32 %301, 0
  br i1 %308, label %._crit_edge1.i526, label %309

309:                                              ; preds = %._crit_edge3
  %310 = add i32 %.lcssa11941200, 1
  %311 = mul i32 %301, 7
  %312 = sdiv i32 %311, 10
  %.not.i525 = icmp slt i32 %310, %312
  br i1 %.not.i525, label %SwissTable_ensure_capacity_required_sizei32.exit530, label %._crit_edge1.i526

._crit_edge1.i526:                                ; preds = %309, %._crit_edge3
  %313 = shl i32 %301, 1
  %spec.select.i527 = call i32 @llvm.smax.i32(i32 %313, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %314 = zext nneg i32 %spec.select.i527 to i64
  %315 = shl nuw nsw i64 %314, 5
  %result.i10.i810 = call noalias ptr @bump_malloc_wrapper(i64 noundef %315) #51
  %result.i9.i811 = call noalias ptr @bump_malloc_wrapper(i64 noundef %314) #51
  %316 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %317 = add i32 %301, -1
  %318 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %319 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %320 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %321 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %322 = icmp slt i32 %317, 0
  br i1 %322, label %SwissTable_resize_new_capacityi32.exit848, label %.lr.ph.i813.preheader

.lr.ph.i813.preheader:                            ; preds = %._crit_edge1.i526
  %323 = load ptr, ptr %16, align 8
  %324 = add nsw i32 %spec.select.i527, -1
  %325 = load ptr, ptr %17, align 8
  br label %.lr.ph.i813

.lr.ph.i813:                                      ; preds = %._crit_edge2.backedge.i819, %.lr.ph.i813.preheader
  %326 = phi i32 [ %400, %._crit_edge2.backedge.i819 ], [ 0, %.lr.ph.i813.preheader ]
  %storemerge.i814 = phi i32 [ %404, %._crit_edge2.backedge.i819 ], [ 1, %.lr.ph.i813.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i815 = phi i32 [ %storemerge.i814, %._crit_edge2.backedge.i819 ], [ 0, %.lr.ph.i813.preheader ]
  %.sroa.0.8.extract.trunc.i816 = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i815 to i64
  %sext.i817 = shl nuw i64 %.sroa.0.8.extract.trunc.i816, 32
  %327 = ashr exact i64 %sext.i817, 27
  %328 = getelementptr i8, ptr %300, i64 %327
  %329 = load ptr, ptr %328, align 8
  %330 = icmp ne ptr %329, @nil_typ
  %331 = icmp ne ptr %329, null
  %.not158.i818 = and i1 %330, %331
  br i1 %.not158.i818, label %332, label %._crit_edge2.backedge.i819

332:                                              ; preds = %.lr.ph.i813
  %333 = getelementptr i8, ptr %328, i64 8
  %334 = load i160, ptr %333, align 4
  %.sroa.3.0.extract.shift.i821 = lshr i160 %334, 64
  %.sroa.3.0.extract.trunc.i822 = trunc i160 %.sroa.3.0.extract.shift.i821 to i64
  %.sroa.0146.0.extract.trunc.i823 = trunc i160 %334 to i64
  %335 = inttoptr i64 %.sroa.0146.0.extract.trunc.i823 to ptr
  %336 = inttoptr i64 %.sroa.3.0.extract.trunc.i822 to ptr
  %hash_coef_ptr.i23.i824 = getelementptr i8, ptr %329, i64 8
  %tbl_size_ptr.i24.i825 = getelementptr i8, ptr %329, i64 16
  %offset_tbl_ptr.i25.i826 = getelementptr i8, ptr %329, i64 40
  %hash_coef.i26.i827 = load i64, ptr %hash_coef_ptr.i23.i824, align 4
  %tbl_size.i27.i828 = load i64, ptr %tbl_size_ptr.i24.i825, align 4
  %offset_tbl.i28.i829 = load ptr, ptr %offset_tbl_ptr.i25.i826, align 8
  %product.i.i29.i830 = mul i64 %hash_coef.i26.i827, 4015701072841558310
  %shifted.i.i30.i831 = lshr i64 %product.i.i29.i830, 32
  %xored.i.i31.i832 = xor i64 %shifted.i.i30.i831, %product.i.i29.i830
  %hash.i.i32.i833 = and i64 %xored.i.i31.i832, %tbl_size.i27.i828
  %offset_ptr.i33.i834 = getelementptr i32, ptr %offset_tbl.i28.i829, i64 %hash.i.i32.i833
  %offset.i34.i835 = load i32, ptr %offset_ptr.i33.i834, align 4
  %337 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %329, 0
  %338 = insertvalue { ptr, ptr, ptr, i32 } %337, ptr %335, 1
  %339 = insertvalue { ptr, ptr, ptr, i32 } %338, ptr %336, 2
  %340 = insertvalue { ptr, ptr, ptr, i32 } %339, i32 %offset.i34.i835, 3
  %341 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %329)
  %343 = sext i32 %offset.i34.i835 to i64
  %344 = getelementptr ptr, ptr %329, i64 %343
  %345 = getelementptr i8, ptr %344, i64 48
  %346 = load ptr, ptr %345, align 8
  %result.i4.i836 = call ptr %346({ ptr, ptr, ptr, i32 } %340, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %347 = call { ptr, i160 } %result.i4.i836({ ptr, ptr, ptr, i32 } %340, { ptr, ptr, ptr, i32 } %340, ptr nonnull align 8 %2)
  %348 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %349 = call i32 %323({ ptr, i160 } %347)
  %350 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %351 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %329)
  %352 = load ptr, ptr %345, align 8
  %result.i3.i838 = call ptr %352({ ptr, ptr, ptr, i32 } %340, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %353 = call { ptr, i160 } %result.i3.i838({ ptr, ptr, ptr, i32 } %340, { ptr, ptr, ptr, i32 } %340, ptr nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %354

354:                                              ; preds = %392, %332
  %.pn1423 = phi i32 [ %349, %332 ], [ %393, %392 ]
  %.01065 = phi i32 [ -1, %332 ], [ %.11066, %392 ]
  %.0..0..0..0..0..0.84.i1029 = phi i32 [ -1, %332 ], [ %spec.store.select9216.i1033, %392 ]
  %.01067 = and i32 %.pn1423, %324
  %355 = zext nneg i32 %.01067 to i64
  %356 = getelementptr i8, ptr %result.i9.i811, i64 %355
  %357 = load i8, ptr %356, align 1
  switch i8 %357, label %._crit_edge.i1038 [
    i8 0, label %394
    i8 -128, label %._crit_edge.thread.i1031
  ]

._crit_edge.thread.i1031:                         ; preds = %354
  %358 = icmp eq i32 %.0..0..0..0..0..0.84.i1029, -1
  %spec.store.select.i1032 = select i1 %358, i32 %.01067, i32 %.0..0..0..0..0..0.84.i1029
  br label %392

._crit_edge.i1038:                                ; preds = %354
  %359 = icmp sgt i8 %357, 0
  br i1 %359, label %360, label %392

360:                                              ; preds = %._crit_edge.i1038
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %362 = shl nuw nsw i64 %355, 5
  %363 = getelementptr i8, ptr %result.i10.i810, i64 %362
  %364 = load ptr, ptr %363, align 8
  %365 = icmp ne ptr %364, @nil_typ
  %366 = icmp ne ptr %364, null
  %.not82.i1040 = and i1 %365, %366
  br i1 %.not82.i1040, label %367, label %392

367:                                              ; preds = %360
  %368 = getelementptr i8, ptr %363, i64 8
  %369 = load i64, ptr %368, align 4
  %.sroa_idx.i1041 = getelementptr i8, ptr %363, i64 16
  %370 = load i64, ptr %.sroa_idx.i1041, align 4
  %371 = inttoptr i64 %369 to ptr
  %372 = inttoptr i64 %370 to ptr
  %hash_coef_ptr.i3.i1042 = getelementptr i8, ptr %364, i64 8
  %tbl_size_ptr.i4.i1043 = getelementptr i8, ptr %364, i64 16
  %offset_tbl_ptr.i5.i1044 = getelementptr i8, ptr %364, i64 40
  %hash_coef.i6.i1045 = load i64, ptr %hash_coef_ptr.i3.i1042, align 4
  %tbl_size.i7.i1046 = load i64, ptr %tbl_size_ptr.i4.i1043, align 4
  %offset_tbl.i8.i1047 = load ptr, ptr %offset_tbl_ptr.i5.i1044, align 8
  %product.i.i9.i1048 = mul i64 %hash_coef.i6.i1045, 4015701072841558310
  %shifted.i.i10.i1049 = lshr i64 %product.i.i9.i1048, 32
  %xored.i.i11.i1050 = xor i64 %shifted.i.i10.i1049, %product.i.i9.i1048
  %hash.i.i12.i1051 = and i64 %xored.i.i11.i1050, %tbl_size.i7.i1046
  %offset_ptr.i13.i1052 = getelementptr i32, ptr %offset_tbl.i8.i1047, i64 %hash.i.i12.i1051
  %offset.i14.i1053 = load i32, ptr %offset_ptr.i13.i1052, align 4
  %373 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %364, 0
  %374 = insertvalue { ptr, ptr, ptr, i32 } %373, ptr %371, 1
  %375 = insertvalue { ptr, ptr, ptr, i32 } %374, ptr %372, 2
  %376 = insertvalue { ptr, ptr, ptr, i32 } %375, i32 %offset.i14.i1053, 3
  %377 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %378 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %364)
  %379 = sext i32 %offset.i14.i1053 to i64
  %380 = getelementptr ptr, ptr %364, i64 %379
  %381 = getelementptr i8, ptr %380, i64 40
  %382 = load ptr, ptr %381, align 8
  %result.i1.i1054 = call ptr %382({ ptr, ptr, ptr, i32 } %376, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %383 = call i32 %result.i1.i1054({ ptr, ptr, ptr, i32 } %376, { ptr, ptr, ptr, i32 } %376, ptr nonnull align 8 %2)
  %384 = icmp eq i32 %383, %349
  br i1 %384, label %._crit_edge2.i1055, label %392

._crit_edge2.i1055:                               ; preds = %367
  %385 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %386 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %364)
  %387 = getelementptr i8, ptr %380, i64 48
  %388 = load ptr, ptr %387, align 8
  %result.i.i1056 = call ptr %388({ ptr, ptr, ptr, i32 } %376, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %389 = call { ptr, i160 } %result.i.i1056({ ptr, ptr, ptr, i32 } %376, { ptr, ptr, ptr, i32 } %376, ptr nonnull align 8 %2)
  %390 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %391 = call i1 %325({ ptr, i160 } %389, { ptr, i160 } %353)
  br i1 %391, label %SwissTable_find_slot_keyK_hashi32.exit1058, label %392

392:                                              ; preds = %._crit_edge2.i1055, %367, %360, %._crit_edge.i1038, %._crit_edge.thread.i1031
  %.11066 = phi i32 [ %.01065, %._crit_edge2.i1055 ], [ %.01065, %367 ], [ %.01065, %360 ], [ %.01065, %._crit_edge.i1038 ], [ %spec.store.select.i1032, %._crit_edge.thread.i1031 ]
  %spec.store.select9216.i1033 = phi i32 [ %.0..0..0..0..0..0.84.i1029, %._crit_edge2.i1055 ], [ %.0..0..0..0..0..0.84.i1029, %367 ], [ %.0..0..0..0..0..0.84.i1029, %360 ], [ %.0..0..0..0..0..0.84.i1029, %._crit_edge.i1038 ], [ %spec.store.select.i1032, %._crit_edge.thread.i1031 ]
  %393 = add nuw nsw i32 %.01067, 1
  br label %354

394:                                              ; preds = %354
  %.not.i1034 = icmp eq i32 %.0..0..0..0..0..0.84.i1029, -1
  %.pre.i1037 = select i1 %.not.i1034, i32 %.01067, i32 %.01065
  %.pre1118 = sext i32 %.pre.i1037 to i64
  %.pre1120 = shl nsw i64 %.pre1118, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1058

SwissTable_find_slot_keyK_hashi32.exit1058:       ; preds = %394, %._crit_edge2.i1055
  %.pre-phi1121 = phi i64 [ %.pre1120, %394 ], [ %362, %._crit_edge2.i1055 ]
  %.pre-phi1119 = phi i64 [ %.pre1118, %394 ], [ %355, %._crit_edge2.i1055 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %395 = getelementptr i8, ptr %result.i10.i810, i64 %.pre-phi1121
  store ptr %329, ptr %395, align 8
  %396 = getelementptr i8, ptr %395, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i823, ptr %396, align 4
  %.sroa_idx120.i843 = getelementptr i8, ptr %395, i64 16
  store i64 %.sroa.3.0.extract.trunc.i822, ptr %.sroa_idx120.i843, align 4
  %.sroa_idx121.i844 = getelementptr i8, ptr %395, i64 24
  store i32 %offset.i34.i835, ptr %.sroa_idx121.i844, align 4
  %397 = getelementptr i8, ptr %result.i9.i811, i64 %.pre-phi1119
  store i8 1, ptr %397, align 1
  %398 = add i32 %326, 1
  %399 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i819

._crit_edge2.backedge.i819:                       ; preds = %SwissTable_find_slot_keyK_hashi32.exit1058, %.lr.ph.i813
  %400 = phi i32 [ %398, %SwissTable_find_slot_keyK_hashi32.exit1058 ], [ %326, %.lr.ph.i813 ]
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %403 = icmp sgt i32 %storemerge.i814, %317
  %404 = add i32 %storemerge.i814, 1
  br i1 %403, label %SwissTable_resize_new_capacityi32.exit848, label %.lr.ph.i813

SwissTable_resize_new_capacityi32.exit848:        ; preds = %._crit_edge2.backedge.i819, %._crit_edge1.i526
  %.lcssa11941201 = phi i32 [ 0, %._crit_edge1.i526 ], [ %400, %._crit_edge2.backedge.i819 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %SwissTable_ensure_capacity_required_sizei32.exit530

SwissTable_ensure_capacity_required_sizei32.exit530: ; preds = %SwissTable_resize_new_capacityi32.exit848, %309
  %.pre775 = phi ptr [ %299, %309 ], [ %result.i9.i811, %SwissTable_resize_new_capacityi32.exit848 ]
  %405 = phi ptr [ %300, %309 ], [ %result.i10.i810, %SwissTable_resize_new_capacityi32.exit848 ]
  %.lcssa11941199 = phi i32 [ %.lcssa11941200, %309 ], [ %.lcssa11941201, %SwissTable_resize_new_capacityi32.exit848 ]
  %406 = phi i32 [ %301, %309 ], [ %spec.select.i527, %SwissTable_resize_new_capacityi32.exit848 ]
  %407 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %408 = call i32 %296({ ptr, i160 } %306)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %409 = add i32 %406, -1
  %410 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %411 = load ptr, ptr %17, align 8
  br label %412

412:                                              ; preds = %450, %SwissTable_ensure_capacity_required_sizei32.exit530
  %.0630 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit530 ], [ %.1631, %450 ]
  %.pn1424 = phi i32 [ %408, %SwissTable_ensure_capacity_required_sizei32.exit530 ], [ %451, %450 ]
  %.0..0..0..0..0..0.84.i546 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit530 ], [ %spec.store.select9216.i550, %450 ]
  %.0629 = and i32 %.pn1424, %409
  %413 = sext i32 %.0629 to i64
  %414 = getelementptr i8, ptr %.pre775, i64 %413
  %415 = load i8, ptr %414, align 1
  switch i8 %415, label %._crit_edge.i555 [
    i8 0, label %452
    i8 -128, label %._crit_edge.thread.i548
  ]

._crit_edge.thread.i548:                          ; preds = %412
  %416 = icmp eq i32 %.0..0..0..0..0..0.84.i546, -1
  %spec.store.select.i549 = select i1 %416, i32 %.0629, i32 %.0..0..0..0..0..0.84.i546
  br label %450

._crit_edge.i555:                                 ; preds = %412
  %417 = icmp sgt i8 %415, 0
  br i1 %417, label %418, label %450

418:                                              ; preds = %._crit_edge.i555
  %419 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %420 = shl nsw i64 %413, 5
  %421 = getelementptr i8, ptr %405, i64 %420
  %422 = load ptr, ptr %421, align 8
  %423 = icmp ne ptr %422, @nil_typ
  %424 = icmp ne ptr %422, null
  %.not82.i557 = and i1 %423, %424
  br i1 %.not82.i557, label %425, label %450

425:                                              ; preds = %418
  %426 = getelementptr i8, ptr %421, i64 8
  %427 = load i64, ptr %426, align 4
  %.sroa_idx.i558 = getelementptr i8, ptr %421, i64 16
  %428 = load i64, ptr %.sroa_idx.i558, align 4
  %429 = inttoptr i64 %427 to ptr
  %430 = inttoptr i64 %428 to ptr
  %hash_coef_ptr.i3.i559 = getelementptr i8, ptr %422, i64 8
  %tbl_size_ptr.i4.i560 = getelementptr i8, ptr %422, i64 16
  %offset_tbl_ptr.i5.i561 = getelementptr i8, ptr %422, i64 40
  %hash_coef.i6.i562 = load i64, ptr %hash_coef_ptr.i3.i559, align 4
  %tbl_size.i7.i563 = load i64, ptr %tbl_size_ptr.i4.i560, align 4
  %offset_tbl.i8.i564 = load ptr, ptr %offset_tbl_ptr.i5.i561, align 8
  %product.i.i9.i565 = mul i64 %hash_coef.i6.i562, 4015701072841558310
  %shifted.i.i10.i566 = lshr i64 %product.i.i9.i565, 32
  %xored.i.i11.i567 = xor i64 %shifted.i.i10.i566, %product.i.i9.i565
  %hash.i.i12.i568 = and i64 %xored.i.i11.i567, %tbl_size.i7.i563
  %offset_ptr.i13.i569 = getelementptr i32, ptr %offset_tbl.i8.i564, i64 %hash.i.i12.i568
  %offset.i14.i570 = load i32, ptr %offset_ptr.i13.i569, align 4
  %431 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %422, 0
  %432 = insertvalue { ptr, ptr, ptr, i32 } %431, ptr %429, 1
  %433 = insertvalue { ptr, ptr, ptr, i32 } %432, ptr %430, 2
  %434 = insertvalue { ptr, ptr, ptr, i32 } %433, i32 %offset.i14.i570, 3
  %435 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %436 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %422)
  %437 = sext i32 %offset.i14.i570 to i64
  %438 = getelementptr ptr, ptr %422, i64 %437
  %439 = getelementptr i8, ptr %438, i64 40
  %440 = load ptr, ptr %439, align 8
  %result.i1.i571 = call ptr %440({ ptr, ptr, ptr, i32 } %434, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %441 = call i32 %result.i1.i571({ ptr, ptr, ptr, i32 } %434, { ptr, ptr, ptr, i32 } %434, ptr nonnull align 8 %2)
  %442 = icmp eq i32 %441, %408
  br i1 %442, label %._crit_edge2.i572, label %450

._crit_edge2.i572:                                ; preds = %425
  %443 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %444 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %422)
  %445 = getelementptr i8, ptr %438, i64 48
  %446 = load ptr, ptr %445, align 8
  %result.i.i573 = call ptr %446({ ptr, ptr, ptr, i32 } %434, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %447 = call { ptr, i160 } %result.i.i573({ ptr, ptr, ptr, i32 } %434, { ptr, ptr, ptr, i32 } %434, ptr nonnull align 8 %2)
  %448 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %449 = call i1 %411({ ptr, i160 } %447, { ptr, i160 } %306)
  br i1 %449, label %SwissTable_find_slot_keyK_hashi32.exit575, label %450

450:                                              ; preds = %._crit_edge2.i572, %425, %418, %._crit_edge.i555, %._crit_edge.thread.i548
  %.1631 = phi i32 [ %.0630, %._crit_edge2.i572 ], [ %.0630, %425 ], [ %.0630, %418 ], [ %.0630, %._crit_edge.i555 ], [ %spec.store.select.i549, %._crit_edge.thread.i548 ]
  %spec.store.select9216.i550 = phi i32 [ %.0..0..0..0..0..0.84.i546, %._crit_edge2.i572 ], [ %.0..0..0..0..0..0.84.i546, %425 ], [ %.0..0..0..0..0..0.84.i546, %418 ], [ %.0..0..0..0..0..0.84.i546, %._crit_edge.i555 ], [ %spec.store.select.i549, %._crit_edge.thread.i548 ]
  %451 = add nuw i32 %.0629, 1
  br label %412

452:                                              ; preds = %412
  %.not.i551 = icmp eq i32 %.0..0..0..0..0..0.84.i546, -1
  %.pre.i554 = select i1 %.not.i551, i32 %.0629, i32 %.0630
  %.pre670 = sext i32 %.pre.i554 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit575

SwissTable_find_slot_keyK_hashi32.exit575:        ; preds = %452, %._crit_edge2.i572
  %.pre-phi671 = phi i64 [ %.pre670, %452 ], [ %413, %._crit_edge2.i572 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %453 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %454 = getelementptr i8, ptr %.pre775, i64 %.pre-phi671
  %455 = load i8, ptr %454, align 1
  %456 = load ptr, ptr %297, align 8, !alias.scope !6
  %457 = getelementptr i8, ptr %456, i64 72
  %458 = load ptr, ptr %457, align 8, !alias.scope !6
  %result.i1.i.i272 = call { i64, i64 } %458(ptr nocapture nofree nonnull readonly %297) #47, !alias.scope !6
  %459 = extractvalue { i64, i64 } %result.i1.i.i272, 0
  %460 = extractvalue { i64, i64 } %result.i1.i.i272, 1
  %461 = urem i64 20, %460
  %462 = icmp eq i64 %461, 0
  %463 = sub i64 %460, %461
  %464 = select i1 %462, i64 0, i64 %463
  %465 = add i64 %459, 20
  %466 = add i64 %465, %464
  %467 = load ptr, ptr %298, align 8, !alias.scope !6
  %468 = getelementptr i8, ptr %467, i64 72
  %469 = load ptr, ptr %468, align 8, !alias.scope !6
  %result.i.i.i273 = call { i64, i64 } %469(ptr nocapture nofree nonnull readonly %298) #47, !alias.scope !6
  %470 = extractvalue { i64, i64 } %result.i.i.i273, 0
  %471 = extractvalue { i64, i64 } %result.i.i.i273, 1
  %472 = call i64 @llvm.umax.i64(i64 %460, i64 %471) #61
  %473 = call i64 @llvm.umax.i64(i64 %472, i64 noundef 8) #61, !range !5
  %474 = urem i64 %466, %471
  %475 = icmp eq i64 %474, 0
  %476 = sub i64 %471, %474
  %477 = select i1 %475, i64 0, i64 %476
  %478 = add i64 %470, %466
  %479 = add i64 %478, %477
  %480 = urem i64 %479, %473
  %481 = icmp eq i64 %480, 0
  %482 = sub i64 %473, %480
  %483 = select i1 %481, i64 0, i64 %482
  %484 = add i64 %483, %479
  %result.i9.i274 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %484) #51
  store ptr %297, ptr %result.i9.i274, align 8
  %485 = getelementptr inbounds i8, ptr %result.i9.i274, i64 8
  store ptr %298, ptr %485, align 8
  %486 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i274)
  %487 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %488 = load ptr, ptr %297, align 8
  %489 = getelementptr i8, ptr %488, i64 72
  %490 = load ptr, ptr %489, align 8
  %result.i.i10.i275 = call { i64, i64 } %490(ptr nocapture nofree nonnull readonly %297) #47
  %491 = extractvalue { i64, i64 } %result.i.i10.i275, 1
  %492 = urem i64 20, %491
  %493 = icmp eq i64 %492, 0
  %reass.sub = sub i64 %491, %492
  %494 = add i64 %reass.sub, 20
  %495 = select i1 %493, i64 20, i64 %494
  %496 = getelementptr i8, ptr %result.i9.i274, i64 %495
  %497 = getelementptr i8, ptr %488, i64 64
  %498 = load ptr, ptr %497, align 8
  call void %498({ ptr, i160 } %306, ptr nocapture nofree nonnull readonly %297, ptr nocapture nofree writeonly %496) #48
  %499 = load ptr, ptr %result.i9.i274, align 8
  %500 = load ptr, ptr %499, align 8
  %501 = getelementptr i8, ptr %500, i64 72
  %502 = load ptr, ptr %501, align 8
  %result.i1.i11.i277 = call { i64, i64 } %502(ptr nocapture nofree nonnull readonly align 8 %499) #47
  %503 = extractvalue { i64, i64 } %result.i1.i11.i277, 0
  %504 = extractvalue { i64, i64 } %result.i1.i11.i277, 1
  %505 = urem i64 20, %504
  %506 = icmp eq i64 %505, 0
  %507 = sub i64 %504, %505
  %508 = select i1 %506, i64 0, i64 %507
  %509 = add i64 %503, 20
  %510 = add i64 %509, %508
  %511 = load ptr, ptr %485, align 8
  %512 = load ptr, ptr %511, align 8
  %513 = getelementptr i8, ptr %512, i64 72
  %514 = load ptr, ptr %513, align 8
  %result.i.i12.i278 = call { i64, i64 } %514(ptr nocapture nofree nonnull readonly align 8 %511) #47
  %515 = extractvalue { i64, i64 } %result.i.i12.i278, 1
  %516 = urem i64 %510, %515
  %517 = icmp eq i64 %516, 0
  %518 = sub i64 %515, %516
  %519 = select i1 %517, i64 0, i64 %518
  %520 = getelementptr i8, ptr %result.i9.i274, i64 %510
  %521 = getelementptr i8, ptr %520, i64 %519
  %522 = getelementptr i8, ptr %512, i64 64
  %523 = load ptr, ptr %522, align 8
  call void %523({ ptr, i160 } %307, ptr nocapture nofree nonnull readonly align 8 %511, ptr nocapture nofree writeonly %521) #48
  %524 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %525 = getelementptr inbounds i8, ptr %result.i9.i274, i64 16
  store i32 %408, ptr %525, align 8
  %526 = icmp eq i8 %455, 0
  br i1 %526, label %527, label %SwissTable_insert_keyK_valueV.exit282

527:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit575
  store i8 1, ptr %454, align 1
  %528 = add i32 %.lcssa11941199, 1
  br label %SwissTable_insert_keyK_valueV.exit282

SwissTable_insert_keyK_valueV.exit282:            ; preds = %527, %SwissTable_find_slot_keyK_hashi32.exit575
  %529 = phi i32 [ %.lcssa11941199, %SwissTable_find_slot_keyK_hashi32.exit575 ], [ %528, %527 ]
  %530 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %531 = shl nsw i64 %.pre-phi671, 5
  %532 = getelementptr i8, ptr %405, i64 %531
  store ptr @Entry, ptr %532, align 8
  %533 = getelementptr i8, ptr %532, i64 8
  %534 = ptrtoint ptr %result.i9.i274 to i64
  store i64 %534, ptr %533, align 4
  %.sroa_idx3.i280 = getelementptr i8, ptr %532, i64 24
  store i32 10, ptr %.sroa_idx3.i280, align 4
  %indvars.iv.next398 = add nuw nsw i64 %indvars.iv397, 1
  %exitcond123.not = icmp eq i64 %indvars.iv.next398, %48
  br i1 %exitcond123.not, label %._crit_edge5, label %._crit_edge3

._crit_edge5:                                     ; preds = %SwissTable_insert_keyK_valueV.exit282
  store i32 %406, ptr %20, align 8
  store i32 %529, ptr %22, align 4
  store ptr %405, ptr %18, align 8
  store ptr %.pre775, ptr %19, align 8
  %.sroa.gep440 = getelementptr inbounds i8, ptr %4, i64 24
  %.sroa.gep434 = getelementptr inbounds i8, ptr %4, i64 8
  %.sroa.gep446 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep437 = getelementptr inbounds i8, ptr %4, i64 16
  %.sroa.gep443 = getelementptr inbounds i8, ptr %3, i64 8
  %.sroa.gep449 = getelementptr inbounds i8, ptr %3, i64 24
  %535 = call i64 @clock()
  %.sroa.0364.0.insert.ext = zext i32 %spec.select to i160
  %536 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0364.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %537 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %538 = load ptr, ptr %16, align 8
  %539 = call i32 %538({ ptr, i160 } %536)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %540 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %541 = load ptr, ptr %17, align 8
  br label %542

542:                                              ; preds = %580, %._crit_edge5
  %.0628 = phi i32 [ -1, %._crit_edge5 ], [ %.1, %580 ]
  %.pn1426 = phi i32 [ %539, %._crit_edge5 ], [ %581, %580 ]
  %.0..0..0..0..0..0.84.i591 = phi i32 [ -1, %._crit_edge5 ], [ %spec.store.select9216.i595, %580 ]
  %.0 = and i32 %.pn1426, %409
  %543 = sext i32 %.0 to i64
  %544 = getelementptr i8, ptr %.pre775, i64 %543
  %545 = load i8, ptr %544, align 1
  switch i8 %545, label %._crit_edge.i600 [
    i8 0, label %582
    i8 -128, label %._crit_edge.thread.i593
  ]

._crit_edge.thread.i593:                          ; preds = %542
  %546 = icmp eq i32 %.0..0..0..0..0..0.84.i591, -1
  %spec.store.select.i594 = select i1 %546, i32 %.0, i32 %.0..0..0..0..0..0.84.i591
  br label %580

._crit_edge.i600:                                 ; preds = %542
  %547 = icmp sgt i8 %545, 0
  br i1 %547, label %548, label %580

548:                                              ; preds = %._crit_edge.i600
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %550 = shl nsw i64 %543, 5
  %551 = getelementptr i8, ptr %405, i64 %550
  %552 = load ptr, ptr %551, align 8
  %553 = icmp ne ptr %552, @nil_typ
  %554 = icmp ne ptr %552, null
  %.not82.i602 = and i1 %553, %554
  br i1 %.not82.i602, label %555, label %580

555:                                              ; preds = %548
  %556 = getelementptr i8, ptr %551, i64 8
  %557 = load i64, ptr %556, align 4
  %.sroa_idx.i603 = getelementptr i8, ptr %551, i64 16
  %558 = load i64, ptr %.sroa_idx.i603, align 4
  %559 = inttoptr i64 %557 to ptr
  %560 = inttoptr i64 %558 to ptr
  %hash_coef_ptr.i3.i604 = getelementptr i8, ptr %552, i64 8
  %tbl_size_ptr.i4.i605 = getelementptr i8, ptr %552, i64 16
  %offset_tbl_ptr.i5.i606 = getelementptr i8, ptr %552, i64 40
  %hash_coef.i6.i607 = load i64, ptr %hash_coef_ptr.i3.i604, align 4
  %tbl_size.i7.i608 = load i64, ptr %tbl_size_ptr.i4.i605, align 4
  %offset_tbl.i8.i609 = load ptr, ptr %offset_tbl_ptr.i5.i606, align 8
  %product.i.i9.i610 = mul i64 %hash_coef.i6.i607, 4015701072841558310
  %shifted.i.i10.i611 = lshr i64 %product.i.i9.i610, 32
  %xored.i.i11.i612 = xor i64 %shifted.i.i10.i611, %product.i.i9.i610
  %hash.i.i12.i613 = and i64 %xored.i.i11.i612, %tbl_size.i7.i608
  %offset_ptr.i13.i614 = getelementptr i32, ptr %offset_tbl.i8.i609, i64 %hash.i.i12.i613
  %offset.i14.i615 = load i32, ptr %offset_ptr.i13.i614, align 4
  %561 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %552, 0
  %562 = insertvalue { ptr, ptr, ptr, i32 } %561, ptr %559, 1
  %563 = insertvalue { ptr, ptr, ptr, i32 } %562, ptr %560, 2
  %564 = insertvalue { ptr, ptr, ptr, i32 } %563, i32 %offset.i14.i615, 3
  %565 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %566 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %552)
  %567 = sext i32 %offset.i14.i615 to i64
  %568 = getelementptr ptr, ptr %552, i64 %567
  %569 = getelementptr i8, ptr %568, i64 40
  %570 = load ptr, ptr %569, align 8
  %result.i1.i616 = call ptr %570({ ptr, ptr, ptr, i32 } %564, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %571 = call i32 %result.i1.i616({ ptr, ptr, ptr, i32 } %564, { ptr, ptr, ptr, i32 } %564, ptr nonnull align 8 %2)
  %572 = icmp eq i32 %571, %539
  br i1 %572, label %._crit_edge2.i617, label %580

._crit_edge2.i617:                                ; preds = %555
  %573 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %574 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %552)
  %575 = getelementptr i8, ptr %568, i64 48
  %576 = load ptr, ptr %575, align 8
  %result.i.i618 = call ptr %576({ ptr, ptr, ptr, i32 } %564, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %577 = call { ptr, i160 } %result.i.i618({ ptr, ptr, ptr, i32 } %564, { ptr, ptr, ptr, i32 } %564, ptr nonnull align 8 %2)
  %578 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %579 = call i1 %541({ ptr, i160 } %577, { ptr, i160 } %536)
  br i1 %579, label %SwissTable_find_slot_keyK_hashi32.exit620, label %580

580:                                              ; preds = %._crit_edge2.i617, %555, %548, %._crit_edge.i600, %._crit_edge.thread.i593
  %.1 = phi i32 [ %.0628, %._crit_edge2.i617 ], [ %.0628, %555 ], [ %.0628, %548 ], [ %.0628, %._crit_edge.i600 ], [ %spec.store.select.i594, %._crit_edge.thread.i593 ]
  %spec.store.select9216.i595 = phi i32 [ %.0..0..0..0..0..0.84.i591, %._crit_edge2.i617 ], [ %.0..0..0..0..0..0.84.i591, %555 ], [ %.0..0..0..0..0..0.84.i591, %548 ], [ %.0..0..0..0..0..0.84.i591, %._crit_edge.i600 ], [ %spec.store.select.i594, %._crit_edge.thread.i593 ]
  %581 = add nuw i32 %.0, 1
  br label %542

582:                                              ; preds = %542
  %.not.i596 = icmp eq i32 %.0..0..0..0..0..0.84.i591, -1
  %.pre.i599 = select i1 %.not.i596, i32 %.0, i32 %.0628
  %.pre672 = sext i32 %.pre.i599 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit620

SwissTable_find_slot_keyK_hashi32.exit620:        ; preds = %582, %._crit_edge2.i617
  %.pre-phi673 = phi i64 [ %.pre672, %582 ], [ %543, %._crit_edge2.i617 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %583 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %584 = getelementptr i8, ptr %.pre775, i64 %.pre-phi673
  %585 = load i8, ptr %584, align 1
  switch i8 %585, label %586 [
    i8 -128, label %SwissTable_get_keyK.exit.thread
    i8 0, label %SwissTable_get_keyK.exit.thread
  ]

586:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit620
  %587 = shl nsw i64 %.pre-phi673, 5
  %588 = getelementptr i8, ptr %405, i64 %587
  %589 = load ptr, ptr %588, align 8
  %590 = icmp ne ptr %589, @nil_typ
  %591 = icmp ne ptr %589, null
  %.not74.i = and i1 %590, %591
  br i1 %.not74.i, label %SwissTable_get_keyK.exit, label %SwissTable_get_keyK.exit.thread

SwissTable_get_keyK.exit.thread:                  ; preds = %586, %SwissTable_find_slot_keyK_hashi32.exit620, %SwissTable_find_slot_keyK_hashi32.exit620
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge6

SwissTable_get_keyK.exit:                         ; preds = %586
  %592 = getelementptr i8, ptr %588, i64 8
  %593 = load i160, ptr %592, align 4
  %.sroa.262.0.extract.shift.i = lshr i160 %593, 64
  %.sroa.262.0.extract.trunc.i = trunc i160 %.sroa.262.0.extract.shift.i to i64
  %.sroa.061.0.extract.trunc.i = trunc i160 %593 to i64
  %594 = inttoptr i64 %.sroa.061.0.extract.trunc.i to ptr
  %595 = inttoptr i64 %.sroa.262.0.extract.trunc.i to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %589, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %589, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %589, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %596 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %589, 0
  %597 = insertvalue { ptr, ptr, ptr, i32 } %596, ptr %594, 1
  %598 = insertvalue { ptr, ptr, ptr, i32 } %597, ptr %595, 2
  %599 = insertvalue { ptr, ptr, ptr, i32 } %598, i32 %offset.i14.i, 3
  %600 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %589)
  %602 = sext i32 %offset.i14.i to i64
  %603 = getelementptr ptr, ptr %589, i64 %602
  %604 = getelementptr i8, ptr %603, i64 56
  %605 = load ptr, ptr %604, align 8
  %result.i1.i298 = call ptr %605({ ptr, ptr, ptr, i32 } %599, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %606 = call { ptr, i160 } %result.i1.i298({ ptr, ptr, ptr, i32 } %599, { ptr, ptr, ptr, i32 } %599, ptr nonnull align 8 %2)
  %.fca.0.extract49.i = extractvalue { ptr, i160 } %606, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %607 = icmp ne ptr %.fca.0.extract49.i, @nil_typ
  %608 = icmp ne ptr %.fca.0.extract49.i, null
  %.not426 = and i1 %607, %608
  br i1 %.not426, label %._crit_edge7, label %._crit_edge6

._crit_edge7:                                     ; preds = %SwissTable_get_keyK.exit
  %.fca.1.extract50.i = extractvalue { ptr, i160 } %606, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract50.i to i32
  %609 = add i32 %spec.select, 1
  %.not430 = icmp eq i32 %609, %.sroa.2.8.extract.trunc
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge7, %SwissTable_get_keyK.exit, %SwissTable_get_keyK.exit.thread
  %.2414 = phi i1 [ %.not430, %._crit_edge7 ], [ false, %SwissTable_get_keyK.exit ], [ false, %SwissTable_get_keyK.exit.thread ]
  %610 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %.not431 = icmp eq i32 %529, %.lcssa1186
  %612 = select i1 %.not431, i1 %.2414, i1 false
  %613 = freeze i1 %612
  br label %RangeIterator_next_.exit52.i.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge6, %._crit_edge2._crit_edge.thread
  %614 = phi i64 [ %294, %._crit_edge6 ], [ %41, %._crit_edge2._crit_edge.thread ]
  %615 = phi i32 [ %.lcssa1186, %._crit_edge6 ], [ 0, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep446468 = phi ptr [ %.sroa.gep446, %._crit_edge6 ], [ %.sroa.gep446463, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep440466 = phi ptr [ %.sroa.gep440, %._crit_edge6 ], [ %.sroa.gep440462, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep434464 = phi ptr [ %.sroa.gep434, %._crit_edge6 ], [ %.sroa.gep434461, %._crit_edge2._crit_edge.thread ]
  %616 = phi i64 [ %535, %._crit_edge6 ], [ %42, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep449132 = phi ptr [ %.sroa.gep449, %._crit_edge6 ], [ %.sroa.gep449127, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep443130 = phi ptr [ %.sroa.gep443, %._crit_edge6 ], [ %.sroa.gep443126, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep437128 = phi ptr [ %.sroa.gep437, %._crit_edge6 ], [ %.sroa.gep437125, %._crit_edge2._crit_edge.thread ]
  %.reg2mem21.0.in = phi i1 [ %613, %._crit_edge6 ], [ true, %._crit_edge2._crit_edge.thread ]
  %.sroa.gep448 = getelementptr inbounds i8, ptr %7, i64 24
  %.sroa.gep442 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep436 = getelementptr inbounds i8, ptr %8, i64 16
  %result.i45 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #51
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i45, align 1
  %617 = sub i64 %616, %614
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %618 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #43
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %619 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %620 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #43
  %result.i5.i1799 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #51
  %621 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %622 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %623 = load i8, ptr %result.i45, align 1
  store i8 %623, ptr %result.i5.i1799, align 1
  %624 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %625 = getelementptr i8, ptr %result.i45, i64 1
  %626 = load i8, ptr %625, align 1
  %627 = getelementptr i8, ptr %result.i5.i1799, i64 1
  store i8 %626, ptr %627, align 1
  %628 = getelementptr i8, ptr %result.i45, i64 2
  %629 = load i8, ptr %628, align 1
  %630 = getelementptr i8, ptr %result.i5.i1799, i64 2
  store i8 %629, ptr %630, align 1
  %631 = getelementptr i8, ptr %result.i45, i64 3
  %632 = load i8, ptr %631, align 1
  %633 = getelementptr i8, ptr %result.i5.i1799, i64 3
  store i8 %632, ptr %633, align 1
  %634 = getelementptr i8, ptr %result.i45, i64 4
  %635 = load i8, ptr %634, align 1
  %636 = getelementptr i8, ptr %result.i5.i1799, i64 4
  store i8 %635, ptr %636, align 1
  %637 = getelementptr i8, ptr %result.i45, i64 5
  %638 = load i8, ptr %637, align 1
  %639 = getelementptr i8, ptr %result.i5.i1799, i64 5
  store i8 %638, ptr %639, align 1
  %640 = getelementptr i8, ptr %result.i45, i64 6
  %641 = load i8, ptr %640, align 1
  %642 = getelementptr i8, ptr %result.i5.i1799, i64 6
  store i8 %641, ptr %642, align 1
  %643 = getelementptr i8, ptr %result.i45, i64 7
  %644 = load i8, ptr %643, align 1
  %645 = getelementptr i8, ptr %result.i5.i1799, i64 7
  store i8 %644, ptr %645, align 1
  %646 = getelementptr i8, ptr %result.i45, i64 8
  %647 = load i8, ptr %646, align 1
  %648 = getelementptr i8, ptr %result.i5.i1799, i64 8
  store i8 %647, ptr %648, align 1
  %649 = getelementptr i8, ptr %result.i45, i64 9
  %650 = load i8, ptr %649, align 1
  %651 = getelementptr i8, ptr %result.i5.i1799, i64 9
  store i8 %650, ptr %651, align 1
  %652 = getelementptr i8, ptr %result.i45, i64 10
  %653 = load i8, ptr %652, align 1
  %654 = getelementptr i8, ptr %result.i5.i1799, i64 10
  store i8 %653, ptr %654, align 1
  %655 = getelementptr i8, ptr %result.i45, i64 11
  %656 = load i8, ptr %655, align 1
  %657 = getelementptr i8, ptr %result.i5.i1799, i64 11
  store i8 %656, ptr %657, align 1
  %658 = getelementptr i8, ptr %result.i45, i64 12
  %659 = load i8, ptr %658, align 1
  %660 = getelementptr i8, ptr %result.i5.i1799, i64 12
  store i8 %659, ptr %660, align 1
  %661 = getelementptr i8, ptr %result.i5.i1799, i64 13
  store i8 0, ptr %661, align 1
  %puts.i1595 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i1799) #52
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %662 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %662, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #59
  %663 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #59
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %664 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %664, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #59
  %665 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %617) #59
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #59
  br i1 %38, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader
  %666 = zext nneg i32 %0 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %667 = mul i64 %617, 1000000
  %668 = sdiv i64 %667, %666
  %669 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %669, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #59
  %670 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %668) #59
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %673 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #59
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  %result.i43 = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i43, align 1
  %674 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %675 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %676 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  store i8 32, ptr %result.i5.i, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i, i64 1
  %scevgep888 = getelementptr inbounds i8, ptr %result.i43, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(18) %scevgep, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(18) %scevgep888, i64 noundef 17, i1 noundef false)
  %.sroa.gep445 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep439 = getelementptr inbounds i8, ptr %8, i64 24
  %.sroa.gep = getelementptr inbounds i8, ptr %8, i64 8
  %677 = getelementptr inbounds i8, ptr %result.i5.i, i64 18
  store i8 0, ptr %677, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %result.i41 = call noalias nonnull dereferenceable(5) ptr @bump_malloc_wrapper(i64 noundef 5) #51
  br i1 %.reg2mem21.0.in, label %678, label %679

678:                                              ; preds = %print_benchmark_result.exit
  br label %679

679:                                              ; preds = %678, %print_benchmark_result.exit
  %680 = phi ptr [ %.sroa.gep449132, %678 ], [ %.sroa.gep448, %print_benchmark_result.exit ]
  %681 = phi ptr [ %.sroa.gep443130, %678 ], [ %.sroa.gep442, %print_benchmark_result.exit ]
  %682 = phi ptr [ %.sroa.gep440466, %678 ], [ %.sroa.gep439, %print_benchmark_result.exit ]
  %683 = phi ptr [ %.sroa.gep434464, %678 ], [ %.sroa.gep, %print_benchmark_result.exit ]
  %684 = phi ptr [ %6, %678 ], [ %10, %print_benchmark_result.exit ]
  %685 = phi i32 [ 1397965136, %678 ], [ 1279869254, %print_benchmark_result.exit ]
  %686 = phi ptr [ %5, %678 ], [ %9, %print_benchmark_result.exit ]
  %687 = phi ptr [ %.sroa.gep437128, %678 ], [ %.sroa.gep436, %print_benchmark_result.exit ]
  %688 = phi ptr [ %4, %678 ], [ %8, %print_benchmark_result.exit ]
  %689 = phi ptr [ %.sroa.gep446468, %678 ], [ %.sroa.gep445, %print_benchmark_result.exit ]
  %690 = phi ptr [ %3, %678 ], [ %7, %print_benchmark_result.exit ]
  store i32 %685, ptr %result.i41, align 1
  store ptr @_parameterization_Bufferi8, ptr %690, align 8
  store ptr @_parameterization_i32, ptr %681, align 8
  store ptr @_parameterization_i32, ptr %689, align 8
  store ptr @_parameterization_i32, ptr %680, align 8
  %691 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %690)
  store ptr @buffer_typ, ptr %688, align 8
  store ptr @i32_typ, ptr %683, align 8
  store ptr @i32_typ, ptr %687, align 8
  store ptr @i32_typ, ptr %682, align 8
  %692 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %688) #43
  store ptr @_parameterization_String, ptr %686, align 8
  %693 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %686)
  store ptr @String, ptr %684, align 8
  %694 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %684) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %695 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %696 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i703 = call noalias nonnull dereferenceable(5) ptr @bump_malloc_wrapper(i64 noundef 5) #51
  %697 = trunc i32 %685 to i8
  store i8 %697, ptr %result.i5.i703, align 1
  %scevgep892 = getelementptr inbounds i8, ptr %result.i5.i703, i64 1
  %scevgep893 = getelementptr inbounds i8, ptr %result.i41, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(4) %scevgep892, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(4) %scevgep893, i64 noundef 3, i1 noundef false)
  %698 = getelementptr inbounds i8, ptr %result.i5.i703, i64 4
  store i8 0, ptr %698, align 1
  %puts.i419 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i703) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %result.i39 = call noalias nonnull dereferenceable(28) ptr @bump_malloc_wrapper(i64 noundef 28) #51
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %result.i39, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %699 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i722 = call noalias nonnull dereferenceable(28) ptr @bump_malloc_wrapper(i64 noundef 28) #51
  store i8 32, ptr %result.i5.i722, align 1
  %scevgep897 = getelementptr inbounds i8, ptr %result.i5.i722, i64 1
  %scevgep898 = getelementptr inbounds i8, ptr %result.i39, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(27) %scevgep897, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(27) %scevgep898, i64 noundef 26, i1 noundef false)
  %701 = getelementptr inbounds i8, ptr %result.i5.i722, i64 27
  store i8 0, ptr %701, align 1
  %puts.i439 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(28) %result.i5.i722) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %702 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %615) #59
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %704 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %705 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i741 = call noalias nonnull dereferenceable(2) ptr @bump_malloc_wrapper(i64 noundef 2) #51
  %706 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 41, ptr %result.i5.i741, align 1
  %707 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %708 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %709 = getelementptr inbounds i8, ptr %result.i5.i741, i64 1
  store i8 0, ptr %709, align 1
  %puts.i459 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i5.i741) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr #17 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %oldProtect.i30 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %3 = alloca [4 x ptr], align 8
  %4 = alloca [4 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %result.i28 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #51
  store ptr @_parameterization_i32, ptr %result.i28, align 8
  %12 = getelementptr inbounds i8, ptr %result.i28, i64 8
  store ptr @_parameterization_i32, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i28, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i28) #60
  %result.i27 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  %result.i29 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i27, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i27, ptr noalias nofree noundef nonnull readnone @akkyvmuyai, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i17 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i27) #50
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i27) #60
  %result.i26 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i30) #60
  %result.i31 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i26, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i30) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i30) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i26, ptr noalias nofree noundef nonnull readnone @lgazvjztvp, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i26) #50
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i26) #60
  %17 = getelementptr inbounds i8, ptr %result.i28, i64 48
  store ptr %ret.i17, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i28, i64 56
  store ptr %ret.i, ptr %18, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  %19 = getelementptr inbounds i8, ptr %result.i28, i64 24
  store ptr %result.i1.i, ptr %19, align 8
  %result.i.i = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %20 = getelementptr inbounds i8, ptr %result.i28, i64 32
  store ptr %result.i.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i28, i64 40
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %23 = getelementptr inbounds i8, ptr %result.i28, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %21, align 8
  %.sroa.gep = getelementptr inbounds i8, ptr %9, i64 8
  %.sroa.gep326 = getelementptr inbounds i8, ptr %9, i64 16
  %.sroa.gep329 = getelementptr inbounds i8, ptr %9, i64 24
  %.sroa.gep332 = getelementptr inbounds i8, ptr %8, i64 8
  %.sroa.gep335 = getelementptr inbounds i8, ptr %8, i64 16
  %.sroa.gep338 = getelementptr inbounds i8, ptr %8, i64 24
  %24 = icmp sgt i32 %0, 0
  br i1 %24, label %._crit_edge.preheader, label %._crit_edge1._crit_edge.thread

._crit_edge1._crit_edge.thread:                   ; preds = %1
  %.sroa.gep32499 = getelementptr inbounds i8, ptr %5, i64 8
  %.sroa.gep330100 = getelementptr inbounds i8, ptr %5, i64 24
  %.sroa.gep336101 = getelementptr inbounds i8, ptr %4, i64 16
  %25 = call i64 @clock()
  %26 = getelementptr inbounds i8, ptr %3, i64 16
  br label %RangeIterator_next_.exit52.i.preheader1144

._crit_edge.preheader:                            ; preds = %1
  %wide.trip.count = zext nneg i32 %0 to i64
  br label %27

27:                                               ; preds = %SwissTable_insert_keyK_valueV.exit, %._crit_edge.preheader
  %28 = phi ptr [ %result.i.i, %._crit_edge.preheader ], [ %127, %SwissTable_insert_keyK_valueV.exit ]
  %29 = phi ptr [ %result.i1.i, %._crit_edge.preheader ], [ %128, %SwissTable_insert_keyK_valueV.exit ]
  %.lcssa603609 = phi i32 [ 0, %._crit_edge.preheader ], [ %.lcssa603607, %SwissTable_insert_keyK_valueV.exit ]
  %30 = phi i32 [ 8, %._crit_edge.preheader ], [ %129, %SwissTable_insert_keyK_valueV.exit ]
  %indvars.iv = phi i64 [ 0, %._crit_edge.preheader ], [ %indvars.iv.next, %SwissTable_insert_keyK_valueV.exit ]
  %.030473 = phi i64 [ 0, %._crit_edge.preheader ], [ %211, %SwissTable_insert_keyK_valueV.exit ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %.sroa.0298.0.insert.ext = zext nneg i64 %indvars.iv to i160
  %31 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0298.0.insert.ext, 1
  %32 = add i32 %.lcssa603609, 1
  %33 = mul i32 %30, 7
  %34 = sdiv i32 %33, 10
  %.not.i = icmp slt i32 %32, %34
  br i1 %.not.i, label %SwissTable_ensure_capacity_required_sizei32.exit, label %._crit_edge1.i

._crit_edge1.i:                                   ; preds = %27
  %35 = shl i32 %30, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %35, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %36 = zext nneg i32 %spec.select.i to i64
  %37 = shl nuw nsw i64 %36, 5
  %result.i10.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %37) #51
  %result.i9.i415 = call noalias ptr @bump_malloc_wrapper(i64 noundef %36) #51
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %39 = add i32 %30, -1
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %44 = icmp slt i32 %39, 0
  br i1 %44, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i.preheader

.lr.ph.i.preheader:                               ; preds = %._crit_edge1.i
  %45 = load ptr, ptr %17, align 8
  %46 = add nsw i32 %spec.select.i, -1
  %47 = load ptr, ptr %18, align 8
  br label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge2.backedge.i, %.lr.ph.i.preheader
  %48 = phi i32 [ %122, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %storemerge.i = phi i32 [ %126, %._crit_edge2.backedge.i ], [ 1, %.lr.ph.i.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i = phi i32 [ %storemerge.i, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %.sroa.0.8.extract.trunc.i = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i to i64
  %sext.i = shl nuw i64 %.sroa.0.8.extract.trunc.i, 32
  %49 = ashr exact i64 %sext.i, 27
  %50 = getelementptr i8, ptr %29, i64 %49
  %51 = load ptr, ptr %50, align 8
  %52 = icmp ne ptr %51, @nil_typ
  %53 = icmp ne ptr %51, null
  %.not158.i = and i1 %52, %53
  br i1 %.not158.i, label %54, label %._crit_edge2.backedge.i

54:                                               ; preds = %.lr.ph.i
  %55 = getelementptr i8, ptr %50, i64 8
  %56 = load i160, ptr %55, align 4
  %.sroa.3.0.extract.shift.i = lshr i160 %56, 64
  %.sroa.3.0.extract.trunc.i = trunc i160 %.sroa.3.0.extract.shift.i to i64
  %.sroa.0146.0.extract.trunc.i = trunc i160 %56 to i64
  %57 = inttoptr i64 %.sroa.0146.0.extract.trunc.i to ptr
  %58 = inttoptr i64 %.sroa.3.0.extract.trunc.i to ptr
  %hash_coef_ptr.i23.i = getelementptr i8, ptr %51, i64 8
  %tbl_size_ptr.i24.i = getelementptr i8, ptr %51, i64 16
  %offset_tbl_ptr.i25.i = getelementptr i8, ptr %51, i64 40
  %hash_coef.i26.i = load i64, ptr %hash_coef_ptr.i23.i, align 4
  %tbl_size.i27.i = load i64, ptr %tbl_size_ptr.i24.i, align 4
  %offset_tbl.i28.i = load ptr, ptr %offset_tbl_ptr.i25.i, align 8
  %product.i.i29.i = mul i64 %hash_coef.i26.i, 4015701072841558310
  %shifted.i.i30.i = lshr i64 %product.i.i29.i, 32
  %xored.i.i31.i = xor i64 %shifted.i.i30.i, %product.i.i29.i
  %hash.i.i32.i = and i64 %xored.i.i31.i, %tbl_size.i27.i
  %offset_ptr.i33.i = getelementptr i32, ptr %offset_tbl.i28.i, i64 %hash.i.i32.i
  %offset.i34.i = load i32, ptr %offset_ptr.i33.i, align 4
  %59 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %57, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %58, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %offset.i34.i, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %51)
  %65 = sext i32 %offset.i34.i to i64
  %66 = getelementptr ptr, ptr %51, i64 %65
  %67 = getelementptr i8, ptr %66, i64 48
  %68 = load ptr, ptr %67, align 8
  %result.i4.i = call ptr %68({ ptr, ptr, ptr, i32 } %62, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %69 = call { ptr, i160 } %result.i4.i({ ptr, ptr, ptr, i32 } %62, { ptr, ptr, ptr, i32 } %62, ptr nonnull align 8 %2)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %71 = call i32 %45({ ptr, i160 } %69)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %51)
  %74 = load ptr, ptr %67, align 8
  %result.i3.i = call ptr %74({ ptr, ptr, ptr, i32 } %62, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %75 = call { ptr, i160 } %result.i3.i({ ptr, ptr, ptr, i32 } %62, { ptr, ptr, ptr, i32 } %62, ptr nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %76

76:                                               ; preds = %114, %54
  %.pn = phi i32 [ %71, %54 ], [ %115, %114 ]
  %.0532 = phi i32 [ -1, %54 ], [ %.1533, %114 ]
  %.0..0..0..0..0..0.84.i506 = phi i32 [ -1, %54 ], [ %spec.store.select9216.i509, %114 ]
  %.0534 = and i32 %.pn, %46
  %77 = zext nneg i32 %.0534 to i64
  %78 = getelementptr i8, ptr %result.i9.i415, i64 %77
  %79 = load i8, ptr %78, align 1
  switch i8 %79, label %._crit_edge.i512 [
    i8 0, label %116
    i8 -128, label %._crit_edge.thread.i507
  ]

._crit_edge.thread.i507:                          ; preds = %76
  %80 = icmp eq i32 %.0..0..0..0..0..0.84.i506, -1
  %spec.store.select.i508 = select i1 %80, i32 %.0534, i32 %.0..0..0..0..0..0.84.i506
  br label %114

._crit_edge.i512:                                 ; preds = %76
  %81 = icmp sgt i8 %79, 0
  br i1 %81, label %82, label %114

82:                                               ; preds = %._crit_edge.i512
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %84 = shl nuw nsw i64 %77, 5
  %85 = getelementptr i8, ptr %result.i10.i, i64 %84
  %86 = load ptr, ptr %85, align 8
  %87 = icmp ne ptr %86, @nil_typ
  %88 = icmp ne ptr %86, null
  %.not82.i513 = and i1 %87, %88
  br i1 %.not82.i513, label %89, label %114

89:                                               ; preds = %82
  %90 = getelementptr i8, ptr %85, i64 8
  %91 = load i64, ptr %90, align 4
  %.sroa_idx.i514 = getelementptr i8, ptr %85, i64 16
  %92 = load i64, ptr %.sroa_idx.i514, align 4
  %93 = inttoptr i64 %91 to ptr
  %94 = inttoptr i64 %92 to ptr
  %hash_coef_ptr.i3.i515 = getelementptr i8, ptr %86, i64 8
  %tbl_size_ptr.i4.i516 = getelementptr i8, ptr %86, i64 16
  %offset_tbl_ptr.i5.i517 = getelementptr i8, ptr %86, i64 40
  %hash_coef.i6.i518 = load i64, ptr %hash_coef_ptr.i3.i515, align 4
  %tbl_size.i7.i519 = load i64, ptr %tbl_size_ptr.i4.i516, align 4
  %offset_tbl.i8.i520 = load ptr, ptr %offset_tbl_ptr.i5.i517, align 8
  %product.i.i9.i521 = mul i64 %hash_coef.i6.i518, 4015701072841558310
  %shifted.i.i10.i522 = lshr i64 %product.i.i9.i521, 32
  %xored.i.i11.i523 = xor i64 %shifted.i.i10.i522, %product.i.i9.i521
  %hash.i.i12.i524 = and i64 %xored.i.i11.i523, %tbl_size.i7.i519
  %offset_ptr.i13.i525 = getelementptr i32, ptr %offset_tbl.i8.i520, i64 %hash.i.i12.i524
  %offset.i14.i526 = load i32, ptr %offset_ptr.i13.i525, align 4
  %95 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %86, 0
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, ptr %93, 1
  %97 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %94, 2
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 %offset.i14.i526, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %86)
  %101 = sext i32 %offset.i14.i526 to i64
  %102 = getelementptr ptr, ptr %86, i64 %101
  %103 = getelementptr i8, ptr %102, i64 40
  %104 = load ptr, ptr %103, align 8
  %result.i1.i527 = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %105 = call i32 %result.i1.i527({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %2)
  %106 = icmp eq i32 %105, %71
  br i1 %106, label %._crit_edge2.i528, label %114

._crit_edge2.i528:                                ; preds = %89
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %86)
  %109 = getelementptr i8, ptr %102, i64 48
  %110 = load ptr, ptr %109, align 8
  %result.i.i529 = call ptr %110({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %111 = call { ptr, i160 } %result.i.i529({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %2)
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %113 = call i1 %47({ ptr, i160 } %111, { ptr, i160 } %75)
  br i1 %113, label %SwissTable_find_slot_keyK_hashi32.exit530, label %114

114:                                              ; preds = %._crit_edge2.i528, %89, %82, %._crit_edge.i512, %._crit_edge.thread.i507
  %.1533 = phi i32 [ %.0532, %._crit_edge2.i528 ], [ %.0532, %89 ], [ %.0532, %82 ], [ %.0532, %._crit_edge.i512 ], [ %spec.store.select.i508, %._crit_edge.thread.i507 ]
  %spec.store.select9216.i509 = phi i32 [ %.0..0..0..0..0..0.84.i506, %._crit_edge2.i528 ], [ %.0..0..0..0..0..0.84.i506, %89 ], [ %.0..0..0..0..0..0.84.i506, %82 ], [ %.0..0..0..0..0..0.84.i506, %._crit_edge.i512 ], [ %spec.store.select.i508, %._crit_edge.thread.i507 ]
  %115 = add nuw nsw i32 %.0534, 1
  br label %76

116:                                              ; preds = %76
  %.not.i510 = icmp eq i32 %.0..0..0..0..0..0.84.i506, -1
  %.pre.i511 = select i1 %.not.i510, i32 %.0534, i32 %.0532
  %.pre565 = sext i32 %.pre.i511 to i64
  %.pre567 = shl nsw i64 %.pre565, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit530

SwissTable_find_slot_keyK_hashi32.exit530:        ; preds = %116, %._crit_edge2.i528
  %.pre-phi568 = phi i64 [ %.pre567, %116 ], [ %84, %._crit_edge2.i528 ]
  %.pre-phi566 = phi i64 [ %.pre565, %116 ], [ %77, %._crit_edge2.i528 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %117 = getelementptr i8, ptr %result.i10.i, i64 %.pre-phi568
  store ptr %51, ptr %117, align 8
  %118 = getelementptr i8, ptr %117, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i, ptr %118, align 4
  %.sroa_idx120.i = getelementptr i8, ptr %117, i64 16
  store i64 %.sroa.3.0.extract.trunc.i, ptr %.sroa_idx120.i, align 4
  %.sroa_idx121.i = getelementptr i8, ptr %117, i64 24
  store i32 %offset.i34.i, ptr %.sroa_idx121.i, align 4
  %119 = getelementptr i8, ptr %result.i9.i415, i64 %.pre-phi566
  store i8 1, ptr %119, align 1
  %120 = add i32 %48, 1
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i

._crit_edge2.backedge.i:                          ; preds = %SwissTable_find_slot_keyK_hashi32.exit530, %.lr.ph.i
  %122 = phi i32 [ %120, %SwissTable_find_slot_keyK_hashi32.exit530 ], [ %48, %.lr.ph.i ]
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %125 = icmp sgt i32 %storemerge.i, %39
  %126 = add i32 %storemerge.i, 1
  br i1 %125, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i

SwissTable_resize_new_capacityi32.exit:           ; preds = %._crit_edge2.backedge.i, %._crit_edge1.i
  %.lcssa603610 = phi i32 [ 0, %._crit_edge1.i ], [ %122, %._crit_edge2.backedge.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %SwissTable_ensure_capacity_required_sizei32.exit

SwissTable_ensure_capacity_required_sizei32.exit: ; preds = %SwissTable_resize_new_capacityi32.exit, %27
  %127 = phi ptr [ %28, %27 ], [ %result.i9.i415, %SwissTable_resize_new_capacityi32.exit ]
  %128 = phi ptr [ %29, %27 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %.lcssa603608 = phi i32 [ %.lcssa603609, %27 ], [ %.lcssa603610, %SwissTable_resize_new_capacityi32.exit ]
  %129 = phi i32 [ %30, %27 ], [ %spec.select.i, %SwissTable_resize_new_capacityi32.exit ]
  %.sroa.1.8.extract.trunc.i = trunc i64 %indvars.iv to i32
  %130 = add i32 %.sroa.1.8.extract.trunc.i, 2127912214
  %131 = shl i32 %.sroa.1.8.extract.trunc.i, 12
  %132 = add i32 %130, %131
  %133 = ashr i32 %132, 19
  %134 = xor i32 %132, %133
  %135 = xor i32 %134, -949894596
  %136 = add i32 %135, 374761393
  %137 = shl i32 %135, 5
  %138 = add i32 %136, %137
  %139 = add i32 %138, -744332180
  %140 = shl i32 %138, 9
  %141 = xor i32 %139, %140
  %142 = add i32 %141, -42973499
  %143 = shl i32 %141, 3
  %144 = add i32 %142, %143
  %145 = ashr i32 %144, 16
  %146 = xor i32 %144, %145
  %147 = xor i32 %146, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %148 = add i32 %129, -1
  %149 = and i32 %148, %147
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %151 = load ptr, ptr %18, align 8
  br label %152

152:                                              ; preds = %190, %SwissTable_ensure_capacity_required_sizei32.exit
  %.0321 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %.1322, %190 ]
  %.0320 = phi i32 [ %149, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %192, %190 ]
  %.0..0..0..0..0..0.84.i = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %spec.store.select9216.i, %190 ]
  %153 = sext i32 %.0320 to i64
  %154 = getelementptr i8, ptr %127, i64 %153
  %155 = load i8, ptr %154, align 1
  switch i8 %155, label %._crit_edge.i [
    i8 0, label %193
    i8 -128, label %._crit_edge.thread.i
  ]

._crit_edge.thread.i:                             ; preds = %152
  %156 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %spec.store.select.i = select i1 %156, i32 %.0320, i32 %.0..0..0..0..0..0.84.i
  br label %190

._crit_edge.i:                                    ; preds = %152
  %157 = icmp sgt i8 %155, 0
  br i1 %157, label %158, label %190

158:                                              ; preds = %._crit_edge.i
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %160 = shl nsw i64 %153, 5
  %161 = getelementptr i8, ptr %128, i64 %160
  %162 = load ptr, ptr %161, align 8
  %163 = icmp ne ptr %162, @nil_typ
  %164 = icmp ne ptr %162, null
  %.not82.i = and i1 %163, %164
  br i1 %.not82.i, label %165, label %190

165:                                              ; preds = %158
  %166 = getelementptr i8, ptr %161, i64 8
  %167 = load i64, ptr %166, align 4
  %.sroa_idx.i = getelementptr i8, ptr %161, i64 16
  %168 = load i64, ptr %.sroa_idx.i, align 4
  %169 = inttoptr i64 %167 to ptr
  %170 = inttoptr i64 %168 to ptr
  %hash_coef_ptr.i3.i257 = getelementptr i8, ptr %162, i64 8
  %tbl_size_ptr.i4.i258 = getelementptr i8, ptr %162, i64 16
  %offset_tbl_ptr.i5.i259 = getelementptr i8, ptr %162, i64 40
  %hash_coef.i6.i260 = load i64, ptr %hash_coef_ptr.i3.i257, align 4
  %tbl_size.i7.i261 = load i64, ptr %tbl_size_ptr.i4.i258, align 4
  %offset_tbl.i8.i262 = load ptr, ptr %offset_tbl_ptr.i5.i259, align 8
  %product.i.i9.i263 = mul i64 %hash_coef.i6.i260, 4015701072841558310
  %shifted.i.i10.i264 = lshr i64 %product.i.i9.i263, 32
  %xored.i.i11.i265 = xor i64 %shifted.i.i10.i264, %product.i.i9.i263
  %hash.i.i12.i266 = and i64 %xored.i.i11.i265, %tbl_size.i7.i261
  %offset_ptr.i13.i267 = getelementptr i32, ptr %offset_tbl.i8.i262, i64 %hash.i.i12.i266
  %offset.i14.i268 = load i32, ptr %offset_ptr.i13.i267, align 4
  %171 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %162, 0
  %172 = insertvalue { ptr, ptr, ptr, i32 } %171, ptr %169, 1
  %173 = insertvalue { ptr, ptr, ptr, i32 } %172, ptr %170, 2
  %174 = insertvalue { ptr, ptr, ptr, i32 } %173, i32 %offset.i14.i268, 3
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %162)
  %177 = sext i32 %offset.i14.i268 to i64
  %178 = getelementptr ptr, ptr %162, i64 %177
  %179 = getelementptr i8, ptr %178, i64 40
  %180 = load ptr, ptr %179, align 8
  %result.i1.i269 = call ptr %180({ ptr, ptr, ptr, i32 } %174, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %181 = call i32 %result.i1.i269({ ptr, ptr, ptr, i32 } %174, { ptr, ptr, ptr, i32 } %174, ptr nonnull align 8 %2)
  %182 = icmp eq i32 %181, %147
  br i1 %182, label %._crit_edge2.i, label %190

._crit_edge2.i:                                   ; preds = %165
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %162)
  %185 = getelementptr i8, ptr %178, i64 48
  %186 = load ptr, ptr %185, align 8
  %result.i.i270 = call ptr %186({ ptr, ptr, ptr, i32 } %174, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %187 = call { ptr, i160 } %result.i.i270({ ptr, ptr, ptr, i32 } %174, { ptr, ptr, ptr, i32 } %174, ptr nonnull align 8 %2)
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %189 = call i1 %151({ ptr, i160 } %187, { ptr, i160 } %31)
  br i1 %189, label %SwissTable_find_slot_keyK_hashi32.exit, label %190

190:                                              ; preds = %._crit_edge2.i, %165, %158, %._crit_edge.i, %._crit_edge.thread.i
  %.1322 = phi i32 [ %.0321, %._crit_edge2.i ], [ %.0321, %165 ], [ %.0321, %158 ], [ %.0321, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %spec.store.select9216.i = phi i32 [ %.0..0..0..0..0..0.84.i, %._crit_edge2.i ], [ %.0..0..0..0..0..0.84.i, %165 ], [ %.0..0..0..0..0..0.84.i, %158 ], [ %.0..0..0..0..0..0.84.i, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %191 = add i32 %.0320, 1
  %192 = and i32 %191, %148
  br label %152

193:                                              ; preds = %152
  %.not.i256 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %.pre.i = select i1 %.not.i256, i32 %.0320, i32 %.0321
  %.pre = sext i32 %.pre.i to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit

SwissTable_find_slot_keyK_hashi32.exit:           ; preds = %193, %._crit_edge2.i
  %.pre-phi = phi i64 [ %.pre, %193 ], [ %153, %._crit_edge2.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %195 = getelementptr i8, ptr %127, i64 %.pre-phi
  %196 = load i8, ptr %195, align 1
  %result.i9.i = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  store ptr @_parameterization_i32, ptr %result.i9.i, align 8
  %197 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr @_parameterization_i32, ptr %197, align 8
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9.i)
  %199 = getelementptr inbounds i8, ptr %result.i9.i, i64 20
  store i32 %.sroa.1.8.extract.trunc.i, ptr %199, align 4
  %200 = getelementptr inbounds i8, ptr %result.i9.i, i64 24
  %.sroa.1.8.extract.trunc.i711 = trunc i64 %indvars.iv.next to i32
  store i32 %.sroa.1.8.extract.trunc.i711, ptr %200, align 8
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %202 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %147, ptr %202, align 8
  %203 = icmp eq i8 %196, 0
  br i1 %203, label %204, label %SwissTable_insert_keyK_valueV.exit

204:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit
  store i8 1, ptr %195, align 1
  %205 = add i32 %.lcssa603608, 1
  br label %SwissTable_insert_keyK_valueV.exit

SwissTable_insert_keyK_valueV.exit:               ; preds = %204, %SwissTable_find_slot_keyK_hashi32.exit
  %.lcssa603607 = phi i32 [ %.lcssa603608, %SwissTable_find_slot_keyK_hashi32.exit ], [ %205, %204 ]
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %207 = shl nsw i64 %.pre-phi, 5
  %208 = getelementptr i8, ptr %128, i64 %207
  store ptr @Entry, ptr %208, align 8
  %209 = getelementptr i8, ptr %208, i64 8
  %210 = ptrtoint ptr %result.i9.i to i64
  store i64 %210, ptr %209, align 4
  %.sroa_idx3.i = getelementptr i8, ptr %208, i64 24
  store i32 10, ptr %.sroa_idx3.i, align 4
  %211 = add i64 %.030473, %indvars.iv.next
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %.lr.ph, label %27

.lr.ph:                                           ; preds = %SwissTable_insert_keyK_valueV.exit
  store i32 %129, ptr %21, align 8
  store i32 %.lcssa603607, ptr %23, align 4
  store ptr %128, ptr %19, align 8
  store ptr %127, ptr %20, align 8
  %212 = call i64 @clock()
  %213 = getelementptr inbounds i8, ptr %3, i64 8
  %214 = load ptr, ptr %17, align 8
  %215 = load ptr, ptr %18, align 8
  br label %216

216:                                              ; preds = %._crit_edge2, %.lr.ph
  %.286 = phi i32 [ 0, %.lr.ph ], [ %303, %._crit_edge2 ]
  %.030685 = phi i64 [ 0, %.lr.ph ], [ %.1307, %._crit_edge2 ]
  %.030984 = phi i1 [ true, %.lr.ph ], [ %.1310, %._crit_edge2 ]
  %.031383 = phi i32 [ 0, %.lr.ph ], [ %.2315, %._crit_edge2 ]
  %.sroa.0280.0.insert.ext = zext nneg i32 %.286 to i160
  %217 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0280.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %219 = call i32 %214({ ptr, i160 } %217)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %220 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %221

221:                                              ; preds = %259, %216
  %.0319 = phi i32 [ -1, %216 ], [ %.1, %259 ]
  %.pn672 = phi i32 [ %219, %216 ], [ %260, %259 ]
  %.0..0..0..0..0..0.84.i286 = phi i32 [ -1, %216 ], [ %spec.store.select9216.i290, %259 ]
  %.0 = and i32 %.pn672, %148
  %222 = sext i32 %.0 to i64
  %223 = getelementptr i8, ptr %127, i64 %222
  %224 = load i8, ptr %223, align 1
  switch i8 %224, label %._crit_edge.i295 [
    i8 0, label %261
    i8 -128, label %._crit_edge.thread.i288
  ]

._crit_edge.thread.i288:                          ; preds = %221
  %225 = icmp eq i32 %.0..0..0..0..0..0.84.i286, -1
  %spec.store.select.i289 = select i1 %225, i32 %.0, i32 %.0..0..0..0..0..0.84.i286
  br label %259

._crit_edge.i295:                                 ; preds = %221
  %226 = icmp sgt i8 %224, 0
  br i1 %226, label %227, label %259

227:                                              ; preds = %._crit_edge.i295
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %229 = shl nsw i64 %222, 5
  %230 = getelementptr i8, ptr %128, i64 %229
  %231 = load ptr, ptr %230, align 8
  %232 = icmp ne ptr %231, @nil_typ
  %233 = icmp ne ptr %231, null
  %.not82.i297 = and i1 %232, %233
  br i1 %.not82.i297, label %234, label %259

234:                                              ; preds = %227
  %235 = getelementptr i8, ptr %230, i64 8
  %236 = load i64, ptr %235, align 4
  %.sroa_idx.i298 = getelementptr i8, ptr %230, i64 16
  %237 = load i64, ptr %.sroa_idx.i298, align 4
  %238 = inttoptr i64 %236 to ptr
  %239 = inttoptr i64 %237 to ptr
  %hash_coef_ptr.i3.i299 = getelementptr i8, ptr %231, i64 8
  %tbl_size_ptr.i4.i300 = getelementptr i8, ptr %231, i64 16
  %offset_tbl_ptr.i5.i301 = getelementptr i8, ptr %231, i64 40
  %hash_coef.i6.i302 = load i64, ptr %hash_coef_ptr.i3.i299, align 4
  %tbl_size.i7.i303 = load i64, ptr %tbl_size_ptr.i4.i300, align 4
  %offset_tbl.i8.i304 = load ptr, ptr %offset_tbl_ptr.i5.i301, align 8
  %product.i.i9.i305 = mul i64 %hash_coef.i6.i302, 4015701072841558310
  %shifted.i.i10.i306 = lshr i64 %product.i.i9.i305, 32
  %xored.i.i11.i307 = xor i64 %shifted.i.i10.i306, %product.i.i9.i305
  %hash.i.i12.i308 = and i64 %xored.i.i11.i307, %tbl_size.i7.i303
  %offset_ptr.i13.i309 = getelementptr i32, ptr %offset_tbl.i8.i304, i64 %hash.i.i12.i308
  %offset.i14.i310 = load i32, ptr %offset_ptr.i13.i309, align 4
  %240 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %231, 0
  %241 = insertvalue { ptr, ptr, ptr, i32 } %240, ptr %238, 1
  %242 = insertvalue { ptr, ptr, ptr, i32 } %241, ptr %239, 2
  %243 = insertvalue { ptr, ptr, ptr, i32 } %242, i32 %offset.i14.i310, 3
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %231)
  %246 = sext i32 %offset.i14.i310 to i64
  %247 = getelementptr ptr, ptr %231, i64 %246
  %248 = getelementptr i8, ptr %247, i64 40
  %249 = load ptr, ptr %248, align 8
  %result.i1.i311 = call ptr %249({ ptr, ptr, ptr, i32 } %243, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %250 = call i32 %result.i1.i311({ ptr, ptr, ptr, i32 } %243, { ptr, ptr, ptr, i32 } %243, ptr nonnull align 8 %2)
  %251 = icmp eq i32 %250, %219
  br i1 %251, label %._crit_edge2.i312, label %259

._crit_edge2.i312:                                ; preds = %234
  %252 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %253 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %231)
  %254 = getelementptr i8, ptr %247, i64 48
  %255 = load ptr, ptr %254, align 8
  %result.i.i313 = call ptr %255({ ptr, ptr, ptr, i32 } %243, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %256 = call { ptr, i160 } %result.i.i313({ ptr, ptr, ptr, i32 } %243, { ptr, ptr, ptr, i32 } %243, ptr nonnull align 8 %2)
  %257 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %258 = call i1 %215({ ptr, i160 } %256, { ptr, i160 } %217)
  br i1 %258, label %SwissTable_find_slot_keyK_hashi32.exit315, label %259

259:                                              ; preds = %._crit_edge2.i312, %234, %227, %._crit_edge.i295, %._crit_edge.thread.i288
  %.1 = phi i32 [ %.0319, %._crit_edge2.i312 ], [ %.0319, %234 ], [ %.0319, %227 ], [ %.0319, %._crit_edge.i295 ], [ %spec.store.select.i289, %._crit_edge.thread.i288 ]
  %spec.store.select9216.i290 = phi i32 [ %.0..0..0..0..0..0.84.i286, %._crit_edge2.i312 ], [ %.0..0..0..0..0..0.84.i286, %234 ], [ %.0..0..0..0..0..0.84.i286, %227 ], [ %.0..0..0..0..0..0.84.i286, %._crit_edge.i295 ], [ %spec.store.select.i289, %._crit_edge.thread.i288 ]
  %260 = add i32 %.0, 1
  br label %221

261:                                              ; preds = %221
  %.not.i291 = icmp eq i32 %.0..0..0..0..0..0.84.i286, -1
  %.pre.i294 = select i1 %.not.i291, i32 %.0, i32 %.0319
  %.pre336 = sext i32 %.pre.i294 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit315

SwissTable_find_slot_keyK_hashi32.exit315:        ; preds = %261, %._crit_edge2.i312
  %.pre-phi337 = phi i64 [ %.pre336, %261 ], [ %222, %._crit_edge2.i312 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %262 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %263 = getelementptr i8, ptr %127, i64 %.pre-phi337
  %264 = load i8, ptr %263, align 1
  switch i8 %264, label %265 [
    i8 -128, label %SwissTable_get_keyK.exit.thread
    i8 0, label %SwissTable_get_keyK.exit.thread
  ]

265:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit315
  %266 = shl nsw i64 %.pre-phi337, 5
  %267 = getelementptr i8, ptr %128, i64 %266
  %268 = load ptr, ptr %267, align 8
  %269 = icmp ne ptr %268, @nil_typ
  %270 = icmp ne ptr %268, null
  %.not74.i = and i1 %269, %270
  br i1 %.not74.i, label %SwissTable_get_keyK.exit, label %SwissTable_get_keyK.exit.thread

SwissTable_get_keyK.exit.thread:                  ; preds = %265, %SwissTable_find_slot_keyK_hashi32.exit315, %SwissTable_find_slot_keyK_hashi32.exit315
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %291

SwissTable_get_keyK.exit:                         ; preds = %265
  %271 = getelementptr i8, ptr %267, i64 8
  %272 = load i160, ptr %271, align 4
  %.sroa.262.0.extract.shift.i = lshr i160 %272, 64
  %.sroa.262.0.extract.trunc.i = trunc i160 %.sroa.262.0.extract.shift.i to i64
  %.sroa.061.0.extract.trunc.i = trunc i160 %272 to i64
  %273 = inttoptr i64 %.sroa.061.0.extract.trunc.i to ptr
  %274 = inttoptr i64 %.sroa.262.0.extract.trunc.i to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %268, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %268, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %268, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %275 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %268, 0
  %276 = insertvalue { ptr, ptr, ptr, i32 } %275, ptr %273, 1
  %277 = insertvalue { ptr, ptr, ptr, i32 } %276, ptr %274, 2
  %278 = insertvalue { ptr, ptr, ptr, i32 } %277, i32 %offset.i14.i, 3
  %279 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %268)
  %281 = sext i32 %offset.i14.i to i64
  %282 = getelementptr ptr, ptr %268, i64 %281
  %283 = getelementptr i8, ptr %282, i64 56
  %284 = load ptr, ptr %283, align 8
  %result.i1.i135 = call ptr %284({ ptr, ptr, ptr, i32 } %278, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %285 = call { ptr, i160 } %result.i1.i135({ ptr, ptr, ptr, i32 } %278, { ptr, ptr, ptr, i32 } %278, ptr nonnull align 8 %2)
  %.fca.0.extract49.i = extractvalue { ptr, i160 } %285, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %286 = icmp ne ptr %.fca.0.extract49.i, @nil_typ
  %287 = icmp ne ptr %.fca.0.extract49.i, null
  %.not323 = and i1 %286, %287
  br i1 %.not323, label %288, label %291

288:                                              ; preds = %SwissTable_get_keyK.exit
  %.fca.1.extract50.i = extractvalue { ptr, i160 } %285, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract50.i to i64
  %sext = shl i64 %.sroa.2.8.extract.trunc, 32
  %289 = ashr exact i64 %sext, 32
  %290 = add i64 %289, %.030685
  br label %._crit_edge2

291:                                              ; preds = %SwissTable_get_keyK.exit, %SwissTable_get_keyK.exit.thread
  %292 = icmp slt i32 %.031383, 10
  br i1 %292, label %RangeIterator_next_.exit52.i.preheader, label %._crit_edge2

RangeIterator_next_.exit52.i.preheader:           ; preds = %291
  %result.i25 = call noalias nonnull dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store <55 x i8> <i8 69, i8 114, i8 114, i8 111, i8 114, i8 58, i8 32, i8 78, i8 105, i8 108, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i25, align 1
  store ptr @_parameterization_Bufferi8, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %213, align 8
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %3)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %294 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %295 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i = call noalias nonnull dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  %296 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 69, ptr %result.i5.i, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i, i64 1
  %scevgep442 = getelementptr inbounds i8, ptr %result.i25, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(55) %scevgep, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(55) %scevgep442, i64 noundef 54, i1 noundef false)
  %297 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %298 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %299 = getelementptr inbounds i8, ptr %result.i5.i, i64 55
  store i8 0, ptr %299, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(56) %result.i5.i) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %300 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %301 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.286) #59
  %302 = add nsw i32 %.031383, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %291, %288
  %.2315 = phi i32 [ %.031383, %288 ], [ %302, %RangeIterator_next_.exit52.i.preheader ], [ %.031383, %291 ]
  %.1310 = phi i1 [ %.030984, %288 ], [ false, %RangeIterator_next_.exit52.i.preheader ], [ false, %291 ]
  %.1307 = phi i64 [ %290, %288 ], [ %.030685, %RangeIterator_next_.exit52.i.preheader ], [ %.030685, %291 ]
  %303 = add nuw nsw i32 %.286, 1
  %exitcond97.not = icmp eq i32 %303, %0
  br i1 %exitcond97.not, label %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit, label %216

IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit: ; preds = %._crit_edge2
  %.sroa.gep330 = getelementptr inbounds i8, ptr %5, i64 24
  %304 = getelementptr inbounds i8, ptr %3, i64 16
  %.sroa.gep324 = getelementptr inbounds i8, ptr %5, i64 8
  %.sroa.gep336 = getelementptr inbounds i8, ptr %4, i64 16
  br label %RangeIterator_next_.exit52.i.preheader1144

RangeIterator_next_.exit52.i.preheader1144:       ; preds = %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit, %._crit_edge1._crit_edge.thread
  %305 = phi ptr [ %26, %._crit_edge1._crit_edge.thread ], [ %304, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  %306 = phi i64 [ %25, %._crit_edge1._crit_edge.thread ], [ %212, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  %.sroa.gep336105 = phi ptr [ %.sroa.gep336101, %._crit_edge1._crit_edge.thread ], [ %.sroa.gep336, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  %.sroa.gep330104 = phi ptr [ %.sroa.gep330100, %._crit_edge1._crit_edge.thread ], [ %.sroa.gep330, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  %.sroa.gep324103 = phi ptr [ %.sroa.gep32499, %._crit_edge1._crit_edge.thread ], [ %.sroa.gep324, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  %.0304.lcssa102 = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %211, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  %.0309.lcssa = phi i1 [ true, %._crit_edge1._crit_edge.thread ], [ %.1310, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  %.0306.lcssa = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %.1307, %IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter.exit49.loopexit ]
  store ptr @_parameterization_i32, ptr %305, align 8
  %.sroa.gep333 = getelementptr inbounds i8, ptr %4, i64 8
  %307 = call i64 @clock()
  %.not = icmp eq i64 %.0306.lcssa, %.0304.lcssa102
  %result.i23 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i23, align 1
  %308 = sub i64 %307, %306
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #43
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %311 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #43
  %result.i5.i1065 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  %312 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %313 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %314 = load i8, ptr %result.i23, align 1
  store i8 %314, ptr %result.i5.i1065, align 1
  %315 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %316 = getelementptr i8, ptr %result.i23, i64 1
  %wide.load = load <16 x i8>, ptr %316, align 1
  %317 = getelementptr i8, ptr %result.i5.i1065, i64 1
  store <16 x i8> %wide.load, ptr %317, align 1
  %318 = getelementptr i8, ptr %result.i23, i64 17
  %319 = load i8, ptr %318, align 1
  %320 = getelementptr i8, ptr %result.i5.i1065, i64 17
  store i8 %319, ptr %320, align 1
  %321 = getelementptr i8, ptr %result.i5.i1065, i64 18
  store i8 0, ptr %321, align 1
  %puts.i950 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i1065) #52
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %322 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %322, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #59
  %323 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #59
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %324 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %324, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #59
  %325 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %308) #59
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #59
  br i1 %24, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader1144
  %326 = zext nneg i32 %0 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %327 = mul i64 %308, 1000000
  %328 = sdiv i64 %327, %326
  %329 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %329, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #59
  %330 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %328) #59
  %331 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #60
  %332 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %333 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %334 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #59
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader1144
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  %result.i21 = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i21, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %335 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i359 = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #51
  store i8 32, ptr %result.i5.i359, align 1
  %scevgep446 = getelementptr inbounds i8, ptr %result.i5.i359, i64 1
  %scevgep447 = getelementptr inbounds i8, ptr %result.i21, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(18) %scevgep446, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(18) %scevgep447, i64 noundef 17, i1 noundef false)
  %.sroa.gep327 = getelementptr inbounds i8, ptr %5, i64 16
  %.sroa.gep339 = getelementptr inbounds i8, ptr %4, i64 24
  %spec.select = select i1 %.not, i1 %.0309.lcssa, i1 false
  %337 = getelementptr inbounds i8, ptr %result.i5.i359, i64 18
  store i8 0, ptr %337, align 1
  %puts.i220 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i359) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %result.i19 = call noalias nonnull dereferenceable(5) ptr @bump_malloc_wrapper(i64 noundef 5) #51
  %.fca.0.extract = select i1 %spec.select, i8 80, i8 70
  %.sroa.0191.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.3 = select i1 %spec.select, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>, <4 x i8> %.sroa.0191.0.vec.insert
  %.sroa.0191.3 = select i1 %spec.select, <4 x i8> %.sroa.0191.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0191.1.vec.insert = insertelement <4 x i8> %.sroa.0191.3, i8 65, i64 1
  %.sroa.0.1.vec.insert = insertelement <4 x i8> %.sroa.0.3, i8 65, i64 1
  %.sroa.0.2 = select i1 %spec.select, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>, <4 x i8> %.sroa.0.1.vec.insert
  %.fca.2.extract = select i1 %spec.select, i8 83, i8 73
  %.sroa.0191.2 = select i1 %spec.select, <4 x i8> %.sroa.0191.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0191.2.vec.insert = insertelement <4 x i8> %.sroa.0191.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.2.vec.insert = insertelement <4 x i8> %.sroa.0.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.1 = select i1 %spec.select, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>, <4 x i8> %.sroa.0.2.vec.insert
  %.fca.3.extract = select i1 %spec.select, i8 83, i8 76
  %.sroa.0191.1 = select i1 %spec.select, <4 x i8> %.sroa.0191.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0191.3.vec.insert = insertelement <4 x i8> %.sroa.0191.1, i8 %.fca.3.extract, i64 3
  %.sroa.0.3.vec.insert = insertelement <4 x i8> %.sroa.0.1, i8 %.fca.3.extract, i64 3
  %.sroa.speculated190 = select i1 %spec.select, <4 x i8> %.sroa.0191.3.vec.insert, <4 x i8> %.sroa.0.3.vec.insert
  store <4 x i8> %.sroa.speculated190, ptr %result.i19, align 1
  br i1 %spec.select, label %RangeIterator_next_.exit52.i381.preheader, label %._crit_edge5.else

._crit_edge5.else:                                ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i381.preheader

RangeIterator_next_.exit52.i381.preheader:        ; preds = %._crit_edge5.else, %print_benchmark_result.exit
  %338 = phi ptr [ %11, %._crit_edge5.else ], [ %7, %print_benchmark_result.exit ]
  %339 = phi ptr [ %10, %._crit_edge5.else ], [ %6, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %._crit_edge5.else ], [ %.sroa.gep324103, %print_benchmark_result.exit ]
  %.sroa.phi325 = phi ptr [ %.sroa.gep326, %._crit_edge5.else ], [ %.sroa.gep327, %print_benchmark_result.exit ]
  %.sroa.phi328 = phi ptr [ %.sroa.gep329, %._crit_edge5.else ], [ %.sroa.gep330104, %print_benchmark_result.exit ]
  %340 = phi ptr [ %9, %._crit_edge5.else ], [ %5, %print_benchmark_result.exit ]
  %.sroa.phi331 = phi ptr [ %.sroa.gep332, %._crit_edge5.else ], [ %.sroa.gep333, %print_benchmark_result.exit ]
  %.sroa.phi334 = phi ptr [ %.sroa.gep335, %._crit_edge5.else ], [ %.sroa.gep336105, %print_benchmark_result.exit ]
  %.sroa.phi337 = phi ptr [ %.sroa.gep338, %._crit_edge5.else ], [ %.sroa.gep339, %print_benchmark_result.exit ]
  %341 = phi ptr [ %8, %._crit_edge5.else ], [ %4, %print_benchmark_result.exit ]
  %342 = extractelement <4 x i8> %.sroa.speculated190, i64 0
  store ptr @_parameterization_Bufferi8, ptr %341, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi331, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi334, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi337, align 8
  %343 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %341)
  store ptr @buffer_typ, ptr %340, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi325, align 8
  store ptr @i32_typ, ptr %.sroa.phi328, align 8
  %344 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %340) #43
  store ptr @_parameterization_String, ptr %339, align 8
  %345 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %339)
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %338, align 8
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %338) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %348 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %349 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i378 = call noalias nonnull dereferenceable(5) ptr @bump_malloc_wrapper(i64 noundef 5) #51
  %350 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 %342, ptr %result.i5.i378, align 1
  %scevgep451 = getelementptr inbounds i8, ptr %result.i5.i378, i64 1
  %scevgep452 = getelementptr inbounds i8, ptr %result.i19, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(4) %scevgep451, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(4) %scevgep452, i64 noundef 3, i1 noundef false)
  %351 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %352 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %353 = getelementptr inbounds i8, ptr %result.i5.i378, i64 4
  store i8 0, ptr %353, align 1
  %puts.i240 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i378) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr #17 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i867.h2s1788 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i867.h2s1788, i8 0, i64 5, i1 false)
  %result.i5.i848.h2s1790 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i848.h2s1790, i8 0, i64 19, i1 false)
  %result.i5.i810.h2s1792 = alloca [34 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(34) %result.i5.i810.h2s1792, i8 0, i64 34, i1 false)
  %result.i5.i.h2s1794 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i.h2s1794, i8 0, i64 30, i1 false)
  %result.i51.h2s1796 = alloca [64 x i8], align 8
  %3 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 24
  %result.i56.h2s1797 = alloca [64 x i8], align 8
  %4 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 24
  %5 = alloca [2 x ptr], align 8
  %oldProtect.i62 = alloca i32, align 4
  %oldProtect.i60 = alloca i32, align 4
  %oldProtect.i58 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0399.sroa.0 = alloca i8, align 8
  %6 = alloca [4 x ptr], align 8
  %7 = alloca { ptr, ptr, ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [4 x ptr], align 8
  %11 = alloca { ptr, ptr, ptr, ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  store ptr @_parameterization_i32, ptr %result.i56.h2s1797, align 8
  %14 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 8
  store ptr @_parameterization_i32, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i56.h2s1797) #60
  %result.i55 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  %result.i57 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i55, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i55, ptr noalias nofree noundef nonnull readnone @slwynonqqw, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i36 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i55) #50
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i55) #60
  %result.i54 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i58) #60
  %result.i59 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i54, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i58) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i58) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i54, ptr noalias nofree noundef nonnull readnone @xfosmqkvur, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i35 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i54) #50
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i54) #60
  %19 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 48
  store ptr %ret.i36, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 56
  store ptr %ret.i35, ptr %20, align 8
  %result.i1.i180 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  store ptr %result.i1.i180, ptr %4, align 8
  %result.i.i181 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %21 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 32
  store ptr %result.i.i181, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 40
  %23 = getelementptr inbounds i8, ptr %result.i56.h2s1797, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %22, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #43
  %25 = sext i32 %0 to i64
  %26 = shl nsw i64 %25, 2
  %result.i2.i209 = call noalias ptr @bump_malloc_wrapper(i64 noundef %26) #51
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  store ptr @_parameterization_i32, ptr %result.i51.h2s1796, align 8
  %28 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 8
  store ptr @_parameterization_Bool, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %29, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i51.h2s1796) #60
  %result.i50 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i60) #60
  %result.i61 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i50, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i60) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i60) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i50, ptr noalias nofree noundef nonnull readnone @yyrxzjdgkt, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i34 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i50) #50
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i50) #60
  %result.i49 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #60
  %result.i63 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i49, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i49, ptr noalias nofree noundef nonnull readnone @eoisxijnjo, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i49) #50
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i49) #60
  %33 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 48
  store ptr %ret.i34, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 56
  store ptr %ret.i, ptr %34, align 8
  %result.i1.i223 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  store ptr %result.i1.i223, ptr %3, align 8
  %result.i.i224 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %35 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 32
  store ptr %result.i.i224, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 40
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %38 = getelementptr inbounds i8, ptr %result.i51.h2s1796, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %36, align 8
  %39 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %11, i64 8
  %.sroa.gep467 = getelementptr inbounds i8, ptr %11, i64 16
  %.sroa.gep470 = getelementptr inbounds i8, ptr %11, i64 24
  %.sroa.gep473 = getelementptr inbounds i8, ptr %10, i64 8
  %.sroa.gep476 = getelementptr inbounds i8, ptr %10, i64 16
  %.sroa.gep479 = getelementptr inbounds i8, ptr %10, i64 24
  %40 = icmp sgt i32 %0, 0
  %41 = icmp sgt i32 %39, 0
  %spec.select149 = and i1 %40, %41
  br i1 %spec.select149, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #43
  %44 = getelementptr inbounds i8, ptr %5, i64 8
  br label %45

45:                                               ; preds = %._crit_edge1, %.lr.ph
  %46 = phi ptr [ %result.i1.i180, %.lr.ph ], [ %587, %._crit_edge1 ]
  %47 = phi ptr [ %result.i.i181, %.lr.ph ], [ %588, %._crit_edge1 ]
  %.pre9081420 = phi ptr [ %result.i.i181, %.lr.ph ], [ %.pre9081421, %._crit_edge1 ]
  %48 = phi ptr [ %result.i.i181, %.lr.ph ], [ %589, %._crit_edge1 ]
  %49 = phi i32 [ 8, %.lr.ph ], [ %590, %._crit_edge1 ]
  %50 = phi ptr [ %result.i1.i180, %.lr.ph ], [ %591, %._crit_edge1 ]
  %51 = phi i32 [ 0, %.lr.ph ], [ %592, %._crit_edge1 ]
  %52 = phi i32 [ 8, %.lr.ph ], [ %593, %._crit_edge1 ]
  %53 = phi ptr [ %result.i1.i223, %.lr.ph ], [ %594, %._crit_edge1 ]
  %.pre907 = phi ptr [ %result.i.i224, %.lr.ph ], [ %.pre9071419, %._crit_edge1 ]
  %54 = phi ptr [ %ret.i, %.lr.ph ], [ %595, %._crit_edge1 ]
  %55 = phi ptr [ %result.i.i224, %.lr.ph ], [ %596, %._crit_edge1 ]
  %56 = phi i32 [ 8, %.lr.ph ], [ %597, %._crit_edge1 ]
  %57 = phi ptr [ %ret.i34, %.lr.ph ], [ %598, %._crit_edge1 ]
  %58 = phi i32 [ 456, %.lr.ph ], [ %61, %._crit_edge1 ]
  %.0437155 = phi i32 [ 0, %.lr.ph ], [ %599, %._crit_edge1 ]
  %.0438154 = phi i32 [ 0, %.lr.ph ], [ %.1439, %._crit_edge1 ]
  %.0454153 = phi i64 [ 0, %.lr.ph ], [ %.1455, %._crit_edge1 ]
  %59 = mul i32 %58, 1103515245
  %60 = add i32 %59, 12345
  %61 = and i32 %60, 2147483647
  %.sroa.0427.0.insert.ext = zext nneg i32 %61 to i160
  %62 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0427.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #60
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %64 = call i32 %57({ ptr, i160 } %62)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %65 = add i32 %56, -1
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %67

67:                                               ; preds = %105, %45
  %.pn = phi i32 [ %64, %45 ], [ %106, %105 ]
  %.0745 = phi i32 [ -1, %45 ], [ %.1746, %105 ]
  %.0..0..0..0..0..0.84.i = phi i32 [ -1, %45 ], [ %spec.store.select9216.i, %105 ]
  %.0747 = and i32 %.pn, %65
  %68 = sext i32 %.0747 to i64
  %69 = getelementptr i8, ptr %55, i64 %68
  %70 = load i8, ptr %69, align 1
  switch i8 %70, label %._crit_edge.i [
    i8 0, label %107
    i8 -128, label %._crit_edge.thread.i
  ]

._crit_edge.thread.i:                             ; preds = %67
  %71 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %spec.store.select.i = select i1 %71, i32 %.0747, i32 %.0..0..0..0..0..0.84.i
  br label %105

._crit_edge.i:                                    ; preds = %67
  %72 = icmp sgt i8 %70, 0
  br i1 %72, label %73, label %105

73:                                               ; preds = %._crit_edge.i
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %75 = shl nsw i64 %68, 5
  %76 = getelementptr i8, ptr %53, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = icmp ne ptr %77, @nil_typ
  %79 = icmp ne ptr %77, null
  %.not82.i = and i1 %78, %79
  br i1 %.not82.i, label %80, label %105

80:                                               ; preds = %73
  %81 = getelementptr i8, ptr %76, i64 8
  %82 = load i64, ptr %81, align 4
  %.sroa_idx.i = getelementptr i8, ptr %76, i64 16
  %83 = load i64, ptr %.sroa_idx.i, align 4
  %84 = inttoptr i64 %82 to ptr
  %85 = inttoptr i64 %83 to ptr
  %hash_coef_ptr.i3.i544 = getelementptr i8, ptr %77, i64 8
  %tbl_size_ptr.i4.i545 = getelementptr i8, ptr %77, i64 16
  %offset_tbl_ptr.i5.i546 = getelementptr i8, ptr %77, i64 40
  %hash_coef.i6.i547 = load i64, ptr %hash_coef_ptr.i3.i544, align 4
  %tbl_size.i7.i548 = load i64, ptr %tbl_size_ptr.i4.i545, align 4
  %offset_tbl.i8.i549 = load ptr, ptr %offset_tbl_ptr.i5.i546, align 8
  %product.i.i9.i550 = mul i64 %hash_coef.i6.i547, 4015701072841558310
  %shifted.i.i10.i551 = lshr i64 %product.i.i9.i550, 32
  %xored.i.i11.i552 = xor i64 %shifted.i.i10.i551, %product.i.i9.i550
  %hash.i.i12.i553 = and i64 %xored.i.i11.i552, %tbl_size.i7.i548
  %offset_ptr.i13.i554 = getelementptr i32, ptr %offset_tbl.i8.i549, i64 %hash.i.i12.i553
  %offset.i14.i555 = load i32, ptr %offset_ptr.i13.i554, align 4
  %86 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %77, 0
  %87 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %84, 1
  %88 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %85, 2
  %89 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %offset.i14.i555, 3
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %77)
  %92 = sext i32 %offset.i14.i555 to i64
  %93 = getelementptr ptr, ptr %77, i64 %92
  %94 = getelementptr i8, ptr %93, i64 40
  %95 = load ptr, ptr %94, align 8
  %result.i1.i = call ptr %95({ ptr, ptr, ptr, i32 } %89, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %96 = call i32 %result.i1.i({ ptr, ptr, ptr, i32 } %89, { ptr, ptr, ptr, i32 } %89, ptr nonnull align 8 %2)
  %97 = icmp eq i32 %96, %64
  br i1 %97, label %._crit_edge2.i, label %105

._crit_edge2.i:                                   ; preds = %80
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %77)
  %100 = getelementptr i8, ptr %93, i64 48
  %101 = load ptr, ptr %100, align 8
  %result.i.i556 = call ptr %101({ ptr, ptr, ptr, i32 } %89, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %102 = call { ptr, i160 } %result.i.i556({ ptr, ptr, ptr, i32 } %89, { ptr, ptr, ptr, i32 } %89, ptr nonnull align 8 %2)
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %104 = call i1 %54({ ptr, i160 } %102, { ptr, i160 } %62)
  br i1 %104, label %SwissTable_find_slot_keyK_hashi32.exit, label %105

105:                                              ; preds = %._crit_edge2.i, %80, %73, %._crit_edge.i, %._crit_edge.thread.i
  %.1746 = phi i32 [ %.0745, %._crit_edge2.i ], [ %.0745, %80 ], [ %.0745, %73 ], [ %.0745, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %spec.store.select9216.i = phi i32 [ %.0..0..0..0..0..0.84.i, %._crit_edge2.i ], [ %.0..0..0..0..0..0.84.i, %80 ], [ %.0..0..0..0..0..0.84.i, %73 ], [ %.0..0..0..0..0..0.84.i, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %106 = add nuw i32 %.0747, 1
  br label %67

107:                                              ; preds = %67
  %.not.i = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %.pre.i = select i1 %.not.i, i32 %.0747, i32 %.0745
  %.pre = sext i32 %.pre.i to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit

SwissTable_find_slot_keyK_hashi32.exit:           ; preds = %107, %._crit_edge2.i
  %108 = phi ptr [ %55, %107 ], [ %.pre907, %._crit_edge2.i ]
  %.pre-phi = phi i64 [ %.pre, %107 ], [ %68, %._crit_edge2.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %110 = getelementptr i8, ptr %108, i64 %.pre-phi
  %111 = load i8, ptr %110, align 1
  switch i8 %111, label %112 [
    i8 -128, label %SwissTable_get_keyK.exit.thread
    i8 0, label %SwissTable_get_keyK.exit.thread
  ]

112:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit
  %113 = shl nsw i64 %.pre-phi, 5
  %114 = getelementptr i8, ptr %53, i64 %113
  %115 = load ptr, ptr %114, align 8
  %116 = icmp ne ptr %115, @nil_typ
  %117 = icmp ne ptr %115, null
  %.not74.i = and i1 %116, %117
  br i1 %.not74.i, label %SwissTable_get_keyK.exit, label %SwissTable_get_keyK.exit.thread

SwissTable_get_keyK.exit.thread:                  ; preds = %112, %SwissTable_find_slot_keyK_hashi32.exit, %SwissTable_find_slot_keyK_hashi32.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %136

SwissTable_get_keyK.exit:                         ; preds = %112
  %118 = getelementptr i8, ptr %114, i64 8
  %119 = load i160, ptr %118, align 4
  %.sroa.262.0.extract.shift.i = lshr i160 %119, 64
  %.sroa.262.0.extract.trunc.i = trunc i160 %.sroa.262.0.extract.shift.i to i64
  %.sroa.061.0.extract.trunc.i = trunc i160 %119 to i64
  %120 = inttoptr i64 %.sroa.061.0.extract.trunc.i to ptr
  %121 = inttoptr i64 %.sroa.262.0.extract.trunc.i to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %115, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %115, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %115, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %122 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %115, 0
  %123 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %120, 1
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %121, 2
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %offset.i14.i, 3
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %115)
  %128 = sext i32 %offset.i14.i to i64
  %129 = getelementptr ptr, ptr %115, i64 %128
  %130 = getelementptr i8, ptr %129, i64 56
  %131 = load ptr, ptr %130, align 8
  %result.i1.i253 = call ptr %131({ ptr, ptr, ptr, i32 } %125, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %132 = call { ptr, i160 } %result.i1.i253({ ptr, ptr, ptr, i32 } %125, { ptr, ptr, ptr, i32 } %125, ptr nonnull align 8 %2)
  %.fca.0.extract49.i = extractvalue { ptr, i160 } %132, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %133 = icmp eq ptr %.fca.0.extract49.i, @nil_typ
  %134 = icmp eq ptr %.fca.0.extract49.i, null
  %135 = or i1 %133, %134
  br i1 %135, label %136, label %._crit_edge1

136:                                              ; preds = %SwissTable_get_keyK.exit, %SwissTable_get_keyK.exit.thread
  %137 = add nuw i32 %61, 1
  %138 = icmp eq i32 %52, 0
  br i1 %138, label %._crit_edge1.i, label %139

139:                                              ; preds = %136
  %140 = add i32 %51, 1
  %141 = mul i32 %52, 7
  %142 = sdiv i32 %141, 10
  %.not.i571 = icmp slt i32 %140, %142
  br i1 %.not.i571, label %SwissTable_ensure_capacity_required_sizei32.exit, label %._crit_edge1.i

._crit_edge1.i:                                   ; preds = %139, %136
  %143 = shl i32 %52, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %143, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %144 = zext nneg i32 %spec.select.i to i64
  %145 = shl nuw nsw i64 %144, 5
  %result.i10.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %145) #51
  store ptr %result.i10.i, ptr %4, align 8
  %result.i9.i935 = call noalias ptr @bump_malloc_wrapper(i64 noundef %144) #51
  store ptr %result.i9.i935, ptr %21, align 8
  store i32 %spec.select.i, ptr %22, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  store i32 0, ptr %23, align 4
  %147 = add i32 %52, -1
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %152 = icmp slt i32 %147, 0
  br i1 %152, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i.preheader

.lr.ph.i.preheader:                               ; preds = %._crit_edge1.i
  %153 = add nsw i32 %spec.select.i, -1
  br label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge2.backedge.i, %.lr.ph.i.preheader
  %154 = phi i32 [ %245, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %storemerge.i = phi i32 [ %249, %._crit_edge2.backedge.i ], [ 1, %.lr.ph.i.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i = phi i32 [ %storemerge.i, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %.sroa.0.8.extract.trunc.i = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i to i64
  %sext.i = shl nuw i64 %.sroa.0.8.extract.trunc.i, 32
  %155 = ashr exact i64 %sext.i, 27
  %156 = getelementptr i8, ptr %50, i64 %155
  %157 = load ptr, ptr %156, align 8
  %158 = icmp ne ptr %157, @nil_typ
  %159 = icmp ne ptr %157, null
  %.not158.i = and i1 %158, %159
  br i1 %.not158.i, label %160, label %._crit_edge2.backedge.i

160:                                              ; preds = %.lr.ph.i
  %161 = getelementptr i8, ptr %156, i64 8
  %162 = load i160, ptr %161, align 4
  %.sroa.3.0.extract.shift.i = lshr i160 %162, 64
  %.sroa.3.0.extract.trunc.i = trunc i160 %.sroa.3.0.extract.shift.i to i64
  %.sroa.0146.0.extract.trunc.i = trunc i160 %162 to i64
  %163 = inttoptr i64 %.sroa.0146.0.extract.trunc.i to ptr
  %164 = inttoptr i64 %.sroa.3.0.extract.trunc.i to ptr
  %hash_coef_ptr.i23.i = getelementptr i8, ptr %157, i64 8
  %tbl_size_ptr.i24.i = getelementptr i8, ptr %157, i64 16
  %offset_tbl_ptr.i25.i = getelementptr i8, ptr %157, i64 40
  %hash_coef.i26.i = load i64, ptr %hash_coef_ptr.i23.i, align 4
  %tbl_size.i27.i = load i64, ptr %tbl_size_ptr.i24.i, align 4
  %offset_tbl.i28.i = load ptr, ptr %offset_tbl_ptr.i25.i, align 8
  %product.i.i29.i = mul i64 %hash_coef.i26.i, 4015701072841558310
  %shifted.i.i30.i = lshr i64 %product.i.i29.i, 32
  %xored.i.i31.i = xor i64 %shifted.i.i30.i, %product.i.i29.i
  %hash.i.i32.i = and i64 %xored.i.i31.i, %tbl_size.i27.i
  %offset_ptr.i33.i = getelementptr i32, ptr %offset_tbl.i28.i, i64 %hash.i.i32.i
  %offset.i34.i = load i32, ptr %offset_ptr.i33.i, align 4
  %165 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %157, 0
  %166 = insertvalue { ptr, ptr, ptr, i32 } %165, ptr %163, 1
  %167 = insertvalue { ptr, ptr, ptr, i32 } %166, ptr %164, 2
  %168 = insertvalue { ptr, ptr, ptr, i32 } %167, i32 %offset.i34.i, 3
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %157)
  %171 = sext i32 %offset.i34.i to i64
  %172 = getelementptr ptr, ptr %157, i64 %171
  %173 = getelementptr i8, ptr %172, i64 48
  %174 = load ptr, ptr %173, align 8
  %result.i4.i = call ptr %174({ ptr, ptr, ptr, i32 } %168, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %175 = call { ptr, i160 } %result.i4.i({ ptr, ptr, ptr, i32 } %168, { ptr, ptr, ptr, i32 } %168, ptr nonnull align 8 %2)
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract.i = extractvalue { ptr, i160 } %175, 1
  %.sroa.1.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i32
  %177 = add i32 %.sroa.1.8.extract.trunc.i, 2127912214
  %178 = shl i32 %.sroa.1.8.extract.trunc.i, 12
  %179 = add i32 %177, %178
  %180 = ashr i32 %179, 19
  %181 = xor i32 %179, %180
  %182 = xor i32 %181, -949894596
  %183 = add i32 %182, 374761393
  %184 = shl i32 %182, 5
  %185 = add i32 %183, %184
  %186 = add i32 %185, -744332180
  %187 = shl i32 %185, 9
  %188 = xor i32 %186, %187
  %189 = add i32 %188, -42973499
  %190 = shl i32 %188, 3
  %191 = add i32 %189, %190
  %192 = ashr i32 %191, 16
  %193 = xor i32 %191, %192
  %194 = xor i32 %193, -1252372727
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %157)
  %197 = load ptr, ptr %173, align 8
  %result.i3.i = call ptr %197({ ptr, ptr, ptr, i32 } %168, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %198 = call { ptr, i160 } %result.i3.i({ ptr, ptr, ptr, i32 } %168, { ptr, ptr, ptr, i32 } %168, ptr nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.1.extract.i1459 = extractvalue { ptr, i160 } %198, 1
  %.sroa.1.8.extract.trunc.i1460 = trunc i160 %.fca.1.extract.i1459 to i32
  br label %199

199:                                              ; preds = %237, %160
  %.pn1507 = phi i32 [ %194, %160 ], [ %238, %237 ]
  %.01240 = phi i32 [ -1, %160 ], [ %.11241, %237 ]
  %.0..0..0..0..0..0.84.i1168 = phi i32 [ -1, %160 ], [ %spec.store.select9216.i1171, %237 ]
  %.01242 = and i32 %.pn1507, %153
  %200 = zext nneg i32 %.01242 to i64
  %201 = getelementptr i8, ptr %result.i9.i935, i64 %200
  %202 = load i8, ptr %201, align 1
  switch i8 %202, label %._crit_edge.i1174 [
    i8 0, label %239
    i8 -128, label %._crit_edge.thread.i1169
  ]

._crit_edge.thread.i1169:                         ; preds = %199
  %203 = icmp eq i32 %.0..0..0..0..0..0.84.i1168, -1
  %spec.store.select.i1170 = select i1 %203, i32 %.01242, i32 %.0..0..0..0..0..0.84.i1168
  br label %237

._crit_edge.i1174:                                ; preds = %199
  %204 = icmp sgt i8 %202, 0
  br i1 %204, label %205, label %237

205:                                              ; preds = %._crit_edge.i1174
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %207 = shl nuw nsw i64 %200, 5
  %208 = getelementptr i8, ptr %result.i10.i, i64 %207
  %209 = load ptr, ptr %208, align 8
  %210 = icmp ne ptr %209, @nil_typ
  %211 = icmp ne ptr %209, null
  %.not82.i1175 = and i1 %210, %211
  br i1 %.not82.i1175, label %212, label %237

212:                                              ; preds = %205
  %213 = getelementptr i8, ptr %208, i64 8
  %214 = load i64, ptr %213, align 4
  %.sroa_idx.i1176 = getelementptr i8, ptr %208, i64 16
  %215 = load i64, ptr %.sroa_idx.i1176, align 4
  %216 = inttoptr i64 %214 to ptr
  %217 = inttoptr i64 %215 to ptr
  %hash_coef_ptr.i3.i1177 = getelementptr i8, ptr %209, i64 8
  %tbl_size_ptr.i4.i1178 = getelementptr i8, ptr %209, i64 16
  %offset_tbl_ptr.i5.i1179 = getelementptr i8, ptr %209, i64 40
  %hash_coef.i6.i1180 = load i64, ptr %hash_coef_ptr.i3.i1177, align 4
  %tbl_size.i7.i1181 = load i64, ptr %tbl_size_ptr.i4.i1178, align 4
  %offset_tbl.i8.i1182 = load ptr, ptr %offset_tbl_ptr.i5.i1179, align 8
  %product.i.i9.i1183 = mul i64 %hash_coef.i6.i1180, 4015701072841558310
  %shifted.i.i10.i1184 = lshr i64 %product.i.i9.i1183, 32
  %xored.i.i11.i1185 = xor i64 %shifted.i.i10.i1184, %product.i.i9.i1183
  %hash.i.i12.i1186 = and i64 %xored.i.i11.i1185, %tbl_size.i7.i1181
  %offset_ptr.i13.i1187 = getelementptr i32, ptr %offset_tbl.i8.i1182, i64 %hash.i.i12.i1186
  %offset.i14.i1188 = load i32, ptr %offset_ptr.i13.i1187, align 4
  %218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %209, 0
  %219 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %216, 1
  %220 = insertvalue { ptr, ptr, ptr, i32 } %219, ptr %217, 2
  %221 = insertvalue { ptr, ptr, ptr, i32 } %220, i32 %offset.i14.i1188, 3
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %209)
  %224 = sext i32 %offset.i14.i1188 to i64
  %225 = getelementptr ptr, ptr %209, i64 %224
  %226 = getelementptr i8, ptr %225, i64 40
  %227 = load ptr, ptr %226, align 8
  %result.i1.i1189 = call ptr %227({ ptr, ptr, ptr, i32 } %221, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %228 = call i32 %result.i1.i1189({ ptr, ptr, ptr, i32 } %221, { ptr, ptr, ptr, i32 } %221, ptr nonnull align 8 %2)
  %229 = icmp eq i32 %228, %194
  br i1 %229, label %._crit_edge2.i1190, label %237

._crit_edge2.i1190:                               ; preds = %212
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %209)
  %232 = getelementptr i8, ptr %225, i64 48
  %233 = load ptr, ptr %232, align 8
  %result.i.i = call ptr %233({ ptr, ptr, ptr, i32 } %221, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %234 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %221, { ptr, ptr, ptr, i32 } %221, ptr nonnull align 8 %2)
  %235 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i = extractvalue { ptr, i160 } %234, 1
  %.sroa.15.8.extract.trunc.i = trunc i160 %.fca.1.extract3.i to i32
  %236 = icmp eq i32 %.sroa.15.8.extract.trunc.i, %.sroa.1.8.extract.trunc.i1460
  br i1 %236, label %SwissTable_find_slot_keyK_hashi32.exit1191, label %237

237:                                              ; preds = %._crit_edge2.i1190, %212, %205, %._crit_edge.i1174, %._crit_edge.thread.i1169
  %.11241 = phi i32 [ %.01240, %._crit_edge2.i1190 ], [ %.01240, %212 ], [ %.01240, %205 ], [ %.01240, %._crit_edge.i1174 ], [ %spec.store.select.i1170, %._crit_edge.thread.i1169 ]
  %spec.store.select9216.i1171 = phi i32 [ %.0..0..0..0..0..0.84.i1168, %._crit_edge2.i1190 ], [ %.0..0..0..0..0..0.84.i1168, %212 ], [ %.0..0..0..0..0..0.84.i1168, %205 ], [ %.0..0..0..0..0..0.84.i1168, %._crit_edge.i1174 ], [ %spec.store.select.i1170, %._crit_edge.thread.i1169 ]
  %238 = add nuw nsw i32 %.01242, 1
  br label %199

239:                                              ; preds = %199
  %.not.i1172 = icmp eq i32 %.0..0..0..0..0..0.84.i1168, -1
  %.pre.i1173 = select i1 %.not.i1172, i32 %.01242, i32 %.01240
  %.pre1312 = sext i32 %.pre.i1173 to i64
  %.pre1314 = shl nsw i64 %.pre1312, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1191

SwissTable_find_slot_keyK_hashi32.exit1191:       ; preds = %239, %._crit_edge2.i1190
  %.pre-phi1315 = phi i64 [ %.pre1314, %239 ], [ %207, %._crit_edge2.i1190 ]
  %.pre-phi1313 = phi i64 [ %.pre1312, %239 ], [ %200, %._crit_edge2.i1190 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %240 = getelementptr i8, ptr %result.i10.i, i64 %.pre-phi1315
  store ptr %157, ptr %240, align 8
  %241 = getelementptr i8, ptr %240, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i, ptr %241, align 4
  %.sroa_idx120.i = getelementptr i8, ptr %240, i64 16
  store i64 %.sroa.3.0.extract.trunc.i, ptr %.sroa_idx120.i, align 4
  %.sroa_idx121.i = getelementptr i8, ptr %240, i64 24
  store i32 %offset.i34.i, ptr %.sroa_idx121.i, align 4
  %242 = getelementptr i8, ptr %result.i9.i935, i64 %.pre-phi1313
  store i8 1, ptr %242, align 1
  %243 = add i32 %154, 1
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i

._crit_edge2.backedge.i:                          ; preds = %SwissTable_find_slot_keyK_hashi32.exit1191, %.lr.ph.i
  %245 = phi i32 [ %243, %SwissTable_find_slot_keyK_hashi32.exit1191 ], [ %154, %.lr.ph.i ]
  %246 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %247 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %248 = icmp sgt i32 %storemerge.i, %147
  %249 = add i32 %storemerge.i, 1
  br i1 %248, label %SwissTable_resize_new_capacityi32.exit.loopexit, label %.lr.ph.i

SwissTable_resize_new_capacityi32.exit.loopexit:  ; preds = %._crit_edge2.backedge.i
  store i32 %245, ptr %23, align 4
  br label %SwissTable_resize_new_capacityi32.exit

SwissTable_resize_new_capacityi32.exit:           ; preds = %SwissTable_resize_new_capacityi32.exit.loopexit, %._crit_edge1.i
  %250 = phi i32 [ %245, %SwissTable_resize_new_capacityi32.exit.loopexit ], [ 0, %._crit_edge1.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %SwissTable_ensure_capacity_required_sizei32.exit

SwissTable_ensure_capacity_required_sizei32.exit: ; preds = %SwissTable_resize_new_capacityi32.exit, %139
  %251 = phi ptr [ %46, %139 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %252 = phi ptr [ %47, %139 ], [ %result.i9.i935, %SwissTable_resize_new_capacityi32.exit ]
  %.pre908 = phi ptr [ %.pre9081420, %139 ], [ %result.i9.i935, %SwissTable_resize_new_capacityi32.exit ]
  %253 = phi ptr [ %50, %139 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %254 = phi ptr [ %48, %139 ], [ %result.i9.i935, %SwissTable_resize_new_capacityi32.exit ]
  %255 = phi i32 [ %49, %139 ], [ %spec.select.i, %SwissTable_resize_new_capacityi32.exit ]
  %256 = phi i32 [ %51, %139 ], [ %250, %SwissTable_resize_new_capacityi32.exit ]
  %257 = add nuw i32 %61, 2127912214
  %258 = shl i32 %60, 12
  %259 = add i32 %257, %258
  %260 = ashr i32 %259, 19
  %261 = xor i32 %259, %260
  %262 = xor i32 %261, -949894596
  %263 = add i32 %262, 374761393
  %264 = shl i32 %262, 5
  %265 = add i32 %263, %264
  %266 = add i32 %265, -744332180
  %267 = shl i32 %265, 9
  %268 = xor i32 %266, %267
  %269 = add i32 %268, -42973499
  %270 = shl i32 %268, 3
  %271 = add i32 %269, %270
  %272 = ashr i32 %271, 16
  %273 = xor i32 %271, %272
  %274 = xor i32 %273, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %275 = add i32 %255, -1
  %276 = and i32 %275, %274
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %278

278:                                              ; preds = %316, %SwissTable_ensure_capacity_required_sizei32.exit
  %.0743 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %.1744, %316 ]
  %.0742 = phi i32 [ %276, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %318, %316 ]
  %.0..0..0..0..0..0.84.i589 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %spec.store.select9216.i593, %316 ]
  %279 = sext i32 %.0742 to i64
  %280 = getelementptr i8, ptr %254, i64 %279
  %281 = load i8, ptr %280, align 1
  switch i8 %281, label %._crit_edge.i598 [
    i8 0, label %319
    i8 -128, label %._crit_edge.thread.i591
  ]

._crit_edge.thread.i591:                          ; preds = %278
  %282 = icmp eq i32 %.0..0..0..0..0..0.84.i589, -1
  %spec.store.select.i592 = select i1 %282, i32 %.0742, i32 %.0..0..0..0..0..0.84.i589
  br label %316

._crit_edge.i598:                                 ; preds = %278
  %283 = icmp sgt i8 %281, 0
  br i1 %283, label %284, label %316

284:                                              ; preds = %._crit_edge.i598
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %286 = shl nsw i64 %279, 5
  %287 = getelementptr i8, ptr %253, i64 %286
  %288 = load ptr, ptr %287, align 8
  %289 = icmp ne ptr %288, @nil_typ
  %290 = icmp ne ptr %288, null
  %.not82.i600 = and i1 %289, %290
  br i1 %.not82.i600, label %291, label %316

291:                                              ; preds = %284
  %292 = getelementptr i8, ptr %287, i64 8
  %293 = load i64, ptr %292, align 4
  %.sroa_idx.i601 = getelementptr i8, ptr %287, i64 16
  %294 = load i64, ptr %.sroa_idx.i601, align 4
  %295 = inttoptr i64 %293 to ptr
  %296 = inttoptr i64 %294 to ptr
  %hash_coef_ptr.i3.i602 = getelementptr i8, ptr %288, i64 8
  %tbl_size_ptr.i4.i603 = getelementptr i8, ptr %288, i64 16
  %offset_tbl_ptr.i5.i604 = getelementptr i8, ptr %288, i64 40
  %hash_coef.i6.i605 = load i64, ptr %hash_coef_ptr.i3.i602, align 4
  %tbl_size.i7.i606 = load i64, ptr %tbl_size_ptr.i4.i603, align 4
  %offset_tbl.i8.i607 = load ptr, ptr %offset_tbl_ptr.i5.i604, align 8
  %product.i.i9.i608 = mul i64 %hash_coef.i6.i605, 4015701072841558310
  %shifted.i.i10.i609 = lshr i64 %product.i.i9.i608, 32
  %xored.i.i11.i610 = xor i64 %shifted.i.i10.i609, %product.i.i9.i608
  %hash.i.i12.i611 = and i64 %xored.i.i11.i610, %tbl_size.i7.i606
  %offset_ptr.i13.i612 = getelementptr i32, ptr %offset_tbl.i8.i607, i64 %hash.i.i12.i611
  %offset.i14.i613 = load i32, ptr %offset_ptr.i13.i612, align 4
  %297 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %288, 0
  %298 = insertvalue { ptr, ptr, ptr, i32 } %297, ptr %295, 1
  %299 = insertvalue { ptr, ptr, ptr, i32 } %298, ptr %296, 2
  %300 = insertvalue { ptr, ptr, ptr, i32 } %299, i32 %offset.i14.i613, 3
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %302 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %288)
  %303 = sext i32 %offset.i14.i613 to i64
  %304 = getelementptr ptr, ptr %288, i64 %303
  %305 = getelementptr i8, ptr %304, i64 40
  %306 = load ptr, ptr %305, align 8
  %result.i1.i614 = call ptr %306({ ptr, ptr, ptr, i32 } %300, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %307 = call i32 %result.i1.i614({ ptr, ptr, ptr, i32 } %300, { ptr, ptr, ptr, i32 } %300, ptr nonnull align 8 %2)
  %308 = icmp eq i32 %307, %274
  br i1 %308, label %._crit_edge2.i615, label %316

._crit_edge2.i615:                                ; preds = %291
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %288)
  %311 = getelementptr i8, ptr %304, i64 48
  %312 = load ptr, ptr %311, align 8
  %result.i.i616 = call ptr %312({ ptr, ptr, ptr, i32 } %300, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %313 = call { ptr, i160 } %result.i.i616({ ptr, ptr, ptr, i32 } %300, { ptr, ptr, ptr, i32 } %300, ptr nonnull align 8 %2)
  %314 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i1463 = extractvalue { ptr, i160 } %313, 1
  %.sroa.15.8.extract.trunc.i1464 = trunc i160 %.fca.1.extract3.i1463 to i32
  %315 = icmp eq i32 %61, %.sroa.15.8.extract.trunc.i1464
  br i1 %315, label %SwissTable_find_slot_keyK_hashi32.exit618, label %316

316:                                              ; preds = %._crit_edge2.i615, %291, %284, %._crit_edge.i598, %._crit_edge.thread.i591
  %.1744 = phi i32 [ %.0743, %._crit_edge2.i615 ], [ %.0743, %291 ], [ %.0743, %284 ], [ %.0743, %._crit_edge.i598 ], [ %spec.store.select.i592, %._crit_edge.thread.i591 ]
  %spec.store.select9216.i593 = phi i32 [ %.0..0..0..0..0..0.84.i589, %._crit_edge2.i615 ], [ %.0..0..0..0..0..0.84.i589, %291 ], [ %.0..0..0..0..0..0.84.i589, %284 ], [ %.0..0..0..0..0..0.84.i589, %._crit_edge.i598 ], [ %spec.store.select.i592, %._crit_edge.thread.i591 ]
  %317 = add i32 %.0742, 1
  %318 = and i32 %317, %275
  br label %278

319:                                              ; preds = %278
  %.not.i594 = icmp eq i32 %.0..0..0..0..0..0.84.i589, -1
  %.pre.i597 = select i1 %.not.i594, i32 %.0742, i32 %.0743
  %.pre775 = sext i32 %.pre.i597 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit618

SwissTable_find_slot_keyK_hashi32.exit618:        ; preds = %319, %._crit_edge2.i615
  %320 = phi ptr [ %254, %319 ], [ %.pre908, %._crit_edge2.i615 ]
  %.pre-phi776 = phi i64 [ %.pre775, %319 ], [ %279, %._crit_edge2.i615 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %321 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %322 = getelementptr i8, ptr %320, i64 %.pre-phi776
  %323 = load i8, ptr %322, align 1
  %result.i9.i = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  store ptr @_parameterization_i32, ptr %result.i9.i, align 8
  %324 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr @_parameterization_i32, ptr %324, align 8
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9.i)
  %326 = getelementptr inbounds i8, ptr %result.i9.i, i64 20
  store i32 %61, ptr %326, align 4
  %327 = getelementptr inbounds i8, ptr %result.i9.i, i64 24
  store i32 %137, ptr %327, align 8
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %329 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %274, ptr %329, align 8
  %330 = icmp eq i8 %323, 0
  br i1 %330, label %331, label %SwissTable_insert_keyK_valueV.exit

331:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit618
  %332 = getelementptr i8, ptr %252, i64 %.pre-phi776
  store i8 1, ptr %332, align 1
  %333 = load i32, ptr %23, align 4
  %334 = add i32 %333, 1
  store i32 %334, ptr %23, align 4
  %.pre1424 = load ptr, ptr %4, align 8
  br label %SwissTable_insert_keyK_valueV.exit

SwissTable_insert_keyK_valueV.exit:               ; preds = %331, %SwissTable_find_slot_keyK_hashi32.exit618
  %335 = phi ptr [ %251, %SwissTable_find_slot_keyK_hashi32.exit618 ], [ %.pre1424, %331 ]
  %.pre9081422 = phi ptr [ %.pre908, %SwissTable_find_slot_keyK_hashi32.exit618 ], [ %252, %331 ]
  %336 = phi ptr [ %320, %SwissTable_find_slot_keyK_hashi32.exit618 ], [ %252, %331 ]
  %337 = phi i32 [ %256, %SwissTable_find_slot_keyK_hashi32.exit618 ], [ %334, %331 ]
  %338 = shl nsw i64 %.pre-phi776, 5
  %339 = getelementptr i8, ptr %335, i64 %338
  store ptr @Entry, ptr %339, align 8
  %340 = getelementptr i8, ptr %339, i64 8
  %341 = ptrtoint ptr %result.i9.i to i64
  store i64 %341, ptr %340, align 4
  %.sroa_idx3.i = getelementptr i8, ptr %339, i64 24
  store i32 10, ptr %.sroa_idx3.i, align 4
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %343 = sext i32 %.0438154 to i64
  %344 = shl nsw i64 %343, 2
  %345 = getelementptr i8, ptr %result.i2.i209, i64 %344
  store i32 %61, ptr %345, align 1
  store i1 true, ptr %.sroa.0399.sroa.0, align 8
  %.sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.0. = load i8, ptr %.sroa.0399.sroa.0, align 8
  %.sroa.0399.0.insert.ext = zext i8 %.sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.sroa.0.0..sroa.0399.0. to i160
  %346 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0399.0.insert.ext, 1
  %347 = load i32, ptr %36, align 8
  %348 = icmp eq i32 %347, 0
  br i1 %348, label %._crit_edge1.i635, label %349

349:                                              ; preds = %SwissTable_insert_keyK_valueV.exit
  %350 = load i32, ptr %38, align 4
  %351 = add i32 %350, 1
  %352 = mul i32 %347, 7
  %353 = sdiv i32 %352, 10
  %.not.i634 = icmp slt i32 %351, %353
  br i1 %.not.i634, label %.SwissTable_ensure_capacity_required_sizei32.exit639_crit_edge, label %._crit_edge1.i635

.SwissTable_ensure_capacity_required_sizei32.exit639_crit_edge: ; preds = %349
  %.pre1425 = load ptr, ptr %35, align 8
  %.pre1426 = load ptr, ptr %3, align 8
  br label %SwissTable_ensure_capacity_required_sizei32.exit639

._crit_edge1.i635:                                ; preds = %349, %SwissTable_insert_keyK_valueV.exit
  %354 = shl i32 %347, 1
  %spec.select.i636 = call i32 @llvm.smax.i32(i32 %354, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %355 = load ptr, ptr %3, align 8
  %356 = zext nneg i32 %spec.select.i636 to i64
  %357 = shl nuw nsw i64 %356, 5
  %result.i10.i951 = call noalias ptr @bump_malloc_wrapper(i64 noundef %357) #51
  store ptr %result.i10.i951, ptr %3, align 8
  %result.i9.i952 = call noalias ptr @bump_malloc_wrapper(i64 noundef %356) #51
  store ptr %result.i9.i952, ptr %35, align 8
  store i32 %spec.select.i636, ptr %36, align 8
  %358 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  store i32 0, ptr %38, align 4
  %359 = add i32 %347, -1
  %360 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %362 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %364 = icmp slt i32 %359, 0
  br i1 %364, label %SwissTable_resize_new_capacityi32.exit989, label %.lr.ph.i954.preheader

.lr.ph.i954.preheader:                            ; preds = %._crit_edge1.i635
  %.promoted1115 = load ptr, ptr %44, align 8
  %365 = load ptr, ptr %33, align 8
  %366 = load ptr, ptr %result.i51.h2s1796, align 8
  %367 = add nsw i32 %spec.select.i636, -1
  %368 = load ptr, ptr %34, align 8
  br label %.lr.ph.i954

.lr.ph.i954:                                      ; preds = %._crit_edge2.backedge.i960, %.lr.ph.i954.preheader
  %369 = phi i32 [ %444, %._crit_edge2.backedge.i960 ], [ 0, %.lr.ph.i954.preheader ]
  %_parameterization_i321116 = phi ptr [ %_parameterization_i321117, %._crit_edge2.backedge.i960 ], [ %.promoted1115, %.lr.ph.i954.preheader ]
  %storemerge.i955 = phi i32 [ %448, %._crit_edge2.backedge.i960 ], [ 1, %.lr.ph.i954.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i956 = phi i32 [ %storemerge.i955, %._crit_edge2.backedge.i960 ], [ 0, %.lr.ph.i954.preheader ]
  %.sroa.0.8.extract.trunc.i957 = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i956 to i64
  %sext.i958 = shl nuw i64 %.sroa.0.8.extract.trunc.i957, 32
  %370 = ashr exact i64 %sext.i958, 27
  %371 = getelementptr i8, ptr %355, i64 %370
  %372 = load ptr, ptr %371, align 8
  %373 = icmp ne ptr %372, @nil_typ
  %374 = icmp ne ptr %372, null
  %.not158.i959 = and i1 %373, %374
  br i1 %.not158.i959, label %375, label %._crit_edge2.backedge.i960

375:                                              ; preds = %.lr.ph.i954
  %376 = getelementptr i8, ptr %371, i64 8
  %377 = load i160, ptr %376, align 4
  %.sroa.3.0.extract.shift.i962 = lshr i160 %377, 64
  %.sroa.3.0.extract.trunc.i963 = trunc i160 %.sroa.3.0.extract.shift.i962 to i64
  %.sroa.0146.0.extract.trunc.i964 = trunc i160 %377 to i64
  %378 = inttoptr i64 %.sroa.0146.0.extract.trunc.i964 to ptr
  %379 = inttoptr i64 %.sroa.3.0.extract.trunc.i963 to ptr
  %hash_coef_ptr.i23.i965 = getelementptr i8, ptr %372, i64 8
  %tbl_size_ptr.i24.i966 = getelementptr i8, ptr %372, i64 16
  %offset_tbl_ptr.i25.i967 = getelementptr i8, ptr %372, i64 40
  %hash_coef.i26.i968 = load i64, ptr %hash_coef_ptr.i23.i965, align 4
  %tbl_size.i27.i969 = load i64, ptr %tbl_size_ptr.i24.i966, align 4
  %offset_tbl.i28.i970 = load ptr, ptr %offset_tbl_ptr.i25.i967, align 8
  %product.i.i29.i971 = mul i64 %hash_coef.i26.i968, 4015701072841558310
  %shifted.i.i30.i972 = lshr i64 %product.i.i29.i971, 32
  %xored.i.i31.i973 = xor i64 %shifted.i.i30.i972, %product.i.i29.i971
  %hash.i.i32.i974 = and i64 %xored.i.i31.i973, %tbl_size.i27.i969
  %offset_ptr.i33.i975 = getelementptr i32, ptr %offset_tbl.i28.i970, i64 %hash.i.i32.i974
  %offset.i34.i976 = load i32, ptr %offset_ptr.i33.i975, align 4
  %380 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %372, 0
  %381 = insertvalue { ptr, ptr, ptr, i32 } %380, ptr %378, 1
  %382 = insertvalue { ptr, ptr, ptr, i32 } %381, ptr %379, 2
  %383 = insertvalue { ptr, ptr, ptr, i32 } %382, i32 %offset.i34.i976, 3
  %384 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %385 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %372)
  %386 = sext i32 %offset.i34.i976 to i64
  %387 = getelementptr ptr, ptr %372, i64 %386
  %388 = getelementptr i8, ptr %387, i64 48
  %389 = load ptr, ptr %388, align 8
  %result.i4.i977 = call ptr %389({ ptr, ptr, ptr, i32 } %383, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %390 = call { ptr, i160 } %result.i4.i977({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull align 8 %2)
  %391 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %392 = call i32 %365({ ptr, i160 } %390)
  %393 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %394 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %372)
  %395 = load ptr, ptr %388, align 8
  %result.i3.i979 = call ptr %395({ ptr, ptr, ptr, i32 } %383, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %396 = call { ptr, i160 } %result.i3.i979({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull align 8 %2)
  store ptr %366, ptr %5, align 8
  %397 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %398

398:                                              ; preds = %436, %375
  %.pn1508 = phi i32 [ %392, %375 ], [ %437, %436 ]
  %.01243 = phi i32 [ -1, %375 ], [ %.11244, %436 ]
  %.0..0..0..0..0..0.84.i1207 = phi i32 [ -1, %375 ], [ %spec.store.select9216.i1211, %436 ]
  %.01245 = and i32 %.pn1508, %367
  %399 = zext nneg i32 %.01245 to i64
  %400 = getelementptr i8, ptr %result.i9.i952, i64 %399
  %401 = load i8, ptr %400, align 1
  switch i8 %401, label %._crit_edge.i1216 [
    i8 0, label %438
    i8 -128, label %._crit_edge.thread.i1209
  ]

._crit_edge.thread.i1209:                         ; preds = %398
  %402 = icmp eq i32 %.0..0..0..0..0..0.84.i1207, -1
  %spec.store.select.i1210 = select i1 %402, i32 %.01245, i32 %.0..0..0..0..0..0.84.i1207
  br label %436

._crit_edge.i1216:                                ; preds = %398
  %403 = icmp sgt i8 %401, 0
  br i1 %403, label %404, label %436

404:                                              ; preds = %._crit_edge.i1216
  %405 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %406 = shl nuw nsw i64 %399, 5
  %407 = getelementptr i8, ptr %result.i10.i951, i64 %406
  %408 = load ptr, ptr %407, align 8
  %409 = icmp ne ptr %408, @nil_typ
  %410 = icmp ne ptr %408, null
  %.not82.i1218 = and i1 %409, %410
  br i1 %.not82.i1218, label %411, label %436

411:                                              ; preds = %404
  %412 = getelementptr i8, ptr %407, i64 8
  %413 = load i64, ptr %412, align 4
  %.sroa_idx.i1219 = getelementptr i8, ptr %407, i64 16
  %414 = load i64, ptr %.sroa_idx.i1219, align 4
  %415 = inttoptr i64 %413 to ptr
  %416 = inttoptr i64 %414 to ptr
  %hash_coef_ptr.i3.i1220 = getelementptr i8, ptr %408, i64 8
  %tbl_size_ptr.i4.i1221 = getelementptr i8, ptr %408, i64 16
  %offset_tbl_ptr.i5.i1222 = getelementptr i8, ptr %408, i64 40
  %hash_coef.i6.i1223 = load i64, ptr %hash_coef_ptr.i3.i1220, align 4
  %tbl_size.i7.i1224 = load i64, ptr %tbl_size_ptr.i4.i1221, align 4
  %offset_tbl.i8.i1225 = load ptr, ptr %offset_tbl_ptr.i5.i1222, align 8
  %product.i.i9.i1226 = mul i64 %hash_coef.i6.i1223, 4015701072841558310
  %shifted.i.i10.i1227 = lshr i64 %product.i.i9.i1226, 32
  %xored.i.i11.i1228 = xor i64 %shifted.i.i10.i1227, %product.i.i9.i1226
  %hash.i.i12.i1229 = and i64 %xored.i.i11.i1228, %tbl_size.i7.i1224
  %offset_ptr.i13.i1230 = getelementptr i32, ptr %offset_tbl.i8.i1225, i64 %hash.i.i12.i1229
  %offset.i14.i1231 = load i32, ptr %offset_ptr.i13.i1230, align 4
  %417 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %408, 0
  %418 = insertvalue { ptr, ptr, ptr, i32 } %417, ptr %415, 1
  %419 = insertvalue { ptr, ptr, ptr, i32 } %418, ptr %416, 2
  %420 = insertvalue { ptr, ptr, ptr, i32 } %419, i32 %offset.i14.i1231, 3
  %421 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %408)
  %423 = sext i32 %offset.i14.i1231 to i64
  %424 = getelementptr ptr, ptr %408, i64 %423
  %425 = getelementptr i8, ptr %424, i64 40
  %426 = load ptr, ptr %425, align 8
  %result.i1.i1232 = call ptr %426({ ptr, ptr, ptr, i32 } %420, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %427 = call i32 %result.i1.i1232({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull align 8 %2)
  %428 = icmp eq i32 %427, %392
  br i1 %428, label %._crit_edge2.i1233, label %436

._crit_edge2.i1233:                               ; preds = %411
  %429 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %430 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %408)
  %431 = getelementptr i8, ptr %424, i64 48
  %432 = load ptr, ptr %431, align 8
  %result.i.i1234 = call ptr %432({ ptr, ptr, ptr, i32 } %420, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %433 = call { ptr, i160 } %result.i.i1234({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull align 8 %2)
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %435 = call i1 %368({ ptr, i160 } %433, { ptr, i160 } %396)
  br i1 %435, label %SwissTable_find_slot_keyK_hashi32.exit1236, label %436

436:                                              ; preds = %._crit_edge2.i1233, %411, %404, %._crit_edge.i1216, %._crit_edge.thread.i1209
  %.11244 = phi i32 [ %.01243, %._crit_edge2.i1233 ], [ %.01243, %411 ], [ %.01243, %404 ], [ %.01243, %._crit_edge.i1216 ], [ %spec.store.select.i1210, %._crit_edge.thread.i1209 ]
  %spec.store.select9216.i1211 = phi i32 [ %.0..0..0..0..0..0.84.i1207, %._crit_edge2.i1233 ], [ %.0..0..0..0..0..0.84.i1207, %411 ], [ %.0..0..0..0..0..0.84.i1207, %404 ], [ %.0..0..0..0..0..0.84.i1207, %._crit_edge.i1216 ], [ %spec.store.select.i1210, %._crit_edge.thread.i1209 ]
  %437 = add nuw nsw i32 %.01245, 1
  br label %398

438:                                              ; preds = %398
  %.not.i1212 = icmp eq i32 %.0..0..0..0..0..0.84.i1207, -1
  %.pre.i1215 = select i1 %.not.i1212, i32 %.01245, i32 %.01243
  %.pre1308 = sext i32 %.pre.i1215 to i64
  %.pre1310 = shl nsw i64 %.pre1308, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1236

SwissTable_find_slot_keyK_hashi32.exit1236:       ; preds = %438, %._crit_edge2.i1233
  %.pre-phi1311 = phi i64 [ %.pre1310, %438 ], [ %406, %._crit_edge2.i1233 ]
  %.pre-phi1309 = phi i64 [ %.pre1308, %438 ], [ %399, %._crit_edge2.i1233 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %439 = getelementptr i8, ptr %result.i10.i951, i64 %.pre-phi1311
  store ptr %372, ptr %439, align 8
  %440 = getelementptr i8, ptr %439, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i964, ptr %440, align 4
  %.sroa_idx120.i984 = getelementptr i8, ptr %439, i64 16
  store i64 %.sroa.3.0.extract.trunc.i963, ptr %.sroa_idx120.i984, align 4
  %.sroa_idx121.i985 = getelementptr i8, ptr %439, i64 24
  store i32 %offset.i34.i976, ptr %.sroa_idx121.i985, align 4
  %441 = getelementptr i8, ptr %result.i9.i952, i64 %.pre-phi1309
  store i8 1, ptr %441, align 1
  %442 = add i32 %369, 1
  %443 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i960

._crit_edge2.backedge.i960:                       ; preds = %SwissTable_find_slot_keyK_hashi32.exit1236, %.lr.ph.i954
  %444 = phi i32 [ %442, %SwissTable_find_slot_keyK_hashi32.exit1236 ], [ %369, %.lr.ph.i954 ]
  %_parameterization_i321117 = phi ptr [ @_parameterization_i32, %SwissTable_find_slot_keyK_hashi32.exit1236 ], [ %_parameterization_i321116, %.lr.ph.i954 ]
  %445 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %446 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %447 = icmp sgt i32 %storemerge.i955, %359
  %448 = add i32 %storemerge.i955, 1
  br i1 %447, label %SwissTable_resize_new_capacityi32.exit989.loopexit, label %.lr.ph.i954

SwissTable_resize_new_capacityi32.exit989.loopexit: ; preds = %._crit_edge2.backedge.i960
  store i32 %444, ptr %38, align 4
  store ptr %_parameterization_i321117, ptr %44, align 8
  br label %SwissTable_resize_new_capacityi32.exit989

SwissTable_resize_new_capacityi32.exit989:        ; preds = %SwissTable_resize_new_capacityi32.exit989.loopexit, %._crit_edge1.i635
  %449 = phi i32 [ %444, %SwissTable_resize_new_capacityi32.exit989.loopexit ], [ 0, %._crit_edge1.i635 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  br label %SwissTable_ensure_capacity_required_sizei32.exit639

SwissTable_ensure_capacity_required_sizei32.exit639: ; preds = %SwissTable_resize_new_capacityi32.exit989, %.SwissTable_ensure_capacity_required_sizei32.exit639_crit_edge
  %450 = phi i32 [ %350, %.SwissTable_ensure_capacity_required_sizei32.exit639_crit_edge ], [ %449, %SwissTable_resize_new_capacityi32.exit989 ]
  %451 = phi ptr [ %.pre1426, %.SwissTable_ensure_capacity_required_sizei32.exit639_crit_edge ], [ %result.i10.i951, %SwissTable_resize_new_capacityi32.exit989 ]
  %452 = phi ptr [ %.pre1425, %.SwissTable_ensure_capacity_required_sizei32.exit639_crit_edge ], [ %result.i9.i952, %SwissTable_resize_new_capacityi32.exit989 ]
  %453 = phi i32 [ %347, %.SwissTable_ensure_capacity_required_sizei32.exit639_crit_edge ], [ %spec.select.i636, %SwissTable_resize_new_capacityi32.exit989 ]
  %454 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %455 = load ptr, ptr %33, align 8
  %456 = call i32 %455({ ptr, i160 } %62)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %457 = add i32 %453, -1
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %459 = load ptr, ptr %34, align 8
  br label %460

460:                                              ; preds = %498, %SwissTable_ensure_capacity_required_sizei32.exit639
  %.0740 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit639 ], [ %.1741, %498 ]
  %.pn1509 = phi i32 [ %456, %SwissTable_ensure_capacity_required_sizei32.exit639 ], [ %499, %498 ]
  %.0..0..0..0..0..0.84.i655 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit639 ], [ %spec.store.select9216.i659, %498 ]
  %.0739 = and i32 %.pn1509, %457
  %461 = sext i32 %.0739 to i64
  %462 = getelementptr i8, ptr %452, i64 %461
  %463 = load i8, ptr %462, align 1
  switch i8 %463, label %._crit_edge.i664 [
    i8 0, label %500
    i8 -128, label %._crit_edge.thread.i657
  ]

._crit_edge.thread.i657:                          ; preds = %460
  %464 = icmp eq i32 %.0..0..0..0..0..0.84.i655, -1
  %spec.store.select.i658 = select i1 %464, i32 %.0739, i32 %.0..0..0..0..0..0.84.i655
  br label %498

._crit_edge.i664:                                 ; preds = %460
  %465 = icmp sgt i8 %463, 0
  br i1 %465, label %466, label %498

466:                                              ; preds = %._crit_edge.i664
  %467 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %468 = shl nsw i64 %461, 5
  %469 = getelementptr i8, ptr %451, i64 %468
  %470 = load ptr, ptr %469, align 8
  %471 = icmp ne ptr %470, @nil_typ
  %472 = icmp ne ptr %470, null
  %.not82.i666 = and i1 %471, %472
  br i1 %.not82.i666, label %473, label %498

473:                                              ; preds = %466
  %474 = getelementptr i8, ptr %469, i64 8
  %475 = load i64, ptr %474, align 4
  %.sroa_idx.i667 = getelementptr i8, ptr %469, i64 16
  %476 = load i64, ptr %.sroa_idx.i667, align 4
  %477 = inttoptr i64 %475 to ptr
  %478 = inttoptr i64 %476 to ptr
  %hash_coef_ptr.i3.i668 = getelementptr i8, ptr %470, i64 8
  %tbl_size_ptr.i4.i669 = getelementptr i8, ptr %470, i64 16
  %offset_tbl_ptr.i5.i670 = getelementptr i8, ptr %470, i64 40
  %hash_coef.i6.i671 = load i64, ptr %hash_coef_ptr.i3.i668, align 4
  %tbl_size.i7.i672 = load i64, ptr %tbl_size_ptr.i4.i669, align 4
  %offset_tbl.i8.i673 = load ptr, ptr %offset_tbl_ptr.i5.i670, align 8
  %product.i.i9.i674 = mul i64 %hash_coef.i6.i671, 4015701072841558310
  %shifted.i.i10.i675 = lshr i64 %product.i.i9.i674, 32
  %xored.i.i11.i676 = xor i64 %shifted.i.i10.i675, %product.i.i9.i674
  %hash.i.i12.i677 = and i64 %xored.i.i11.i676, %tbl_size.i7.i672
  %offset_ptr.i13.i678 = getelementptr i32, ptr %offset_tbl.i8.i673, i64 %hash.i.i12.i677
  %offset.i14.i679 = load i32, ptr %offset_ptr.i13.i678, align 4
  %479 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %470, 0
  %480 = insertvalue { ptr, ptr, ptr, i32 } %479, ptr %477, 1
  %481 = insertvalue { ptr, ptr, ptr, i32 } %480, ptr %478, 2
  %482 = insertvalue { ptr, ptr, ptr, i32 } %481, i32 %offset.i14.i679, 3
  %483 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %484 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %470)
  %485 = sext i32 %offset.i14.i679 to i64
  %486 = getelementptr ptr, ptr %470, i64 %485
  %487 = getelementptr i8, ptr %486, i64 40
  %488 = load ptr, ptr %487, align 8
  %result.i1.i680 = call ptr %488({ ptr, ptr, ptr, i32 } %482, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %489 = call i32 %result.i1.i680({ ptr, ptr, ptr, i32 } %482, { ptr, ptr, ptr, i32 } %482, ptr nonnull align 8 %2)
  %490 = icmp eq i32 %489, %456
  br i1 %490, label %._crit_edge2.i681, label %498

._crit_edge2.i681:                                ; preds = %473
  %491 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %492 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %470)
  %493 = getelementptr i8, ptr %486, i64 48
  %494 = load ptr, ptr %493, align 8
  %result.i.i682 = call ptr %494({ ptr, ptr, ptr, i32 } %482, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %495 = call { ptr, i160 } %result.i.i682({ ptr, ptr, ptr, i32 } %482, { ptr, ptr, ptr, i32 } %482, ptr nonnull align 8 %2)
  %496 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %497 = call i1 %459({ ptr, i160 } %495, { ptr, i160 } %62)
  br i1 %497, label %SwissTable_find_slot_keyK_hashi32.exit684, label %498

498:                                              ; preds = %._crit_edge2.i681, %473, %466, %._crit_edge.i664, %._crit_edge.thread.i657
  %.1741 = phi i32 [ %.0740, %._crit_edge2.i681 ], [ %.0740, %473 ], [ %.0740, %466 ], [ %.0740, %._crit_edge.i664 ], [ %spec.store.select.i658, %._crit_edge.thread.i657 ]
  %spec.store.select9216.i659 = phi i32 [ %.0..0..0..0..0..0.84.i655, %._crit_edge2.i681 ], [ %.0..0..0..0..0..0.84.i655, %473 ], [ %.0..0..0..0..0..0.84.i655, %466 ], [ %.0..0..0..0..0..0.84.i655, %._crit_edge.i664 ], [ %spec.store.select.i658, %._crit_edge.thread.i657 ]
  %499 = add nuw i32 %.0739, 1
  br label %460

500:                                              ; preds = %460
  %.not.i660 = icmp eq i32 %.0..0..0..0..0..0.84.i655, -1
  %.pre.i663 = select i1 %.not.i660, i32 %.0739, i32 %.0740
  %.pre777 = sext i32 %.pre.i663 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit684

SwissTable_find_slot_keyK_hashi32.exit684:        ; preds = %500, %._crit_edge2.i681
  %.pre-phi778 = phi i64 [ %.pre777, %500 ], [ %461, %._crit_edge2.i681 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %502 = getelementptr i8, ptr %452, i64 %.pre-phi778
  %503 = load i8, ptr %502, align 1
  %504 = load ptr, ptr %result.i51.h2s1796, align 8
  %505 = load ptr, ptr %28, align 8
  %506 = load ptr, ptr %504, align 8, !alias.scope !9
  %507 = getelementptr i8, ptr %506, i64 72
  %508 = load ptr, ptr %507, align 8, !alias.scope !9
  %result.i1.i.i306 = call { i64, i64 } %508(ptr nocapture nofree nonnull readonly align 8 %504) #47, !alias.scope !9
  %509 = extractvalue { i64, i64 } %result.i1.i.i306, 0
  %510 = extractvalue { i64, i64 } %result.i1.i.i306, 1
  %511 = urem i64 20, %510
  %512 = icmp eq i64 %511, 0
  %513 = sub i64 %510, %511
  %514 = select i1 %512, i64 0, i64 %513
  %515 = add i64 %509, 20
  %516 = add i64 %515, %514
  %517 = load ptr, ptr %505, align 8, !alias.scope !9
  %518 = getelementptr i8, ptr %517, i64 72
  %519 = load ptr, ptr %518, align 8, !alias.scope !9
  %result.i.i.i307 = call { i64, i64 } %519(ptr nocapture nofree nonnull readonly align 8 %505) #47, !alias.scope !9
  %520 = extractvalue { i64, i64 } %result.i.i.i307, 0
  %521 = extractvalue { i64, i64 } %result.i.i.i307, 1
  %522 = call i64 @llvm.umax.i64(i64 %510, i64 %521) #61
  %523 = call i64 @llvm.umax.i64(i64 %522, i64 noundef 8) #61, !range !5
  %524 = urem i64 %516, %521
  %525 = icmp eq i64 %524, 0
  %526 = sub i64 %521, %524
  %527 = select i1 %525, i64 0, i64 %526
  %528 = add i64 %520, %516
  %529 = add i64 %528, %527
  %530 = urem i64 %529, %523
  %531 = icmp eq i64 %530, 0
  %532 = sub i64 %523, %530
  %533 = select i1 %531, i64 0, i64 %532
  %534 = add i64 %533, %529
  %result.i9.i308 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %534) #51
  store ptr %504, ptr %result.i9.i308, align 8
  %535 = getelementptr inbounds i8, ptr %result.i9.i308, i64 8
  store ptr %505, ptr %535, align 8
  %536 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i308)
  %537 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %538 = load ptr, ptr %504, align 8
  %539 = getelementptr i8, ptr %538, i64 72
  %540 = load ptr, ptr %539, align 8
  %result.i.i10.i309 = call { i64, i64 } %540(ptr nocapture nofree nonnull readonly align 8 %504) #47
  %541 = extractvalue { i64, i64 } %result.i.i10.i309, 1
  %542 = urem i64 20, %541
  %543 = icmp eq i64 %542, 0
  %reass.sub = sub i64 %541, %542
  %544 = add i64 %reass.sub, 20
  %545 = select i1 %543, i64 20, i64 %544
  %546 = getelementptr i8, ptr %result.i9.i308, i64 %545
  %547 = getelementptr i8, ptr %538, i64 64
  %548 = load ptr, ptr %547, align 8
  call void %548({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %504, ptr nocapture nofree writeonly %546) #48
  %549 = load ptr, ptr %result.i9.i308, align 8
  %550 = load ptr, ptr %549, align 8
  %551 = getelementptr i8, ptr %550, i64 72
  %552 = load ptr, ptr %551, align 8
  %result.i1.i11.i311 = call { i64, i64 } %552(ptr nocapture nofree nonnull readonly align 8 %549) #47
  %553 = extractvalue { i64, i64 } %result.i1.i11.i311, 0
  %554 = extractvalue { i64, i64 } %result.i1.i11.i311, 1
  %555 = urem i64 20, %554
  %556 = icmp eq i64 %555, 0
  %557 = sub i64 %554, %555
  %558 = select i1 %556, i64 0, i64 %557
  %559 = add i64 %553, 20
  %560 = add i64 %559, %558
  %561 = load ptr, ptr %535, align 8
  %562 = load ptr, ptr %561, align 8
  %563 = getelementptr i8, ptr %562, i64 72
  %564 = load ptr, ptr %563, align 8
  %result.i.i12.i312 = call { i64, i64 } %564(ptr nocapture nofree nonnull readonly align 8 %561) #47
  %565 = extractvalue { i64, i64 } %result.i.i12.i312, 1
  %566 = urem i64 %560, %565
  %567 = icmp eq i64 %566, 0
  %568 = sub i64 %565, %566
  %569 = select i1 %567, i64 0, i64 %568
  %570 = getelementptr i8, ptr %result.i9.i308, i64 %560
  %571 = getelementptr i8, ptr %570, i64 %569
  %572 = getelementptr i8, ptr %562, i64 64
  %573 = load ptr, ptr %572, align 8
  call void %573({ ptr, i160 } %346, ptr nocapture nofree nonnull readonly align 8 %561, ptr nocapture nofree writeonly %571) #48
  %574 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %575 = getelementptr inbounds i8, ptr %result.i9.i308, i64 16
  store i32 %456, ptr %575, align 8
  %576 = icmp eq i8 %503, 0
  br i1 %576, label %577, label %SwissTable_insert_keyK_valueV.exit316

577:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit684
  store i8 1, ptr %502, align 1
  %578 = add i32 %450, 1
  store i32 %578, ptr %38, align 4
  br label %SwissTable_insert_keyK_valueV.exit316

SwissTable_insert_keyK_valueV.exit316:            ; preds = %577, %SwissTable_find_slot_keyK_hashi32.exit684
  %579 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %580 = shl nsw i64 %.pre-phi778, 5
  %581 = getelementptr i8, ptr %451, i64 %580
  store ptr @Entry, ptr %581, align 8
  %582 = getelementptr i8, ptr %581, i64 8
  %583 = ptrtoint ptr %result.i9.i308 to i64
  store i64 %583, ptr %582, align 4
  %.sroa_idx3.i314 = getelementptr i8, ptr %581, i64 24
  store i32 10, ptr %.sroa_idx3.i314, align 4
  %584 = sext i32 %137 to i64
  %585 = add i64 %.0454153, %584
  %586 = add nsw i32 %.0438154, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %SwissTable_insert_keyK_valueV.exit316, %SwissTable_get_keyK.exit
  %587 = phi ptr [ %335, %SwissTable_insert_keyK_valueV.exit316 ], [ %46, %SwissTable_get_keyK.exit ]
  %588 = phi ptr [ %252, %SwissTable_insert_keyK_valueV.exit316 ], [ %47, %SwissTable_get_keyK.exit ]
  %.pre9081421 = phi ptr [ %.pre9081422, %SwissTable_insert_keyK_valueV.exit316 ], [ %.pre9081420, %SwissTable_get_keyK.exit ]
  %589 = phi ptr [ %336, %SwissTable_insert_keyK_valueV.exit316 ], [ %48, %SwissTable_get_keyK.exit ]
  %590 = phi i32 [ %255, %SwissTable_insert_keyK_valueV.exit316 ], [ %49, %SwissTable_get_keyK.exit ]
  %591 = phi ptr [ %335, %SwissTable_insert_keyK_valueV.exit316 ], [ %50, %SwissTable_get_keyK.exit ]
  %592 = phi i32 [ %337, %SwissTable_insert_keyK_valueV.exit316 ], [ %51, %SwissTable_get_keyK.exit ]
  %593 = phi i32 [ %255, %SwissTable_insert_keyK_valueV.exit316 ], [ %52, %SwissTable_get_keyK.exit ]
  %594 = phi ptr [ %451, %SwissTable_insert_keyK_valueV.exit316 ], [ %53, %SwissTable_get_keyK.exit ]
  %.pre9071419 = phi ptr [ %452, %SwissTable_insert_keyK_valueV.exit316 ], [ %.pre907, %SwissTable_get_keyK.exit ]
  %595 = phi ptr [ %459, %SwissTable_insert_keyK_valueV.exit316 ], [ %54, %SwissTable_get_keyK.exit ]
  %596 = phi ptr [ %452, %SwissTable_insert_keyK_valueV.exit316 ], [ %108, %SwissTable_get_keyK.exit ]
  %597 = phi i32 [ %453, %SwissTable_insert_keyK_valueV.exit316 ], [ %56, %SwissTable_get_keyK.exit ]
  %598 = phi ptr [ %455, %SwissTable_insert_keyK_valueV.exit316 ], [ %57, %SwissTable_get_keyK.exit ]
  %.1455 = phi i64 [ %585, %SwissTable_insert_keyK_valueV.exit316 ], [ %.0454153, %SwissTable_get_keyK.exit ]
  %.1439 = phi i32 [ %586, %SwissTable_insert_keyK_valueV.exit316 ], [ %.0438154, %SwissTable_get_keyK.exit ]
  %599 = add nuw nsw i32 %.0437155, 1
  %600 = icmp slt i32 %.1439, %0
  %601 = icmp slt i32 %599, %39
  %spec.select = select i1 %600, i1 %601, i1 false
  br i1 %spec.select, label %45, label %._crit_edge3._crit_edge.loopexit

._crit_edge3._crit_edge.loopexit:                 ; preds = %._crit_edge1
  %602 = add i32 %590, -1
  br label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge3._crit_edge.loopexit, %1
  %603 = phi ptr [ %result.i.i181, %1 ], [ %588, %._crit_edge3._crit_edge.loopexit ]
  %604 = phi i32 [ 7, %1 ], [ %602, %._crit_edge3._crit_edge.loopexit ]
  %.0454.lcssa = phi i64 [ 0, %1 ], [ %.1455, %._crit_edge3._crit_edge.loopexit ]
  %.0438.lcssa = phi i32 [ 0, %1 ], [ %.1439, %._crit_edge3._crit_edge.loopexit ]
  %.sroa.gep465 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep468 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep471 = getelementptr inbounds i8, ptr %7, i64 24
  %.sroa.gep474 = getelementptr inbounds i8, ptr %6, i64 8
  %.sroa.gep477 = getelementptr inbounds i8, ptr %6, i64 16
  %.sroa.gep480 = getelementptr inbounds i8, ptr %6, i64 24
  %605 = icmp slt i32 %.0438.lcssa, %0
  br i1 %605, label %RangeIterator_next_.exit52.i.preheader, label %._crit_edge4

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge3._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %606 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %607 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 87, ptr %result.i5.i.h2s1794, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s1794, i64 1
  store <28 x i8> <i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %scevgep, align 1
  %608 = getelementptr inbounds i8, ptr %result.i5.i.h2s1794, i64 29
  store i8 0, ptr %608, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i.h2s1794) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %609 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0438.lcssa) #59
  %610 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %612 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %613 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 32, ptr %result.i5.i810.h2s1792, align 1
  %scevgep1045 = getelementptr inbounds i8, ptr %result.i5.i810.h2s1792, i64 1
  store <32 x i8> <i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %scevgep1045, align 1
  %614 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %615 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %616 = getelementptr inbounds i8, ptr %result.i5.i810.h2s1792, i64 33
  store i8 0, ptr %616, align 1
  %puts.i480 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(34) %result.i5.i810.h2s1792) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %._crit_edge3._crit_edge
  %.0459 = phi i32 [ %.0438.lcssa, %RangeIterator_next_.exit52.i.preheader ], [ %0, %._crit_edge3._crit_edge ]
  %617 = call i64 @clock()
  %618 = icmp sgt i32 %.0459, 0
  br i1 %618, label %.lr.ph172.preheader, label %RangeIterator_next_.exit52.i.preheader2322

.lr.ph172.preheader:                              ; preds = %._crit_edge4
  %619 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %620 = zext nneg i32 %.0459 to i64
  %621 = load ptr, ptr %4, align 8
  br label %.lr.ph172

.lr.ph172:                                        ; preds = %._crit_edge5, %.lr.ph172.preheader
  %indvars.iv = phi i64 [ 0, %.lr.ph172.preheader ], [ %indvars.iv.next, %._crit_edge5 ]
  %.0440171 = phi i64 [ 0, %.lr.ph172.preheader ], [ %.1441, %._crit_edge5 ]
  %.0443170 = phi i1 [ true, %.lr.ph172.preheader ], [ %.1444, %._crit_edge5 ]
  %.0446169 = phi i32 [ 0, %.lr.ph172.preheader ], [ %.2448, %._crit_edge5 ]
  %622 = shl i64 %indvars.iv, 2
  %623 = getelementptr i8, ptr %result.i2.i209, i64 %622
  %624 = load i32, ptr %623, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %625 = add i32 %624, 2127912214
  %626 = shl i32 %624, 12
  %627 = add i32 %625, %626
  %628 = ashr i32 %627, 19
  %629 = xor i32 %627, %628
  %630 = xor i32 %629, -949894596
  %631 = add i32 %630, 374761393
  %632 = shl i32 %630, 5
  %633 = add i32 %631, %632
  %634 = add i32 %633, -744332180
  %635 = shl i32 %633, 9
  %636 = xor i32 %634, %635
  %637 = add i32 %636, -42973499
  %638 = shl i32 %636, 3
  %639 = add i32 %637, %638
  %640 = ashr i32 %639, 16
  %641 = xor i32 %639, %640
  %642 = xor i32 %641, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %643 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %644

644:                                              ; preds = %682, %.lr.ph172
  %.0738 = phi i32 [ -1, %.lr.ph172 ], [ %.1, %682 ]
  %.pn1511 = phi i32 [ %642, %.lr.ph172 ], [ %683, %682 ]
  %.0..0..0..0..0..0.84.i699 = phi i32 [ -1, %.lr.ph172 ], [ %spec.store.select9216.i703, %682 ]
  %.0 = and i32 %.pn1511, %604
  %645 = sext i32 %.0 to i64
  %646 = getelementptr i8, ptr %603, i64 %645
  %647 = load i8, ptr %646, align 1
  switch i8 %647, label %._crit_edge.i708 [
    i8 0, label %684
    i8 -128, label %._crit_edge.thread.i701
  ]

._crit_edge.thread.i701:                          ; preds = %644
  %648 = icmp eq i32 %.0..0..0..0..0..0.84.i699, -1
  %spec.store.select.i702 = select i1 %648, i32 %.0, i32 %.0..0..0..0..0..0.84.i699
  br label %682

._crit_edge.i708:                                 ; preds = %644
  %649 = icmp sgt i8 %647, 0
  br i1 %649, label %650, label %682

650:                                              ; preds = %._crit_edge.i708
  %651 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %652 = shl nsw i64 %645, 5
  %653 = getelementptr i8, ptr %621, i64 %652
  %654 = load ptr, ptr %653, align 8
  %655 = icmp ne ptr %654, @nil_typ
  %656 = icmp ne ptr %654, null
  %.not82.i710 = and i1 %655, %656
  br i1 %.not82.i710, label %657, label %682

657:                                              ; preds = %650
  %658 = getelementptr i8, ptr %653, i64 8
  %659 = load i64, ptr %658, align 4
  %.sroa_idx.i711 = getelementptr i8, ptr %653, i64 16
  %660 = load i64, ptr %.sroa_idx.i711, align 4
  %661 = inttoptr i64 %659 to ptr
  %662 = inttoptr i64 %660 to ptr
  %hash_coef_ptr.i3.i712 = getelementptr i8, ptr %654, i64 8
  %tbl_size_ptr.i4.i713 = getelementptr i8, ptr %654, i64 16
  %offset_tbl_ptr.i5.i714 = getelementptr i8, ptr %654, i64 40
  %hash_coef.i6.i715 = load i64, ptr %hash_coef_ptr.i3.i712, align 4
  %tbl_size.i7.i716 = load i64, ptr %tbl_size_ptr.i4.i713, align 4
  %offset_tbl.i8.i717 = load ptr, ptr %offset_tbl_ptr.i5.i714, align 8
  %product.i.i9.i718 = mul i64 %hash_coef.i6.i715, 4015701072841558310
  %shifted.i.i10.i719 = lshr i64 %product.i.i9.i718, 32
  %xored.i.i11.i720 = xor i64 %shifted.i.i10.i719, %product.i.i9.i718
  %hash.i.i12.i721 = and i64 %xored.i.i11.i720, %tbl_size.i7.i716
  %offset_ptr.i13.i722 = getelementptr i32, ptr %offset_tbl.i8.i717, i64 %hash.i.i12.i721
  %offset.i14.i723 = load i32, ptr %offset_ptr.i13.i722, align 4
  %663 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %654, 0
  %664 = insertvalue { ptr, ptr, ptr, i32 } %663, ptr %661, 1
  %665 = insertvalue { ptr, ptr, ptr, i32 } %664, ptr %662, 2
  %666 = insertvalue { ptr, ptr, ptr, i32 } %665, i32 %offset.i14.i723, 3
  %667 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %668 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %654)
  %669 = sext i32 %offset.i14.i723 to i64
  %670 = getelementptr ptr, ptr %654, i64 %669
  %671 = getelementptr i8, ptr %670, i64 40
  %672 = load ptr, ptr %671, align 8
  %result.i1.i724 = call ptr %672({ ptr, ptr, ptr, i32 } %666, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %673 = call i32 %result.i1.i724({ ptr, ptr, ptr, i32 } %666, { ptr, ptr, ptr, i32 } %666, ptr nonnull align 8 %2)
  %674 = icmp eq i32 %673, %642
  br i1 %674, label %._crit_edge2.i725, label %682

._crit_edge2.i725:                                ; preds = %657
  %675 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %676 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %654)
  %677 = getelementptr i8, ptr %670, i64 48
  %678 = load ptr, ptr %677, align 8
  %result.i.i726 = call ptr %678({ ptr, ptr, ptr, i32 } %666, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %679 = call { ptr, i160 } %result.i.i726({ ptr, ptr, ptr, i32 } %666, { ptr, ptr, ptr, i32 } %666, ptr nonnull align 8 %2)
  %680 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i1471 = extractvalue { ptr, i160 } %679, 1
  %.sroa.15.8.extract.trunc.i1472 = trunc i160 %.fca.1.extract3.i1471 to i32
  %681 = icmp eq i32 %624, %.sroa.15.8.extract.trunc.i1472
  br i1 %681, label %SwissTable_find_slot_keyK_hashi32.exit728, label %682

682:                                              ; preds = %._crit_edge2.i725, %657, %650, %._crit_edge.i708, %._crit_edge.thread.i701
  %.1 = phi i32 [ %.0738, %._crit_edge2.i725 ], [ %.0738, %657 ], [ %.0738, %650 ], [ %.0738, %._crit_edge.i708 ], [ %spec.store.select.i702, %._crit_edge.thread.i701 ]
  %spec.store.select9216.i703 = phi i32 [ %.0..0..0..0..0..0.84.i699, %._crit_edge2.i725 ], [ %.0..0..0..0..0..0.84.i699, %657 ], [ %.0..0..0..0..0..0.84.i699, %650 ], [ %.0..0..0..0..0..0.84.i699, %._crit_edge.i708 ], [ %spec.store.select.i702, %._crit_edge.thread.i701 ]
  %683 = add i32 %.0, 1
  br label %644

684:                                              ; preds = %644
  %.not.i704 = icmp eq i32 %.0..0..0..0..0..0.84.i699, -1
  %.pre.i707 = select i1 %.not.i704, i32 %.0, i32 %.0738
  %.pre779 = sext i32 %.pre.i707 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit728

SwissTable_find_slot_keyK_hashi32.exit728:        ; preds = %684, %._crit_edge2.i725
  %.pre-phi780 = phi i64 [ %.pre779, %684 ], [ %645, %._crit_edge2.i725 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %685 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %686 = getelementptr i8, ptr %603, i64 %.pre-phi780
  %687 = load i8, ptr %686, align 1
  switch i8 %687, label %688 [
    i8 -128, label %SwissTable_get_keyK.exit396.thread
    i8 0, label %SwissTable_get_keyK.exit396.thread
  ]

688:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit728
  %689 = shl nsw i64 %.pre-phi780, 5
  %690 = getelementptr i8, ptr %621, i64 %689
  %691 = load ptr, ptr %690, align 8
  %692 = icmp ne ptr %691, @nil_typ
  %693 = icmp ne ptr %691, null
  %.not74.i377 = and i1 %692, %693
  br i1 %.not74.i377, label %SwissTable_get_keyK.exit396, label %SwissTable_get_keyK.exit396.thread

SwissTable_get_keyK.exit396.thread:               ; preds = %688, %SwissTable_find_slot_keyK_hashi32.exit728, %SwissTable_find_slot_keyK_hashi32.exit728
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %714

SwissTable_get_keyK.exit396:                      ; preds = %688
  %694 = getelementptr i8, ptr %690, i64 8
  %695 = load i160, ptr %694, align 4
  %.sroa.262.0.extract.shift.i378 = lshr i160 %695, 64
  %.sroa.262.0.extract.trunc.i379 = trunc i160 %.sroa.262.0.extract.shift.i378 to i64
  %.sroa.061.0.extract.trunc.i380 = trunc i160 %695 to i64
  %696 = inttoptr i64 %.sroa.061.0.extract.trunc.i380 to ptr
  %697 = inttoptr i64 %.sroa.262.0.extract.trunc.i379 to ptr
  %hash_coef_ptr.i3.i381 = getelementptr i8, ptr %691, i64 8
  %tbl_size_ptr.i4.i382 = getelementptr i8, ptr %691, i64 16
  %offset_tbl_ptr.i5.i383 = getelementptr i8, ptr %691, i64 40
  %hash_coef.i6.i384 = load i64, ptr %hash_coef_ptr.i3.i381, align 4
  %tbl_size.i7.i385 = load i64, ptr %tbl_size_ptr.i4.i382, align 4
  %offset_tbl.i8.i386 = load ptr, ptr %offset_tbl_ptr.i5.i383, align 8
  %product.i.i9.i387 = mul i64 %hash_coef.i6.i384, 4015701072841558310
  %shifted.i.i10.i388 = lshr i64 %product.i.i9.i387, 32
  %xored.i.i11.i389 = xor i64 %shifted.i.i10.i388, %product.i.i9.i387
  %hash.i.i12.i390 = and i64 %xored.i.i11.i389, %tbl_size.i7.i385
  %offset_ptr.i13.i391 = getelementptr i32, ptr %offset_tbl.i8.i386, i64 %hash.i.i12.i390
  %offset.i14.i392 = load i32, ptr %offset_ptr.i13.i391, align 4
  %698 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %691, 0
  %699 = insertvalue { ptr, ptr, ptr, i32 } %698, ptr %696, 1
  %700 = insertvalue { ptr, ptr, ptr, i32 } %699, ptr %697, 2
  %701 = insertvalue { ptr, ptr, ptr, i32 } %700, i32 %offset.i14.i392, 3
  %702 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %691)
  %704 = sext i32 %offset.i14.i392 to i64
  %705 = getelementptr ptr, ptr %691, i64 %704
  %706 = getelementptr i8, ptr %705, i64 56
  %707 = load ptr, ptr %706, align 8
  %result.i1.i393 = call ptr %707({ ptr, ptr, ptr, i32 } %701, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %708 = call { ptr, i160 } %result.i1.i393({ ptr, ptr, ptr, i32 } %701, { ptr, ptr, ptr, i32 } %701, ptr nonnull align 8 %2)
  %.fca.0.extract49.i394 = extractvalue { ptr, i160 } %708, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %709 = icmp ne ptr %.fca.0.extract49.i394, @nil_typ
  %710 = icmp ne ptr %.fca.0.extract49.i394, null
  %.not463 = and i1 %709, %710
  br i1 %.not463, label %711, label %714

711:                                              ; preds = %SwissTable_get_keyK.exit396
  %.fca.1.extract50.i395 = extractvalue { ptr, i160 } %708, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract50.i395 to i64
  %sext = shl i64 %.sroa.2.8.extract.trunc, 32
  %712 = ashr exact i64 %sext, 32
  %713 = add i64 %712, %.0440171
  br label %._crit_edge5

714:                                              ; preds = %SwissTable_get_keyK.exit396, %SwissTable_get_keyK.exit396.thread
  %715 = icmp slt i32 %.0446169, 10
  br i1 %715, label %RangeIterator_next_.exit52.i832.preheader, label %._crit_edge5

RangeIterator_next_.exit52.i832.preheader:        ; preds = %714
  %result.i44.h2s1798 = alloca [52 x i8], align 1
  %716 = getelementptr inbounds i8, ptr %result.i44.h2s1798, i64 51
  store i8 0, ptr %716, align 1
  store <51 x i8> <i8 69, i8 114, i8 114, i8 111, i8 114, i8 58, i8 32, i8 78, i8 105, i8 108, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 114, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i44.h2s1798, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %717 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %718 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i829.h2s1799 = alloca [52 x i8], align 1
  %719 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 69, ptr %result.i5.i829.h2s1799, align 1
  %scevgep1050 = getelementptr inbounds i8, ptr %result.i5.i829.h2s1799, i64 1
  %scevgep1051 = getelementptr inbounds i8, ptr %result.i44.h2s1798, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(51) %scevgep1050, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(51) %scevgep1051, i64 noundef 50, i1 noundef false)
  %720 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %721 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %722 = getelementptr inbounds i8, ptr %result.i5.i829.h2s1799, i64 51
  store i8 0, ptr %722, align 1
  %puts.i499 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(52) %result.i5.i829.h2s1799) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %723 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %724 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %624) #59
  %725 = add nsw i32 %.0446169, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %RangeIterator_next_.exit52.i832.preheader, %714, %711
  %.2448 = phi i32 [ %.0446169, %711 ], [ %725, %RangeIterator_next_.exit52.i832.preheader ], [ %.0446169, %714 ]
  %.1444 = phi i1 [ %.0443170, %711 ], [ false, %RangeIterator_next_.exit52.i832.preheader ], [ false, %714 ]
  %.1441 = phi i64 [ %713, %711 ], [ %.0440171, %RangeIterator_next_.exit52.i832.preheader ], [ %.0440171, %714 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %620
  br i1 %exitcond.not, label %RangeIterator_next_.exit52.i.preheader2322, label %.lr.ph172

RangeIterator_next_.exit52.i.preheader2322:       ; preds = %._crit_edge5, %._crit_edge4
  %.0443.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.1444, %._crit_edge5 ]
  %.0440.lcssa = phi i64 [ 0, %._crit_edge4 ], [ %.1441, %._crit_edge5 ]
  %726 = call i64 @clock()
  %.not = icmp eq i64 %.0440.lcssa, %.0454.lcssa
  %result.i42 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #51
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i42, align 1
  %727 = sub i64 %726, %617
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %728 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #43
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %730 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #43
  %result.i5.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #51
  %731 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %732 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %733 = load i8, ptr %result.i42, align 1
  store i8 %733, ptr %result.i5.i, align 1
  %734 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %735 = getelementptr i8, ptr %result.i42, i64 1
  %736 = load i8, ptr %735, align 1
  %737 = getelementptr i8, ptr %result.i5.i, i64 1
  store i8 %736, ptr %737, align 1
  %738 = getelementptr i8, ptr %result.i42, i64 2
  %739 = load i8, ptr %738, align 1
  %740 = getelementptr i8, ptr %result.i5.i, i64 2
  store i8 %739, ptr %740, align 1
  %741 = getelementptr i8, ptr %result.i42, i64 3
  %742 = load i8, ptr %741, align 1
  %743 = getelementptr i8, ptr %result.i5.i, i64 3
  store i8 %742, ptr %743, align 1
  %744 = getelementptr i8, ptr %result.i42, i64 4
  %745 = load i8, ptr %744, align 1
  %746 = getelementptr i8, ptr %result.i5.i, i64 4
  store i8 %745, ptr %746, align 1
  %747 = getelementptr i8, ptr %result.i42, i64 5
  %748 = load i8, ptr %747, align 1
  %749 = getelementptr i8, ptr %result.i5.i, i64 5
  store i8 %748, ptr %749, align 1
  %750 = getelementptr i8, ptr %result.i42, i64 6
  %751 = load i8, ptr %750, align 1
  %752 = getelementptr i8, ptr %result.i5.i, i64 6
  store i8 %751, ptr %752, align 1
  %753 = getelementptr i8, ptr %result.i42, i64 7
  %754 = load i8, ptr %753, align 1
  %755 = getelementptr i8, ptr %result.i5.i, i64 7
  store i8 %754, ptr %755, align 1
  %756 = getelementptr i8, ptr %result.i42, i64 8
  %757 = load i8, ptr %756, align 1
  %758 = getelementptr i8, ptr %result.i5.i, i64 8
  store i8 %757, ptr %758, align 1
  %759 = getelementptr i8, ptr %result.i42, i64 9
  %760 = load i8, ptr %759, align 1
  %761 = getelementptr i8, ptr %result.i5.i, i64 9
  store i8 %760, ptr %761, align 1
  %762 = getelementptr i8, ptr %result.i42, i64 10
  %763 = load i8, ptr %762, align 1
  %764 = getelementptr i8, ptr %result.i5.i, i64 10
  store i8 %763, ptr %764, align 1
  %765 = getelementptr i8, ptr %result.i42, i64 11
  %766 = load i8, ptr %765, align 1
  %767 = getelementptr i8, ptr %result.i5.i, i64 11
  store i8 %766, ptr %767, align 1
  %768 = getelementptr i8, ptr %result.i42, i64 12
  %769 = load i8, ptr %768, align 1
  %770 = getelementptr i8, ptr %result.i5.i, i64 12
  store i8 %769, ptr %770, align 1
  %771 = getelementptr i8, ptr %result.i42, i64 13
  %772 = load i8, ptr %771, align 1
  %773 = getelementptr i8, ptr %result.i5.i, i64 13
  store i8 %772, ptr %773, align 1
  %774 = getelementptr i8, ptr %result.i5.i, i64 14
  store i8 0, ptr %774, align 1
  %puts.i1997 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #52
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %775 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %775, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #59
  %776 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0459) #59
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %777 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %777, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #59
  %778 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %727) #59
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #59
  br i1 %618, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader2322
  %779 = zext nneg i32 %.0459 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %780 = mul i64 %727, 1000000
  %781 = sdiv i64 %780, %779
  %782 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %782, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #59
  %783 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %781) #59
  %784 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #60
  %785 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %786 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %787 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #59
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader2322
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %788 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %789 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 32, ptr %result.i5.i848.h2s1790, align 1
  %scevgep1055 = getelementptr inbounds i8, ptr %result.i5.i848.h2s1790, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep1055, align 1
  %spec.select464 = select i1 %.not, i1 %.0443.lcssa, i1 false
  %790 = getelementptr inbounds i8, ptr %result.i5.i848.h2s1790, i64 18
  store i8 0, ptr %790, align 1
  %puts.i520 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i848.h2s1790) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.0.extract = select i1 %spec.select464, i8 80, i8 70
  %.sroa.0245.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0245.3 = select i1 %spec.select464, <4 x i8> %.sroa.0245.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0245.1.vec.insert = insertelement <4 x i8> %.sroa.0245.3, i8 65, i64 1
  %.fca.2.extract = select i1 %spec.select464, i8 83, i8 73
  %.sroa.0245.2 = select i1 %spec.select464, <4 x i8> %.sroa.0245.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0245.2.vec.insert = insertelement <4 x i8> %.sroa.0245.2, i8 %.fca.2.extract, i64 2
  %.fca.3.extract = select i1 %spec.select464, i8 83, i8 76
  %.sroa.0245.1 = select i1 %spec.select464, <4 x i8> %.sroa.0245.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0245.3.vec.insert = insertelement <4 x i8> %.sroa.0245.1, i8 %.fca.3.extract, i64 3
  br i1 %spec.select464, label %RangeIterator_next_.exit52.i870.preheader, label %._crit_edge8.else

._crit_edge8.else:                                ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i870.preheader

RangeIterator_next_.exit52.i870.preheader:        ; preds = %._crit_edge8.else, %print_benchmark_result.exit
  %.sroa.speculated244 = phi <4 x i8> [ %.sroa.0245.3.vec.insert, %print_benchmark_result.exit ], [ <i8 70, i8 65, i8 73, i8 76>, %._crit_edge8.else ]
  %791 = phi ptr [ %9, %print_benchmark_result.exit ], [ %13, %._crit_edge8.else ]
  %792 = phi ptr [ %8, %print_benchmark_result.exit ], [ %12, %._crit_edge8.else ]
  %.sroa.phi = phi ptr [ %.sroa.gep465, %print_benchmark_result.exit ], [ %.sroa.gep, %._crit_edge8.else ]
  %.sroa.phi466 = phi ptr [ %.sroa.gep468, %print_benchmark_result.exit ], [ %.sroa.gep467, %._crit_edge8.else ]
  %.sroa.phi469 = phi ptr [ %.sroa.gep471, %print_benchmark_result.exit ], [ %.sroa.gep470, %._crit_edge8.else ]
  %793 = phi ptr [ %7, %print_benchmark_result.exit ], [ %11, %._crit_edge8.else ]
  %.sroa.phi472 = phi ptr [ %.sroa.gep474, %print_benchmark_result.exit ], [ %.sroa.gep473, %._crit_edge8.else ]
  %.sroa.phi475 = phi ptr [ %.sroa.gep477, %print_benchmark_result.exit ], [ %.sroa.gep476, %._crit_edge8.else ]
  %.sroa.phi478 = phi ptr [ %.sroa.gep480, %print_benchmark_result.exit ], [ %.sroa.gep479, %._crit_edge8.else ]
  %794 = phi ptr [ %6, %print_benchmark_result.exit ], [ %10, %._crit_edge8.else ]
  %795 = extractelement <4 x i8> %.sroa.speculated244, i64 0
  store ptr @_parameterization_Bufferi8, ptr %794, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi472, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi475, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi478, align 8
  %796 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %794)
  store ptr @buffer_typ, ptr %793, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi466, align 8
  store ptr @i32_typ, ptr %.sroa.phi469, align 8
  %797 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %793) #43
  store ptr @_parameterization_String, ptr %792, align 8
  %798 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %792)
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %791, align 8
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %791) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %801 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %802 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %803 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 %795, ptr %result.i5.i867.h2s1788, align 1
  %scevgep1060 = getelementptr inbounds i8, ptr %result.i5.i867.h2s1788, i64 1
  %result.i38.h2s1789.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sroa.speculated244, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i38.h2s1789.sroa.0.1.vec.extract, ptr %scevgep1060, align 1
  %804 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %805 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %806 = getelementptr inbounds i8, ptr %result.i5.i867.h2s1788, i64 4
  store i8 0, ptr %806, align 1
  %puts.i540 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i867.h2s1788) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr #17 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i1166.h2s2256 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i5.i1166.h2s2256, align 2
  %result.i5.i1147.h2s2257 = alloca [9 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i5.i1147.h2s2257, i8 0, i64 9, i1 false)
  %result.i5.i1128.h2s2259 = alloca [14 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i5.i1128.h2s2259, i8 0, i64 14, i1 false)
  %result.i5.i1109.h2s2261 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i1109.h2s2261, i8 0, i64 5, i1 false)
  %result.i5.i1090.h2s2263 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i1090.h2s2263, i8 0, i64 19, i1 false)
  %result.i5.i1071.h2s2265 = alloca [23 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(23) %result.i5.i1071.h2s2265, i8 0, i64 23, i1 false)
  %result.i5.i.h2s2267 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i.h2s2267, i8 0, i64 30, i1 false)
  %result.i67.h2s2269 = alloca [64 x i8], align 8
  %3 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 24
  %result.i72.h2s2270 = alloca [64 x i8], align 8
  %4 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 24
  %5 = alloca [2 x ptr], align 8
  %oldProtect.i78 = alloca i32, align 4
  %oldProtect.i76 = alloca i32, align 4
  %oldProtect.i74 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0509.sroa.0 = alloca i8, align 8
  %6 = alloca [4 x ptr], align 8
  %7 = alloca { ptr, ptr, ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [4 x ptr], align 8
  %11 = alloca { ptr, ptr, ptr, ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  store ptr @_parameterization_i32, ptr %result.i72.h2s2270, align 8
  %14 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 8
  store ptr @_parameterization_i32, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i72.h2s2270) #60
  %result.i71 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  %result.i73 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i71, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i71, ptr noalias nofree noundef nonnull readnone @zhsmkwsjzt, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i47 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i71) #50
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i71) #60
  %result.i70 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i74) #60
  %result.i75 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i70, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i74) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i74) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i70, ptr noalias nofree noundef nonnull readnone @enhzrnpgee, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i46 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i70) #50
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i70) #60
  %19 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 48
  store ptr %ret.i47, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 56
  store ptr %ret.i46, ptr %20, align 8
  %result.i1.i218 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  store ptr %result.i1.i218, ptr %4, align 8
  %result.i.i219 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %21 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 32
  store ptr %result.i.i219, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 40
  %23 = getelementptr inbounds i8, ptr %result.i72.h2s2270, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %22, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #43
  store ptr @_parameterization_i32, ptr %result.i67.h2s2269, align 8
  %25 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 8
  store ptr @_parameterization_Bool, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i67.h2s2269) #60
  %result.i66 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i76) #60
  %result.i77 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i66, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i76) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i76) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i66, ptr noalias nofree noundef nonnull readnone @vncryakffn, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i45 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i66) #50
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i66) #60
  %result.i65 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #60
  %result.i79 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i65, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i65, ptr noalias nofree noundef nonnull readnone @yfgrqyuxdb, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i65) #50
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i65) #60
  %30 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 48
  store ptr %ret.i45, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 56
  store ptr %ret.i, ptr %31, align 8
  %result.i1.i258 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  store ptr %result.i1.i258, ptr %3, align 8
  %result.i.i259 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %32 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 32
  store ptr %result.i.i259, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 40
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %35 = getelementptr inbounds i8, ptr %result.i67.h2s2269, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %33, align 8
  %36 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %11, i64 8
  %.sroa.gep576 = getelementptr inbounds i8, ptr %11, i64 16
  %.sroa.gep579 = getelementptr inbounds i8, ptr %11, i64 24
  %.sroa.gep582 = getelementptr inbounds i8, ptr %10, i64 8
  %.sroa.gep585 = getelementptr inbounds i8, ptr %10, i64 16
  %.sroa.gep588 = getelementptr inbounds i8, ptr %10, i64 24
  %37 = icmp sgt i32 %0, 0
  %38 = icmp sgt i32 %36, 0
  %spec.select191 = and i1 %37, %38
  br i1 %spec.select191, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #43
  %41 = getelementptr inbounds i8, ptr %5, i64 8
  br label %42

42:                                               ; preds = %._crit_edge1, %.lr.ph
  %43 = phi ptr [ %result.i1.i218, %.lr.ph ], [ %578, %._crit_edge1 ]
  %44 = phi ptr [ %result.i.i219, %.lr.ph ], [ %579, %._crit_edge1 ]
  %.pre12151803 = phi ptr [ %result.i.i219, %.lr.ph ], [ %.pre12151804, %._crit_edge1 ]
  %45 = phi ptr [ %result.i.i219, %.lr.ph ], [ %580, %._crit_edge1 ]
  %46 = phi i32 [ 8, %.lr.ph ], [ %581, %._crit_edge1 ]
  %47 = phi ptr [ %result.i1.i218, %.lr.ph ], [ %582, %._crit_edge1 ]
  %48 = phi i32 [ 0, %.lr.ph ], [ %583, %._crit_edge1 ]
  %49 = phi i32 [ 8, %.lr.ph ], [ %584, %._crit_edge1 ]
  %50 = phi ptr [ %result.i1.i258, %.lr.ph ], [ %585, %._crit_edge1 ]
  %.pre1214 = phi ptr [ %result.i.i259, %.lr.ph ], [ %.pre12141802, %._crit_edge1 ]
  %51 = phi ptr [ %ret.i, %.lr.ph ], [ %586, %._crit_edge1 ]
  %52 = phi ptr [ %result.i.i259, %.lr.ph ], [ %587, %._crit_edge1 ]
  %53 = phi i32 [ 8, %.lr.ph ], [ %588, %._crit_edge1 ]
  %54 = phi ptr [ %ret.i45, %.lr.ph ], [ %589, %._crit_edge1 ]
  %55 = phi i32 [ 789, %.lr.ph ], [ %58, %._crit_edge1 ]
  %.0543195 = phi i32 [ 0, %.lr.ph ], [ %590, %._crit_edge1 ]
  %.0546194 = phi i32 [ 0, %.lr.ph ], [ %.1547, %._crit_edge1 ]
  %56 = mul i32 %55, 1103515245
  %57 = add i32 %56, 12345
  %58 = and i32 %57, 2147483647
  %.sroa.0533.0.insert.ext = zext nneg i32 %58 to i160
  %59 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0533.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #60
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %61 = call i32 %54({ ptr, i160 } %59)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %62 = add i32 %53, -1
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %64

64:                                               ; preds = %102, %42
  %.pn = phi i32 [ %61, %42 ], [ %103, %102 ]
  %.0992 = phi i32 [ -1, %42 ], [ %.1993, %102 ]
  %.0..0..0..0..0..0.84.i = phi i32 [ -1, %42 ], [ %spec.store.select9216.i, %102 ]
  %.0994 = and i32 %.pn, %62
  %65 = sext i32 %.0994 to i64
  %66 = getelementptr i8, ptr %52, i64 %65
  %67 = load i8, ptr %66, align 1
  switch i8 %67, label %._crit_edge.i [
    i8 0, label %104
    i8 -128, label %._crit_edge.thread.i
  ]

._crit_edge.thread.i:                             ; preds = %64
  %68 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %spec.store.select.i = select i1 %68, i32 %.0994, i32 %.0..0..0..0..0..0.84.i
  br label %102

._crit_edge.i:                                    ; preds = %64
  %69 = icmp sgt i8 %67, 0
  br i1 %69, label %70, label %102

70:                                               ; preds = %._crit_edge.i
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %72 = shl nsw i64 %65, 5
  %73 = getelementptr i8, ptr %50, i64 %72
  %74 = load ptr, ptr %73, align 8
  %75 = icmp ne ptr %74, @nil_typ
  %76 = icmp ne ptr %74, null
  %.not82.i = and i1 %75, %76
  br i1 %.not82.i, label %77, label %102

77:                                               ; preds = %70
  %78 = getelementptr i8, ptr %73, i64 8
  %79 = load i64, ptr %78, align 4
  %.sroa_idx.i = getelementptr i8, ptr %73, i64 16
  %80 = load i64, ptr %.sroa_idx.i, align 4
  %81 = inttoptr i64 %79 to ptr
  %82 = inttoptr i64 %80 to ptr
  %hash_coef_ptr.i3.i743 = getelementptr i8, ptr %74, i64 8
  %tbl_size_ptr.i4.i744 = getelementptr i8, ptr %74, i64 16
  %offset_tbl_ptr.i5.i745 = getelementptr i8, ptr %74, i64 40
  %hash_coef.i6.i746 = load i64, ptr %hash_coef_ptr.i3.i743, align 4
  %tbl_size.i7.i747 = load i64, ptr %tbl_size_ptr.i4.i744, align 4
  %offset_tbl.i8.i748 = load ptr, ptr %offset_tbl_ptr.i5.i745, align 8
  %product.i.i9.i749 = mul i64 %hash_coef.i6.i746, 4015701072841558310
  %shifted.i.i10.i750 = lshr i64 %product.i.i9.i749, 32
  %xored.i.i11.i751 = xor i64 %shifted.i.i10.i750, %product.i.i9.i749
  %hash.i.i12.i752 = and i64 %xored.i.i11.i751, %tbl_size.i7.i747
  %offset_ptr.i13.i753 = getelementptr i32, ptr %offset_tbl.i8.i748, i64 %hash.i.i12.i752
  %offset.i14.i754 = load i32, ptr %offset_ptr.i13.i753, align 4
  %83 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %74, 0
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %81, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %82, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %offset.i14.i754, 3
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %74)
  %89 = sext i32 %offset.i14.i754 to i64
  %90 = getelementptr ptr, ptr %74, i64 %89
  %91 = getelementptr i8, ptr %90, i64 40
  %92 = load ptr, ptr %91, align 8
  %result.i1.i = call ptr %92({ ptr, ptr, ptr, i32 } %86, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %93 = call i32 %result.i1.i({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull align 8 %2)
  %94 = icmp eq i32 %93, %61
  br i1 %94, label %._crit_edge2.i, label %102

._crit_edge2.i:                                   ; preds = %77
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %74)
  %97 = getelementptr i8, ptr %90, i64 48
  %98 = load ptr, ptr %97, align 8
  %result.i.i755 = call ptr %98({ ptr, ptr, ptr, i32 } %86, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %99 = call { ptr, i160 } %result.i.i755({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull align 8 %2)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %101 = call i1 %51({ ptr, i160 } %99, { ptr, i160 } %59)
  br i1 %101, label %SwissTable_find_slot_keyK_hashi32.exit, label %102

102:                                              ; preds = %._crit_edge2.i, %77, %70, %._crit_edge.i, %._crit_edge.thread.i
  %.1993 = phi i32 [ %.0992, %._crit_edge2.i ], [ %.0992, %77 ], [ %.0992, %70 ], [ %.0992, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %spec.store.select9216.i = phi i32 [ %.0..0..0..0..0..0.84.i, %._crit_edge2.i ], [ %.0..0..0..0..0..0.84.i, %77 ], [ %.0..0..0..0..0..0.84.i, %70 ], [ %.0..0..0..0..0..0.84.i, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %103 = add nuw i32 %.0994, 1
  br label %64

104:                                              ; preds = %64
  %.not.i = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %.pre.i = select i1 %.not.i, i32 %.0994, i32 %.0992
  %.pre = sext i32 %.pre.i to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit

SwissTable_find_slot_keyK_hashi32.exit:           ; preds = %104, %._crit_edge2.i
  %105 = phi ptr [ %52, %104 ], [ %.pre1214, %._crit_edge2.i ]
  %.pre-phi = phi i64 [ %.pre, %104 ], [ %65, %._crit_edge2.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %107 = getelementptr i8, ptr %105, i64 %.pre-phi
  %108 = load i8, ptr %107, align 1
  switch i8 %108, label %109 [
    i8 -128, label %SwissTable_get_keyK.exit.thread
    i8 0, label %SwissTable_get_keyK.exit.thread
  ]

109:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit
  %110 = shl nsw i64 %.pre-phi, 5
  %111 = getelementptr i8, ptr %50, i64 %110
  %112 = load ptr, ptr %111, align 8
  %113 = icmp ne ptr %112, @nil_typ
  %114 = icmp ne ptr %112, null
  %.not74.i = and i1 %113, %114
  br i1 %.not74.i, label %SwissTable_get_keyK.exit, label %SwissTable_get_keyK.exit.thread

SwissTable_get_keyK.exit.thread:                  ; preds = %109, %SwissTable_find_slot_keyK_hashi32.exit, %SwissTable_find_slot_keyK_hashi32.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %133

SwissTable_get_keyK.exit:                         ; preds = %109
  %115 = getelementptr i8, ptr %111, i64 8
  %116 = load i160, ptr %115, align 4
  %.sroa.262.0.extract.shift.i = lshr i160 %116, 64
  %.sroa.262.0.extract.trunc.i = trunc i160 %.sroa.262.0.extract.shift.i to i64
  %.sroa.061.0.extract.trunc.i = trunc i160 %116 to i64
  %117 = inttoptr i64 %.sroa.061.0.extract.trunc.i to ptr
  %118 = inttoptr i64 %.sroa.262.0.extract.trunc.i to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %112, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %112, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %112, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %119 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %112, 0
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr %117, 1
  %121 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %118, 2
  %122 = insertvalue { ptr, ptr, ptr, i32 } %121, i32 %offset.i14.i, 3
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %112)
  %125 = sext i32 %offset.i14.i to i64
  %126 = getelementptr ptr, ptr %112, i64 %125
  %127 = getelementptr i8, ptr %126, i64 56
  %128 = load ptr, ptr %127, align 8
  %result.i1.i288 = call ptr %128({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %129 = call { ptr, i160 } %result.i1.i288({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 %2)
  %.fca.0.extract49.i = extractvalue { ptr, i160 } %129, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %130 = icmp eq ptr %.fca.0.extract49.i, @nil_typ
  %131 = icmp eq ptr %.fca.0.extract49.i, null
  %132 = or i1 %130, %131
  br i1 %132, label %133, label %._crit_edge1

133:                                              ; preds = %SwissTable_get_keyK.exit, %SwissTable_get_keyK.exit.thread
  %134 = add nuw i32 %58, 1
  %135 = icmp eq i32 %49, 0
  br i1 %135, label %._crit_edge1.i, label %136

136:                                              ; preds = %133
  %137 = add i32 %48, 1
  %138 = mul i32 %49, 7
  %139 = sdiv i32 %138, 10
  %.not.i770 = icmp slt i32 %137, %139
  br i1 %.not.i770, label %SwissTable_ensure_capacity_required_sizei32.exit, label %._crit_edge1.i

._crit_edge1.i:                                   ; preds = %136, %133
  %140 = shl i32 %49, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %140, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %141 = zext nneg i32 %spec.select.i to i64
  %142 = shl nuw nsw i64 %141, 5
  %result.i10.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %142) #51
  store ptr %result.i10.i, ptr %4, align 8
  %result.i9.i1249 = call noalias ptr @bump_malloc_wrapper(i64 noundef %141) #51
  store ptr %result.i9.i1249, ptr %21, align 8
  store i32 %spec.select.i, ptr %22, align 8
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  store i32 0, ptr %23, align 4
  %144 = add i32 %49, -1
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %149 = icmp slt i32 %144, 0
  br i1 %149, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i.preheader

.lr.ph.i.preheader:                               ; preds = %._crit_edge1.i
  %150 = add nsw i32 %spec.select.i, -1
  br label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge2.backedge.i, %.lr.ph.i.preheader
  %151 = phi i32 [ %242, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %storemerge.i = phi i32 [ %246, %._crit_edge2.backedge.i ], [ 1, %.lr.ph.i.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i = phi i32 [ %storemerge.i, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %.sroa.0.8.extract.trunc.i = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i to i64
  %sext.i = shl nuw i64 %.sroa.0.8.extract.trunc.i, 32
  %152 = ashr exact i64 %sext.i, 27
  %153 = getelementptr i8, ptr %47, i64 %152
  %154 = load ptr, ptr %153, align 8
  %155 = icmp ne ptr %154, @nil_typ
  %156 = icmp ne ptr %154, null
  %.not158.i = and i1 %155, %156
  br i1 %.not158.i, label %157, label %._crit_edge2.backedge.i

157:                                              ; preds = %.lr.ph.i
  %158 = getelementptr i8, ptr %153, i64 8
  %159 = load i160, ptr %158, align 4
  %.sroa.3.0.extract.shift.i = lshr i160 %159, 64
  %.sroa.3.0.extract.trunc.i = trunc i160 %.sroa.3.0.extract.shift.i to i64
  %.sroa.0146.0.extract.trunc.i = trunc i160 %159 to i64
  %160 = inttoptr i64 %.sroa.0146.0.extract.trunc.i to ptr
  %161 = inttoptr i64 %.sroa.3.0.extract.trunc.i to ptr
  %hash_coef_ptr.i23.i = getelementptr i8, ptr %154, i64 8
  %tbl_size_ptr.i24.i = getelementptr i8, ptr %154, i64 16
  %offset_tbl_ptr.i25.i = getelementptr i8, ptr %154, i64 40
  %hash_coef.i26.i = load i64, ptr %hash_coef_ptr.i23.i, align 4
  %tbl_size.i27.i = load i64, ptr %tbl_size_ptr.i24.i, align 4
  %offset_tbl.i28.i = load ptr, ptr %offset_tbl_ptr.i25.i, align 8
  %product.i.i29.i = mul i64 %hash_coef.i26.i, 4015701072841558310
  %shifted.i.i30.i = lshr i64 %product.i.i29.i, 32
  %xored.i.i31.i = xor i64 %shifted.i.i30.i, %product.i.i29.i
  %hash.i.i32.i = and i64 %xored.i.i31.i, %tbl_size.i27.i
  %offset_ptr.i33.i = getelementptr i32, ptr %offset_tbl.i28.i, i64 %hash.i.i32.i
  %offset.i34.i = load i32, ptr %offset_ptr.i33.i, align 4
  %162 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %154, 0
  %163 = insertvalue { ptr, ptr, ptr, i32 } %162, ptr %160, 1
  %164 = insertvalue { ptr, ptr, ptr, i32 } %163, ptr %161, 2
  %165 = insertvalue { ptr, ptr, ptr, i32 } %164, i32 %offset.i34.i, 3
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %154)
  %168 = sext i32 %offset.i34.i to i64
  %169 = getelementptr ptr, ptr %154, i64 %168
  %170 = getelementptr i8, ptr %169, i64 48
  %171 = load ptr, ptr %170, align 8
  %result.i4.i = call ptr %171({ ptr, ptr, ptr, i32 } %165, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %172 = call { ptr, i160 } %result.i4.i({ ptr, ptr, ptr, i32 } %165, { ptr, ptr, ptr, i32 } %165, ptr nonnull align 8 %2)
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract.i = extractvalue { ptr, i160 } %172, 1
  %.sroa.1.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i32
  %174 = add i32 %.sroa.1.8.extract.trunc.i, 2127912214
  %175 = shl i32 %.sroa.1.8.extract.trunc.i, 12
  %176 = add i32 %174, %175
  %177 = ashr i32 %176, 19
  %178 = xor i32 %176, %177
  %179 = xor i32 %178, -949894596
  %180 = add i32 %179, 374761393
  %181 = shl i32 %179, 5
  %182 = add i32 %180, %181
  %183 = add i32 %182, -744332180
  %184 = shl i32 %182, 9
  %185 = xor i32 %183, %184
  %186 = add i32 %185, -42973499
  %187 = shl i32 %185, 3
  %188 = add i32 %186, %187
  %189 = ashr i32 %188, 16
  %190 = xor i32 %188, %189
  %191 = xor i32 %190, -1252372727
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %154)
  %194 = load ptr, ptr %170, align 8
  %result.i3.i = call ptr %194({ ptr, ptr, ptr, i32 } %165, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %195 = call { ptr, i160 } %result.i3.i({ ptr, ptr, ptr, i32 } %165, { ptr, ptr, ptr, i32 } %165, ptr nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.1.extract.i1850 = extractvalue { ptr, i160 } %195, 1
  %.sroa.1.8.extract.trunc.i1851 = trunc i160 %.fca.1.extract.i1850 to i32
  br label %196

196:                                              ; preds = %234, %157
  %.pn1906 = phi i32 [ %191, %157 ], [ %235, %234 ]
  %.01595 = phi i32 [ -1, %157 ], [ %.11596, %234 ]
  %.0..0..0..0..0..0.84.i1523 = phi i32 [ -1, %157 ], [ %spec.store.select9216.i1526, %234 ]
  %.01597 = and i32 %.pn1906, %150
  %197 = zext nneg i32 %.01597 to i64
  %198 = getelementptr i8, ptr %result.i9.i1249, i64 %197
  %199 = load i8, ptr %198, align 1
  switch i8 %199, label %._crit_edge.i1529 [
    i8 0, label %236
    i8 -128, label %._crit_edge.thread.i1524
  ]

._crit_edge.thread.i1524:                         ; preds = %196
  %200 = icmp eq i32 %.0..0..0..0..0..0.84.i1523, -1
  %spec.store.select.i1525 = select i1 %200, i32 %.01597, i32 %.0..0..0..0..0..0.84.i1523
  br label %234

._crit_edge.i1529:                                ; preds = %196
  %201 = icmp sgt i8 %199, 0
  br i1 %201, label %202, label %234

202:                                              ; preds = %._crit_edge.i1529
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %204 = shl nuw nsw i64 %197, 5
  %205 = getelementptr i8, ptr %result.i10.i, i64 %204
  %206 = load ptr, ptr %205, align 8
  %207 = icmp ne ptr %206, @nil_typ
  %208 = icmp ne ptr %206, null
  %.not82.i1530 = and i1 %207, %208
  br i1 %.not82.i1530, label %209, label %234

209:                                              ; preds = %202
  %210 = getelementptr i8, ptr %205, i64 8
  %211 = load i64, ptr %210, align 4
  %.sroa_idx.i1531 = getelementptr i8, ptr %205, i64 16
  %212 = load i64, ptr %.sroa_idx.i1531, align 4
  %213 = inttoptr i64 %211 to ptr
  %214 = inttoptr i64 %212 to ptr
  %hash_coef_ptr.i3.i1532 = getelementptr i8, ptr %206, i64 8
  %tbl_size_ptr.i4.i1533 = getelementptr i8, ptr %206, i64 16
  %offset_tbl_ptr.i5.i1534 = getelementptr i8, ptr %206, i64 40
  %hash_coef.i6.i1535 = load i64, ptr %hash_coef_ptr.i3.i1532, align 4
  %tbl_size.i7.i1536 = load i64, ptr %tbl_size_ptr.i4.i1533, align 4
  %offset_tbl.i8.i1537 = load ptr, ptr %offset_tbl_ptr.i5.i1534, align 8
  %product.i.i9.i1538 = mul i64 %hash_coef.i6.i1535, 4015701072841558310
  %shifted.i.i10.i1539 = lshr i64 %product.i.i9.i1538, 32
  %xored.i.i11.i1540 = xor i64 %shifted.i.i10.i1539, %product.i.i9.i1538
  %hash.i.i12.i1541 = and i64 %xored.i.i11.i1540, %tbl_size.i7.i1536
  %offset_ptr.i13.i1542 = getelementptr i32, ptr %offset_tbl.i8.i1537, i64 %hash.i.i12.i1541
  %offset.i14.i1543 = load i32, ptr %offset_ptr.i13.i1542, align 4
  %215 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %206, 0
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, ptr %213, 1
  %217 = insertvalue { ptr, ptr, ptr, i32 } %216, ptr %214, 2
  %218 = insertvalue { ptr, ptr, ptr, i32 } %217, i32 %offset.i14.i1543, 3
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %220 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %206)
  %221 = sext i32 %offset.i14.i1543 to i64
  %222 = getelementptr ptr, ptr %206, i64 %221
  %223 = getelementptr i8, ptr %222, i64 40
  %224 = load ptr, ptr %223, align 8
  %result.i1.i1544 = call ptr %224({ ptr, ptr, ptr, i32 } %218, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %225 = call i32 %result.i1.i1544({ ptr, ptr, ptr, i32 } %218, { ptr, ptr, ptr, i32 } %218, ptr nonnull align 8 %2)
  %226 = icmp eq i32 %225, %191
  br i1 %226, label %._crit_edge2.i1545, label %234

._crit_edge2.i1545:                               ; preds = %209
  %227 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %206)
  %229 = getelementptr i8, ptr %222, i64 48
  %230 = load ptr, ptr %229, align 8
  %result.i.i = call ptr %230({ ptr, ptr, ptr, i32 } %218, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %231 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %218, { ptr, ptr, ptr, i32 } %218, ptr nonnull align 8 %2)
  %232 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i = extractvalue { ptr, i160 } %231, 1
  %.sroa.15.8.extract.trunc.i = trunc i160 %.fca.1.extract3.i to i32
  %233 = icmp eq i32 %.sroa.15.8.extract.trunc.i, %.sroa.1.8.extract.trunc.i1851
  br i1 %233, label %SwissTable_find_slot_keyK_hashi32.exit1546, label %234

234:                                              ; preds = %._crit_edge2.i1545, %209, %202, %._crit_edge.i1529, %._crit_edge.thread.i1524
  %.11596 = phi i32 [ %.01595, %._crit_edge2.i1545 ], [ %.01595, %209 ], [ %.01595, %202 ], [ %.01595, %._crit_edge.i1529 ], [ %spec.store.select.i1525, %._crit_edge.thread.i1524 ]
  %spec.store.select9216.i1526 = phi i32 [ %.0..0..0..0..0..0.84.i1523, %._crit_edge2.i1545 ], [ %.0..0..0..0..0..0.84.i1523, %209 ], [ %.0..0..0..0..0..0.84.i1523, %202 ], [ %.0..0..0..0..0..0.84.i1523, %._crit_edge.i1529 ], [ %spec.store.select.i1525, %._crit_edge.thread.i1524 ]
  %235 = add nuw nsw i32 %.01597, 1
  br label %196

236:                                              ; preds = %196
  %.not.i1527 = icmp eq i32 %.0..0..0..0..0..0.84.i1523, -1
  %.pre.i1528 = select i1 %.not.i1527, i32 %.01597, i32 %.01595
  %.pre1679 = sext i32 %.pre.i1528 to i64
  %.pre1681 = shl nsw i64 %.pre1679, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1546

SwissTable_find_slot_keyK_hashi32.exit1546:       ; preds = %236, %._crit_edge2.i1545
  %.pre-phi1682 = phi i64 [ %.pre1681, %236 ], [ %204, %._crit_edge2.i1545 ]
  %.pre-phi1680 = phi i64 [ %.pre1679, %236 ], [ %197, %._crit_edge2.i1545 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %237 = getelementptr i8, ptr %result.i10.i, i64 %.pre-phi1682
  store ptr %154, ptr %237, align 8
  %238 = getelementptr i8, ptr %237, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i, ptr %238, align 4
  %.sroa_idx120.i = getelementptr i8, ptr %237, i64 16
  store i64 %.sroa.3.0.extract.trunc.i, ptr %.sroa_idx120.i, align 4
  %.sroa_idx121.i = getelementptr i8, ptr %237, i64 24
  store i32 %offset.i34.i, ptr %.sroa_idx121.i, align 4
  %239 = getelementptr i8, ptr %result.i9.i1249, i64 %.pre-phi1680
  store i8 1, ptr %239, align 1
  %240 = add i32 %151, 1
  %241 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i

._crit_edge2.backedge.i:                          ; preds = %SwissTable_find_slot_keyK_hashi32.exit1546, %.lr.ph.i
  %242 = phi i32 [ %240, %SwissTable_find_slot_keyK_hashi32.exit1546 ], [ %151, %.lr.ph.i ]
  %243 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %245 = icmp sgt i32 %storemerge.i, %144
  %246 = add i32 %storemerge.i, 1
  br i1 %245, label %SwissTable_resize_new_capacityi32.exit.loopexit, label %.lr.ph.i

SwissTable_resize_new_capacityi32.exit.loopexit:  ; preds = %._crit_edge2.backedge.i
  store i32 %242, ptr %23, align 4
  br label %SwissTable_resize_new_capacityi32.exit

SwissTable_resize_new_capacityi32.exit:           ; preds = %SwissTable_resize_new_capacityi32.exit.loopexit, %._crit_edge1.i
  %247 = phi i32 [ %242, %SwissTable_resize_new_capacityi32.exit.loopexit ], [ 0, %._crit_edge1.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %SwissTable_ensure_capacity_required_sizei32.exit

SwissTable_ensure_capacity_required_sizei32.exit: ; preds = %SwissTable_resize_new_capacityi32.exit, %136
  %248 = phi ptr [ %43, %136 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %249 = phi ptr [ %44, %136 ], [ %result.i9.i1249, %SwissTable_resize_new_capacityi32.exit ]
  %.pre1215 = phi ptr [ %.pre12151803, %136 ], [ %result.i9.i1249, %SwissTable_resize_new_capacityi32.exit ]
  %250 = phi ptr [ %47, %136 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %251 = phi ptr [ %45, %136 ], [ %result.i9.i1249, %SwissTable_resize_new_capacityi32.exit ]
  %252 = phi i32 [ %46, %136 ], [ %spec.select.i, %SwissTable_resize_new_capacityi32.exit ]
  %253 = phi i32 [ %48, %136 ], [ %247, %SwissTable_resize_new_capacityi32.exit ]
  %254 = add nuw i32 %58, 2127912214
  %255 = shl i32 %57, 12
  %256 = add i32 %254, %255
  %257 = ashr i32 %256, 19
  %258 = xor i32 %256, %257
  %259 = xor i32 %258, -949894596
  %260 = add i32 %259, 374761393
  %261 = shl i32 %259, 5
  %262 = add i32 %260, %261
  %263 = add i32 %262, -744332180
  %264 = shl i32 %262, 9
  %265 = xor i32 %263, %264
  %266 = add i32 %265, -42973499
  %267 = shl i32 %265, 3
  %268 = add i32 %266, %267
  %269 = ashr i32 %268, 16
  %270 = xor i32 %268, %269
  %271 = xor i32 %270, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %272 = add i32 %252, -1
  %273 = and i32 %272, %271
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %275

275:                                              ; preds = %313, %SwissTable_ensure_capacity_required_sizei32.exit
  %.0995 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %.1996, %313 ]
  %.0991 = phi i32 [ %273, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %315, %313 ]
  %.0..0..0..0..0..0.84.i788 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %spec.store.select9216.i792, %313 ]
  %276 = sext i32 %.0991 to i64
  %277 = getelementptr i8, ptr %251, i64 %276
  %278 = load i8, ptr %277, align 1
  switch i8 %278, label %._crit_edge.i797 [
    i8 0, label %316
    i8 -128, label %._crit_edge.thread.i790
  ]

._crit_edge.thread.i790:                          ; preds = %275
  %279 = icmp eq i32 %.0..0..0..0..0..0.84.i788, -1
  %spec.store.select.i791 = select i1 %279, i32 %.0991, i32 %.0..0..0..0..0..0.84.i788
  br label %313

._crit_edge.i797:                                 ; preds = %275
  %280 = icmp sgt i8 %278, 0
  br i1 %280, label %281, label %313

281:                                              ; preds = %._crit_edge.i797
  %282 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %283 = shl nsw i64 %276, 5
  %284 = getelementptr i8, ptr %250, i64 %283
  %285 = load ptr, ptr %284, align 8
  %286 = icmp ne ptr %285, @nil_typ
  %287 = icmp ne ptr %285, null
  %.not82.i799 = and i1 %286, %287
  br i1 %.not82.i799, label %288, label %313

288:                                              ; preds = %281
  %289 = getelementptr i8, ptr %284, i64 8
  %290 = load i64, ptr %289, align 4
  %.sroa_idx.i800 = getelementptr i8, ptr %284, i64 16
  %291 = load i64, ptr %.sroa_idx.i800, align 4
  %292 = inttoptr i64 %290 to ptr
  %293 = inttoptr i64 %291 to ptr
  %hash_coef_ptr.i3.i801 = getelementptr i8, ptr %285, i64 8
  %tbl_size_ptr.i4.i802 = getelementptr i8, ptr %285, i64 16
  %offset_tbl_ptr.i5.i803 = getelementptr i8, ptr %285, i64 40
  %hash_coef.i6.i804 = load i64, ptr %hash_coef_ptr.i3.i801, align 4
  %tbl_size.i7.i805 = load i64, ptr %tbl_size_ptr.i4.i802, align 4
  %offset_tbl.i8.i806 = load ptr, ptr %offset_tbl_ptr.i5.i803, align 8
  %product.i.i9.i807 = mul i64 %hash_coef.i6.i804, 4015701072841558310
  %shifted.i.i10.i808 = lshr i64 %product.i.i9.i807, 32
  %xored.i.i11.i809 = xor i64 %shifted.i.i10.i808, %product.i.i9.i807
  %hash.i.i12.i810 = and i64 %xored.i.i11.i809, %tbl_size.i7.i805
  %offset_ptr.i13.i811 = getelementptr i32, ptr %offset_tbl.i8.i806, i64 %hash.i.i12.i810
  %offset.i14.i812 = load i32, ptr %offset_ptr.i13.i811, align 4
  %294 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %285, 0
  %295 = insertvalue { ptr, ptr, ptr, i32 } %294, ptr %292, 1
  %296 = insertvalue { ptr, ptr, ptr, i32 } %295, ptr %293, 2
  %297 = insertvalue { ptr, ptr, ptr, i32 } %296, i32 %offset.i14.i812, 3
  %298 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %299 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %285)
  %300 = sext i32 %offset.i14.i812 to i64
  %301 = getelementptr ptr, ptr %285, i64 %300
  %302 = getelementptr i8, ptr %301, i64 40
  %303 = load ptr, ptr %302, align 8
  %result.i1.i813 = call ptr %303({ ptr, ptr, ptr, i32 } %297, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %304 = call i32 %result.i1.i813({ ptr, ptr, ptr, i32 } %297, { ptr, ptr, ptr, i32 } %297, ptr nonnull align 8 %2)
  %305 = icmp eq i32 %304, %271
  br i1 %305, label %._crit_edge2.i814, label %313

._crit_edge2.i814:                                ; preds = %288
  %306 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %307 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %285)
  %308 = getelementptr i8, ptr %301, i64 48
  %309 = load ptr, ptr %308, align 8
  %result.i.i815 = call ptr %309({ ptr, ptr, ptr, i32 } %297, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %310 = call { ptr, i160 } %result.i.i815({ ptr, ptr, ptr, i32 } %297, { ptr, ptr, ptr, i32 } %297, ptr nonnull align 8 %2)
  %311 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i1854 = extractvalue { ptr, i160 } %310, 1
  %.sroa.15.8.extract.trunc.i1855 = trunc i160 %.fca.1.extract3.i1854 to i32
  %312 = icmp eq i32 %58, %.sroa.15.8.extract.trunc.i1855
  br i1 %312, label %SwissTable_find_slot_keyK_hashi32.exit817, label %313

313:                                              ; preds = %._crit_edge2.i814, %288, %281, %._crit_edge.i797, %._crit_edge.thread.i790
  %.1996 = phi i32 [ %.0995, %._crit_edge2.i814 ], [ %.0995, %288 ], [ %.0995, %281 ], [ %.0995, %._crit_edge.i797 ], [ %spec.store.select.i791, %._crit_edge.thread.i790 ]
  %spec.store.select9216.i792 = phi i32 [ %.0..0..0..0..0..0.84.i788, %._crit_edge2.i814 ], [ %.0..0..0..0..0..0.84.i788, %288 ], [ %.0..0..0..0..0..0.84.i788, %281 ], [ %.0..0..0..0..0..0.84.i788, %._crit_edge.i797 ], [ %spec.store.select.i791, %._crit_edge.thread.i790 ]
  %314 = add i32 %.0991, 1
  %315 = and i32 %314, %272
  br label %275

316:                                              ; preds = %275
  %.not.i793 = icmp eq i32 %.0..0..0..0..0..0.84.i788, -1
  %.pre.i796 = select i1 %.not.i793, i32 %.0991, i32 %.0995
  %.pre1030 = sext i32 %.pre.i796 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit817

SwissTable_find_slot_keyK_hashi32.exit817:        ; preds = %316, %._crit_edge2.i814
  %317 = phi ptr [ %251, %316 ], [ %.pre1215, %._crit_edge2.i814 ]
  %.pre-phi1031 = phi i64 [ %.pre1030, %316 ], [ %276, %._crit_edge2.i814 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %318 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %319 = getelementptr i8, ptr %317, i64 %.pre-phi1031
  %320 = load i8, ptr %319, align 1
  %result.i9.i = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  store ptr @_parameterization_i32, ptr %result.i9.i, align 8
  %321 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr @_parameterization_i32, ptr %321, align 8
  %322 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9.i)
  %323 = getelementptr inbounds i8, ptr %result.i9.i, i64 20
  store i32 %58, ptr %323, align 4
  %324 = getelementptr inbounds i8, ptr %result.i9.i, i64 24
  store i32 %134, ptr %324, align 8
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %326 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %271, ptr %326, align 8
  %327 = icmp eq i8 %320, 0
  br i1 %327, label %328, label %SwissTable_insert_keyK_valueV.exit

328:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit817
  %329 = getelementptr i8, ptr %249, i64 %.pre-phi1031
  store i8 1, ptr %329, align 1
  %330 = load i32, ptr %23, align 4
  %331 = add i32 %330, 1
  store i32 %331, ptr %23, align 4
  %.pre1807 = load ptr, ptr %4, align 8
  br label %SwissTable_insert_keyK_valueV.exit

SwissTable_insert_keyK_valueV.exit:               ; preds = %328, %SwissTable_find_slot_keyK_hashi32.exit817
  %332 = phi ptr [ %248, %SwissTable_find_slot_keyK_hashi32.exit817 ], [ %.pre1807, %328 ]
  %.pre12151805 = phi ptr [ %.pre1215, %SwissTable_find_slot_keyK_hashi32.exit817 ], [ %249, %328 ]
  %333 = phi ptr [ %317, %SwissTable_find_slot_keyK_hashi32.exit817 ], [ %249, %328 ]
  %334 = phi i32 [ %253, %SwissTable_find_slot_keyK_hashi32.exit817 ], [ %331, %328 ]
  %335 = shl nsw i64 %.pre-phi1031, 5
  %336 = getelementptr i8, ptr %332, i64 %335
  store ptr @Entry, ptr %336, align 8
  %337 = getelementptr i8, ptr %336, i64 8
  %338 = ptrtoint ptr %result.i9.i to i64
  store i64 %338, ptr %337, align 4
  %.sroa_idx3.i = getelementptr i8, ptr %336, i64 24
  store i32 10, ptr %.sroa_idx3.i, align 4
  store i1 true, ptr %.sroa.0509.sroa.0, align 8
  %.sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.0. = load i8, ptr %.sroa.0509.sroa.0, align 8
  %.sroa.0509.0.insert.ext = zext i8 %.sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.0. to i160
  %339 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0509.0.insert.ext, 1
  %340 = load i32, ptr %33, align 8
  %341 = icmp eq i32 %340, 0
  br i1 %341, label %._crit_edge1.i833, label %342

342:                                              ; preds = %SwissTable_insert_keyK_valueV.exit
  %343 = load i32, ptr %35, align 4
  %344 = add i32 %343, 1
  %345 = mul i32 %340, 7
  %346 = sdiv i32 %345, 10
  %.not.i832 = icmp slt i32 %344, %346
  br i1 %.not.i832, label %.SwissTable_ensure_capacity_required_sizei32.exit837_crit_edge, label %._crit_edge1.i833

.SwissTable_ensure_capacity_required_sizei32.exit837_crit_edge: ; preds = %342
  %.pre1808 = load ptr, ptr %32, align 8
  %.pre1809 = load ptr, ptr %3, align 8
  br label %SwissTable_ensure_capacity_required_sizei32.exit837

._crit_edge1.i833:                                ; preds = %342, %SwissTable_insert_keyK_valueV.exit
  %347 = shl i32 %340, 1
  %spec.select.i834 = call i32 @llvm.smax.i32(i32 %347, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %348 = load ptr, ptr %3, align 8
  %349 = zext nneg i32 %spec.select.i834 to i64
  %350 = shl nuw nsw i64 %349, 5
  %result.i10.i1265 = call noalias ptr @bump_malloc_wrapper(i64 noundef %350) #51
  store ptr %result.i10.i1265, ptr %3, align 8
  %result.i9.i1266 = call noalias ptr @bump_malloc_wrapper(i64 noundef %349) #51
  store ptr %result.i9.i1266, ptr %32, align 8
  store i32 %spec.select.i834, ptr %33, align 8
  %351 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  store i32 0, ptr %35, align 4
  %352 = add i32 %340, -1
  %353 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %354 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %355 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %356 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %357 = icmp slt i32 %352, 0
  br i1 %357, label %SwissTable_resize_new_capacityi32.exit1303, label %.lr.ph.i1268.preheader

.lr.ph.i1268.preheader:                           ; preds = %._crit_edge1.i833
  %.promoted1458 = load ptr, ptr %41, align 8
  %358 = load ptr, ptr %30, align 8
  %359 = load ptr, ptr %result.i67.h2s2269, align 8
  %360 = add nsw i32 %spec.select.i834, -1
  %361 = load ptr, ptr %31, align 8
  br label %.lr.ph.i1268

.lr.ph.i1268:                                     ; preds = %._crit_edge2.backedge.i1274, %.lr.ph.i1268.preheader
  %362 = phi i32 [ %437, %._crit_edge2.backedge.i1274 ], [ 0, %.lr.ph.i1268.preheader ]
  %_parameterization_i321459 = phi ptr [ %_parameterization_i321460, %._crit_edge2.backedge.i1274 ], [ %.promoted1458, %.lr.ph.i1268.preheader ]
  %storemerge.i1269 = phi i32 [ %441, %._crit_edge2.backedge.i1274 ], [ 1, %.lr.ph.i1268.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i1270 = phi i32 [ %storemerge.i1269, %._crit_edge2.backedge.i1274 ], [ 0, %.lr.ph.i1268.preheader ]
  %.sroa.0.8.extract.trunc.i1271 = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i1270 to i64
  %sext.i1272 = shl nuw i64 %.sroa.0.8.extract.trunc.i1271, 32
  %363 = ashr exact i64 %sext.i1272, 27
  %364 = getelementptr i8, ptr %348, i64 %363
  %365 = load ptr, ptr %364, align 8
  %366 = icmp ne ptr %365, @nil_typ
  %367 = icmp ne ptr %365, null
  %.not158.i1273 = and i1 %366, %367
  br i1 %.not158.i1273, label %368, label %._crit_edge2.backedge.i1274

368:                                              ; preds = %.lr.ph.i1268
  %369 = getelementptr i8, ptr %364, i64 8
  %370 = load i160, ptr %369, align 4
  %.sroa.3.0.extract.shift.i1276 = lshr i160 %370, 64
  %.sroa.3.0.extract.trunc.i1277 = trunc i160 %.sroa.3.0.extract.shift.i1276 to i64
  %.sroa.0146.0.extract.trunc.i1278 = trunc i160 %370 to i64
  %371 = inttoptr i64 %.sroa.0146.0.extract.trunc.i1278 to ptr
  %372 = inttoptr i64 %.sroa.3.0.extract.trunc.i1277 to ptr
  %hash_coef_ptr.i23.i1279 = getelementptr i8, ptr %365, i64 8
  %tbl_size_ptr.i24.i1280 = getelementptr i8, ptr %365, i64 16
  %offset_tbl_ptr.i25.i1281 = getelementptr i8, ptr %365, i64 40
  %hash_coef.i26.i1282 = load i64, ptr %hash_coef_ptr.i23.i1279, align 4
  %tbl_size.i27.i1283 = load i64, ptr %tbl_size_ptr.i24.i1280, align 4
  %offset_tbl.i28.i1284 = load ptr, ptr %offset_tbl_ptr.i25.i1281, align 8
  %product.i.i29.i1285 = mul i64 %hash_coef.i26.i1282, 4015701072841558310
  %shifted.i.i30.i1286 = lshr i64 %product.i.i29.i1285, 32
  %xored.i.i31.i1287 = xor i64 %shifted.i.i30.i1286, %product.i.i29.i1285
  %hash.i.i32.i1288 = and i64 %xored.i.i31.i1287, %tbl_size.i27.i1283
  %offset_ptr.i33.i1289 = getelementptr i32, ptr %offset_tbl.i28.i1284, i64 %hash.i.i32.i1288
  %offset.i34.i1290 = load i32, ptr %offset_ptr.i33.i1289, align 4
  %373 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %365, 0
  %374 = insertvalue { ptr, ptr, ptr, i32 } %373, ptr %371, 1
  %375 = insertvalue { ptr, ptr, ptr, i32 } %374, ptr %372, 2
  %376 = insertvalue { ptr, ptr, ptr, i32 } %375, i32 %offset.i34.i1290, 3
  %377 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %378 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %365)
  %379 = sext i32 %offset.i34.i1290 to i64
  %380 = getelementptr ptr, ptr %365, i64 %379
  %381 = getelementptr i8, ptr %380, i64 48
  %382 = load ptr, ptr %381, align 8
  %result.i4.i1291 = call ptr %382({ ptr, ptr, ptr, i32 } %376, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %383 = call { ptr, i160 } %result.i4.i1291({ ptr, ptr, ptr, i32 } %376, { ptr, ptr, ptr, i32 } %376, ptr nonnull align 8 %2)
  %384 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %385 = call i32 %358({ ptr, i160 } %383)
  %386 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %387 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %365)
  %388 = load ptr, ptr %381, align 8
  %result.i3.i1293 = call ptr %388({ ptr, ptr, ptr, i32 } %376, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %389 = call { ptr, i160 } %result.i3.i1293({ ptr, ptr, ptr, i32 } %376, { ptr, ptr, ptr, i32 } %376, ptr nonnull align 8 %2)
  store ptr %359, ptr %5, align 8
  %390 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %391

391:                                              ; preds = %429, %368
  %.pn1907 = phi i32 [ %385, %368 ], [ %430, %429 ]
  %.01598 = phi i32 [ -1, %368 ], [ %.11599, %429 ]
  %.0..0..0..0..0..0.84.i1562 = phi i32 [ -1, %368 ], [ %spec.store.select9216.i1566, %429 ]
  %.01600 = and i32 %.pn1907, %360
  %392 = zext nneg i32 %.01600 to i64
  %393 = getelementptr i8, ptr %result.i9.i1266, i64 %392
  %394 = load i8, ptr %393, align 1
  switch i8 %394, label %._crit_edge.i1571 [
    i8 0, label %431
    i8 -128, label %._crit_edge.thread.i1564
  ]

._crit_edge.thread.i1564:                         ; preds = %391
  %395 = icmp eq i32 %.0..0..0..0..0..0.84.i1562, -1
  %spec.store.select.i1565 = select i1 %395, i32 %.01600, i32 %.0..0..0..0..0..0.84.i1562
  br label %429

._crit_edge.i1571:                                ; preds = %391
  %396 = icmp sgt i8 %394, 0
  br i1 %396, label %397, label %429

397:                                              ; preds = %._crit_edge.i1571
  %398 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %399 = shl nuw nsw i64 %392, 5
  %400 = getelementptr i8, ptr %result.i10.i1265, i64 %399
  %401 = load ptr, ptr %400, align 8
  %402 = icmp ne ptr %401, @nil_typ
  %403 = icmp ne ptr %401, null
  %.not82.i1573 = and i1 %402, %403
  br i1 %.not82.i1573, label %404, label %429

404:                                              ; preds = %397
  %405 = getelementptr i8, ptr %400, i64 8
  %406 = load i64, ptr %405, align 4
  %.sroa_idx.i1574 = getelementptr i8, ptr %400, i64 16
  %407 = load i64, ptr %.sroa_idx.i1574, align 4
  %408 = inttoptr i64 %406 to ptr
  %409 = inttoptr i64 %407 to ptr
  %hash_coef_ptr.i3.i1575 = getelementptr i8, ptr %401, i64 8
  %tbl_size_ptr.i4.i1576 = getelementptr i8, ptr %401, i64 16
  %offset_tbl_ptr.i5.i1577 = getelementptr i8, ptr %401, i64 40
  %hash_coef.i6.i1578 = load i64, ptr %hash_coef_ptr.i3.i1575, align 4
  %tbl_size.i7.i1579 = load i64, ptr %tbl_size_ptr.i4.i1576, align 4
  %offset_tbl.i8.i1580 = load ptr, ptr %offset_tbl_ptr.i5.i1577, align 8
  %product.i.i9.i1581 = mul i64 %hash_coef.i6.i1578, 4015701072841558310
  %shifted.i.i10.i1582 = lshr i64 %product.i.i9.i1581, 32
  %xored.i.i11.i1583 = xor i64 %shifted.i.i10.i1582, %product.i.i9.i1581
  %hash.i.i12.i1584 = and i64 %xored.i.i11.i1583, %tbl_size.i7.i1579
  %offset_ptr.i13.i1585 = getelementptr i32, ptr %offset_tbl.i8.i1580, i64 %hash.i.i12.i1584
  %offset.i14.i1586 = load i32, ptr %offset_ptr.i13.i1585, align 4
  %410 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %401, 0
  %411 = insertvalue { ptr, ptr, ptr, i32 } %410, ptr %408, 1
  %412 = insertvalue { ptr, ptr, ptr, i32 } %411, ptr %409, 2
  %413 = insertvalue { ptr, ptr, ptr, i32 } %412, i32 %offset.i14.i1586, 3
  %414 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %415 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %401)
  %416 = sext i32 %offset.i14.i1586 to i64
  %417 = getelementptr ptr, ptr %401, i64 %416
  %418 = getelementptr i8, ptr %417, i64 40
  %419 = load ptr, ptr %418, align 8
  %result.i1.i1587 = call ptr %419({ ptr, ptr, ptr, i32 } %413, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %420 = call i32 %result.i1.i1587({ ptr, ptr, ptr, i32 } %413, { ptr, ptr, ptr, i32 } %413, ptr nonnull align 8 %2)
  %421 = icmp eq i32 %420, %385
  br i1 %421, label %._crit_edge2.i1588, label %429

._crit_edge2.i1588:                               ; preds = %404
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %423 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %401)
  %424 = getelementptr i8, ptr %417, i64 48
  %425 = load ptr, ptr %424, align 8
  %result.i.i1589 = call ptr %425({ ptr, ptr, ptr, i32 } %413, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %426 = call { ptr, i160 } %result.i.i1589({ ptr, ptr, ptr, i32 } %413, { ptr, ptr, ptr, i32 } %413, ptr nonnull align 8 %2)
  %427 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %428 = call i1 %361({ ptr, i160 } %426, { ptr, i160 } %389)
  br i1 %428, label %SwissTable_find_slot_keyK_hashi32.exit1591, label %429

429:                                              ; preds = %._crit_edge2.i1588, %404, %397, %._crit_edge.i1571, %._crit_edge.thread.i1564
  %.11599 = phi i32 [ %.01598, %._crit_edge2.i1588 ], [ %.01598, %404 ], [ %.01598, %397 ], [ %.01598, %._crit_edge.i1571 ], [ %spec.store.select.i1565, %._crit_edge.thread.i1564 ]
  %spec.store.select9216.i1566 = phi i32 [ %.0..0..0..0..0..0.84.i1562, %._crit_edge2.i1588 ], [ %.0..0..0..0..0..0.84.i1562, %404 ], [ %.0..0..0..0..0..0.84.i1562, %397 ], [ %.0..0..0..0..0..0.84.i1562, %._crit_edge.i1571 ], [ %spec.store.select.i1565, %._crit_edge.thread.i1564 ]
  %430 = add nuw nsw i32 %.01600, 1
  br label %391

431:                                              ; preds = %391
  %.not.i1567 = icmp eq i32 %.0..0..0..0..0..0.84.i1562, -1
  %.pre.i1570 = select i1 %.not.i1567, i32 %.01600, i32 %.01598
  %.pre1675 = sext i32 %.pre.i1570 to i64
  %.pre1677 = shl nsw i64 %.pre1675, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1591

SwissTable_find_slot_keyK_hashi32.exit1591:       ; preds = %431, %._crit_edge2.i1588
  %.pre-phi1678 = phi i64 [ %.pre1677, %431 ], [ %399, %._crit_edge2.i1588 ]
  %.pre-phi1676 = phi i64 [ %.pre1675, %431 ], [ %392, %._crit_edge2.i1588 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %432 = getelementptr i8, ptr %result.i10.i1265, i64 %.pre-phi1678
  store ptr %365, ptr %432, align 8
  %433 = getelementptr i8, ptr %432, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i1278, ptr %433, align 4
  %.sroa_idx120.i1298 = getelementptr i8, ptr %432, i64 16
  store i64 %.sroa.3.0.extract.trunc.i1277, ptr %.sroa_idx120.i1298, align 4
  %.sroa_idx121.i1299 = getelementptr i8, ptr %432, i64 24
  store i32 %offset.i34.i1290, ptr %.sroa_idx121.i1299, align 4
  %434 = getelementptr i8, ptr %result.i9.i1266, i64 %.pre-phi1676
  store i8 1, ptr %434, align 1
  %435 = add i32 %362, 1
  %436 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i1274

._crit_edge2.backedge.i1274:                      ; preds = %SwissTable_find_slot_keyK_hashi32.exit1591, %.lr.ph.i1268
  %437 = phi i32 [ %435, %SwissTable_find_slot_keyK_hashi32.exit1591 ], [ %362, %.lr.ph.i1268 ]
  %_parameterization_i321460 = phi ptr [ @_parameterization_i32, %SwissTable_find_slot_keyK_hashi32.exit1591 ], [ %_parameterization_i321459, %.lr.ph.i1268 ]
  %438 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %439 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %440 = icmp sgt i32 %storemerge.i1269, %352
  %441 = add i32 %storemerge.i1269, 1
  br i1 %440, label %SwissTable_resize_new_capacityi32.exit1303.loopexit, label %.lr.ph.i1268

SwissTable_resize_new_capacityi32.exit1303.loopexit: ; preds = %._crit_edge2.backedge.i1274
  store i32 %437, ptr %35, align 4
  store ptr %_parameterization_i321460, ptr %41, align 8
  br label %SwissTable_resize_new_capacityi32.exit1303

SwissTable_resize_new_capacityi32.exit1303:       ; preds = %SwissTable_resize_new_capacityi32.exit1303.loopexit, %._crit_edge1.i833
  %442 = phi i32 [ %437, %SwissTable_resize_new_capacityi32.exit1303.loopexit ], [ 0, %._crit_edge1.i833 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  br label %SwissTable_ensure_capacity_required_sizei32.exit837

SwissTable_ensure_capacity_required_sizei32.exit837: ; preds = %SwissTable_resize_new_capacityi32.exit1303, %.SwissTable_ensure_capacity_required_sizei32.exit837_crit_edge
  %443 = phi i32 [ %343, %.SwissTable_ensure_capacity_required_sizei32.exit837_crit_edge ], [ %442, %SwissTable_resize_new_capacityi32.exit1303 ]
  %444 = phi ptr [ %.pre1809, %.SwissTable_ensure_capacity_required_sizei32.exit837_crit_edge ], [ %result.i10.i1265, %SwissTable_resize_new_capacityi32.exit1303 ]
  %445 = phi ptr [ %.pre1808, %.SwissTable_ensure_capacity_required_sizei32.exit837_crit_edge ], [ %result.i9.i1266, %SwissTable_resize_new_capacityi32.exit1303 ]
  %446 = phi i32 [ %340, %.SwissTable_ensure_capacity_required_sizei32.exit837_crit_edge ], [ %spec.select.i834, %SwissTable_resize_new_capacityi32.exit1303 ]
  %447 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %448 = load ptr, ptr %30, align 8
  %449 = call i32 %448({ ptr, i160 } %59)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %450 = add i32 %446, -1
  %451 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %452 = load ptr, ptr %31, align 8
  br label %453

453:                                              ; preds = %491, %SwissTable_ensure_capacity_required_sizei32.exit837
  %.0989 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit837 ], [ %.1990, %491 ]
  %.pn1908 = phi i32 [ %449, %SwissTable_ensure_capacity_required_sizei32.exit837 ], [ %492, %491 ]
  %.0..0..0..0..0..0.84.i853 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit837 ], [ %spec.store.select9216.i857, %491 ]
  %.0988 = and i32 %.pn1908, %450
  %454 = sext i32 %.0988 to i64
  %455 = getelementptr i8, ptr %445, i64 %454
  %456 = load i8, ptr %455, align 1
  switch i8 %456, label %._crit_edge.i862 [
    i8 0, label %493
    i8 -128, label %._crit_edge.thread.i855
  ]

._crit_edge.thread.i855:                          ; preds = %453
  %457 = icmp eq i32 %.0..0..0..0..0..0.84.i853, -1
  %spec.store.select.i856 = select i1 %457, i32 %.0988, i32 %.0..0..0..0..0..0.84.i853
  br label %491

._crit_edge.i862:                                 ; preds = %453
  %458 = icmp sgt i8 %456, 0
  br i1 %458, label %459, label %491

459:                                              ; preds = %._crit_edge.i862
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %461 = shl nsw i64 %454, 5
  %462 = getelementptr i8, ptr %444, i64 %461
  %463 = load ptr, ptr %462, align 8
  %464 = icmp ne ptr %463, @nil_typ
  %465 = icmp ne ptr %463, null
  %.not82.i864 = and i1 %464, %465
  br i1 %.not82.i864, label %466, label %491

466:                                              ; preds = %459
  %467 = getelementptr i8, ptr %462, i64 8
  %468 = load i64, ptr %467, align 4
  %.sroa_idx.i865 = getelementptr i8, ptr %462, i64 16
  %469 = load i64, ptr %.sroa_idx.i865, align 4
  %470 = inttoptr i64 %468 to ptr
  %471 = inttoptr i64 %469 to ptr
  %hash_coef_ptr.i3.i866 = getelementptr i8, ptr %463, i64 8
  %tbl_size_ptr.i4.i867 = getelementptr i8, ptr %463, i64 16
  %offset_tbl_ptr.i5.i868 = getelementptr i8, ptr %463, i64 40
  %hash_coef.i6.i869 = load i64, ptr %hash_coef_ptr.i3.i866, align 4
  %tbl_size.i7.i870 = load i64, ptr %tbl_size_ptr.i4.i867, align 4
  %offset_tbl.i8.i871 = load ptr, ptr %offset_tbl_ptr.i5.i868, align 8
  %product.i.i9.i872 = mul i64 %hash_coef.i6.i869, 4015701072841558310
  %shifted.i.i10.i873 = lshr i64 %product.i.i9.i872, 32
  %xored.i.i11.i874 = xor i64 %shifted.i.i10.i873, %product.i.i9.i872
  %hash.i.i12.i875 = and i64 %xored.i.i11.i874, %tbl_size.i7.i870
  %offset_ptr.i13.i876 = getelementptr i32, ptr %offset_tbl.i8.i871, i64 %hash.i.i12.i875
  %offset.i14.i877 = load i32, ptr %offset_ptr.i13.i876, align 4
  %472 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %463, 0
  %473 = insertvalue { ptr, ptr, ptr, i32 } %472, ptr %470, 1
  %474 = insertvalue { ptr, ptr, ptr, i32 } %473, ptr %471, 2
  %475 = insertvalue { ptr, ptr, ptr, i32 } %474, i32 %offset.i14.i877, 3
  %476 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %477 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %463)
  %478 = sext i32 %offset.i14.i877 to i64
  %479 = getelementptr ptr, ptr %463, i64 %478
  %480 = getelementptr i8, ptr %479, i64 40
  %481 = load ptr, ptr %480, align 8
  %result.i1.i878 = call ptr %481({ ptr, ptr, ptr, i32 } %475, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %482 = call i32 %result.i1.i878({ ptr, ptr, ptr, i32 } %475, { ptr, ptr, ptr, i32 } %475, ptr nonnull align 8 %2)
  %483 = icmp eq i32 %482, %449
  br i1 %483, label %._crit_edge2.i879, label %491

._crit_edge2.i879:                                ; preds = %466
  %484 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %485 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %463)
  %486 = getelementptr i8, ptr %479, i64 48
  %487 = load ptr, ptr %486, align 8
  %result.i.i880 = call ptr %487({ ptr, ptr, ptr, i32 } %475, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %488 = call { ptr, i160 } %result.i.i880({ ptr, ptr, ptr, i32 } %475, { ptr, ptr, ptr, i32 } %475, ptr nonnull align 8 %2)
  %489 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %490 = call i1 %452({ ptr, i160 } %488, { ptr, i160 } %59)
  br i1 %490, label %SwissTable_find_slot_keyK_hashi32.exit882, label %491

491:                                              ; preds = %._crit_edge2.i879, %466, %459, %._crit_edge.i862, %._crit_edge.thread.i855
  %.1990 = phi i32 [ %.0989, %._crit_edge2.i879 ], [ %.0989, %466 ], [ %.0989, %459 ], [ %.0989, %._crit_edge.i862 ], [ %spec.store.select.i856, %._crit_edge.thread.i855 ]
  %spec.store.select9216.i857 = phi i32 [ %.0..0..0..0..0..0.84.i853, %._crit_edge2.i879 ], [ %.0..0..0..0..0..0.84.i853, %466 ], [ %.0..0..0..0..0..0.84.i853, %459 ], [ %.0..0..0..0..0..0.84.i853, %._crit_edge.i862 ], [ %spec.store.select.i856, %._crit_edge.thread.i855 ]
  %492 = add nuw i32 %.0988, 1
  br label %453

493:                                              ; preds = %453
  %.not.i858 = icmp eq i32 %.0..0..0..0..0..0.84.i853, -1
  %.pre.i861 = select i1 %.not.i858, i32 %.0988, i32 %.0989
  %.pre1032 = sext i32 %.pre.i861 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit882

SwissTable_find_slot_keyK_hashi32.exit882:        ; preds = %493, %._crit_edge2.i879
  %.pre-phi1033 = phi i64 [ %.pre1032, %493 ], [ %454, %._crit_edge2.i879 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %494 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %495 = getelementptr i8, ptr %445, i64 %.pre-phi1033
  %496 = load i8, ptr %495, align 1
  %497 = load ptr, ptr %result.i67.h2s2269, align 8
  %498 = load ptr, ptr %25, align 8
  %499 = load ptr, ptr %497, align 8, !alias.scope !12
  %500 = getelementptr i8, ptr %499, i64 72
  %501 = load ptr, ptr %500, align 8, !alias.scope !12
  %result.i1.i.i326 = call { i64, i64 } %501(ptr nocapture nofree nonnull readonly align 8 %497) #47, !alias.scope !12
  %502 = extractvalue { i64, i64 } %result.i1.i.i326, 0
  %503 = extractvalue { i64, i64 } %result.i1.i.i326, 1
  %504 = urem i64 20, %503
  %505 = icmp eq i64 %504, 0
  %506 = sub i64 %503, %504
  %507 = select i1 %505, i64 0, i64 %506
  %508 = add i64 %502, 20
  %509 = add i64 %508, %507
  %510 = load ptr, ptr %498, align 8, !alias.scope !12
  %511 = getelementptr i8, ptr %510, i64 72
  %512 = load ptr, ptr %511, align 8, !alias.scope !12
  %result.i.i.i327 = call { i64, i64 } %512(ptr nocapture nofree nonnull readonly align 8 %498) #47, !alias.scope !12
  %513 = extractvalue { i64, i64 } %result.i.i.i327, 0
  %514 = extractvalue { i64, i64 } %result.i.i.i327, 1
  %515 = call i64 @llvm.umax.i64(i64 %503, i64 %514) #61
  %516 = call i64 @llvm.umax.i64(i64 %515, i64 noundef 8) #61, !range !5
  %517 = urem i64 %509, %514
  %518 = icmp eq i64 %517, 0
  %519 = sub i64 %514, %517
  %520 = select i1 %518, i64 0, i64 %519
  %521 = add i64 %513, %509
  %522 = add i64 %521, %520
  %523 = urem i64 %522, %516
  %524 = icmp eq i64 %523, 0
  %525 = sub i64 %516, %523
  %526 = select i1 %524, i64 0, i64 %525
  %527 = add i64 %526, %522
  %result.i9.i328 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %527) #51
  store ptr %497, ptr %result.i9.i328, align 8
  %528 = getelementptr inbounds i8, ptr %result.i9.i328, i64 8
  store ptr %498, ptr %528, align 8
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i328)
  %530 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %531 = load ptr, ptr %497, align 8
  %532 = getelementptr i8, ptr %531, i64 72
  %533 = load ptr, ptr %532, align 8
  %result.i.i10.i329 = call { i64, i64 } %533(ptr nocapture nofree nonnull readonly align 8 %497) #47
  %534 = extractvalue { i64, i64 } %result.i.i10.i329, 1
  %535 = urem i64 20, %534
  %536 = icmp eq i64 %535, 0
  %reass.sub = sub i64 %534, %535
  %537 = add i64 %reass.sub, 20
  %538 = select i1 %536, i64 20, i64 %537
  %539 = getelementptr i8, ptr %result.i9.i328, i64 %538
  %540 = getelementptr i8, ptr %531, i64 64
  %541 = load ptr, ptr %540, align 8
  call void %541({ ptr, i160 } %59, ptr nocapture nofree nonnull readonly align 8 %497, ptr nocapture nofree writeonly %539) #48
  %542 = load ptr, ptr %result.i9.i328, align 8
  %543 = load ptr, ptr %542, align 8
  %544 = getelementptr i8, ptr %543, i64 72
  %545 = load ptr, ptr %544, align 8
  %result.i1.i11.i331 = call { i64, i64 } %545(ptr nocapture nofree nonnull readonly align 8 %542) #47
  %546 = extractvalue { i64, i64 } %result.i1.i11.i331, 0
  %547 = extractvalue { i64, i64 } %result.i1.i11.i331, 1
  %548 = urem i64 20, %547
  %549 = icmp eq i64 %548, 0
  %550 = sub i64 %547, %548
  %551 = select i1 %549, i64 0, i64 %550
  %552 = add i64 %546, 20
  %553 = add i64 %552, %551
  %554 = load ptr, ptr %528, align 8
  %555 = load ptr, ptr %554, align 8
  %556 = getelementptr i8, ptr %555, i64 72
  %557 = load ptr, ptr %556, align 8
  %result.i.i12.i332 = call { i64, i64 } %557(ptr nocapture nofree nonnull readonly align 8 %554) #47
  %558 = extractvalue { i64, i64 } %result.i.i12.i332, 1
  %559 = urem i64 %553, %558
  %560 = icmp eq i64 %559, 0
  %561 = sub i64 %558, %559
  %562 = select i1 %560, i64 0, i64 %561
  %563 = getelementptr i8, ptr %result.i9.i328, i64 %553
  %564 = getelementptr i8, ptr %563, i64 %562
  %565 = getelementptr i8, ptr %555, i64 64
  %566 = load ptr, ptr %565, align 8
  call void %566({ ptr, i160 } %339, ptr nocapture nofree nonnull readonly align 8 %554, ptr nocapture nofree writeonly %564) #48
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %568 = getelementptr inbounds i8, ptr %result.i9.i328, i64 16
  store i32 %449, ptr %568, align 8
  %569 = icmp eq i8 %496, 0
  br i1 %569, label %570, label %SwissTable_insert_keyK_valueV.exit336

570:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit882
  store i8 1, ptr %495, align 1
  %571 = add i32 %443, 1
  store i32 %571, ptr %35, align 4
  br label %SwissTable_insert_keyK_valueV.exit336

SwissTable_insert_keyK_valueV.exit336:            ; preds = %570, %SwissTable_find_slot_keyK_hashi32.exit882
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %573 = shl nsw i64 %.pre-phi1033, 5
  %574 = getelementptr i8, ptr %444, i64 %573
  store ptr @Entry, ptr %574, align 8
  %575 = getelementptr i8, ptr %574, i64 8
  %576 = ptrtoint ptr %result.i9.i328 to i64
  store i64 %576, ptr %575, align 4
  %.sroa_idx3.i334 = getelementptr i8, ptr %574, i64 24
  store i32 10, ptr %.sroa_idx3.i334, align 4
  %577 = add nsw i32 %.0546194, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %SwissTable_insert_keyK_valueV.exit336, %SwissTable_get_keyK.exit
  %578 = phi ptr [ %332, %SwissTable_insert_keyK_valueV.exit336 ], [ %43, %SwissTable_get_keyK.exit ]
  %579 = phi ptr [ %249, %SwissTable_insert_keyK_valueV.exit336 ], [ %44, %SwissTable_get_keyK.exit ]
  %.pre12151804 = phi ptr [ %.pre12151805, %SwissTable_insert_keyK_valueV.exit336 ], [ %.pre12151803, %SwissTable_get_keyK.exit ]
  %580 = phi ptr [ %333, %SwissTable_insert_keyK_valueV.exit336 ], [ %45, %SwissTable_get_keyK.exit ]
  %581 = phi i32 [ %252, %SwissTable_insert_keyK_valueV.exit336 ], [ %46, %SwissTable_get_keyK.exit ]
  %582 = phi ptr [ %332, %SwissTable_insert_keyK_valueV.exit336 ], [ %47, %SwissTable_get_keyK.exit ]
  %583 = phi i32 [ %334, %SwissTable_insert_keyK_valueV.exit336 ], [ %48, %SwissTable_get_keyK.exit ]
  %584 = phi i32 [ %252, %SwissTable_insert_keyK_valueV.exit336 ], [ %49, %SwissTable_get_keyK.exit ]
  %585 = phi ptr [ %444, %SwissTable_insert_keyK_valueV.exit336 ], [ %50, %SwissTable_get_keyK.exit ]
  %.pre12141802 = phi ptr [ %445, %SwissTable_insert_keyK_valueV.exit336 ], [ %.pre1214, %SwissTable_get_keyK.exit ]
  %586 = phi ptr [ %452, %SwissTable_insert_keyK_valueV.exit336 ], [ %51, %SwissTable_get_keyK.exit ]
  %587 = phi ptr [ %445, %SwissTable_insert_keyK_valueV.exit336 ], [ %105, %SwissTable_get_keyK.exit ]
  %588 = phi i32 [ %446, %SwissTable_insert_keyK_valueV.exit336 ], [ %53, %SwissTable_get_keyK.exit ]
  %589 = phi ptr [ %448, %SwissTable_insert_keyK_valueV.exit336 ], [ %54, %SwissTable_get_keyK.exit ]
  %.1547 = phi i32 [ %577, %SwissTable_insert_keyK_valueV.exit336 ], [ %.0546194, %SwissTable_get_keyK.exit ]
  %590 = add nuw nsw i32 %.0543195, 1
  %591 = icmp slt i32 %.1547, %0
  %592 = icmp slt i32 %590, %36
  %spec.select = select i1 %591, i1 %592, i1 false
  br i1 %spec.select, label %42, label %._crit_edge3._crit_edge.loopexit

._crit_edge3._crit_edge.loopexit:                 ; preds = %._crit_edge1
  %593 = add i32 %588, -1
  %594 = add i32 %581, -1
  br label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge3._crit_edge.loopexit, %1
  %595 = phi ptr [ %579, %._crit_edge3._crit_edge.loopexit ], [ %result.i.i219, %1 ]
  %596 = phi i32 [ %594, %._crit_edge3._crit_edge.loopexit ], [ 7, %1 ]
  %597 = phi ptr [ %586, %._crit_edge3._crit_edge.loopexit ], [ %ret.i, %1 ]
  %598 = phi ptr [ %585, %._crit_edge3._crit_edge.loopexit ], [ %result.i1.i258, %1 ]
  %599 = phi ptr [ %.pre12141802, %._crit_edge3._crit_edge.loopexit ], [ %result.i.i259, %1 ]
  %600 = phi i32 [ %593, %._crit_edge3._crit_edge.loopexit ], [ 7, %1 ]
  %601 = phi ptr [ %589, %._crit_edge3._crit_edge.loopexit ], [ %ret.i45, %1 ]
  %.sroa.gep574 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep580 = getelementptr inbounds i8, ptr %7, i64 24
  %.sroa.gep586 = getelementptr inbounds i8, ptr %6, i64 16
  %602 = sext i32 %0 to i64
  %603 = shl nsw i64 %602, 2
  %result.i2.i352 = call noalias ptr @bump_malloc_wrapper(i64 noundef %603) #51
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %605 = mul i32 %0, 20
  %606 = icmp sgt i32 %605, 0
  %spec.select573200 = and i1 %37, %606
  br i1 %spec.select573200, label %.lr.ph204, label %._crit_edge7._crit_edge

.lr.ph204:                                        ; preds = %._crit_edge3._crit_edge
  %607 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %608 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #46
  br label %609

609:                                              ; preds = %._crit_edge5, %.lr.ph204
  %610 = phi i32 [ 987, %.lr.ph204 ], [ %613, %._crit_edge5 ]
  %.0542203 = phi i32 [ 0, %.lr.ph204 ], [ %.1, %._crit_edge5 ]
  %.2545202 = phi i32 [ 0, %.lr.ph204 ], [ %692, %._crit_edge5 ]
  %611 = mul i32 %610, 1103515245
  %612 = add i32 %611, 12345
  %613 = and i32 %612, 2147483647
  %.sroa.0472.0.insert.ext = zext nneg i32 %613 to i160
  %614 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0472.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %615 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %616 = call i32 %601({ ptr, i160 } %614)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %617 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %618

618:                                              ; preds = %656, %609
  %.0986 = phi i32 [ -1, %609 ], [ %.1987, %656 ]
  %.pn1910 = phi i32 [ %616, %609 ], [ %657, %656 ]
  %.0..0..0..0..0..0.84.i898 = phi i32 [ -1, %609 ], [ %spec.store.select9216.i902, %656 ]
  %.0985 = and i32 %.pn1910, %600
  %619 = sext i32 %.0985 to i64
  %620 = getelementptr i8, ptr %599, i64 %619
  %621 = load i8, ptr %620, align 1
  switch i8 %621, label %._crit_edge.i907 [
    i8 0, label %658
    i8 -128, label %._crit_edge.thread.i900
  ]

._crit_edge.thread.i900:                          ; preds = %618
  %622 = icmp eq i32 %.0..0..0..0..0..0.84.i898, -1
  %spec.store.select.i901 = select i1 %622, i32 %.0985, i32 %.0..0..0..0..0..0.84.i898
  br label %656

._crit_edge.i907:                                 ; preds = %618
  %623 = icmp sgt i8 %621, 0
  br i1 %623, label %624, label %656

624:                                              ; preds = %._crit_edge.i907
  %625 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %626 = shl nsw i64 %619, 5
  %627 = getelementptr i8, ptr %598, i64 %626
  %628 = load ptr, ptr %627, align 8
  %629 = icmp ne ptr %628, @nil_typ
  %630 = icmp ne ptr %628, null
  %.not82.i909 = and i1 %629, %630
  br i1 %.not82.i909, label %631, label %656

631:                                              ; preds = %624
  %632 = getelementptr i8, ptr %627, i64 8
  %633 = load i64, ptr %632, align 4
  %.sroa_idx.i910 = getelementptr i8, ptr %627, i64 16
  %634 = load i64, ptr %.sroa_idx.i910, align 4
  %635 = inttoptr i64 %633 to ptr
  %636 = inttoptr i64 %634 to ptr
  %hash_coef_ptr.i3.i911 = getelementptr i8, ptr %628, i64 8
  %tbl_size_ptr.i4.i912 = getelementptr i8, ptr %628, i64 16
  %offset_tbl_ptr.i5.i913 = getelementptr i8, ptr %628, i64 40
  %hash_coef.i6.i914 = load i64, ptr %hash_coef_ptr.i3.i911, align 4
  %tbl_size.i7.i915 = load i64, ptr %tbl_size_ptr.i4.i912, align 4
  %offset_tbl.i8.i916 = load ptr, ptr %offset_tbl_ptr.i5.i913, align 8
  %product.i.i9.i917 = mul i64 %hash_coef.i6.i914, 4015701072841558310
  %shifted.i.i10.i918 = lshr i64 %product.i.i9.i917, 32
  %xored.i.i11.i919 = xor i64 %shifted.i.i10.i918, %product.i.i9.i917
  %hash.i.i12.i920 = and i64 %xored.i.i11.i919, %tbl_size.i7.i915
  %offset_ptr.i13.i921 = getelementptr i32, ptr %offset_tbl.i8.i916, i64 %hash.i.i12.i920
  %offset.i14.i922 = load i32, ptr %offset_ptr.i13.i921, align 4
  %637 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %628, 0
  %638 = insertvalue { ptr, ptr, ptr, i32 } %637, ptr %635, 1
  %639 = insertvalue { ptr, ptr, ptr, i32 } %638, ptr %636, 2
  %640 = insertvalue { ptr, ptr, ptr, i32 } %639, i32 %offset.i14.i922, 3
  %641 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %642 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %628)
  %643 = sext i32 %offset.i14.i922 to i64
  %644 = getelementptr ptr, ptr %628, i64 %643
  %645 = getelementptr i8, ptr %644, i64 40
  %646 = load ptr, ptr %645, align 8
  %result.i1.i923 = call ptr %646({ ptr, ptr, ptr, i32 } %640, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %647 = call i32 %result.i1.i923({ ptr, ptr, ptr, i32 } %640, { ptr, ptr, ptr, i32 } %640, ptr nonnull align 8 %2)
  %648 = icmp eq i32 %647, %616
  br i1 %648, label %._crit_edge2.i924, label %656

._crit_edge2.i924:                                ; preds = %631
  %649 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %650 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %628)
  %651 = getelementptr i8, ptr %644, i64 48
  %652 = load ptr, ptr %651, align 8
  %result.i.i925 = call ptr %652({ ptr, ptr, ptr, i32 } %640, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %653 = call { ptr, i160 } %result.i.i925({ ptr, ptr, ptr, i32 } %640, { ptr, ptr, ptr, i32 } %640, ptr nonnull align 8 %2)
  %654 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %655 = call i1 %597({ ptr, i160 } %653, { ptr, i160 } %614)
  br i1 %655, label %SwissTable_find_slot_keyK_hashi32.exit927, label %656

656:                                              ; preds = %._crit_edge2.i924, %631, %624, %._crit_edge.i907, %._crit_edge.thread.i900
  %.1987 = phi i32 [ %.0986, %._crit_edge2.i924 ], [ %.0986, %631 ], [ %.0986, %624 ], [ %.0986, %._crit_edge.i907 ], [ %spec.store.select.i901, %._crit_edge.thread.i900 ]
  %spec.store.select9216.i902 = phi i32 [ %.0..0..0..0..0..0.84.i898, %._crit_edge2.i924 ], [ %.0..0..0..0..0..0.84.i898, %631 ], [ %.0..0..0..0..0..0.84.i898, %624 ], [ %.0..0..0..0..0..0.84.i898, %._crit_edge.i907 ], [ %spec.store.select.i901, %._crit_edge.thread.i900 ]
  %657 = add nuw i32 %.0985, 1
  br label %618

658:                                              ; preds = %618
  %.not.i903 = icmp eq i32 %.0..0..0..0..0..0.84.i898, -1
  %.pre.i906 = select i1 %.not.i903, i32 %.0985, i32 %.0986
  %.pre1034 = sext i32 %.pre.i906 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit927

SwissTable_find_slot_keyK_hashi32.exit927:        ; preds = %658, %._crit_edge2.i924
  %.pre-phi1035 = phi i64 [ %.pre1034, %658 ], [ %619, %._crit_edge2.i924 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %660 = getelementptr i8, ptr %599, i64 %.pre-phi1035
  %661 = load i8, ptr %660, align 1
  switch i8 %661, label %662 [
    i8 -128, label %SwissTable_get_keyK.exit408.thread
    i8 0, label %SwissTable_get_keyK.exit408.thread
  ]

662:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit927
  %663 = shl nsw i64 %.pre-phi1035, 5
  %664 = getelementptr i8, ptr %598, i64 %663
  %665 = load ptr, ptr %664, align 8
  %666 = icmp ne ptr %665, @nil_typ
  %667 = icmp ne ptr %665, null
  %.not74.i389 = and i1 %666, %667
  br i1 %.not74.i389, label %SwissTable_get_keyK.exit408, label %SwissTable_get_keyK.exit408.thread

SwissTable_get_keyK.exit408.thread:               ; preds = %662, %SwissTable_find_slot_keyK_hashi32.exit927, %SwissTable_find_slot_keyK_hashi32.exit927
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %686

SwissTable_get_keyK.exit408:                      ; preds = %662
  %668 = getelementptr i8, ptr %664, i64 8
  %669 = load i160, ptr %668, align 4
  %.sroa.262.0.extract.shift.i390 = lshr i160 %669, 64
  %.sroa.262.0.extract.trunc.i391 = trunc i160 %.sroa.262.0.extract.shift.i390 to i64
  %.sroa.061.0.extract.trunc.i392 = trunc i160 %669 to i64
  %670 = inttoptr i64 %.sroa.061.0.extract.trunc.i392 to ptr
  %671 = inttoptr i64 %.sroa.262.0.extract.trunc.i391 to ptr
  %hash_coef_ptr.i3.i393 = getelementptr i8, ptr %665, i64 8
  %tbl_size_ptr.i4.i394 = getelementptr i8, ptr %665, i64 16
  %offset_tbl_ptr.i5.i395 = getelementptr i8, ptr %665, i64 40
  %hash_coef.i6.i396 = load i64, ptr %hash_coef_ptr.i3.i393, align 4
  %tbl_size.i7.i397 = load i64, ptr %tbl_size_ptr.i4.i394, align 4
  %offset_tbl.i8.i398 = load ptr, ptr %offset_tbl_ptr.i5.i395, align 8
  %product.i.i9.i399 = mul i64 %hash_coef.i6.i396, 4015701072841558310
  %shifted.i.i10.i400 = lshr i64 %product.i.i9.i399, 32
  %xored.i.i11.i401 = xor i64 %shifted.i.i10.i400, %product.i.i9.i399
  %hash.i.i12.i402 = and i64 %xored.i.i11.i401, %tbl_size.i7.i397
  %offset_ptr.i13.i403 = getelementptr i32, ptr %offset_tbl.i8.i398, i64 %hash.i.i12.i402
  %offset.i14.i404 = load i32, ptr %offset_ptr.i13.i403, align 4
  %672 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %665, 0
  %673 = insertvalue { ptr, ptr, ptr, i32 } %672, ptr %670, 1
  %674 = insertvalue { ptr, ptr, ptr, i32 } %673, ptr %671, 2
  %675 = insertvalue { ptr, ptr, ptr, i32 } %674, i32 %offset.i14.i404, 3
  %676 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %677 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %665)
  %678 = sext i32 %offset.i14.i404 to i64
  %679 = getelementptr ptr, ptr %665, i64 %678
  %680 = getelementptr i8, ptr %679, i64 56
  %681 = load ptr, ptr %680, align 8
  %result.i1.i405 = call ptr %681({ ptr, ptr, ptr, i32 } %675, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %682 = call { ptr, i160 } %result.i1.i405({ ptr, ptr, ptr, i32 } %675, { ptr, ptr, ptr, i32 } %675, ptr nonnull align 8 %2)
  %.fca.0.extract49.i406 = extractvalue { ptr, i160 } %682, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %683 = icmp eq ptr %.fca.0.extract49.i406, @nil_typ
  %684 = icmp eq ptr %.fca.0.extract49.i406, null
  %685 = or i1 %683, %684
  br i1 %685, label %686, label %._crit_edge5

686:                                              ; preds = %SwissTable_get_keyK.exit408, %SwissTable_get_keyK.exit408.thread
  %687 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %688 = sext i32 %.0542203 to i64
  %689 = shl nsw i64 %688, 2
  %690 = getelementptr i8, ptr %result.i2.i352, i64 %689
  store i32 %613, ptr %690, align 1
  %691 = add nsw i32 %.0542203, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %686, %SwissTable_get_keyK.exit408
  %.1 = phi i32 [ %691, %686 ], [ %.0542203, %SwissTable_get_keyK.exit408 ]
  %692 = add nuw nsw i32 %.2545202, 1
  %693 = icmp slt i32 %.1, %0
  %694 = icmp slt i32 %692, %605
  %spec.select573 = select i1 %693, i1 %694, i1 false
  br i1 %spec.select573, label %609, label %._crit_edge7._crit_edge

._crit_edge7._crit_edge:                          ; preds = %._crit_edge5, %._crit_edge3._crit_edge
  %.0542.lcssa = phi i32 [ 0, %._crit_edge3._crit_edge ], [ %.1, %._crit_edge5 ]
  %.sroa.gep577 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep583 = getelementptr inbounds i8, ptr %6, i64 8
  %.sroa.gep589 = getelementptr inbounds i8, ptr %6, i64 24
  %695 = icmp slt i32 %.0542.lcssa, %0
  br i1 %695, label %RangeIterator_next_.exit52.i.preheader, label %._crit_edge8

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge7._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %696 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %697 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 87, ptr %result.i5.i.h2s2267, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s2267, i64 1
  store <28 x i8> <i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %scevgep, align 1
  %698 = getelementptr inbounds i8, ptr %result.i5.i.h2s2267, i64 29
  store i8 0, ptr %698, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i.h2s2267) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %699 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0542.lcssa) #59
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %702 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 32, ptr %result.i5.i1071.h2s2265, align 1
  %scevgep1371 = getelementptr inbounds i8, ptr %result.i5.i1071.h2s2265, i64 1
  store <21 x i8> <i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %scevgep1371, align 1
  %704 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %705 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %706 = getelementptr inbounds i8, ptr %result.i5.i1071.h2s2265, i64 22
  store i8 0, ptr %706, align 1
  %puts.i636 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(23) %result.i5.i1071.h2s2265) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %._crit_edge7._crit_edge
  %.0569 = phi i32 [ %.0542.lcssa, %RangeIterator_next_.exit52.i.preheader ], [ %0, %._crit_edge7._crit_edge ]
  %707 = call i64 @clock()
  %708 = icmp sgt i32 %.0569, 0
  br i1 %708, label %._crit_edge9.preheader, label %809

._crit_edge9.preheader:                           ; preds = %._crit_edge8
  %709 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %710 = zext nneg i32 %.0569 to i64
  %711 = load ptr, ptr %4, align 8
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %SwissTable_get_keyK.exit503, %._crit_edge9.preheader
  %indvars.iv = phi i64 [ 0, %._crit_edge9.preheader ], [ %indvars.iv.next, %SwissTable_get_keyK.exit503 ]
  %.0550209 = phi i32 [ 0, %._crit_edge9.preheader ], [ %.2552, %SwissTable_get_keyK.exit503 ]
  %.0553208 = phi i32 [ 0, %._crit_edge9.preheader ], [ %.2555, %SwissTable_get_keyK.exit503 ]
  %712 = shl i64 %indvars.iv, 2
  %713 = getelementptr i8, ptr %result.i2.i352, i64 %712
  %714 = load i32, ptr %713, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %715 = add i32 %714, 2127912214
  %716 = shl i32 %714, 12
  %717 = add i32 %715, %716
  %718 = ashr i32 %717, 19
  %719 = xor i32 %717, %718
  %720 = xor i32 %719, -949894596
  %721 = add i32 %720, 374761393
  %722 = shl i32 %720, 5
  %723 = add i32 %721, %722
  %724 = add i32 %723, -744332180
  %725 = shl i32 %723, 9
  %726 = xor i32 %724, %725
  %727 = add i32 %726, -42973499
  %728 = shl i32 %726, 3
  %729 = add i32 %727, %728
  %730 = ashr i32 %729, 16
  %731 = xor i32 %729, %730
  %732 = xor i32 %731, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %733 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %734

734:                                              ; preds = %772, %._crit_edge9
  %.0983 = phi i32 [ -1, %._crit_edge9 ], [ %.1984, %772 ]
  %.pn1911 = phi i32 [ %732, %._crit_edge9 ], [ %773, %772 ]
  %.0..0..0..0..0..0.84.i942 = phi i32 [ -1, %._crit_edge9 ], [ %spec.store.select9216.i946, %772 ]
  %.0 = and i32 %.pn1911, %596
  %735 = sext i32 %.0 to i64
  %736 = getelementptr i8, ptr %595, i64 %735
  %737 = load i8, ptr %736, align 1
  switch i8 %737, label %._crit_edge.i951 [
    i8 0, label %774
    i8 -128, label %._crit_edge.thread.i944
  ]

._crit_edge.thread.i944:                          ; preds = %734
  %738 = icmp eq i32 %.0..0..0..0..0..0.84.i942, -1
  %spec.store.select.i945 = select i1 %738, i32 %.0, i32 %.0..0..0..0..0..0.84.i942
  br label %772

._crit_edge.i951:                                 ; preds = %734
  %739 = icmp sgt i8 %737, 0
  br i1 %739, label %740, label %772

740:                                              ; preds = %._crit_edge.i951
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %742 = shl nsw i64 %735, 5
  %743 = getelementptr i8, ptr %711, i64 %742
  %744 = load ptr, ptr %743, align 8
  %745 = icmp ne ptr %744, @nil_typ
  %746 = icmp ne ptr %744, null
  %.not82.i953 = and i1 %745, %746
  br i1 %.not82.i953, label %747, label %772

747:                                              ; preds = %740
  %748 = getelementptr i8, ptr %743, i64 8
  %749 = load i64, ptr %748, align 4
  %.sroa_idx.i954 = getelementptr i8, ptr %743, i64 16
  %750 = load i64, ptr %.sroa_idx.i954, align 4
  %751 = inttoptr i64 %749 to ptr
  %752 = inttoptr i64 %750 to ptr
  %hash_coef_ptr.i3.i955 = getelementptr i8, ptr %744, i64 8
  %tbl_size_ptr.i4.i956 = getelementptr i8, ptr %744, i64 16
  %offset_tbl_ptr.i5.i957 = getelementptr i8, ptr %744, i64 40
  %hash_coef.i6.i958 = load i64, ptr %hash_coef_ptr.i3.i955, align 4
  %tbl_size.i7.i959 = load i64, ptr %tbl_size_ptr.i4.i956, align 4
  %offset_tbl.i8.i960 = load ptr, ptr %offset_tbl_ptr.i5.i957, align 8
  %product.i.i9.i961 = mul i64 %hash_coef.i6.i958, 4015701072841558310
  %shifted.i.i10.i962 = lshr i64 %product.i.i9.i961, 32
  %xored.i.i11.i963 = xor i64 %shifted.i.i10.i962, %product.i.i9.i961
  %hash.i.i12.i964 = and i64 %xored.i.i11.i963, %tbl_size.i7.i959
  %offset_ptr.i13.i965 = getelementptr i32, ptr %offset_tbl.i8.i960, i64 %hash.i.i12.i964
  %offset.i14.i966 = load i32, ptr %offset_ptr.i13.i965, align 4
  %753 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %744, 0
  %754 = insertvalue { ptr, ptr, ptr, i32 } %753, ptr %751, 1
  %755 = insertvalue { ptr, ptr, ptr, i32 } %754, ptr %752, 2
  %756 = insertvalue { ptr, ptr, ptr, i32 } %755, i32 %offset.i14.i966, 3
  %757 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %758 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %744)
  %759 = sext i32 %offset.i14.i966 to i64
  %760 = getelementptr ptr, ptr %744, i64 %759
  %761 = getelementptr i8, ptr %760, i64 40
  %762 = load ptr, ptr %761, align 8
  %result.i1.i967 = call ptr %762({ ptr, ptr, ptr, i32 } %756, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %763 = call i32 %result.i1.i967({ ptr, ptr, ptr, i32 } %756, { ptr, ptr, ptr, i32 } %756, ptr nonnull align 8 %2)
  %764 = icmp eq i32 %763, %732
  br i1 %764, label %._crit_edge2.i968, label %772

._crit_edge2.i968:                                ; preds = %747
  %765 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %766 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %744)
  %767 = getelementptr i8, ptr %760, i64 48
  %768 = load ptr, ptr %767, align 8
  %result.i.i969 = call ptr %768({ ptr, ptr, ptr, i32 } %756, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %769 = call { ptr, i160 } %result.i.i969({ ptr, ptr, ptr, i32 } %756, { ptr, ptr, ptr, i32 } %756, ptr nonnull align 8 %2)
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i1862 = extractvalue { ptr, i160 } %769, 1
  %.sroa.15.8.extract.trunc.i1863 = trunc i160 %.fca.1.extract3.i1862 to i32
  %771 = icmp eq i32 %714, %.sroa.15.8.extract.trunc.i1863
  br i1 %771, label %SwissTable_find_slot_keyK_hashi32.exit971, label %772

772:                                              ; preds = %._crit_edge2.i968, %747, %740, %._crit_edge.i951, %._crit_edge.thread.i944
  %.1984 = phi i32 [ %.0983, %._crit_edge2.i968 ], [ %.0983, %747 ], [ %.0983, %740 ], [ %.0983, %._crit_edge.i951 ], [ %spec.store.select.i945, %._crit_edge.thread.i944 ]
  %spec.store.select9216.i946 = phi i32 [ %.0..0..0..0..0..0.84.i942, %._crit_edge2.i968 ], [ %.0..0..0..0..0..0.84.i942, %747 ], [ %.0..0..0..0..0..0.84.i942, %740 ], [ %.0..0..0..0..0..0.84.i942, %._crit_edge.i951 ], [ %spec.store.select.i945, %._crit_edge.thread.i944 ]
  %773 = add i32 %.0, 1
  br label %734

774:                                              ; preds = %734
  %.not.i947 = icmp eq i32 %.0..0..0..0..0..0.84.i942, -1
  %.pre.i950 = select i1 %.not.i947, i32 %.0, i32 %.0983
  %.pre1036 = sext i32 %.pre.i950 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit971

SwissTable_find_slot_keyK_hashi32.exit971:        ; preds = %774, %._crit_edge2.i968
  %.pre-phi1037 = phi i64 [ %.pre1036, %774 ], [ %735, %._crit_edge2.i968 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %775 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %776 = getelementptr i8, ptr %595, i64 %.pre-phi1037
  %777 = load i8, ptr %776, align 1
  switch i8 %777, label %778 [
    i8 -128, label %SwissTable_get_keyK.exit503
    i8 0, label %SwissTable_get_keyK.exit503
  ]

778:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit971
  %779 = shl nsw i64 %.pre-phi1037, 5
  %780 = getelementptr i8, ptr %711, i64 %779
  %781 = load ptr, ptr %780, align 8
  %782 = icmp ne ptr %781, @nil_typ
  %783 = icmp ne ptr %781, null
  %.not74.i484 = and i1 %782, %783
  br i1 %.not74.i484, label %784, label %SwissTable_get_keyK.exit503

784:                                              ; preds = %778
  %785 = getelementptr i8, ptr %780, i64 8
  %786 = load i160, ptr %785, align 4
  %.sroa.262.0.extract.shift.i485 = lshr i160 %786, 64
  %.sroa.262.0.extract.trunc.i486 = trunc i160 %.sroa.262.0.extract.shift.i485 to i64
  %.sroa.061.0.extract.trunc.i487 = trunc i160 %786 to i64
  %787 = inttoptr i64 %.sroa.061.0.extract.trunc.i487 to ptr
  %788 = inttoptr i64 %.sroa.262.0.extract.trunc.i486 to ptr
  %hash_coef_ptr.i3.i488 = getelementptr i8, ptr %781, i64 8
  %tbl_size_ptr.i4.i489 = getelementptr i8, ptr %781, i64 16
  %offset_tbl_ptr.i5.i490 = getelementptr i8, ptr %781, i64 40
  %hash_coef.i6.i491 = load i64, ptr %hash_coef_ptr.i3.i488, align 4
  %tbl_size.i7.i492 = load i64, ptr %tbl_size_ptr.i4.i489, align 4
  %offset_tbl.i8.i493 = load ptr, ptr %offset_tbl_ptr.i5.i490, align 8
  %product.i.i9.i494 = mul i64 %hash_coef.i6.i491, 4015701072841558310
  %shifted.i.i10.i495 = lshr i64 %product.i.i9.i494, 32
  %xored.i.i11.i496 = xor i64 %shifted.i.i10.i495, %product.i.i9.i494
  %hash.i.i12.i497 = and i64 %xored.i.i11.i496, %tbl_size.i7.i492
  %offset_ptr.i13.i498 = getelementptr i32, ptr %offset_tbl.i8.i493, i64 %hash.i.i12.i497
  %offset.i14.i499 = load i32, ptr %offset_ptr.i13.i498, align 4
  %789 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %781, 0
  %790 = insertvalue { ptr, ptr, ptr, i32 } %789, ptr %787, 1
  %791 = insertvalue { ptr, ptr, ptr, i32 } %790, ptr %788, 2
  %792 = insertvalue { ptr, ptr, ptr, i32 } %791, i32 %offset.i14.i499, 3
  %793 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %781)
  %795 = sext i32 %offset.i14.i499 to i64
  %796 = getelementptr ptr, ptr %781, i64 %795
  %797 = getelementptr i8, ptr %796, i64 56
  %798 = load ptr, ptr %797, align 8
  %result.i1.i500 = call ptr %798({ ptr, ptr, ptr, i32 } %792, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %799 = call { ptr, i160 } %result.i1.i500({ ptr, ptr, ptr, i32 } %792, { ptr, ptr, ptr, i32 } %792, ptr nonnull align 8 %2)
  %.fca.0.extract49.i501 = extractvalue { ptr, i160 } %799, 0
  br label %SwissTable_get_keyK.exit503

SwissTable_get_keyK.exit503:                      ; preds = %784, %778, %SwissTable_find_slot_keyK_hashi32.exit971, %SwissTable_find_slot_keyK_hashi32.exit971
  %.reg2mem9.sroa.0.0.i479 = phi ptr [ @nil_typ, %SwissTable_find_slot_keyK_hashi32.exit971 ], [ %.fca.0.extract49.i501, %784 ], [ @nil_typ, %778 ], [ @nil_typ, %SwissTable_find_slot_keyK_hashi32.exit971 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %800 = icmp eq ptr %.reg2mem9.sroa.0.0.i479, @nil_typ
  %801 = icmp eq ptr %.reg2mem9.sroa.0.0.i479, null
  %802 = or i1 %800, %801
  %.0550..0553 = select i1 %802, i32 %.0550209, i32 %.0553208
  %803 = add i32 %.0550..0553, 1
  %.2555 = select i1 %802, i32 %.0553208, i32 %803
  %.2552 = select i1 %802, i32 %803, i32 %.0550209
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %710
  br i1 %exitcond.not, label %804, label %._crit_edge9

804:                                              ; preds = %SwissTable_get_keyK.exit503
  %805 = call i64 @clock()
  %806 = mul i32 %.2555, 100
  %807 = sdiv i32 %806, %.0569
  %.fr = freeze i32 %807
  %808 = icmp slt i32 %.fr, 5
  br label %RangeIterator_next_.exit52.i.preheader2921

809:                                              ; preds = %._crit_edge8
  %810 = call i64 @clock()
  br label %RangeIterator_next_.exit52.i.preheader2921

RangeIterator_next_.exit52.i.preheader2921:       ; preds = %809, %804
  %811 = phi i64 [ %805, %804 ], [ %810, %809 ]
  %.0550.lcssa216 = phi i32 [ %.2552, %804 ], [ 0, %809 ]
  %.0553.lcssa215 = phi i32 [ %.2555, %804 ], [ 0, %809 ]
  %.reg2mem27.0.in = phi i1 [ %808, %804 ], [ true, %809 ]
  %result.i59 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %result.i59, align 1
  %812 = sub i64 %811, %707
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %813 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #43
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %814 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %815 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #43
  %result.i5.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %816 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %817 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %818 = load i8, ptr %result.i59, align 1
  store i8 %818, ptr %result.i5.i, align 1
  %819 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %820 = getelementptr i8, ptr %result.i59, i64 1
  %821 = load i8, ptr %820, align 1
  %822 = getelementptr i8, ptr %result.i5.i, i64 1
  store i8 %821, ptr %822, align 1
  %823 = getelementptr i8, ptr %result.i59, i64 2
  %824 = load i8, ptr %823, align 1
  %825 = getelementptr i8, ptr %result.i5.i, i64 2
  store i8 %824, ptr %825, align 1
  %826 = getelementptr i8, ptr %result.i59, i64 3
  %827 = load i8, ptr %826, align 1
  %828 = getelementptr i8, ptr %result.i5.i, i64 3
  store i8 %827, ptr %828, align 1
  %829 = getelementptr i8, ptr %result.i59, i64 4
  %830 = load i8, ptr %829, align 1
  %831 = getelementptr i8, ptr %result.i5.i, i64 4
  store i8 %830, ptr %831, align 1
  %832 = getelementptr i8, ptr %result.i59, i64 5
  %833 = load i8, ptr %832, align 1
  %834 = getelementptr i8, ptr %result.i5.i, i64 5
  store i8 %833, ptr %834, align 1
  %835 = getelementptr i8, ptr %result.i59, i64 6
  %836 = load i8, ptr %835, align 1
  %837 = getelementptr i8, ptr %result.i5.i, i64 6
  store i8 %836, ptr %837, align 1
  %838 = getelementptr i8, ptr %result.i59, i64 7
  %839 = load i8, ptr %838, align 1
  %840 = getelementptr i8, ptr %result.i5.i, i64 7
  store i8 %839, ptr %840, align 1
  %841 = getelementptr i8, ptr %result.i59, i64 8
  %842 = load i8, ptr %841, align 1
  %843 = getelementptr i8, ptr %result.i5.i, i64 8
  store i8 %842, ptr %843, align 1
  %844 = getelementptr i8, ptr %result.i59, i64 9
  %845 = load i8, ptr %844, align 1
  %846 = getelementptr i8, ptr %result.i5.i, i64 9
  store i8 %845, ptr %846, align 1
  %847 = getelementptr i8, ptr %result.i59, i64 10
  %848 = load i8, ptr %847, align 1
  %849 = getelementptr i8, ptr %result.i5.i, i64 10
  store i8 %848, ptr %849, align 1
  %850 = getelementptr i8, ptr %result.i59, i64 11
  %851 = load i8, ptr %850, align 1
  %852 = getelementptr i8, ptr %result.i5.i, i64 11
  store i8 %851, ptr %852, align 1
  %853 = getelementptr i8, ptr %result.i59, i64 12
  %854 = load i8, ptr %853, align 1
  %855 = getelementptr i8, ptr %result.i5.i, i64 12
  store i8 %854, ptr %855, align 1
  %856 = getelementptr i8, ptr %result.i59, i64 13
  %857 = load i8, ptr %856, align 1
  %858 = getelementptr i8, ptr %result.i5.i, i64 13
  store i8 %857, ptr %858, align 1
  %859 = getelementptr i8, ptr %result.i59, i64 14
  %860 = load i8, ptr %859, align 1
  %861 = getelementptr i8, ptr %result.i5.i, i64 14
  store i8 %860, ptr %861, align 1
  %862 = getelementptr i8, ptr %result.i5.i, i64 15
  store i8 0, ptr %862, align 1
  %puts.i2516 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #52
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %863 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %863, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #59
  %864 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0569) #59
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %865 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %865, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #59
  %866 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %812) #59
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #59
  br i1 %708, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader2921
  %867 = zext nneg i32 %.0569 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %868 = mul i64 %812, 1000000
  %869 = sdiv i64 %868, %867
  %870 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %870, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #59
  %871 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %869) #59
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #60
  %873 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %874 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %875 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #59
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader2921
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %876 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %877 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 32, ptr %result.i5.i1090.h2s2263, align 1
  %scevgep1376 = getelementptr inbounds i8, ptr %result.i5.i1090.h2s2263, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep1376, align 1
  %878 = getelementptr inbounds i8, ptr %result.i5.i1090.h2s2263, i64 18
  store i8 0, ptr %878, align 1
  %puts.i656 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i1090.h2s2263) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br i1 %.reg2mem27.0.in, label %RangeIterator_next_.exit52.i1112.preheader, label %.else

.else:                                            ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i1112.preheader

RangeIterator_next_.exit52.i1112.preheader:       ; preds = %.else, %print_benchmark_result.exit
  %879 = phi i32 [ 1279869254, %.else ], [ 1397965136, %print_benchmark_result.exit ]
  %880 = phi ptr [ %13, %.else ], [ %9, %print_benchmark_result.exit ]
  %881 = phi ptr [ %12, %.else ], [ %8, %print_benchmark_result.exit ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %.else ], [ %.sroa.gep574, %print_benchmark_result.exit ]
  %.sroa.phi575 = phi ptr [ %.sroa.gep576, %.else ], [ %.sroa.gep577, %print_benchmark_result.exit ]
  %.sroa.phi578 = phi ptr [ %.sroa.gep579, %.else ], [ %.sroa.gep580, %print_benchmark_result.exit ]
  %882 = phi ptr [ %11, %.else ], [ %7, %print_benchmark_result.exit ]
  %.sroa.phi581 = phi ptr [ %.sroa.gep582, %.else ], [ %.sroa.gep583, %print_benchmark_result.exit ]
  %.sroa.phi584 = phi ptr [ %.sroa.gep585, %.else ], [ %.sroa.gep586, %print_benchmark_result.exit ]
  %.sroa.phi587 = phi ptr [ %.sroa.gep588, %.else ], [ %.sroa.gep589, %print_benchmark_result.exit ]
  %883 = phi ptr [ %10, %.else ], [ %6, %print_benchmark_result.exit ]
  store ptr @_parameterization_Bufferi8, ptr %883, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi581, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi584, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi587, align 8
  %884 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %883)
  store ptr @buffer_typ, ptr %882, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi575, align 8
  store ptr @i32_typ, ptr %.sroa.phi578, align 8
  %885 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %882) #43
  store ptr @_parameterization_String, ptr %881, align 8
  %886 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %881)
  store ptr @String, ptr %880, align 8
  %887 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %880) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %888 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %890 = trunc i32 %879 to i8
  store i8 %890, ptr %result.i5.i1109.h2s2261, align 1
  %scevgep1381 = getelementptr inbounds i8, ptr %result.i5.i1109.h2s2261, i64 1
  %result.i55.h2s2262.sroa.0.1.extract.shift = lshr i32 %879, 8
  %result.i55.h2s2262.sroa.0.1.extract.trunc = trunc nuw nsw i32 %result.i55.h2s2262.sroa.0.1.extract.shift to i24
  store i24 %result.i55.h2s2262.sroa.0.1.extract.trunc, ptr %scevgep1381, align 1
  %891 = getelementptr inbounds i8, ptr %result.i5.i1109.h2s2261, i64 4
  store i8 0, ptr %891, align 1
  %puts.i676 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i1109.h2s2261) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %893 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 32, ptr %result.i5.i1128.h2s2259, align 1
  %scevgep1386 = getelementptr inbounds i8, ptr %result.i5.i1128.h2s2259, i64 1
  store <12 x i8> <i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %scevgep1386, align 1
  %894 = getelementptr inbounds i8, ptr %result.i5.i1128.h2s2259, i64 13
  store i8 0, ptr %894, align 1
  %puts.i696 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(14) %result.i5.i1128.h2s2259) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %895 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0550.lcssa216) #59
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %896 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %897 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 44, ptr %result.i5.i1147.h2s2257, align 1
  %scevgep1391 = getelementptr inbounds i8, ptr %result.i5.i1147.h2s2257, i64 1
  store <7 x i8> <i8 32, i8 72, i8 105, i8 116, i8 115, i8 58, i8 32>, ptr %scevgep1391, align 1
  %898 = getelementptr inbounds i8, ptr %result.i5.i1147.h2s2257, i64 8
  store i8 0, ptr %898, align 1
  %puts.i716 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(9) %result.i5.i1147.h2s2257) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %899 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0553.lcssa215) #59
  %900 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %901 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %902 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %903 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 41, ptr %result.i5.i1166.h2s2256, align 2
  %904 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %905 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %906 = getelementptr inbounds i8, ptr %result.i5.i1166.h2s2256, i64 1
  store i8 0, ptr %906, align 1
  %puts.i736 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i5.i1166.h2s2256) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr #17 {
  %2 = alloca [0 x ptr], align 8
  %result.i5.i309.h2s330.i = alloca [4 x i8], align 4
  %result.i5.i289.h2s332.i = alloca [16 x i8], align 1
  %result.i5.i269.h2s334.i = alloca [4 x i8], align 4
  %result.i5.i249.h2s336.i = alloca [15 x i8], align 1
  %result.i5.i.h2s338.i = alloca [15 x i8], align 1
  %result.i5.i1214.h2s2311 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i5.i1214.h2s2311, align 2
  %result.i5.i1195.h2s2312 = alloca [21 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(21) %result.i5.i1195.h2s2312, i8 0, i64 21, i1 false)
  %result.i5.i1176.h2s2314 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i1176.h2s2314, i8 0, i64 5, i1 false)
  %result.i5.i1157.h2s2316 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i5.i1157.h2s2316, i8 0, i64 19, i1 false)
  %result.i5.i1100.h2s2318 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i1100.h2s2318, i8 0, i64 30, i1 false)
  %result.i5.i.h2s2320 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i5.i.h2s2320, i8 0, i64 30, i1 false)
  %result.i71.h2s2322 = alloca [64 x i8], align 8
  %3 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 24
  %result.i76.h2s2323 = alloca [64 x i8], align 8
  %4 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 24
  %5 = alloca [2 x ptr], align 8
  %oldProtect.i82 = alloca i32, align 4
  %oldProtect.i80 = alloca i32, align 4
  %oldProtect.i78 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0512.sroa.0 = alloca i8, align 8
  %6 = alloca [4 x ptr], align 8
  %7 = alloca { ptr, ptr, ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [4 x ptr], align 8
  %11 = alloca { ptr, ptr, ptr, ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  store ptr @_parameterization_i32, ptr %result.i76.h2s2323, align 8
  %14 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 8
  store ptr @_parameterization_i32, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i76.h2s2323) #60
  %result.i75 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  %result.i77 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i75, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i75, ptr noalias nofree noundef nonnull readnone @ziplyfqyzr, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i50 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i75) #50
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i75) #60
  %result.i74 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #60
  %result.i79 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i74, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i78) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i74, ptr noalias nofree noundef nonnull readnone @wmeuadletf, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i49 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i74) #50
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i74) #60
  %19 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 48
  store ptr %ret.i50, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 56
  store ptr %ret.i49, ptr %20, align 8
  %result.i1.i261 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  store ptr %result.i1.i261, ptr %4, align 8
  %result.i.i262 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %21 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 32
  store ptr %result.i.i262, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 40
  %23 = getelementptr inbounds i8, ptr %result.i76.h2s2323, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %22, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #43
  %25 = sext i32 %0 to i64
  %26 = shl nsw i64 %25, 2
  %result.i2.i290 = call noalias ptr @bump_malloc_wrapper(i64 noundef %26) #51
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  store ptr @_parameterization_i32, ptr %result.i71.h2s2322, align 8
  %28 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 8
  store ptr @_parameterization_Bool, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %29, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i71.h2s2322) #60
  %result.i70 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i80) #60
  %result.i81 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i70, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i80) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i80) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i70, ptr noalias nofree noundef nonnull readnone @yvhtirisyp, ptr noalias nofree noundef nonnull readnone @i32_hasher) #60
  %ret.i48 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i70) #50
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i70) #60
  %result.i69 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i82) #60
  %result.i83 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i69, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i82) #59
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i82) #60
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i69, ptr noalias nofree noundef nonnull readnone @rhxjymbtkk, ptr noalias nofree noundef nonnull readnone @i32_eq) #60
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i69) #50
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i69) #60
  %33 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 48
  store ptr %ret.i48, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 56
  store ptr %ret.i, ptr %34, align 8
  %result.i1.i304 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  store ptr %result.i1.i304, ptr %3, align 8
  %result.i.i305 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %35 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 32
  store ptr %result.i.i305, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 40
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %38 = getelementptr inbounds i8, ptr %result.i71.h2s2322, i64 44
  store <2 x i32> <i32 8, i32 0>, ptr %36, align 8
  %39 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %11, i64 8
  %.sroa.gep584 = getelementptr inbounds i8, ptr %11, i64 16
  %.sroa.gep587 = getelementptr inbounds i8, ptr %11, i64 24
  %.sroa.gep590 = getelementptr inbounds i8, ptr %10, i64 8
  %.sroa.gep593 = getelementptr inbounds i8, ptr %10, i64 16
  %.sroa.gep596 = getelementptr inbounds i8, ptr %10, i64 24
  %40 = icmp sgt i32 %0, 0
  %41 = icmp sgt i32 %39, 0
  %spec.select215 = and i1 %40, %41
  br i1 %spec.select215, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #43
  %44 = getelementptr inbounds i8, ptr %5, i64 8
  br label %45

45:                                               ; preds = %._crit_edge1, %.lr.ph
  %46 = phi ptr [ %result.i1.i261, %.lr.ph ], [ %585, %._crit_edge1 ]
  %47 = phi ptr [ %result.i.i262, %.lr.ph ], [ %586, %._crit_edge1 ]
  %.pre12631860 = phi ptr [ %result.i.i262, %.lr.ph ], [ %.pre12631861, %._crit_edge1 ]
  %48 = phi ptr [ %result.i.i262, %.lr.ph ], [ %587, %._crit_edge1 ]
  %49 = phi i32 [ 8, %.lr.ph ], [ %588, %._crit_edge1 ]
  %50 = phi ptr [ %result.i1.i261, %.lr.ph ], [ %589, %._crit_edge1 ]
  %51 = phi i32 [ 0, %.lr.ph ], [ %590, %._crit_edge1 ]
  %52 = phi i32 [ 8, %.lr.ph ], [ %591, %._crit_edge1 ]
  %53 = phi ptr [ %result.i1.i304, %.lr.ph ], [ %592, %._crit_edge1 ]
  %.pre1262 = phi ptr [ %result.i.i305, %.lr.ph ], [ %.pre12621859, %._crit_edge1 ]
  %54 = phi ptr [ %ret.i, %.lr.ph ], [ %593, %._crit_edge1 ]
  %55 = phi ptr [ %result.i.i305, %.lr.ph ], [ %594, %._crit_edge1 ]
  %56 = phi i32 [ 8, %.lr.ph ], [ %595, %._crit_edge1 ]
  %57 = phi ptr [ %ret.i48, %.lr.ph ], [ %596, %._crit_edge1 ]
  %58 = phi i32 [ 101112, %.lr.ph ], [ %61, %._crit_edge1 ]
  %.0549220 = phi i32 [ 0, %.lr.ph ], [ %597, %._crit_edge1 ]
  %.0550219 = phi i32 [ 0, %.lr.ph ], [ %.1551, %._crit_edge1 ]
  %59 = mul i32 %58, 1103515245
  %60 = add i32 %59, 12345
  %61 = and i32 %60, 2147483647
  %.sroa.0539.0.insert.ext = zext nneg i32 %61 to i160
  %62 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0539.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #60
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %64 = call i32 %57({ ptr, i160 } %62)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %65 = add i32 %56, -1
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %67

67:                                               ; preds = %105, %45
  %.pn = phi i32 [ %64, %45 ], [ %106, %105 ]
  %.01020 = phi i32 [ -1, %45 ], [ %.11021, %105 ]
  %.0..0..0..0..0..0.84.i = phi i32 [ -1, %45 ], [ %spec.store.select9216.i, %105 ]
  %.01022 = and i32 %.pn, %65
  %68 = sext i32 %.01022 to i64
  %69 = getelementptr i8, ptr %55, i64 %68
  %70 = load i8, ptr %69, align 1
  switch i8 %70, label %._crit_edge.i [
    i8 0, label %107
    i8 -128, label %._crit_edge.thread.i
  ]

._crit_edge.thread.i:                             ; preds = %67
  %71 = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %spec.store.select.i = select i1 %71, i32 %.01022, i32 %.0..0..0..0..0..0.84.i
  br label %105

._crit_edge.i:                                    ; preds = %67
  %72 = icmp sgt i8 %70, 0
  br i1 %72, label %73, label %105

73:                                               ; preds = %._crit_edge.i
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %75 = shl nsw i64 %68, 5
  %76 = getelementptr i8, ptr %53, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = icmp ne ptr %77, @nil_typ
  %79 = icmp ne ptr %77, null
  %.not82.i = and i1 %78, %79
  br i1 %.not82.i, label %80, label %105

80:                                               ; preds = %73
  %81 = getelementptr i8, ptr %76, i64 8
  %82 = load i64, ptr %81, align 4
  %.sroa_idx.i = getelementptr i8, ptr %76, i64 16
  %83 = load i64, ptr %.sroa_idx.i, align 4
  %84 = inttoptr i64 %82 to ptr
  %85 = inttoptr i64 %83 to ptr
  %hash_coef_ptr.i3.i773 = getelementptr i8, ptr %77, i64 8
  %tbl_size_ptr.i4.i774 = getelementptr i8, ptr %77, i64 16
  %offset_tbl_ptr.i5.i775 = getelementptr i8, ptr %77, i64 40
  %hash_coef.i6.i776 = load i64, ptr %hash_coef_ptr.i3.i773, align 4
  %tbl_size.i7.i777 = load i64, ptr %tbl_size_ptr.i4.i774, align 4
  %offset_tbl.i8.i778 = load ptr, ptr %offset_tbl_ptr.i5.i775, align 8
  %product.i.i9.i779 = mul i64 %hash_coef.i6.i776, 4015701072841558310
  %shifted.i.i10.i780 = lshr i64 %product.i.i9.i779, 32
  %xored.i.i11.i781 = xor i64 %shifted.i.i10.i780, %product.i.i9.i779
  %hash.i.i12.i782 = and i64 %xored.i.i11.i781, %tbl_size.i7.i777
  %offset_ptr.i13.i783 = getelementptr i32, ptr %offset_tbl.i8.i778, i64 %hash.i.i12.i782
  %offset.i14.i784 = load i32, ptr %offset_ptr.i13.i783, align 4
  %86 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %77, 0
  %87 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %84, 1
  %88 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %85, 2
  %89 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %offset.i14.i784, 3
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %77)
  %92 = sext i32 %offset.i14.i784 to i64
  %93 = getelementptr ptr, ptr %77, i64 %92
  %94 = getelementptr i8, ptr %93, i64 40
  %95 = load ptr, ptr %94, align 8
  %result.i1.i = call ptr %95({ ptr, ptr, ptr, i32 } %89, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %96 = call i32 %result.i1.i({ ptr, ptr, ptr, i32 } %89, { ptr, ptr, ptr, i32 } %89, ptr nonnull align 8 %2)
  %97 = icmp eq i32 %96, %64
  br i1 %97, label %._crit_edge2.i, label %105

._crit_edge2.i:                                   ; preds = %80
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %77)
  %100 = getelementptr i8, ptr %93, i64 48
  %101 = load ptr, ptr %100, align 8
  %result.i.i785 = call ptr %101({ ptr, ptr, ptr, i32 } %89, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %102 = call { ptr, i160 } %result.i.i785({ ptr, ptr, ptr, i32 } %89, { ptr, ptr, ptr, i32 } %89, ptr nonnull align 8 %2)
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %104 = call i1 %54({ ptr, i160 } %102, { ptr, i160 } %62)
  br i1 %104, label %SwissTable_find_slot_keyK_hashi32.exit, label %105

105:                                              ; preds = %._crit_edge2.i, %80, %73, %._crit_edge.i, %._crit_edge.thread.i
  %.11021 = phi i32 [ %.01020, %._crit_edge2.i ], [ %.01020, %80 ], [ %.01020, %73 ], [ %.01020, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %spec.store.select9216.i = phi i32 [ %.0..0..0..0..0..0.84.i, %._crit_edge2.i ], [ %.0..0..0..0..0..0.84.i, %80 ], [ %.0..0..0..0..0..0.84.i, %73 ], [ %.0..0..0..0..0..0.84.i, %._crit_edge.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %106 = add nuw i32 %.01022, 1
  br label %67

107:                                              ; preds = %67
  %.not.i = icmp eq i32 %.0..0..0..0..0..0.84.i, -1
  %.pre.i = select i1 %.not.i, i32 %.01022, i32 %.01020
  %.pre = sext i32 %.pre.i to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit

SwissTable_find_slot_keyK_hashi32.exit:           ; preds = %107, %._crit_edge2.i
  %108 = phi ptr [ %55, %107 ], [ %.pre1262, %._crit_edge2.i ]
  %.pre-phi = phi i64 [ %.pre, %107 ], [ %68, %._crit_edge2.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %110 = getelementptr i8, ptr %108, i64 %.pre-phi
  %111 = load i8, ptr %110, align 1
  switch i8 %111, label %112 [
    i8 -128, label %SwissTable_get_keyK.exit.thread
    i8 0, label %SwissTable_get_keyK.exit.thread
  ]

112:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit
  %113 = shl nsw i64 %.pre-phi, 5
  %114 = getelementptr i8, ptr %53, i64 %113
  %115 = load ptr, ptr %114, align 8
  %116 = icmp ne ptr %115, @nil_typ
  %117 = icmp ne ptr %115, null
  %.not74.i = and i1 %116, %117
  br i1 %.not74.i, label %SwissTable_get_keyK.exit, label %SwissTable_get_keyK.exit.thread

SwissTable_get_keyK.exit.thread:                  ; preds = %112, %SwissTable_find_slot_keyK_hashi32.exit, %SwissTable_find_slot_keyK_hashi32.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %136

SwissTable_get_keyK.exit:                         ; preds = %112
  %118 = getelementptr i8, ptr %114, i64 8
  %119 = load i160, ptr %118, align 4
  %.sroa.262.0.extract.shift.i = lshr i160 %119, 64
  %.sroa.262.0.extract.trunc.i = trunc i160 %.sroa.262.0.extract.shift.i to i64
  %.sroa.061.0.extract.trunc.i = trunc i160 %119 to i64
  %120 = inttoptr i64 %.sroa.061.0.extract.trunc.i to ptr
  %121 = inttoptr i64 %.sroa.262.0.extract.trunc.i to ptr
  %hash_coef_ptr.i3.i = getelementptr i8, ptr %115, i64 8
  %tbl_size_ptr.i4.i = getelementptr i8, ptr %115, i64 16
  %offset_tbl_ptr.i5.i = getelementptr i8, ptr %115, i64 40
  %hash_coef.i6.i = load i64, ptr %hash_coef_ptr.i3.i, align 4
  %tbl_size.i7.i = load i64, ptr %tbl_size_ptr.i4.i, align 4
  %offset_tbl.i8.i = load ptr, ptr %offset_tbl_ptr.i5.i, align 8
  %product.i.i9.i = mul i64 %hash_coef.i6.i, 4015701072841558310
  %shifted.i.i10.i = lshr i64 %product.i.i9.i, 32
  %xored.i.i11.i = xor i64 %shifted.i.i10.i, %product.i.i9.i
  %hash.i.i12.i = and i64 %xored.i.i11.i, %tbl_size.i7.i
  %offset_ptr.i13.i = getelementptr i32, ptr %offset_tbl.i8.i, i64 %hash.i.i12.i
  %offset.i14.i = load i32, ptr %offset_ptr.i13.i, align 4
  %122 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %115, 0
  %123 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %120, 1
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %121, 2
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %offset.i14.i, 3
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %115)
  %128 = sext i32 %offset.i14.i to i64
  %129 = getelementptr ptr, ptr %115, i64 %128
  %130 = getelementptr i8, ptr %129, i64 56
  %131 = load ptr, ptr %130, align 8
  %result.i1.i334 = call ptr %131({ ptr, ptr, ptr, i32 } %125, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %132 = call { ptr, i160 } %result.i1.i334({ ptr, ptr, ptr, i32 } %125, { ptr, ptr, ptr, i32 } %125, ptr nonnull align 8 %2)
  %.fca.0.extract49.i = extractvalue { ptr, i160 } %132, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %133 = icmp eq ptr %.fca.0.extract49.i, @nil_typ
  %134 = icmp eq ptr %.fca.0.extract49.i, null
  %135 = or i1 %133, %134
  br i1 %135, label %136, label %._crit_edge1

136:                                              ; preds = %SwissTable_get_keyK.exit, %SwissTable_get_keyK.exit.thread
  %137 = add nuw i32 %61, 1
  %138 = icmp eq i32 %52, 0
  br i1 %138, label %._crit_edge1.i, label %139

139:                                              ; preds = %136
  %140 = add i32 %51, 1
  %141 = mul i32 %52, 7
  %142 = sdiv i32 %141, 10
  %.not.i800 = icmp slt i32 %140, %142
  br i1 %.not.i800, label %SwissTable_ensure_capacity_required_sizei32.exit, label %._crit_edge1.i

._crit_edge1.i:                                   ; preds = %139, %136
  %143 = shl i32 %52, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %143, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %144 = zext nneg i32 %spec.select.i to i64
  %145 = shl nuw nsw i64 %144, 5
  %result.i10.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %145) #51
  store ptr %result.i10.i, ptr %4, align 8
  %result.i9.i1297 = call noalias ptr @bump_malloc_wrapper(i64 noundef %144) #51
  store ptr %result.i9.i1297, ptr %21, align 8
  store i32 %spec.select.i, ptr %22, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  store i32 0, ptr %23, align 4
  %147 = add i32 %52, -1
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %152 = icmp slt i32 %147, 0
  br i1 %152, label %SwissTable_resize_new_capacityi32.exit, label %.lr.ph.i.preheader

.lr.ph.i.preheader:                               ; preds = %._crit_edge1.i
  %153 = add nsw i32 %spec.select.i, -1
  br label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge2.backedge.i, %.lr.ph.i.preheader
  %154 = phi i32 [ %245, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %storemerge.i = phi i32 [ %249, %._crit_edge2.backedge.i ], [ 1, %.lr.ph.i.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i = phi i32 [ %storemerge.i, %._crit_edge2.backedge.i ], [ 0, %.lr.ph.i.preheader ]
  %.sroa.0.8.extract.trunc.i = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i to i64
  %sext.i = shl nuw i64 %.sroa.0.8.extract.trunc.i, 32
  %155 = ashr exact i64 %sext.i, 27
  %156 = getelementptr i8, ptr %50, i64 %155
  %157 = load ptr, ptr %156, align 8
  %158 = icmp ne ptr %157, @nil_typ
  %159 = icmp ne ptr %157, null
  %.not158.i = and i1 %158, %159
  br i1 %.not158.i, label %160, label %._crit_edge2.backedge.i

160:                                              ; preds = %.lr.ph.i
  %161 = getelementptr i8, ptr %156, i64 8
  %162 = load i160, ptr %161, align 4
  %.sroa.3.0.extract.shift.i = lshr i160 %162, 64
  %.sroa.3.0.extract.trunc.i = trunc i160 %.sroa.3.0.extract.shift.i to i64
  %.sroa.0146.0.extract.trunc.i = trunc i160 %162 to i64
  %163 = inttoptr i64 %.sroa.0146.0.extract.trunc.i to ptr
  %164 = inttoptr i64 %.sroa.3.0.extract.trunc.i to ptr
  %hash_coef_ptr.i23.i = getelementptr i8, ptr %157, i64 8
  %tbl_size_ptr.i24.i = getelementptr i8, ptr %157, i64 16
  %offset_tbl_ptr.i25.i = getelementptr i8, ptr %157, i64 40
  %hash_coef.i26.i = load i64, ptr %hash_coef_ptr.i23.i, align 4
  %tbl_size.i27.i = load i64, ptr %tbl_size_ptr.i24.i, align 4
  %offset_tbl.i28.i = load ptr, ptr %offset_tbl_ptr.i25.i, align 8
  %product.i.i29.i = mul i64 %hash_coef.i26.i, 4015701072841558310
  %shifted.i.i30.i = lshr i64 %product.i.i29.i, 32
  %xored.i.i31.i = xor i64 %shifted.i.i30.i, %product.i.i29.i
  %hash.i.i32.i = and i64 %xored.i.i31.i, %tbl_size.i27.i
  %offset_ptr.i33.i = getelementptr i32, ptr %offset_tbl.i28.i, i64 %hash.i.i32.i
  %offset.i34.i = load i32, ptr %offset_ptr.i33.i, align 4
  %165 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %157, 0
  %166 = insertvalue { ptr, ptr, ptr, i32 } %165, ptr %163, 1
  %167 = insertvalue { ptr, ptr, ptr, i32 } %166, ptr %164, 2
  %168 = insertvalue { ptr, ptr, ptr, i32 } %167, i32 %offset.i34.i, 3
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %157)
  %171 = sext i32 %offset.i34.i to i64
  %172 = getelementptr ptr, ptr %157, i64 %171
  %173 = getelementptr i8, ptr %172, i64 48
  %174 = load ptr, ptr %173, align 8
  %result.i4.i1298 = call ptr %174({ ptr, ptr, ptr, i32 } %168, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %175 = call { ptr, i160 } %result.i4.i1298({ ptr, ptr, ptr, i32 } %168, { ptr, ptr, ptr, i32 } %168, ptr nonnull align 8 %2)
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract.i = extractvalue { ptr, i160 } %175, 1
  %.sroa.1.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i32
  %177 = add i32 %.sroa.1.8.extract.trunc.i, 2127912214
  %178 = shl i32 %.sroa.1.8.extract.trunc.i, 12
  %179 = add i32 %177, %178
  %180 = ashr i32 %179, 19
  %181 = xor i32 %179, %180
  %182 = xor i32 %181, -949894596
  %183 = add i32 %182, 374761393
  %184 = shl i32 %182, 5
  %185 = add i32 %183, %184
  %186 = add i32 %185, -744332180
  %187 = shl i32 %185, 9
  %188 = xor i32 %186, %187
  %189 = add i32 %188, -42973499
  %190 = shl i32 %188, 3
  %191 = add i32 %189, %190
  %192 = ashr i32 %191, 16
  %193 = xor i32 %191, %192
  %194 = xor i32 %193, -1252372727
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %157)
  %197 = load ptr, ptr %173, align 8
  %result.i3.i = call ptr %197({ ptr, ptr, ptr, i32 } %168, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %198 = call { ptr, i160 } %result.i3.i({ ptr, ptr, ptr, i32 } %168, { ptr, ptr, ptr, i32 } %168, ptr nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.1.extract.i1908 = extractvalue { ptr, i160 } %198, 1
  %.sroa.1.8.extract.trunc.i1909 = trunc i160 %.fca.1.extract.i1908 to i32
  br label %199

199:                                              ; preds = %237, %160
  %.pn1964 = phi i32 [ %194, %160 ], [ %238, %237 ]
  %.01651 = phi i32 [ -1, %160 ], [ %.11652, %237 ]
  %.0..0..0..0..0..0.84.i1578 = phi i32 [ -1, %160 ], [ %spec.store.select9216.i1581, %237 ]
  %.01653 = and i32 %.pn1964, %153
  %200 = zext nneg i32 %.01653 to i64
  %201 = getelementptr i8, ptr %result.i9.i1297, i64 %200
  %202 = load i8, ptr %201, align 1
  switch i8 %202, label %._crit_edge.i1584 [
    i8 0, label %239
    i8 -128, label %._crit_edge.thread.i1579
  ]

._crit_edge.thread.i1579:                         ; preds = %199
  %203 = icmp eq i32 %.0..0..0..0..0..0.84.i1578, -1
  %spec.store.select.i1580 = select i1 %203, i32 %.01653, i32 %.0..0..0..0..0..0.84.i1578
  br label %237

._crit_edge.i1584:                                ; preds = %199
  %204 = icmp sgt i8 %202, 0
  br i1 %204, label %205, label %237

205:                                              ; preds = %._crit_edge.i1584
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %207 = shl nuw nsw i64 %200, 5
  %208 = getelementptr i8, ptr %result.i10.i, i64 %207
  %209 = load ptr, ptr %208, align 8
  %210 = icmp ne ptr %209, @nil_typ
  %211 = icmp ne ptr %209, null
  %.not82.i1585 = and i1 %210, %211
  br i1 %.not82.i1585, label %212, label %237

212:                                              ; preds = %205
  %213 = getelementptr i8, ptr %208, i64 8
  %214 = load i64, ptr %213, align 4
  %.sroa_idx.i1586 = getelementptr i8, ptr %208, i64 16
  %215 = load i64, ptr %.sroa_idx.i1586, align 4
  %216 = inttoptr i64 %214 to ptr
  %217 = inttoptr i64 %215 to ptr
  %hash_coef_ptr.i3.i1587 = getelementptr i8, ptr %209, i64 8
  %tbl_size_ptr.i4.i1588 = getelementptr i8, ptr %209, i64 16
  %offset_tbl_ptr.i5.i1589 = getelementptr i8, ptr %209, i64 40
  %hash_coef.i6.i1590 = load i64, ptr %hash_coef_ptr.i3.i1587, align 4
  %tbl_size.i7.i1591 = load i64, ptr %tbl_size_ptr.i4.i1588, align 4
  %offset_tbl.i8.i1592 = load ptr, ptr %offset_tbl_ptr.i5.i1589, align 8
  %product.i.i9.i1593 = mul i64 %hash_coef.i6.i1590, 4015701072841558310
  %shifted.i.i10.i1594 = lshr i64 %product.i.i9.i1593, 32
  %xored.i.i11.i1595 = xor i64 %shifted.i.i10.i1594, %product.i.i9.i1593
  %hash.i.i12.i1596 = and i64 %xored.i.i11.i1595, %tbl_size.i7.i1591
  %offset_ptr.i13.i1597 = getelementptr i32, ptr %offset_tbl.i8.i1592, i64 %hash.i.i12.i1596
  %offset.i14.i1598 = load i32, ptr %offset_ptr.i13.i1597, align 4
  %218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %209, 0
  %219 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %216, 1
  %220 = insertvalue { ptr, ptr, ptr, i32 } %219, ptr %217, 2
  %221 = insertvalue { ptr, ptr, ptr, i32 } %220, i32 %offset.i14.i1598, 3
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %209)
  %224 = sext i32 %offset.i14.i1598 to i64
  %225 = getelementptr ptr, ptr %209, i64 %224
  %226 = getelementptr i8, ptr %225, i64 40
  %227 = load ptr, ptr %226, align 8
  %result.i1.i1599 = call ptr %227({ ptr, ptr, ptr, i32 } %221, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %228 = call i32 %result.i1.i1599({ ptr, ptr, ptr, i32 } %221, { ptr, ptr, ptr, i32 } %221, ptr nonnull align 8 %2)
  %229 = icmp eq i32 %228, %194
  br i1 %229, label %._crit_edge2.i1600, label %237

._crit_edge2.i1600:                               ; preds = %212
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %209)
  %232 = getelementptr i8, ptr %225, i64 48
  %233 = load ptr, ptr %232, align 8
  %result.i.i1601 = call ptr %233({ ptr, ptr, ptr, i32 } %221, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %234 = call { ptr, i160 } %result.i.i1601({ ptr, ptr, ptr, i32 } %221, { ptr, ptr, ptr, i32 } %221, ptr nonnull align 8 %2)
  %235 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i = extractvalue { ptr, i160 } %234, 1
  %.sroa.15.8.extract.trunc.i = trunc i160 %.fca.1.extract3.i to i32
  %236 = icmp eq i32 %.sroa.15.8.extract.trunc.i, %.sroa.1.8.extract.trunc.i1909
  br i1 %236, label %SwissTable_find_slot_keyK_hashi32.exit1602, label %237

237:                                              ; preds = %._crit_edge2.i1600, %212, %205, %._crit_edge.i1584, %._crit_edge.thread.i1579
  %.11652 = phi i32 [ %.01651, %._crit_edge2.i1600 ], [ %.01651, %212 ], [ %.01651, %205 ], [ %.01651, %._crit_edge.i1584 ], [ %spec.store.select.i1580, %._crit_edge.thread.i1579 ]
  %spec.store.select9216.i1581 = phi i32 [ %.0..0..0..0..0..0.84.i1578, %._crit_edge2.i1600 ], [ %.0..0..0..0..0..0.84.i1578, %212 ], [ %.0..0..0..0..0..0.84.i1578, %205 ], [ %.0..0..0..0..0..0.84.i1578, %._crit_edge.i1584 ], [ %spec.store.select.i1580, %._crit_edge.thread.i1579 ]
  %238 = add nuw nsw i32 %.01653, 1
  br label %199

239:                                              ; preds = %199
  %.not.i1582 = icmp eq i32 %.0..0..0..0..0..0.84.i1578, -1
  %.pre.i1583 = select i1 %.not.i1582, i32 %.01653, i32 %.01651
  %.pre1735 = sext i32 %.pre.i1583 to i64
  %.pre1737 = shl nsw i64 %.pre1735, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1602

SwissTable_find_slot_keyK_hashi32.exit1602:       ; preds = %239, %._crit_edge2.i1600
  %.pre-phi1738 = phi i64 [ %.pre1737, %239 ], [ %207, %._crit_edge2.i1600 ]
  %.pre-phi1736 = phi i64 [ %.pre1735, %239 ], [ %200, %._crit_edge2.i1600 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %240 = getelementptr i8, ptr %result.i10.i, i64 %.pre-phi1738
  store ptr %157, ptr %240, align 8
  %241 = getelementptr i8, ptr %240, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i, ptr %241, align 4
  %.sroa_idx120.i = getelementptr i8, ptr %240, i64 16
  store i64 %.sroa.3.0.extract.trunc.i, ptr %.sroa_idx120.i, align 4
  %.sroa_idx121.i = getelementptr i8, ptr %240, i64 24
  store i32 %offset.i34.i, ptr %.sroa_idx121.i, align 4
  %242 = getelementptr i8, ptr %result.i9.i1297, i64 %.pre-phi1736
  store i8 1, ptr %242, align 1
  %243 = add i32 %154, 1
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i

._crit_edge2.backedge.i:                          ; preds = %SwissTable_find_slot_keyK_hashi32.exit1602, %.lr.ph.i
  %245 = phi i32 [ %243, %SwissTable_find_slot_keyK_hashi32.exit1602 ], [ %154, %.lr.ph.i ]
  %246 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %247 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %248 = icmp sgt i32 %storemerge.i, %147
  %249 = add i32 %storemerge.i, 1
  br i1 %248, label %SwissTable_resize_new_capacityi32.exit.loopexit, label %.lr.ph.i

SwissTable_resize_new_capacityi32.exit.loopexit:  ; preds = %._crit_edge2.backedge.i
  store i32 %245, ptr %23, align 4
  br label %SwissTable_resize_new_capacityi32.exit

SwissTable_resize_new_capacityi32.exit:           ; preds = %SwissTable_resize_new_capacityi32.exit.loopexit, %._crit_edge1.i
  %250 = phi i32 [ %245, %SwissTable_resize_new_capacityi32.exit.loopexit ], [ 0, %._crit_edge1.i ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %SwissTable_ensure_capacity_required_sizei32.exit

SwissTable_ensure_capacity_required_sizei32.exit: ; preds = %SwissTable_resize_new_capacityi32.exit, %139
  %251 = phi ptr [ %46, %139 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %252 = phi ptr [ %47, %139 ], [ %result.i9.i1297, %SwissTable_resize_new_capacityi32.exit ]
  %.pre1263 = phi ptr [ %.pre12631860, %139 ], [ %result.i9.i1297, %SwissTable_resize_new_capacityi32.exit ]
  %253 = phi ptr [ %50, %139 ], [ %result.i10.i, %SwissTable_resize_new_capacityi32.exit ]
  %254 = phi ptr [ %48, %139 ], [ %result.i9.i1297, %SwissTable_resize_new_capacityi32.exit ]
  %255 = phi i32 [ %49, %139 ], [ %spec.select.i, %SwissTable_resize_new_capacityi32.exit ]
  %256 = phi i32 [ %51, %139 ], [ %250, %SwissTable_resize_new_capacityi32.exit ]
  %257 = add nuw i32 %61, 2127912214
  %258 = shl i32 %60, 12
  %259 = add i32 %257, %258
  %260 = ashr i32 %259, 19
  %261 = xor i32 %259, %260
  %262 = xor i32 %261, -949894596
  %263 = add i32 %262, 374761393
  %264 = shl i32 %262, 5
  %265 = add i32 %263, %264
  %266 = add i32 %265, -744332180
  %267 = shl i32 %265, 9
  %268 = xor i32 %266, %267
  %269 = add i32 %268, -42973499
  %270 = shl i32 %268, 3
  %271 = add i32 %269, %270
  %272 = ashr i32 %271, 16
  %273 = xor i32 %271, %272
  %274 = xor i32 %273, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %275 = add i32 %255, -1
  %276 = and i32 %275, %274
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %278

278:                                              ; preds = %316, %SwissTable_ensure_capacity_required_sizei32.exit
  %.01025 = phi i32 [ %276, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %318, %316 ]
  %.01023 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %.11024, %316 ]
  %.0..0..0..0..0..0.84.i818 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit ], [ %spec.store.select9216.i822, %316 ]
  %279 = sext i32 %.01025 to i64
  %280 = getelementptr i8, ptr %254, i64 %279
  %281 = load i8, ptr %280, align 1
  switch i8 %281, label %._crit_edge.i827 [
    i8 0, label %319
    i8 -128, label %._crit_edge.thread.i820
  ]

._crit_edge.thread.i820:                          ; preds = %278
  %282 = icmp eq i32 %.0..0..0..0..0..0.84.i818, -1
  %spec.store.select.i821 = select i1 %282, i32 %.01025, i32 %.0..0..0..0..0..0.84.i818
  br label %316

._crit_edge.i827:                                 ; preds = %278
  %283 = icmp sgt i8 %281, 0
  br i1 %283, label %284, label %316

284:                                              ; preds = %._crit_edge.i827
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %286 = shl nsw i64 %279, 5
  %287 = getelementptr i8, ptr %253, i64 %286
  %288 = load ptr, ptr %287, align 8
  %289 = icmp ne ptr %288, @nil_typ
  %290 = icmp ne ptr %288, null
  %.not82.i829 = and i1 %289, %290
  br i1 %.not82.i829, label %291, label %316

291:                                              ; preds = %284
  %292 = getelementptr i8, ptr %287, i64 8
  %293 = load i64, ptr %292, align 4
  %.sroa_idx.i830 = getelementptr i8, ptr %287, i64 16
  %294 = load i64, ptr %.sroa_idx.i830, align 4
  %295 = inttoptr i64 %293 to ptr
  %296 = inttoptr i64 %294 to ptr
  %hash_coef_ptr.i3.i831 = getelementptr i8, ptr %288, i64 8
  %tbl_size_ptr.i4.i832 = getelementptr i8, ptr %288, i64 16
  %offset_tbl_ptr.i5.i833 = getelementptr i8, ptr %288, i64 40
  %hash_coef.i6.i834 = load i64, ptr %hash_coef_ptr.i3.i831, align 4
  %tbl_size.i7.i835 = load i64, ptr %tbl_size_ptr.i4.i832, align 4
  %offset_tbl.i8.i836 = load ptr, ptr %offset_tbl_ptr.i5.i833, align 8
  %product.i.i9.i837 = mul i64 %hash_coef.i6.i834, 4015701072841558310
  %shifted.i.i10.i838 = lshr i64 %product.i.i9.i837, 32
  %xored.i.i11.i839 = xor i64 %shifted.i.i10.i838, %product.i.i9.i837
  %hash.i.i12.i840 = and i64 %xored.i.i11.i839, %tbl_size.i7.i835
  %offset_ptr.i13.i841 = getelementptr i32, ptr %offset_tbl.i8.i836, i64 %hash.i.i12.i840
  %offset.i14.i842 = load i32, ptr %offset_ptr.i13.i841, align 4
  %297 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %288, 0
  %298 = insertvalue { ptr, ptr, ptr, i32 } %297, ptr %295, 1
  %299 = insertvalue { ptr, ptr, ptr, i32 } %298, ptr %296, 2
  %300 = insertvalue { ptr, ptr, ptr, i32 } %299, i32 %offset.i14.i842, 3
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %302 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %288)
  %303 = sext i32 %offset.i14.i842 to i64
  %304 = getelementptr ptr, ptr %288, i64 %303
  %305 = getelementptr i8, ptr %304, i64 40
  %306 = load ptr, ptr %305, align 8
  %result.i1.i843 = call ptr %306({ ptr, ptr, ptr, i32 } %300, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %307 = call i32 %result.i1.i843({ ptr, ptr, ptr, i32 } %300, { ptr, ptr, ptr, i32 } %300, ptr nonnull align 8 %2)
  %308 = icmp eq i32 %307, %274
  br i1 %308, label %._crit_edge2.i844, label %316

._crit_edge2.i844:                                ; preds = %291
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %288)
  %311 = getelementptr i8, ptr %304, i64 48
  %312 = load ptr, ptr %311, align 8
  %result.i.i845 = call ptr %312({ ptr, ptr, ptr, i32 } %300, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %313 = call { ptr, i160 } %result.i.i845({ ptr, ptr, ptr, i32 } %300, { ptr, ptr, ptr, i32 } %300, ptr nonnull align 8 %2)
  %314 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i1912 = extractvalue { ptr, i160 } %313, 1
  %.sroa.15.8.extract.trunc.i1913 = trunc i160 %.fca.1.extract3.i1912 to i32
  %315 = icmp eq i32 %61, %.sroa.15.8.extract.trunc.i1913
  br i1 %315, label %SwissTable_find_slot_keyK_hashi32.exit847, label %316

316:                                              ; preds = %._crit_edge2.i844, %291, %284, %._crit_edge.i827, %._crit_edge.thread.i820
  %.11024 = phi i32 [ %.01023, %._crit_edge2.i844 ], [ %.01023, %291 ], [ %.01023, %284 ], [ %.01023, %._crit_edge.i827 ], [ %spec.store.select.i821, %._crit_edge.thread.i820 ]
  %spec.store.select9216.i822 = phi i32 [ %.0..0..0..0..0..0.84.i818, %._crit_edge2.i844 ], [ %.0..0..0..0..0..0.84.i818, %291 ], [ %.0..0..0..0..0..0.84.i818, %284 ], [ %.0..0..0..0..0..0.84.i818, %._crit_edge.i827 ], [ %spec.store.select.i821, %._crit_edge.thread.i820 ]
  %317 = add i32 %.01025, 1
  %318 = and i32 %317, %275
  br label %278

319:                                              ; preds = %278
  %.not.i823 = icmp eq i32 %.0..0..0..0..0..0.84.i818, -1
  %.pre.i826 = select i1 %.not.i823, i32 %.01025, i32 %.01023
  %.pre1059 = sext i32 %.pre.i826 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit847

SwissTable_find_slot_keyK_hashi32.exit847:        ; preds = %319, %._crit_edge2.i844
  %320 = phi ptr [ %254, %319 ], [ %.pre1263, %._crit_edge2.i844 ]
  %.pre-phi1060 = phi i64 [ %.pre1059, %319 ], [ %279, %._crit_edge2.i844 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %321 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %322 = getelementptr i8, ptr %320, i64 %.pre-phi1060
  %323 = load i8, ptr %322, align 1
  %result.i9.i = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  store ptr @_parameterization_i32, ptr %result.i9.i, align 8
  %324 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr @_parameterization_i32, ptr %324, align 8
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9.i)
  %326 = getelementptr inbounds i8, ptr %result.i9.i, i64 20
  store i32 %61, ptr %326, align 4
  %327 = getelementptr inbounds i8, ptr %result.i9.i, i64 24
  store i32 %137, ptr %327, align 8
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %329 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %274, ptr %329, align 8
  %330 = icmp eq i8 %323, 0
  br i1 %330, label %331, label %SwissTable_insert_keyK_valueV.exit

331:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit847
  %332 = getelementptr i8, ptr %252, i64 %.pre-phi1060
  store i8 1, ptr %332, align 1
  %333 = load i32, ptr %23, align 4
  %334 = add i32 %333, 1
  store i32 %334, ptr %23, align 4
  %.pre1864 = load ptr, ptr %4, align 8
  br label %SwissTable_insert_keyK_valueV.exit

SwissTable_insert_keyK_valueV.exit:               ; preds = %331, %SwissTable_find_slot_keyK_hashi32.exit847
  %335 = phi ptr [ %251, %SwissTable_find_slot_keyK_hashi32.exit847 ], [ %.pre1864, %331 ]
  %.pre12631862 = phi ptr [ %.pre1263, %SwissTable_find_slot_keyK_hashi32.exit847 ], [ %252, %331 ]
  %336 = phi ptr [ %320, %SwissTable_find_slot_keyK_hashi32.exit847 ], [ %252, %331 ]
  %337 = phi i32 [ %256, %SwissTable_find_slot_keyK_hashi32.exit847 ], [ %334, %331 ]
  %338 = shl nsw i64 %.pre-phi1060, 5
  %339 = getelementptr i8, ptr %335, i64 %338
  store ptr @Entry, ptr %339, align 8
  %340 = getelementptr i8, ptr %339, i64 8
  %341 = ptrtoint ptr %result.i9.i to i64
  store i64 %341, ptr %340, align 4
  %.sroa_idx3.i = getelementptr i8, ptr %339, i64 24
  store i32 10, ptr %.sroa_idx3.i, align 4
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %343 = sext i32 %.0550219 to i64
  %344 = shl nsw i64 %343, 2
  %345 = getelementptr i8, ptr %result.i2.i290, i64 %344
  store i32 %61, ptr %345, align 1
  store i1 true, ptr %.sroa.0512.sroa.0, align 8
  %.sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.0. = load i8, ptr %.sroa.0512.sroa.0, align 8
  %.sroa.0512.0.insert.ext = zext i8 %.sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.sroa.0.0..sroa.0512.0. to i160
  %346 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0512.0.insert.ext, 1
  %347 = load i32, ptr %36, align 8
  %348 = icmp eq i32 %347, 0
  br i1 %348, label %._crit_edge1.i863, label %349

349:                                              ; preds = %SwissTable_insert_keyK_valueV.exit
  %350 = load i32, ptr %38, align 4
  %351 = add i32 %350, 1
  %352 = mul i32 %347, 7
  %353 = sdiv i32 %352, 10
  %.not.i862 = icmp slt i32 %351, %353
  br i1 %.not.i862, label %.SwissTable_ensure_capacity_required_sizei32.exit867_crit_edge, label %._crit_edge1.i863

.SwissTable_ensure_capacity_required_sizei32.exit867_crit_edge: ; preds = %349
  %.pre1865 = load ptr, ptr %35, align 8
  %.pre1866 = load ptr, ptr %3, align 8
  br label %SwissTable_ensure_capacity_required_sizei32.exit867

._crit_edge1.i863:                                ; preds = %349, %SwissTable_insert_keyK_valueV.exit
  %354 = shl i32 %347, 1
  %spec.select.i864 = call i32 @llvm.smax.i32(i32 %354, i32 noundef 8) #46, !range !1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %355 = load ptr, ptr %3, align 8
  %356 = zext nneg i32 %spec.select.i864 to i64
  %357 = shl nuw nsw i64 %356, 5
  %result.i10.i1315 = call noalias ptr @bump_malloc_wrapper(i64 noundef %357) #51
  store ptr %result.i10.i1315, ptr %3, align 8
  %result.i9.i1316 = call noalias ptr @bump_malloc_wrapper(i64 noundef %356) #51
  store ptr %result.i9.i1316, ptr %35, align 8
  store i32 %spec.select.i864, ptr %36, align 8
  %358 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  store i32 0, ptr %38, align 4
  %359 = add i32 %347, -1
  %360 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %362 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %364 = icmp slt i32 %359, 0
  br i1 %364, label %SwissTable_resize_new_capacityi32.exit1353, label %.lr.ph.i1318.preheader

.lr.ph.i1318.preheader:                           ; preds = %._crit_edge1.i863
  %.promoted1513 = load ptr, ptr %44, align 8
  %365 = load ptr, ptr %33, align 8
  %366 = load ptr, ptr %result.i71.h2s2322, align 8
  %367 = add nsw i32 %spec.select.i864, -1
  %368 = load ptr, ptr %34, align 8
  br label %.lr.ph.i1318

.lr.ph.i1318:                                     ; preds = %._crit_edge2.backedge.i1324, %.lr.ph.i1318.preheader
  %369 = phi i32 [ %444, %._crit_edge2.backedge.i1324 ], [ 0, %.lr.ph.i1318.preheader ]
  %_parameterization_i321514 = phi ptr [ %_parameterization_i321515, %._crit_edge2.backedge.i1324 ], [ %.promoted1513, %.lr.ph.i1318.preheader ]
  %storemerge.i1319 = phi i32 [ %448, %._crit_edge2.backedge.i1324 ], [ 1, %.lr.ph.i1318.preheader ]
  %.sroa.026.0.insert.ext.i64.pn.in.i1320 = phi i32 [ %storemerge.i1319, %._crit_edge2.backedge.i1324 ], [ 0, %.lr.ph.i1318.preheader ]
  %.sroa.0.8.extract.trunc.i1321 = zext i32 %.sroa.026.0.insert.ext.i64.pn.in.i1320 to i64
  %sext.i1322 = shl nuw i64 %.sroa.0.8.extract.trunc.i1321, 32
  %370 = ashr exact i64 %sext.i1322, 27
  %371 = getelementptr i8, ptr %355, i64 %370
  %372 = load ptr, ptr %371, align 8
  %373 = icmp ne ptr %372, @nil_typ
  %374 = icmp ne ptr %372, null
  %.not158.i1323 = and i1 %373, %374
  br i1 %.not158.i1323, label %375, label %._crit_edge2.backedge.i1324

375:                                              ; preds = %.lr.ph.i1318
  %376 = getelementptr i8, ptr %371, i64 8
  %377 = load i160, ptr %376, align 4
  %.sroa.3.0.extract.shift.i1326 = lshr i160 %377, 64
  %.sroa.3.0.extract.trunc.i1327 = trunc i160 %.sroa.3.0.extract.shift.i1326 to i64
  %.sroa.0146.0.extract.trunc.i1328 = trunc i160 %377 to i64
  %378 = inttoptr i64 %.sroa.0146.0.extract.trunc.i1328 to ptr
  %379 = inttoptr i64 %.sroa.3.0.extract.trunc.i1327 to ptr
  %hash_coef_ptr.i23.i1329 = getelementptr i8, ptr %372, i64 8
  %tbl_size_ptr.i24.i1330 = getelementptr i8, ptr %372, i64 16
  %offset_tbl_ptr.i25.i1331 = getelementptr i8, ptr %372, i64 40
  %hash_coef.i26.i1332 = load i64, ptr %hash_coef_ptr.i23.i1329, align 4
  %tbl_size.i27.i1333 = load i64, ptr %tbl_size_ptr.i24.i1330, align 4
  %offset_tbl.i28.i1334 = load ptr, ptr %offset_tbl_ptr.i25.i1331, align 8
  %product.i.i29.i1335 = mul i64 %hash_coef.i26.i1332, 4015701072841558310
  %shifted.i.i30.i1336 = lshr i64 %product.i.i29.i1335, 32
  %xored.i.i31.i1337 = xor i64 %shifted.i.i30.i1336, %product.i.i29.i1335
  %hash.i.i32.i1338 = and i64 %xored.i.i31.i1337, %tbl_size.i27.i1333
  %offset_ptr.i33.i1339 = getelementptr i32, ptr %offset_tbl.i28.i1334, i64 %hash.i.i32.i1338
  %offset.i34.i1340 = load i32, ptr %offset_ptr.i33.i1339, align 4
  %380 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %372, 0
  %381 = insertvalue { ptr, ptr, ptr, i32 } %380, ptr %378, 1
  %382 = insertvalue { ptr, ptr, ptr, i32 } %381, ptr %379, 2
  %383 = insertvalue { ptr, ptr, ptr, i32 } %382, i32 %offset.i34.i1340, 3
  %384 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %385 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %372)
  %386 = sext i32 %offset.i34.i1340 to i64
  %387 = getelementptr ptr, ptr %372, i64 %386
  %388 = getelementptr i8, ptr %387, i64 48
  %389 = load ptr, ptr %388, align 8
  %result.i4.i1341 = call ptr %389({ ptr, ptr, ptr, i32 } %383, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %390 = call { ptr, i160 } %result.i4.i1341({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull align 8 %2)
  %391 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %392 = call i32 %365({ ptr, i160 } %390)
  %393 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %394 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %372)
  %395 = load ptr, ptr %388, align 8
  %result.i3.i1343 = call ptr %395({ ptr, ptr, ptr, i32 } %383, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %396 = call { ptr, i160 } %result.i3.i1343({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull align 8 %2)
  store ptr %366, ptr %5, align 8
  %397 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %398

398:                                              ; preds = %436, %375
  %.pn1965 = phi i32 [ %392, %375 ], [ %437, %436 ]
  %.01654 = phi i32 [ -1, %375 ], [ %.11655, %436 ]
  %.0..0..0..0..0..0.84.i1618 = phi i32 [ -1, %375 ], [ %spec.store.select9216.i1622, %436 ]
  %.01656 = and i32 %.pn1965, %367
  %399 = zext nneg i32 %.01656 to i64
  %400 = getelementptr i8, ptr %result.i9.i1316, i64 %399
  %401 = load i8, ptr %400, align 1
  switch i8 %401, label %._crit_edge.i1627 [
    i8 0, label %438
    i8 -128, label %._crit_edge.thread.i1620
  ]

._crit_edge.thread.i1620:                         ; preds = %398
  %402 = icmp eq i32 %.0..0..0..0..0..0.84.i1618, -1
  %spec.store.select.i1621 = select i1 %402, i32 %.01656, i32 %.0..0..0..0..0..0.84.i1618
  br label %436

._crit_edge.i1627:                                ; preds = %398
  %403 = icmp sgt i8 %401, 0
  br i1 %403, label %404, label %436

404:                                              ; preds = %._crit_edge.i1627
  %405 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %406 = shl nuw nsw i64 %399, 5
  %407 = getelementptr i8, ptr %result.i10.i1315, i64 %406
  %408 = load ptr, ptr %407, align 8
  %409 = icmp ne ptr %408, @nil_typ
  %410 = icmp ne ptr %408, null
  %.not82.i1629 = and i1 %409, %410
  br i1 %.not82.i1629, label %411, label %436

411:                                              ; preds = %404
  %412 = getelementptr i8, ptr %407, i64 8
  %413 = load i64, ptr %412, align 4
  %.sroa_idx.i1630 = getelementptr i8, ptr %407, i64 16
  %414 = load i64, ptr %.sroa_idx.i1630, align 4
  %415 = inttoptr i64 %413 to ptr
  %416 = inttoptr i64 %414 to ptr
  %hash_coef_ptr.i3.i1631 = getelementptr i8, ptr %408, i64 8
  %tbl_size_ptr.i4.i1632 = getelementptr i8, ptr %408, i64 16
  %offset_tbl_ptr.i5.i1633 = getelementptr i8, ptr %408, i64 40
  %hash_coef.i6.i1634 = load i64, ptr %hash_coef_ptr.i3.i1631, align 4
  %tbl_size.i7.i1635 = load i64, ptr %tbl_size_ptr.i4.i1632, align 4
  %offset_tbl.i8.i1636 = load ptr, ptr %offset_tbl_ptr.i5.i1633, align 8
  %product.i.i9.i1637 = mul i64 %hash_coef.i6.i1634, 4015701072841558310
  %shifted.i.i10.i1638 = lshr i64 %product.i.i9.i1637, 32
  %xored.i.i11.i1639 = xor i64 %shifted.i.i10.i1638, %product.i.i9.i1637
  %hash.i.i12.i1640 = and i64 %xored.i.i11.i1639, %tbl_size.i7.i1635
  %offset_ptr.i13.i1641 = getelementptr i32, ptr %offset_tbl.i8.i1636, i64 %hash.i.i12.i1640
  %offset.i14.i1642 = load i32, ptr %offset_ptr.i13.i1641, align 4
  %417 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %408, 0
  %418 = insertvalue { ptr, ptr, ptr, i32 } %417, ptr %415, 1
  %419 = insertvalue { ptr, ptr, ptr, i32 } %418, ptr %416, 2
  %420 = insertvalue { ptr, ptr, ptr, i32 } %419, i32 %offset.i14.i1642, 3
  %421 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %408)
  %423 = sext i32 %offset.i14.i1642 to i64
  %424 = getelementptr ptr, ptr %408, i64 %423
  %425 = getelementptr i8, ptr %424, i64 40
  %426 = load ptr, ptr %425, align 8
  %result.i1.i1643 = call ptr %426({ ptr, ptr, ptr, i32 } %420, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %427 = call i32 %result.i1.i1643({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull align 8 %2)
  %428 = icmp eq i32 %427, %392
  br i1 %428, label %._crit_edge2.i1644, label %436

._crit_edge2.i1644:                               ; preds = %411
  %429 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %430 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %408)
  %431 = getelementptr i8, ptr %424, i64 48
  %432 = load ptr, ptr %431, align 8
  %result.i.i1645 = call ptr %432({ ptr, ptr, ptr, i32 } %420, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %433 = call { ptr, i160 } %result.i.i1645({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull align 8 %2)
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %435 = call i1 %368({ ptr, i160 } %433, { ptr, i160 } %396)
  br i1 %435, label %SwissTable_find_slot_keyK_hashi32.exit1647, label %436

436:                                              ; preds = %._crit_edge2.i1644, %411, %404, %._crit_edge.i1627, %._crit_edge.thread.i1620
  %.11655 = phi i32 [ %.01654, %._crit_edge2.i1644 ], [ %.01654, %411 ], [ %.01654, %404 ], [ %.01654, %._crit_edge.i1627 ], [ %spec.store.select.i1621, %._crit_edge.thread.i1620 ]
  %spec.store.select9216.i1622 = phi i32 [ %.0..0..0..0..0..0.84.i1618, %._crit_edge2.i1644 ], [ %.0..0..0..0..0..0.84.i1618, %411 ], [ %.0..0..0..0..0..0.84.i1618, %404 ], [ %.0..0..0..0..0..0.84.i1618, %._crit_edge.i1627 ], [ %spec.store.select.i1621, %._crit_edge.thread.i1620 ]
  %437 = add nuw nsw i32 %.01656, 1
  br label %398

438:                                              ; preds = %398
  %.not.i1623 = icmp eq i32 %.0..0..0..0..0..0.84.i1618, -1
  %.pre.i1626 = select i1 %.not.i1623, i32 %.01656, i32 %.01654
  %.pre1731 = sext i32 %.pre.i1626 to i64
  %.pre1733 = shl nsw i64 %.pre1731, 5
  br label %SwissTable_find_slot_keyK_hashi32.exit1647

SwissTable_find_slot_keyK_hashi32.exit1647:       ; preds = %438, %._crit_edge2.i1644
  %.pre-phi1734 = phi i64 [ %.pre1733, %438 ], [ %406, %._crit_edge2.i1644 ]
  %.pre-phi1732 = phi i64 [ %.pre1731, %438 ], [ %399, %._crit_edge2.i1644 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %439 = getelementptr i8, ptr %result.i10.i1315, i64 %.pre-phi1734
  store ptr %372, ptr %439, align 8
  %440 = getelementptr i8, ptr %439, i64 8
  store i64 %.sroa.0146.0.extract.trunc.i1328, ptr %440, align 4
  %.sroa_idx120.i1348 = getelementptr i8, ptr %439, i64 16
  store i64 %.sroa.3.0.extract.trunc.i1327, ptr %.sroa_idx120.i1348, align 4
  %.sroa_idx121.i1349 = getelementptr i8, ptr %439, i64 24
  store i32 %offset.i34.i1340, ptr %.sroa_idx121.i1349, align 4
  %441 = getelementptr i8, ptr %result.i9.i1316, i64 %.pre-phi1732
  store i8 1, ptr %441, align 1
  %442 = add i32 %369, 1
  %443 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %._crit_edge2.backedge.i1324

._crit_edge2.backedge.i1324:                      ; preds = %SwissTable_find_slot_keyK_hashi32.exit1647, %.lr.ph.i1318
  %444 = phi i32 [ %442, %SwissTable_find_slot_keyK_hashi32.exit1647 ], [ %369, %.lr.ph.i1318 ]
  %_parameterization_i321515 = phi ptr [ @_parameterization_i32, %SwissTable_find_slot_keyK_hashi32.exit1647 ], [ %_parameterization_i321514, %.lr.ph.i1318 ]
  %445 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %446 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %447 = icmp sgt i32 %storemerge.i1319, %359
  %448 = add i32 %storemerge.i1319, 1
  br i1 %447, label %SwissTable_resize_new_capacityi32.exit1353.loopexit, label %.lr.ph.i1318

SwissTable_resize_new_capacityi32.exit1353.loopexit: ; preds = %._crit_edge2.backedge.i1324
  store i32 %444, ptr %38, align 4
  store ptr %_parameterization_i321515, ptr %44, align 8
  br label %SwissTable_resize_new_capacityi32.exit1353

SwissTable_resize_new_capacityi32.exit1353:       ; preds = %SwissTable_resize_new_capacityi32.exit1353.loopexit, %._crit_edge1.i863
  %449 = phi i32 [ %444, %SwissTable_resize_new_capacityi32.exit1353.loopexit ], [ 0, %._crit_edge1.i863 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  br label %SwissTable_ensure_capacity_required_sizei32.exit867

SwissTable_ensure_capacity_required_sizei32.exit867: ; preds = %SwissTable_resize_new_capacityi32.exit1353, %.SwissTable_ensure_capacity_required_sizei32.exit867_crit_edge
  %450 = phi i32 [ %350, %.SwissTable_ensure_capacity_required_sizei32.exit867_crit_edge ], [ %449, %SwissTable_resize_new_capacityi32.exit1353 ]
  %451 = phi ptr [ %.pre1866, %.SwissTable_ensure_capacity_required_sizei32.exit867_crit_edge ], [ %result.i10.i1315, %SwissTable_resize_new_capacityi32.exit1353 ]
  %452 = phi ptr [ %.pre1865, %.SwissTable_ensure_capacity_required_sizei32.exit867_crit_edge ], [ %result.i9.i1316, %SwissTable_resize_new_capacityi32.exit1353 ]
  %453 = phi i32 [ %347, %.SwissTable_ensure_capacity_required_sizei32.exit867_crit_edge ], [ %spec.select.i864, %SwissTable_resize_new_capacityi32.exit1353 ]
  %454 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %455 = load ptr, ptr %33, align 8
  %456 = call i32 %455({ ptr, i160 } %62)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %457 = add i32 %453, -1
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %459 = load ptr, ptr %34, align 8
  br label %460

460:                                              ; preds = %498, %SwissTable_ensure_capacity_required_sizei32.exit867
  %.01018 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit867 ], [ %.11019, %498 ]
  %.pn1966 = phi i32 [ %456, %SwissTable_ensure_capacity_required_sizei32.exit867 ], [ %499, %498 ]
  %.0..0..0..0..0..0.84.i883 = phi i32 [ -1, %SwissTable_ensure_capacity_required_sizei32.exit867 ], [ %spec.store.select9216.i887, %498 ]
  %.01017 = and i32 %.pn1966, %457
  %461 = sext i32 %.01017 to i64
  %462 = getelementptr i8, ptr %452, i64 %461
  %463 = load i8, ptr %462, align 1
  switch i8 %463, label %._crit_edge.i892 [
    i8 0, label %500
    i8 -128, label %._crit_edge.thread.i885
  ]

._crit_edge.thread.i885:                          ; preds = %460
  %464 = icmp eq i32 %.0..0..0..0..0..0.84.i883, -1
  %spec.store.select.i886 = select i1 %464, i32 %.01017, i32 %.0..0..0..0..0..0.84.i883
  br label %498

._crit_edge.i892:                                 ; preds = %460
  %465 = icmp sgt i8 %463, 0
  br i1 %465, label %466, label %498

466:                                              ; preds = %._crit_edge.i892
  %467 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %468 = shl nsw i64 %461, 5
  %469 = getelementptr i8, ptr %451, i64 %468
  %470 = load ptr, ptr %469, align 8
  %471 = icmp ne ptr %470, @nil_typ
  %472 = icmp ne ptr %470, null
  %.not82.i894 = and i1 %471, %472
  br i1 %.not82.i894, label %473, label %498

473:                                              ; preds = %466
  %474 = getelementptr i8, ptr %469, i64 8
  %475 = load i64, ptr %474, align 4
  %.sroa_idx.i895 = getelementptr i8, ptr %469, i64 16
  %476 = load i64, ptr %.sroa_idx.i895, align 4
  %477 = inttoptr i64 %475 to ptr
  %478 = inttoptr i64 %476 to ptr
  %hash_coef_ptr.i3.i896 = getelementptr i8, ptr %470, i64 8
  %tbl_size_ptr.i4.i897 = getelementptr i8, ptr %470, i64 16
  %offset_tbl_ptr.i5.i898 = getelementptr i8, ptr %470, i64 40
  %hash_coef.i6.i899 = load i64, ptr %hash_coef_ptr.i3.i896, align 4
  %tbl_size.i7.i900 = load i64, ptr %tbl_size_ptr.i4.i897, align 4
  %offset_tbl.i8.i901 = load ptr, ptr %offset_tbl_ptr.i5.i898, align 8
  %product.i.i9.i902 = mul i64 %hash_coef.i6.i899, 4015701072841558310
  %shifted.i.i10.i903 = lshr i64 %product.i.i9.i902, 32
  %xored.i.i11.i904 = xor i64 %shifted.i.i10.i903, %product.i.i9.i902
  %hash.i.i12.i905 = and i64 %xored.i.i11.i904, %tbl_size.i7.i900
  %offset_ptr.i13.i906 = getelementptr i32, ptr %offset_tbl.i8.i901, i64 %hash.i.i12.i905
  %offset.i14.i907 = load i32, ptr %offset_ptr.i13.i906, align 4
  %479 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %470, 0
  %480 = insertvalue { ptr, ptr, ptr, i32 } %479, ptr %477, 1
  %481 = insertvalue { ptr, ptr, ptr, i32 } %480, ptr %478, 2
  %482 = insertvalue { ptr, ptr, ptr, i32 } %481, i32 %offset.i14.i907, 3
  %483 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %484 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %470)
  %485 = sext i32 %offset.i14.i907 to i64
  %486 = getelementptr ptr, ptr %470, i64 %485
  %487 = getelementptr i8, ptr %486, i64 40
  %488 = load ptr, ptr %487, align 8
  %result.i1.i908 = call ptr %488({ ptr, ptr, ptr, i32 } %482, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %489 = call i32 %result.i1.i908({ ptr, ptr, ptr, i32 } %482, { ptr, ptr, ptr, i32 } %482, ptr nonnull align 8 %2)
  %490 = icmp eq i32 %489, %456
  br i1 %490, label %._crit_edge2.i909, label %498

._crit_edge2.i909:                                ; preds = %473
  %491 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %492 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %470)
  %493 = getelementptr i8, ptr %486, i64 48
  %494 = load ptr, ptr %493, align 8
  %result.i.i910 = call ptr %494({ ptr, ptr, ptr, i32 } %482, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %495 = call { ptr, i160 } %result.i.i910({ ptr, ptr, ptr, i32 } %482, { ptr, ptr, ptr, i32 } %482, ptr nonnull align 8 %2)
  %496 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %497 = call i1 %459({ ptr, i160 } %495, { ptr, i160 } %62)
  br i1 %497, label %SwissTable_find_slot_keyK_hashi32.exit912, label %498

498:                                              ; preds = %._crit_edge2.i909, %473, %466, %._crit_edge.i892, %._crit_edge.thread.i885
  %.11019 = phi i32 [ %.01018, %._crit_edge2.i909 ], [ %.01018, %473 ], [ %.01018, %466 ], [ %.01018, %._crit_edge.i892 ], [ %spec.store.select.i886, %._crit_edge.thread.i885 ]
  %spec.store.select9216.i887 = phi i32 [ %.0..0..0..0..0..0.84.i883, %._crit_edge2.i909 ], [ %.0..0..0..0..0..0.84.i883, %473 ], [ %.0..0..0..0..0..0.84.i883, %466 ], [ %.0..0..0..0..0..0.84.i883, %._crit_edge.i892 ], [ %spec.store.select.i886, %._crit_edge.thread.i885 ]
  %499 = add nuw i32 %.01017, 1
  br label %460

500:                                              ; preds = %460
  %.not.i888 = icmp eq i32 %.0..0..0..0..0..0.84.i883, -1
  %.pre.i891 = select i1 %.not.i888, i32 %.01017, i32 %.01018
  %.pre1061 = sext i32 %.pre.i891 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit912

SwissTable_find_slot_keyK_hashi32.exit912:        ; preds = %500, %._crit_edge2.i909
  %.pre-phi1062 = phi i64 [ %.pre1061, %500 ], [ %461, %._crit_edge2.i909 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %502 = getelementptr i8, ptr %452, i64 %.pre-phi1062
  %503 = load i8, ptr %502, align 1
  %504 = load ptr, ptr %result.i71.h2s2322, align 8
  %505 = load ptr, ptr %28, align 8
  %506 = load ptr, ptr %504, align 8, !alias.scope !15
  %507 = getelementptr i8, ptr %506, i64 72
  %508 = load ptr, ptr %507, align 8, !alias.scope !15
  %result.i1.i.i387 = call { i64, i64 } %508(ptr nocapture nofree nonnull readonly align 8 %504) #47, !alias.scope !15
  %509 = extractvalue { i64, i64 } %result.i1.i.i387, 0
  %510 = extractvalue { i64, i64 } %result.i1.i.i387, 1
  %511 = urem i64 20, %510
  %512 = icmp eq i64 %511, 0
  %513 = sub i64 %510, %511
  %514 = select i1 %512, i64 0, i64 %513
  %515 = add i64 %509, 20
  %516 = add i64 %515, %514
  %517 = load ptr, ptr %505, align 8, !alias.scope !15
  %518 = getelementptr i8, ptr %517, i64 72
  %519 = load ptr, ptr %518, align 8, !alias.scope !15
  %result.i.i.i388 = call { i64, i64 } %519(ptr nocapture nofree nonnull readonly align 8 %505) #47, !alias.scope !15
  %520 = extractvalue { i64, i64 } %result.i.i.i388, 0
  %521 = extractvalue { i64, i64 } %result.i.i.i388, 1
  %522 = call i64 @llvm.umax.i64(i64 %510, i64 %521) #61
  %523 = call i64 @llvm.umax.i64(i64 %522, i64 noundef 8) #61, !range !5
  %524 = urem i64 %516, %521
  %525 = icmp eq i64 %524, 0
  %526 = sub i64 %521, %524
  %527 = select i1 %525, i64 0, i64 %526
  %528 = add i64 %520, %516
  %529 = add i64 %528, %527
  %530 = urem i64 %529, %523
  %531 = icmp eq i64 %530, 0
  %532 = sub i64 %523, %530
  %533 = select i1 %531, i64 0, i64 %532
  %534 = add i64 %533, %529
  %result.i9.i389 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %534) #51
  store ptr %504, ptr %result.i9.i389, align 8
  %535 = getelementptr inbounds i8, ptr %result.i9.i389, i64 8
  store ptr %505, ptr %535, align 8
  %536 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i389)
  %537 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %538 = load ptr, ptr %504, align 8
  %539 = getelementptr i8, ptr %538, i64 72
  %540 = load ptr, ptr %539, align 8
  %result.i.i10.i390 = call { i64, i64 } %540(ptr nocapture nofree nonnull readonly align 8 %504) #47
  %541 = extractvalue { i64, i64 } %result.i.i10.i390, 1
  %542 = urem i64 20, %541
  %543 = icmp eq i64 %542, 0
  %reass.sub = sub i64 %541, %542
  %544 = add i64 %reass.sub, 20
  %545 = select i1 %543, i64 20, i64 %544
  %546 = getelementptr i8, ptr %result.i9.i389, i64 %545
  %547 = getelementptr i8, ptr %538, i64 64
  %548 = load ptr, ptr %547, align 8
  call void %548({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %504, ptr nocapture nofree writeonly %546) #48
  %549 = load ptr, ptr %result.i9.i389, align 8
  %550 = load ptr, ptr %549, align 8
  %551 = getelementptr i8, ptr %550, i64 72
  %552 = load ptr, ptr %551, align 8
  %result.i1.i11.i392 = call { i64, i64 } %552(ptr nocapture nofree nonnull readonly align 8 %549) #47
  %553 = extractvalue { i64, i64 } %result.i1.i11.i392, 0
  %554 = extractvalue { i64, i64 } %result.i1.i11.i392, 1
  %555 = urem i64 20, %554
  %556 = icmp eq i64 %555, 0
  %557 = sub i64 %554, %555
  %558 = select i1 %556, i64 0, i64 %557
  %559 = add i64 %553, 20
  %560 = add i64 %559, %558
  %561 = load ptr, ptr %535, align 8
  %562 = load ptr, ptr %561, align 8
  %563 = getelementptr i8, ptr %562, i64 72
  %564 = load ptr, ptr %563, align 8
  %result.i.i12.i393 = call { i64, i64 } %564(ptr nocapture nofree nonnull readonly align 8 %561) #47
  %565 = extractvalue { i64, i64 } %result.i.i12.i393, 1
  %566 = urem i64 %560, %565
  %567 = icmp eq i64 %566, 0
  %568 = sub i64 %565, %566
  %569 = select i1 %567, i64 0, i64 %568
  %570 = getelementptr i8, ptr %result.i9.i389, i64 %560
  %571 = getelementptr i8, ptr %570, i64 %569
  %572 = getelementptr i8, ptr %562, i64 64
  %573 = load ptr, ptr %572, align 8
  call void %573({ ptr, i160 } %346, ptr nocapture nofree nonnull readonly align 8 %561, ptr nocapture nofree writeonly %571) #48
  %574 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %575 = getelementptr inbounds i8, ptr %result.i9.i389, i64 16
  store i32 %456, ptr %575, align 8
  %576 = icmp eq i8 %503, 0
  br i1 %576, label %577, label %SwissTable_insert_keyK_valueV.exit397

577:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit912
  store i8 1, ptr %502, align 1
  %578 = add i32 %450, 1
  store i32 %578, ptr %38, align 4
  br label %SwissTable_insert_keyK_valueV.exit397

SwissTable_insert_keyK_valueV.exit397:            ; preds = %577, %SwissTable_find_slot_keyK_hashi32.exit912
  %579 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %580 = shl nsw i64 %.pre-phi1062, 5
  %581 = getelementptr i8, ptr %451, i64 %580
  store ptr @Entry, ptr %581, align 8
  %582 = getelementptr i8, ptr %581, i64 8
  %583 = ptrtoint ptr %result.i9.i389 to i64
  store i64 %583, ptr %582, align 4
  %.sroa_idx3.i395 = getelementptr i8, ptr %581, i64 24
  store i32 10, ptr %.sroa_idx3.i395, align 4
  %584 = add nsw i32 %.0550219, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %SwissTable_insert_keyK_valueV.exit397, %SwissTable_get_keyK.exit
  %585 = phi ptr [ %335, %SwissTable_insert_keyK_valueV.exit397 ], [ %46, %SwissTable_get_keyK.exit ]
  %586 = phi ptr [ %252, %SwissTable_insert_keyK_valueV.exit397 ], [ %47, %SwissTable_get_keyK.exit ]
  %.pre12631861 = phi ptr [ %.pre12631862, %SwissTable_insert_keyK_valueV.exit397 ], [ %.pre12631860, %SwissTable_get_keyK.exit ]
  %587 = phi ptr [ %336, %SwissTable_insert_keyK_valueV.exit397 ], [ %48, %SwissTable_get_keyK.exit ]
  %588 = phi i32 [ %255, %SwissTable_insert_keyK_valueV.exit397 ], [ %49, %SwissTable_get_keyK.exit ]
  %589 = phi ptr [ %335, %SwissTable_insert_keyK_valueV.exit397 ], [ %50, %SwissTable_get_keyK.exit ]
  %590 = phi i32 [ %337, %SwissTable_insert_keyK_valueV.exit397 ], [ %51, %SwissTable_get_keyK.exit ]
  %591 = phi i32 [ %255, %SwissTable_insert_keyK_valueV.exit397 ], [ %52, %SwissTable_get_keyK.exit ]
  %592 = phi ptr [ %451, %SwissTable_insert_keyK_valueV.exit397 ], [ %53, %SwissTable_get_keyK.exit ]
  %.pre12621859 = phi ptr [ %452, %SwissTable_insert_keyK_valueV.exit397 ], [ %.pre1262, %SwissTable_get_keyK.exit ]
  %593 = phi ptr [ %459, %SwissTable_insert_keyK_valueV.exit397 ], [ %54, %SwissTable_get_keyK.exit ]
  %594 = phi ptr [ %452, %SwissTable_insert_keyK_valueV.exit397 ], [ %108, %SwissTable_get_keyK.exit ]
  %595 = phi i32 [ %453, %SwissTable_insert_keyK_valueV.exit397 ], [ %56, %SwissTable_get_keyK.exit ]
  %596 = phi ptr [ %455, %SwissTable_insert_keyK_valueV.exit397 ], [ %57, %SwissTable_get_keyK.exit ]
  %.1551 = phi i32 [ %584, %SwissTable_insert_keyK_valueV.exit397 ], [ %.0550219, %SwissTable_get_keyK.exit ]
  %597 = add nuw nsw i32 %.0549220, 1
  %598 = icmp slt i32 %.1551, %0
  %599 = icmp slt i32 %597, %39
  %spec.select = select i1 %598, i1 %599, i1 false
  br i1 %spec.select, label %45, label %._crit_edge3._crit_edge.loopexit

._crit_edge3._crit_edge.loopexit:                 ; preds = %._crit_edge1
  %600 = add i32 %588, -1
  br label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge3._crit_edge.loopexit, %1
  %601 = phi ptr [ %result.i.i262, %1 ], [ %586, %._crit_edge3._crit_edge.loopexit ]
  %602 = phi i32 [ 7, %1 ], [ %600, %._crit_edge3._crit_edge.loopexit ]
  %.promoted1822 = phi i32 [ 0, %1 ], [ %590, %._crit_edge3._crit_edge.loopexit ]
  %.0550.lcssa = phi i32 [ 0, %1 ], [ %.1551, %._crit_edge3._crit_edge.loopexit ]
  %.sroa.gep582 = getelementptr inbounds i8, ptr %7, i64 8
  %.sroa.gep585 = getelementptr inbounds i8, ptr %7, i64 16
  %.sroa.gep588 = getelementptr inbounds i8, ptr %7, i64 24
  %.sroa.gep591 = getelementptr inbounds i8, ptr %6, i64 8
  %.sroa.gep594 = getelementptr inbounds i8, ptr %6, i64 16
  %.sroa.gep597 = getelementptr inbounds i8, ptr %6, i64 24
  %603 = icmp slt i32 %.0550.lcssa, %0
  br i1 %603, label %RangeIterator_next_.exit52.i.preheader, label %._crit_edge4

RangeIterator_next_.exit52.i.preheader:           ; preds = %._crit_edge3._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %605 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 87, ptr %result.i5.i.h2s2320, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s2320, i64 1
  store <28 x i8> <i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %scevgep, align 1
  %606 = getelementptr inbounds i8, ptr %result.i5.i.h2s2320, i64 29
  store i8 0, ptr %606, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i.h2s2320) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %607 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0550.lcssa) #59
  %608 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %609 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %610 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 32, ptr %result.i5.i1100.h2s2318, align 1
  %scevgep1421 = getelementptr inbounds i8, ptr %result.i5.i1100.h2s2318, i64 1
  store <28 x i8> <i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %scevgep1421, align 1
  %612 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %613 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %614 = getelementptr inbounds i8, ptr %result.i5.i1100.h2s2318, i64 29
  store i8 0, ptr %614, align 1
  %puts.i649 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i5.i1100.h2s2318) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %RangeIterator_next_.exit52.i.preheader, %._crit_edge3._crit_edge
  %.0569 = phi i32 [ %.0550.lcssa, %RangeIterator_next_.exit52.i.preheader ], [ %0, %._crit_edge3._crit_edge ]
  %615 = call i64 @clock()
  %616 = icmp sgt i32 %.0569, 0
  br i1 %616, label %.lr.ph247.preheader, label %._crit_edge10

.lr.ph247.preheader:                              ; preds = %._crit_edge4
  %617 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %618 = zext nneg i32 %.0569 to i64
  %619 = load ptr, ptr %4, align 8
  br label %.lr.ph247

.lr.ph247:                                        ; preds = %._crit_edge5, %.lr.ph247.preheader
  %620 = phi i32 [ %.promoted1822, %.lr.ph247.preheader ], [ %748, %._crit_edge5 ]
  %indvars.iv = phi i64 [ 0, %.lr.ph247.preheader ], [ %indvars.iv.next, %._crit_edge5 ]
  %.0552246 = phi i32 [ 0, %.lr.ph247.preheader ], [ %.1553, %._crit_edge5 ]
  %.0555245 = phi i1 [ true, %.lr.ph247.preheader ], [ %.2557, %._crit_edge5 ]
  %.0558244 = phi i32 [ 0, %.lr.ph247.preheader ], [ %.3561, %._crit_edge5 ]
  %621 = shl i64 %indvars.iv, 2
  %622 = getelementptr i8, ptr %result.i2.i290, i64 %621
  %623 = load i32, ptr %622, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %624 = add i32 %623, 2127912214
  %625 = shl i32 %623, 12
  %626 = add i32 %624, %625
  %627 = ashr i32 %626, 19
  %628 = xor i32 %626, %627
  %629 = xor i32 %628, -949894596
  %630 = add i32 %629, 374761393
  %631 = shl i32 %629, 5
  %632 = add i32 %630, %631
  %633 = add i32 %632, -744332180
  %634 = shl i32 %632, 9
  %635 = xor i32 %633, %634
  %636 = add i32 %635, -42973499
  %637 = shl i32 %635, 3
  %638 = add i32 %636, %637
  %639 = ashr i32 %638, 16
  %640 = xor i32 %638, %639
  %641 = xor i32 %640, -1252372727
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %642 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  br label %643

643:                                              ; preds = %681, %.lr.ph247
  %.01015 = phi i32 [ -1, %.lr.ph247 ], [ %.11016, %681 ]
  %.pn1968 = phi i32 [ %641, %.lr.ph247 ], [ %682, %681 ]
  %.0..0..0..0..0..0.84.i927 = phi i32 [ -1, %.lr.ph247 ], [ %spec.store.select9216.i931, %681 ]
  %.01014 = and i32 %.pn1968, %602
  %644 = sext i32 %.01014 to i64
  %645 = getelementptr i8, ptr %601, i64 %644
  %646 = load i8, ptr %645, align 1
  switch i8 %646, label %._crit_edge.i936 [
    i8 0, label %683
    i8 -128, label %._crit_edge.thread.i929
  ]

._crit_edge.thread.i929:                          ; preds = %643
  %647 = icmp eq i32 %.0..0..0..0..0..0.84.i927, -1
  %spec.store.select.i930 = select i1 %647, i32 %.01014, i32 %.0..0..0..0..0..0.84.i927
  br label %681

._crit_edge.i936:                                 ; preds = %643
  %648 = icmp sgt i8 %646, 0
  br i1 %648, label %649, label %681

649:                                              ; preds = %._crit_edge.i936
  %650 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %651 = shl nsw i64 %644, 5
  %652 = getelementptr i8, ptr %619, i64 %651
  %653 = load ptr, ptr %652, align 8
  %654 = icmp ne ptr %653, @nil_typ
  %655 = icmp ne ptr %653, null
  %.not82.i938 = and i1 %654, %655
  br i1 %.not82.i938, label %656, label %681

656:                                              ; preds = %649
  %657 = getelementptr i8, ptr %652, i64 8
  %658 = load i64, ptr %657, align 4
  %.sroa_idx.i939 = getelementptr i8, ptr %652, i64 16
  %659 = load i64, ptr %.sroa_idx.i939, align 4
  %660 = inttoptr i64 %658 to ptr
  %661 = inttoptr i64 %659 to ptr
  %hash_coef_ptr.i3.i940 = getelementptr i8, ptr %653, i64 8
  %tbl_size_ptr.i4.i941 = getelementptr i8, ptr %653, i64 16
  %offset_tbl_ptr.i5.i942 = getelementptr i8, ptr %653, i64 40
  %hash_coef.i6.i943 = load i64, ptr %hash_coef_ptr.i3.i940, align 4
  %tbl_size.i7.i944 = load i64, ptr %tbl_size_ptr.i4.i941, align 4
  %offset_tbl.i8.i945 = load ptr, ptr %offset_tbl_ptr.i5.i942, align 8
  %product.i.i9.i946 = mul i64 %hash_coef.i6.i943, 4015701072841558310
  %shifted.i.i10.i947 = lshr i64 %product.i.i9.i946, 32
  %xored.i.i11.i948 = xor i64 %shifted.i.i10.i947, %product.i.i9.i946
  %hash.i.i12.i949 = and i64 %xored.i.i11.i948, %tbl_size.i7.i944
  %offset_ptr.i13.i950 = getelementptr i32, ptr %offset_tbl.i8.i945, i64 %hash.i.i12.i949
  %offset.i14.i951 = load i32, ptr %offset_ptr.i13.i950, align 4
  %662 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %653, 0
  %663 = insertvalue { ptr, ptr, ptr, i32 } %662, ptr %660, 1
  %664 = insertvalue { ptr, ptr, ptr, i32 } %663, ptr %661, 2
  %665 = insertvalue { ptr, ptr, ptr, i32 } %664, i32 %offset.i14.i951, 3
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %667 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %653)
  %668 = sext i32 %offset.i14.i951 to i64
  %669 = getelementptr ptr, ptr %653, i64 %668
  %670 = getelementptr i8, ptr %669, i64 40
  %671 = load ptr, ptr %670, align 8
  %result.i1.i952 = call ptr %671({ ptr, ptr, ptr, i32 } %665, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %672 = call i32 %result.i1.i952({ ptr, ptr, ptr, i32 } %665, { ptr, ptr, ptr, i32 } %665, ptr nonnull align 8 %2)
  %673 = icmp eq i32 %672, %641
  br i1 %673, label %._crit_edge2.i953, label %681

._crit_edge2.i953:                                ; preds = %656
  %674 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %675 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %653)
  %676 = getelementptr i8, ptr %669, i64 48
  %677 = load ptr, ptr %676, align 8
  %result.i.i954 = call ptr %677({ ptr, ptr, ptr, i32 } %665, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %678 = call { ptr, i160 } %result.i.i954({ ptr, ptr, ptr, i32 } %665, { ptr, ptr, ptr, i32 } %665, ptr nonnull align 8 %2)
  %679 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %.fca.1.extract3.i1920 = extractvalue { ptr, i160 } %678, 1
  %.sroa.15.8.extract.trunc.i1921 = trunc i160 %.fca.1.extract3.i1920 to i32
  %680 = icmp eq i32 %623, %.sroa.15.8.extract.trunc.i1921
  br i1 %680, label %SwissTable_find_slot_keyK_hashi32.exit956, label %681

681:                                              ; preds = %._crit_edge2.i953, %656, %649, %._crit_edge.i936, %._crit_edge.thread.i929
  %.11016 = phi i32 [ %.01015, %._crit_edge2.i953 ], [ %.01015, %656 ], [ %.01015, %649 ], [ %.01015, %._crit_edge.i936 ], [ %spec.store.select.i930, %._crit_edge.thread.i929 ]
  %spec.store.select9216.i931 = phi i32 [ %.0..0..0..0..0..0.84.i927, %._crit_edge2.i953 ], [ %.0..0..0..0..0..0.84.i927, %656 ], [ %.0..0..0..0..0..0.84.i927, %649 ], [ %.0..0..0..0..0..0.84.i927, %._crit_edge.i936 ], [ %spec.store.select.i930, %._crit_edge.thread.i929 ]
  %682 = add i32 %.01014, 1
  br label %643

683:                                              ; preds = %643
  %.not.i932 = icmp eq i32 %.0..0..0..0..0..0.84.i927, -1
  %.pre.i935 = select i1 %.not.i932, i32 %.01014, i32 %.01015
  %.pre1063 = sext i32 %.pre.i935 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit956

SwissTable_find_slot_keyK_hashi32.exit956:        ; preds = %683, %._crit_edge2.i953
  %.pre-phi1064 = phi i64 [ %.pre1063, %683 ], [ %644, %._crit_edge2.i953 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %684 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %685 = getelementptr i8, ptr %601, i64 %.pre-phi1064
  %686 = load i8, ptr %685, align 1
  switch i8 %686, label %687 [
    i8 -128, label %SwissTable_remove_keyK.exit.thread
    i8 0, label %SwissTable_remove_keyK.exit.thread
  ]

687:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit956
  %688 = shl nsw i64 %.pre-phi1064, 5
  %689 = getelementptr i8, ptr %619, i64 %688
  %690 = load ptr, ptr %689, align 8
  %691 = icmp eq ptr %690, @nil_typ
  %692 = icmp eq ptr %690, null
  %.not115.not.i = or i1 %691, %692
  br i1 %.not115.not.i, label %SwissTable_remove_keyK.exit.thread, label %693

693:                                              ; preds = %687
  %694 = getelementptr i8, ptr %689, i64 8
  %695 = load i160, ptr %694, align 4
  %.sroa.2103.0.extract.shift.i = lshr i160 %695, 64
  %.sroa.2103.0.extract.trunc.i = trunc i160 %.sroa.2103.0.extract.shift.i to i64
  %.sroa.0102.0.extract.trunc.i = trunc i160 %695 to i64
  %696 = inttoptr i64 %.sroa.0102.0.extract.trunc.i to ptr
  %697 = inttoptr i64 %.sroa.2103.0.extract.trunc.i to ptr
  %hash_coef_ptr.i5.i = getelementptr i8, ptr %690, i64 8
  %tbl_size_ptr.i6.i = getelementptr i8, ptr %690, i64 16
  %offset_tbl_ptr.i7.i = getelementptr i8, ptr %690, i64 40
  %hash_coef.i8.i = load i64, ptr %hash_coef_ptr.i5.i, align 4
  %tbl_size.i9.i = load i64, ptr %tbl_size_ptr.i6.i, align 4
  %offset_tbl.i10.i = load ptr, ptr %offset_tbl_ptr.i7.i, align 8
  %product.i.i11.i = mul i64 %hash_coef.i8.i, 4015701072841558310
  %shifted.i.i12.i = lshr i64 %product.i.i11.i, 32
  %xored.i.i13.i = xor i64 %shifted.i.i12.i, %product.i.i11.i
  %hash.i.i14.i = and i64 %xored.i.i13.i, %tbl_size.i9.i
  %offset_ptr.i15.i = getelementptr i32, ptr %offset_tbl.i10.i, i64 %hash.i.i14.i
  %offset.i16.i = load i32, ptr %offset_ptr.i15.i, align 4
  %698 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %690, 0
  %699 = insertvalue { ptr, ptr, ptr, i32 } %698, ptr %696, 1
  %700 = insertvalue { ptr, ptr, ptr, i32 } %699, ptr %697, 2
  %701 = insertvalue { ptr, ptr, ptr, i32 } %700, i32 %offset.i16.i, 3
  %702 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %690)
  %704 = sext i32 %offset.i16.i to i64
  %705 = getelementptr ptr, ptr %690, i64 %704
  %706 = getelementptr i8, ptr %705, i64 56
  %707 = load ptr, ptr %706, align 8
  %result.i2.i449 = call ptr %707({ ptr, ptr, ptr, i32 } %701, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %708 = call { ptr, i160 } %result.i2.i449({ ptr, ptr, ptr, i32 } %701, { ptr, ptr, ptr, i32 } %701, ptr nonnull align 8 %2)
  %.fca.0.extract86.i = extractvalue { ptr, i160 } %708, 0
  %.fca.1.extract87.i = extractvalue { ptr, i160 } %708, 1
  %709 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %710 = getelementptr i8, ptr %.fca.0.extract86.i, i64 8
  %711 = getelementptr i8, ptr %.fca.0.extract86.i, i64 16
  %712 = getelementptr i8, ptr %.fca.0.extract86.i, i64 24
  %713 = getelementptr i8, ptr %.fca.0.extract86.i, i64 32
  %714 = load i64, ptr %710, align 4
  %715 = load i64, ptr %711, align 4
  %716 = load ptr, ptr %712, align 8
  %717 = load ptr, ptr %713, align 8
  %result.i4.i = call i1 %716(i64 %715, i64 %714, i64 -2253724949814257982, i64 ptrtoint (ptr @i32_typ to i64), ptr readonly %717) #47
  br i1 %result.i4.i, label %SwissTable_remove_keyK.exit, label %SwissTable_remove_keyK.exit.thread

SwissTable_remove_keyK.exit.thread:               ; preds = %693, %687, %SwissTable_find_slot_keyK_hashi32.exit956, %SwissTable_find_slot_keyK_hashi32.exit956
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %735

SwissTable_remove_keyK.exit:                      ; preds = %693
  store i8 -128, ptr %685, align 1
  store ptr @nil_typ, ptr %689, align 8
  %718 = add i32 %620, -1
  %719 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  store i32 %718, ptr %23, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.not626 = icmp eq ptr %.fca.0.extract86.i, @nil_typ
  br i1 %.not626, label %735, label %720

720:                                              ; preds = %SwissTable_remove_keyK.exit
  %.sroa.2438.8.extract.trunc = trunc i160 %.fca.1.extract87.i to i32
  %721 = add i32 %623, 1
  %.not = icmp eq i32 %721, %.sroa.2438.8.extract.trunc
  br i1 %.not, label %._crit_edge6, label %722

722:                                              ; preds = %720
  %723 = icmp slt i32 %.0558244, 10
  br i1 %723, label %RangeIterator_next_.exit52.i1122.preheader, label %._crit_edge6

RangeIterator_next_.exit52.i1122.preheader:       ; preds = %722
  %result.i64.h2s2324 = alloca [46 x i8], align 1
  %724 = getelementptr inbounds i8, ptr %result.i64.h2s2324, i64 45
  store i8 0, ptr %724, align 1
  store <45 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 119, i8 114, i8 111, i8 110, i8 103, i8 32, i8 118, i8 97, i8 108, i8 117, i8 101, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i64.h2s2324, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %725 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %726 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i1119.h2s2325 = alloca [46 x i8], align 1
  %727 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 87, ptr %result.i5.i1119.h2s2325, align 1
  %scevgep1426 = getelementptr inbounds i8, ptr %result.i5.i1119.h2s2325, i64 1
  %scevgep1427 = getelementptr inbounds i8, ptr %result.i64.h2s2324, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(45) %scevgep1426, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(45) %scevgep1427, i64 noundef 44, i1 noundef false)
  %728 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %730 = getelementptr inbounds i8, ptr %result.i5.i1119.h2s2325, i64 45
  store i8 0, ptr %730, align 1
  %puts.i668 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(46) %result.i5.i1119.h2s2325) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %731 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %732 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %623) #59
  %733 = add nsw i32 %.0558244, 1
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %RangeIterator_next_.exit52.i1122.preheader, %722, %720
  %.1559 = phi i32 [ %733, %RangeIterator_next_.exit52.i1122.preheader ], [ %.0558244, %722 ], [ %.0558244, %720 ]
  %.1556 = phi i1 [ false, %RangeIterator_next_.exit52.i1122.preheader ], [ false, %722 ], [ %.0555245, %720 ]
  %734 = add i32 %.0552246, 1
  br label %._crit_edge5

735:                                              ; preds = %SwissTable_remove_keyK.exit, %SwissTable_remove_keyK.exit.thread
  %736 = phi i32 [ %620, %SwissTable_remove_keyK.exit.thread ], [ %718, %SwissTable_remove_keyK.exit ]
  %737 = icmp slt i32 %.0558244, 10
  br i1 %737, label %RangeIterator_next_.exit52.i1141.preheader, label %._crit_edge5

RangeIterator_next_.exit52.i1141.preheader:       ; preds = %735
  %result.i62.h2s2326 = alloca [38 x i8], align 1
  %738 = getelementptr inbounds i8, ptr %result.i62.h2s2326, i64 37
  store i8 0, ptr %738, align 1
  store <37 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 78, i8 105, i8 108, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %result.i62.h2s2326, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %739 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %740 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %result.i5.i1138.h2s2327 = alloca [38 x i8], align 1
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 87, ptr %result.i5.i1138.h2s2327, align 1
  %scevgep1431 = getelementptr inbounds i8, ptr %result.i5.i1138.h2s2327, i64 1
  %scevgep1432 = getelementptr inbounds i8, ptr %result.i62.h2s2326, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(37) %scevgep1431, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(37) %scevgep1432, i64 noundef 36, i1 noundef false)
  %742 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %743 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %744 = getelementptr inbounds i8, ptr %result.i5.i1138.h2s2327, i64 37
  store i8 0, ptr %744, align 1
  %puts.i688 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(38) %result.i5.i1138.h2s2327) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %745 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %746 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %623) #59
  %747 = add nsw i32 %.0558244, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %RangeIterator_next_.exit52.i1141.preheader, %735, %._crit_edge6
  %748 = phi i32 [ %718, %._crit_edge6 ], [ %736, %RangeIterator_next_.exit52.i1141.preheader ], [ %736, %735 ]
  %.3561 = phi i32 [ %.1559, %._crit_edge6 ], [ %747, %RangeIterator_next_.exit52.i1141.preheader ], [ %.0558244, %735 ]
  %.2557 = phi i1 [ %.1556, %._crit_edge6 ], [ false, %RangeIterator_next_.exit52.i1141.preheader ], [ false, %735 ]
  %.1553 = phi i32 [ %734, %._crit_edge6 ], [ %.0552246, %RangeIterator_next_.exit52.i1141.preheader ], [ %.0552246, %735 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %618
  br i1 %exitcond.not, label %._crit_edge10, label %.lr.ph247

._crit_edge10:                                    ; preds = %._crit_edge5, %._crit_edge4
  %749 = phi i32 [ %.promoted1822, %._crit_edge4 ], [ %748, %._crit_edge5 ]
  %.0555.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.2557, %._crit_edge5 ]
  %.0552.lcssa = phi i32 [ 0, %._crit_edge4 ], [ %.1553, %._crit_edge5 ]
  %750 = call i64 @clock()
  %.not574 = icmp eq i32 %.0552.lcssa, %.0569
  %751 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %752 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %.not575 = icmp eq i32 %749, 0
  %753 = select i1 %.not575, i1 %.not574, i1 false
  %spec.select581 = select i1 %753, i1 %.0555.lcssa, i1 false
  br i1 %616, label %754, label %RangeIterator_next_.exit52.i.preheader2978

754:                                              ; preds = %._crit_edge10
  %755 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #46
  %756 = load i32, ptr %result.i2.i290, align 1
  %.sroa.2.sroa.0.0.insert.ext.i957 = zext i32 %756 to i160
  %757 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i957, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %758 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable) #43
  %759 = load ptr, ptr %19, align 8
  %760 = call i32 %759({ ptr, i160 } %757)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %761 = load i32, ptr %22, align 8
  %762 = add i32 %761, -1
  %763 = and i32 %762, %760
  %764 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %765 = load ptr, ptr %21, align 8
  %766 = load ptr, ptr %4, align 8
  %767 = load ptr, ptr %20, align 8
  br label %768

768:                                              ; preds = %806, %754
  %.01013 = phi i32 [ -1, %754 ], [ %.1, %806 ]
  %.0 = phi i32 [ %763, %754 ], [ %808, %806 ]
  %.0..0..0..0..0..0.84.i973 = phi i32 [ -1, %754 ], [ %spec.store.select9216.i977, %806 ]
  %769 = sext i32 %.0 to i64
  %770 = getelementptr i8, ptr %765, i64 %769
  %771 = load i8, ptr %770, align 1
  switch i8 %771, label %._crit_edge.i982 [
    i8 0, label %809
    i8 -128, label %._crit_edge.thread.i975
  ]

._crit_edge.thread.i975:                          ; preds = %768
  %772 = icmp eq i32 %.0..0..0..0..0..0.84.i973, -1
  %spec.store.select.i976 = select i1 %772, i32 %.0, i32 %.0..0..0..0..0..0.84.i973
  br label %806

._crit_edge.i982:                                 ; preds = %768
  %773 = icmp sgt i8 %771, 0
  br i1 %773, label %774, label %806

774:                                              ; preds = %._crit_edge.i982
  %775 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %776 = shl nsw i64 %769, 5
  %777 = getelementptr i8, ptr %766, i64 %776
  %778 = load ptr, ptr %777, align 8
  %779 = icmp ne ptr %778, @nil_typ
  %780 = icmp ne ptr %778, null
  %.not82.i984 = and i1 %779, %780
  br i1 %.not82.i984, label %781, label %806

781:                                              ; preds = %774
  %782 = getelementptr i8, ptr %777, i64 8
  %783 = load i64, ptr %782, align 4
  %.sroa_idx.i985 = getelementptr i8, ptr %777, i64 16
  %784 = load i64, ptr %.sroa_idx.i985, align 4
  %785 = inttoptr i64 %783 to ptr
  %786 = inttoptr i64 %784 to ptr
  %hash_coef_ptr.i3.i986 = getelementptr i8, ptr %778, i64 8
  %tbl_size_ptr.i4.i987 = getelementptr i8, ptr %778, i64 16
  %offset_tbl_ptr.i5.i988 = getelementptr i8, ptr %778, i64 40
  %hash_coef.i6.i989 = load i64, ptr %hash_coef_ptr.i3.i986, align 4
  %tbl_size.i7.i990 = load i64, ptr %tbl_size_ptr.i4.i987, align 4
  %offset_tbl.i8.i991 = load ptr, ptr %offset_tbl_ptr.i5.i988, align 8
  %product.i.i9.i992 = mul i64 %hash_coef.i6.i989, 4015701072841558310
  %shifted.i.i10.i993 = lshr i64 %product.i.i9.i992, 32
  %xored.i.i11.i994 = xor i64 %shifted.i.i10.i993, %product.i.i9.i992
  %hash.i.i12.i995 = and i64 %xored.i.i11.i994, %tbl_size.i7.i990
  %offset_ptr.i13.i996 = getelementptr i32, ptr %offset_tbl.i8.i991, i64 %hash.i.i12.i995
  %offset.i14.i997 = load i32, ptr %offset_ptr.i13.i996, align 4
  %787 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %778, 0
  %788 = insertvalue { ptr, ptr, ptr, i32 } %787, ptr %785, 1
  %789 = insertvalue { ptr, ptr, ptr, i32 } %788, ptr %786, 2
  %790 = insertvalue { ptr, ptr, ptr, i32 } %789, i32 %offset.i14.i997, 3
  %791 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %792 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %778)
  %793 = sext i32 %offset.i14.i997 to i64
  %794 = getelementptr ptr, ptr %778, i64 %793
  %795 = getelementptr i8, ptr %794, i64 40
  %796 = load ptr, ptr %795, align 8
  %result.i1.i998 = call ptr %796({ ptr, ptr, ptr, i32 } %790, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %797 = call i32 %result.i1.i998({ ptr, ptr, ptr, i32 } %790, { ptr, ptr, ptr, i32 } %790, ptr nonnull align 8 %2)
  %798 = icmp eq i32 %797, %760
  br i1 %798, label %._crit_edge2.i999, label %806

._crit_edge2.i999:                                ; preds = %781
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %778)
  %801 = getelementptr i8, ptr %794, i64 48
  %802 = load ptr, ptr %801, align 8
  %result.i.i = call ptr %802({ ptr, ptr, ptr, i32 } %790, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %803 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %790, { ptr, ptr, ptr, i32 } %790, ptr nonnull align 8 %2)
  %804 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %805 = call i1 %767({ ptr, i160 } %803, { ptr, i160 } %757)
  br i1 %805, label %SwissTable_find_slot_keyK_hashi32.exit1001, label %806

806:                                              ; preds = %._crit_edge2.i999, %781, %774, %._crit_edge.i982, %._crit_edge.thread.i975
  %.1 = phi i32 [ %.01013, %._crit_edge2.i999 ], [ %.01013, %781 ], [ %.01013, %774 ], [ %.01013, %._crit_edge.i982 ], [ %spec.store.select.i976, %._crit_edge.thread.i975 ]
  %spec.store.select9216.i977 = phi i32 [ %.0..0..0..0..0..0.84.i973, %._crit_edge2.i999 ], [ %.0..0..0..0..0..0.84.i973, %781 ], [ %.0..0..0..0..0..0.84.i973, %774 ], [ %.0..0..0..0..0..0.84.i973, %._crit_edge.i982 ], [ %spec.store.select.i976, %._crit_edge.thread.i975 ]
  %807 = add i32 %.0, 1
  %808 = and i32 %807, %762
  br label %768

809:                                              ; preds = %768
  %.not.i978 = icmp eq i32 %.0..0..0..0..0..0.84.i973, -1
  %.pre.i981 = select i1 %.not.i978, i32 %.0, i32 %.01013
  %.pre1065 = sext i32 %.pre.i981 to i64
  br label %SwissTable_find_slot_keyK_hashi32.exit1001

SwissTable_find_slot_keyK_hashi32.exit1001:       ; preds = %809, %._crit_edge2.i999
  %.pre-phi1066 = phi i64 [ %.pre1065, %809 ], [ %769, %._crit_edge2.i999 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %810 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9120) @SwissTable)
  %811 = getelementptr i8, ptr %765, i64 %.pre-phi1066
  %812 = load i8, ptr %811, align 1
  switch i8 %812, label %813 [
    i8 -128, label %SwissTable_get_keyK.exit550
    i8 0, label %SwissTable_get_keyK.exit550
  ]

813:                                              ; preds = %SwissTable_find_slot_keyK_hashi32.exit1001
  %814 = shl nsw i64 %.pre-phi1066, 5
  %815 = getelementptr i8, ptr %766, i64 %814
  %816 = load ptr, ptr %815, align 8
  %817 = icmp ne ptr %816, @nil_typ
  %818 = icmp ne ptr %816, null
  %.not74.i531 = and i1 %817, %818
  br i1 %.not74.i531, label %819, label %SwissTable_get_keyK.exit550

819:                                              ; preds = %813
  %820 = getelementptr i8, ptr %815, i64 8
  %821 = load i160, ptr %820, align 4
  %.sroa.262.0.extract.shift.i532 = lshr i160 %821, 64
  %.sroa.262.0.extract.trunc.i533 = trunc i160 %.sroa.262.0.extract.shift.i532 to i64
  %.sroa.061.0.extract.trunc.i534 = trunc i160 %821 to i64
  %822 = inttoptr i64 %.sroa.061.0.extract.trunc.i534 to ptr
  %823 = inttoptr i64 %.sroa.262.0.extract.trunc.i533 to ptr
  %hash_coef_ptr.i3.i535 = getelementptr i8, ptr %816, i64 8
  %tbl_size_ptr.i4.i536 = getelementptr i8, ptr %816, i64 16
  %offset_tbl_ptr.i5.i537 = getelementptr i8, ptr %816, i64 40
  %hash_coef.i6.i538 = load i64, ptr %hash_coef_ptr.i3.i535, align 4
  %tbl_size.i7.i539 = load i64, ptr %tbl_size_ptr.i4.i536, align 4
  %offset_tbl.i8.i540 = load ptr, ptr %offset_tbl_ptr.i5.i537, align 8
  %product.i.i9.i541 = mul i64 %hash_coef.i6.i538, 4015701072841558310
  %shifted.i.i10.i542 = lshr i64 %product.i.i9.i541, 32
  %xored.i.i11.i543 = xor i64 %shifted.i.i10.i542, %product.i.i9.i541
  %hash.i.i12.i544 = and i64 %xored.i.i11.i543, %tbl_size.i7.i539
  %offset_ptr.i13.i545 = getelementptr i32, ptr %offset_tbl.i8.i540, i64 %hash.i.i12.i544
  %offset.i14.i546 = load i32, ptr %offset_ptr.i13.i545, align 4
  %824 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %816, 0
  %825 = insertvalue { ptr, ptr, ptr, i32 } %824, ptr %822, 1
  %826 = insertvalue { ptr, ptr, ptr, i32 } %825, ptr %823, 2
  %827 = insertvalue { ptr, ptr, ptr, i32 } %826, i32 %offset.i14.i546, 3
  %828 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %816)
  %830 = sext i32 %offset.i14.i546 to i64
  %831 = getelementptr ptr, ptr %816, i64 %830
  %832 = getelementptr i8, ptr %831, i64 56
  %833 = load ptr, ptr %832, align 8
  %result.i1.i547 = call ptr %833({ ptr, ptr, ptr, i32 } %827, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  %834 = call { ptr, i160 } %result.i1.i547({ ptr, ptr, ptr, i32 } %827, { ptr, ptr, ptr, i32 } %827, ptr nonnull align 8 %2)
  %.fca.0.extract49.i548 = extractvalue { ptr, i160 } %834, 0
  br label %SwissTable_get_keyK.exit550

SwissTable_get_keyK.exit550:                      ; preds = %819, %813, %SwissTable_find_slot_keyK_hashi32.exit1001, %SwissTable_find_slot_keyK_hashi32.exit1001
  %.reg2mem9.sroa.0.0.i526 = phi ptr [ @nil_typ, %SwissTable_find_slot_keyK_hashi32.exit1001 ], [ %.fca.0.extract49.i548, %819 ], [ @nil_typ, %813 ], [ @nil_typ, %SwissTable_find_slot_keyK_hashi32.exit1001 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %835 = icmp eq ptr %.reg2mem9.sroa.0.0.i526, @nil_typ
  %836 = icmp eq ptr %.reg2mem9.sroa.0.0.i526, null
  %.not578.not = or i1 %835, %836
  %spec.select580 = select i1 %.not578.not, i1 %spec.select581, i1 false
  br label %RangeIterator_next_.exit52.i.preheader2978

RangeIterator_next_.exit52.i.preheader2978:       ; preds = %SwissTable_get_keyK.exit550, %._crit_edge10
  %.6 = phi i1 [ %spec.select581, %._crit_edge10 ], [ %spec.select580, %SwissTable_get_keyK.exit550 ]
  %result.i60 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #51
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i60, align 1
  %837 = sub i64 %750, %615
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.start.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  store i32 7564832, ptr %result.i5.i309.h2s330.i, align 4
  store i32 7564576, ptr %result.i5.i269.h2s334.i, align 4
  %838 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #43
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %839 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %840 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #43
  %result.i5.i = call noalias dereferenceable_or_null(14) ptr @bump_malloc_wrapper(i64 noundef 14) #51
  %841 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %842 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 @String)
  %843 = load i8, ptr %result.i60, align 1
  store i8 %843, ptr %result.i5.i, align 1
  %844 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %845 = getelementptr i8, ptr %result.i60, i64 1
  %846 = load i8, ptr %845, align 1
  %847 = getelementptr i8, ptr %result.i5.i, i64 1
  store i8 %846, ptr %847, align 1
  %848 = getelementptr i8, ptr %result.i60, i64 2
  %849 = load i8, ptr %848, align 1
  %850 = getelementptr i8, ptr %result.i5.i, i64 2
  store i8 %849, ptr %850, align 1
  %851 = getelementptr i8, ptr %result.i60, i64 3
  %852 = load i8, ptr %851, align 1
  %853 = getelementptr i8, ptr %result.i5.i, i64 3
  store i8 %852, ptr %853, align 1
  %854 = getelementptr i8, ptr %result.i60, i64 4
  %855 = load i8, ptr %854, align 1
  %856 = getelementptr i8, ptr %result.i5.i, i64 4
  store i8 %855, ptr %856, align 1
  %857 = getelementptr i8, ptr %result.i60, i64 5
  %858 = load i8, ptr %857, align 1
  %859 = getelementptr i8, ptr %result.i5.i, i64 5
  store i8 %858, ptr %859, align 1
  %860 = getelementptr i8, ptr %result.i60, i64 6
  %861 = load i8, ptr %860, align 1
  %862 = getelementptr i8, ptr %result.i5.i, i64 6
  store i8 %861, ptr %862, align 1
  %863 = getelementptr i8, ptr %result.i60, i64 7
  %864 = load i8, ptr %863, align 1
  %865 = getelementptr i8, ptr %result.i5.i, i64 7
  store i8 %864, ptr %865, align 1
  %866 = getelementptr i8, ptr %result.i60, i64 8
  %867 = load i8, ptr %866, align 1
  %868 = getelementptr i8, ptr %result.i5.i, i64 8
  store i8 %867, ptr %868, align 1
  %869 = getelementptr i8, ptr %result.i60, i64 9
  %870 = load i8, ptr %869, align 1
  %871 = getelementptr i8, ptr %result.i5.i, i64 9
  store i8 %870, ptr %871, align 1
  %872 = getelementptr i8, ptr %result.i60, i64 10
  %873 = load i8, ptr %872, align 1
  %874 = getelementptr i8, ptr %result.i5.i, i64 10
  store i8 %873, ptr %874, align 1
  %875 = getelementptr i8, ptr %result.i60, i64 11
  %876 = load i8, ptr %875, align 1
  %877 = getelementptr i8, ptr %result.i5.i, i64 11
  store i8 %876, ptr %877, align 1
  %878 = getelementptr i8, ptr %result.i60, i64 12
  %879 = load i8, ptr %878, align 1
  %880 = getelementptr i8, ptr %result.i5.i, i64 12
  store i8 %879, ptr %880, align 1
  %881 = getelementptr i8, ptr %result.i5.i, i64 13
  store i8 0, ptr %881, align 1
  %puts.i2573 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %result.i5.i) #52
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i8 32, ptr %result.i5.i.h2s338.i, align 1
  %scevgep.i = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 1
  store <13 x i8> <i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %scevgep.i, align 1
  %882 = getelementptr inbounds i8, ptr %result.i5.i.h2s338.i, i64 14
  store i8 0, ptr %882, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i.h2s338.i) #59
  %883 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0569) #59
  store i8 32, ptr %result.i5.i249.h2s336.i, align 1
  %scevgep318.i = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 1
  store <13 x i8> <i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %scevgep318.i, align 1
  %884 = getelementptr inbounds i8, ptr %result.i5.i249.h2s336.i, i64 14
  store i8 0, ptr %884, align 1
  %puts.i174.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i5.i249.h2s336.i) #59
  %885 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %837) #59
  %puts.i194.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i269.h2s334.i) #59
  br i1 %616, label %RangeIterator_next_.exit52.i292.preheader.i, label %print_benchmark_result.exit

RangeIterator_next_.exit52.i292.preheader.i:      ; preds = %RangeIterator_next_.exit52.i.preheader2978
  %886 = zext nneg i32 %.0569 to i64
  store i8 32, ptr %result.i5.i289.h2s332.i, align 1
  %scevgep324.i = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 1
  store <14 x i8> <i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %scevgep324.i, align 1
  %887 = mul i64 %837, 1000000
  %888 = sdiv i64 %887, %886
  %889 = getelementptr inbounds i8, ptr %result.i5.i289.h2s332.i, i64 15
  store i8 0, ptr %889, align 1
  %puts.i214.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i5.i289.h2s332.i) #59
  %890 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %888) #59
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #60
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %893 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %894 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %puts.i234.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i309.h2s330.i) #59
  br label %print_benchmark_result.exit

print_benchmark_result.exit:                      ; preds = %RangeIterator_next_.exit52.i292.preheader.i, %RangeIterator_next_.exit52.i.preheader2978
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i309.h2s330.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %result.i5.i289.h2s332.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %result.i5.i269.h2s334.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i249.h2s336.i)
  call void @llvm.lifetime.end.p0(i64 15, ptr nonnull %result.i5.i.h2s338.i)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %895 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %896 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 32, ptr %result.i5.i1157.h2s2316, align 1
  %scevgep1436 = getelementptr inbounds i8, ptr %result.i5.i1157.h2s2316, i64 1
  store <17 x i8> <i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %scevgep1436, align 1
  %897 = getelementptr inbounds i8, ptr %result.i5.i1157.h2s2316, i64 18
  store i8 0, ptr %897, align 1
  %puts.i709 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i5.i1157.h2s2316) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.fca.0.extract = select i1 %.6, i8 80, i8 70
  %.sroa.0295.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0295.3 = select i1 %.6, <4 x i8> %.sroa.0295.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0295.1.vec.insert = insertelement <4 x i8> %.sroa.0295.3, i8 65, i64 1
  %.fca.2.extract = select i1 %.6, i8 83, i8 73
  %.sroa.0295.2 = select i1 %.6, <4 x i8> %.sroa.0295.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0295.2.vec.insert = insertelement <4 x i8> %.sroa.0295.2, i8 %.fca.2.extract, i64 2
  %.fca.3.extract = select i1 %.6, i8 83, i8 76
  %.sroa.0295.1 = select i1 %.6, <4 x i8> %.sroa.0295.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0295.3.vec.insert = insertelement <4 x i8> %.sroa.0295.1, i8 %.fca.3.extract, i64 3
  br i1 %.6, label %RangeIterator_next_.exit52.i1179.preheader, label %._crit_edge12.else

._crit_edge12.else:                               ; preds = %print_benchmark_result.exit
  br label %RangeIterator_next_.exit52.i1179.preheader

RangeIterator_next_.exit52.i1179.preheader:       ; preds = %._crit_edge12.else, %print_benchmark_result.exit
  %.sroa.speculated294 = phi <4 x i8> [ %.sroa.0295.3.vec.insert, %print_benchmark_result.exit ], [ <i8 70, i8 65, i8 73, i8 76>, %._crit_edge12.else ]
  %898 = phi ptr [ %9, %print_benchmark_result.exit ], [ %13, %._crit_edge12.else ]
  %899 = phi ptr [ %8, %print_benchmark_result.exit ], [ %12, %._crit_edge12.else ]
  %.sroa.phi = phi ptr [ %.sroa.gep582, %print_benchmark_result.exit ], [ %.sroa.gep, %._crit_edge12.else ]
  %.sroa.phi583 = phi ptr [ %.sroa.gep585, %print_benchmark_result.exit ], [ %.sroa.gep584, %._crit_edge12.else ]
  %.sroa.phi586 = phi ptr [ %.sroa.gep588, %print_benchmark_result.exit ], [ %.sroa.gep587, %._crit_edge12.else ]
  %900 = phi ptr [ %7, %print_benchmark_result.exit ], [ %11, %._crit_edge12.else ]
  %.sroa.phi589 = phi ptr [ %.sroa.gep591, %print_benchmark_result.exit ], [ %.sroa.gep590, %._crit_edge12.else ]
  %.sroa.phi592 = phi ptr [ %.sroa.gep594, %print_benchmark_result.exit ], [ %.sroa.gep593, %._crit_edge12.else ]
  %.sroa.phi595 = phi ptr [ %.sroa.gep597, %print_benchmark_result.exit ], [ %.sroa.gep596, %._crit_edge12.else ]
  %901 = phi ptr [ %6, %print_benchmark_result.exit ], [ %10, %._crit_edge12.else ]
  %902 = extractelement <4 x i8> %.sroa.speculated294, i64 0
  store ptr @_parameterization_Bufferi8, ptr %901, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi589, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi592, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi595, align 8
  %903 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %901)
  store ptr @buffer_typ, ptr %900, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi583, align 8
  store ptr @i32_typ, ptr %.sroa.phi586, align 8
  %904 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %900) #43
  store ptr @_parameterization_String, ptr %899, align 8
  %905 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %899)
  store ptr @String, ptr %898, align 8
  %906 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %898) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %907 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %908 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 %902, ptr %result.i5.i1176.h2s2314, align 1
  %scevgep1441 = getelementptr inbounds i8, ptr %result.i5.i1176.h2s2314, i64 1
  %result.i56.h2s2315.sroa.0.1.vec.extract = shufflevector <4 x i8> %.sroa.speculated294, <4 x i8> poison, <3 x i32> <i32 1, i32 2, i32 3>
  store <3 x i8> %result.i56.h2s2315.sroa.0.1.vec.extract, ptr %scevgep1441, align 1
  %909 = getelementptr inbounds i8, ptr %result.i5.i1176.h2s2314, i64 4
  store i8 0, ptr %909, align 1
  %puts.i729 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i1176.h2s2314) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %910 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %911 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  store i8 32, ptr %result.i5.i1195.h2s2312, align 1
  %scevgep1446 = getelementptr inbounds i8, ptr %result.i5.i1195.h2s2312, i64 1
  store <19 x i8> <i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %scevgep1446, align 1
  %912 = getelementptr inbounds i8, ptr %result.i5.i1195.h2s2312, i64 20
  store i8 0, ptr %912, align 1
  %puts.i749 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(21) %result.i5.i1195.h2s2312) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %913 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0552.lcssa) #59
  %914 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %915 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %916 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #43
  %917 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 41, ptr %result.i5.i1214.h2s2311, align 2
  %918 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %919 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %920 = getelementptr inbounds i8, ptr %result.i5.i1214.h2s2311, i64 1
  store i8 0, ptr %920, align 1
  %puts.i769 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i5.i1214.h2s2311) #52
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define noundef i32 @main() local_unnamed_addr #17 {
RangeIterator_next_.exit52.i.preheader:
  %result.i5.i65.h2s76 = alloca [28 x i8], align 1
  %result.i5.i.h2s78 = alloca [23 x i8], align 1
  call void @setup_landing_pad()
  %0 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 45, ptr %result.i5.i.h2s78, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s78, i64 1
  store <21 x i8> <i8 45, i8 45, i8 32, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %scevgep, align 1
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %4 = getelementptr inbounds i8, ptr %result.i5.i.h2s78, i64 22
  store i8 0, ptr %4, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(23) %result.i5.i.h2s78) #52
  call void @benchmark_insert_sequential(i32 noundef 1000000)
  call void @benchmark_insert_random(i32 noundef 1000000)
  call void @benchmark_get_sequential_hit(i32 noundef 1000000)
  call void @benchmark_get_random_hit(i32 noundef 1000000)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 45, ptr %result.i5.i65.h2s76, align 1
  %scevgep73 = getelementptr inbounds i8, ptr %result.i5.i65.h2s76, i64 1
  store <26 x i8> <i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %scevgep73, align 1
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %9 = getelementptr inbounds i8, ptr %result.i5.i65.h2s76, i64 27
  store i8 0, ptr %9, align 1
  %puts.i51 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(28) %result.i5.i65.h2s76) #52
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_bool_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @IO_B__Self_print_xi32__Self_print_xString__Self_print_xRepresentable__Self_print_xi8__Self_print_xf64__Self_print_xBool__Self_print_xi64__Self_print_xNil__Self_print_xCharacter(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #43
  %3 = load ptr, ptr %0, align 8
  %4 = icmp eq ptr %3, @i8_typ
  br i1 %4, label %._crit_edge, label %5

5:                                                ; preds = %1
  %6 = icmp eq ptr %3, @f64_typ
  br i1 %6, label %._crit_edge, label %7

7:                                                ; preds = %5
  %8 = icmp eq ptr %3, @i32_typ
  br i1 %8, label %._crit_edge, label %9

9:                                                ; preds = %7
  %10 = icmp eq ptr %3, @bool_typ
  br i1 %10, label %._crit_edge, label %11

11:                                               ; preds = %9
  %12 = icmp eq ptr %3, @i64_typ
  br i1 %12, label %._crit_edge, label %13

13:                                               ; preds = %11
  %14 = icmp eq ptr %3, @nil_typ
  %15 = icmp eq ptr %3, null
  %16 = or i1 %14, %15
  br i1 %16, label %._crit_edge, label %17

17:                                               ; preds = %13
  %18 = getelementptr i8, ptr %3, i64 8
  %19 = getelementptr i8, ptr %3, i64 16
  %20 = getelementptr i8, ptr %3, i64 24
  %21 = getelementptr i8, ptr %3, i64 32
  %22 = load i64, ptr %18, align 4
  %23 = load i64, ptr %19, align 4
  %24 = load ptr, ptr %20, align 8
  %25 = load ptr, ptr %21, align 8
  %result.i4 = call i1 %24(i64 %23, i64 %22, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %25) #47
  br i1 %result.i4, label %26, label %.critedge

26:                                               ; preds = %17
  %result.i3 = call i1 %24(i64 %23, i64 %22, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %25) #47
  br i1 %result.i3, label %.critedge, label %27

27:                                               ; preds = %26
  %result.i2 = call i1 %24(i64 %23, i64 %22, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %25) #47
  br i1 %result.i2, label %.critedge, label %._crit_edge

.critedge:                                        ; preds = %27, %26, %17
  %result.i1 = call i1 %24(i64 %23, i64 %22, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %25) #47
  br i1 %result.i1, label %28, label %.critedge14

28:                                               ; preds = %.critedge
  %result.i = call i1 %24(i64 %23, i64 %22, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %25) #47
  br i1 %result.i, label %.critedge14, label %._crit_edge

.critedge14:                                      ; preds = %28, %.critedge
  br label %._crit_edge

._crit_edge:                                      ; preds = %.critedge14, %28, %27, %13, %11, %9, %7, %5, %1
  %.reg2mem25.0 = phi i64 [ 4, %1 ], [ 5, %5 ], [ 1, %7 ], [ 6, %9 ], [ 7, %11 ], [ 8, %13 ], [ 9, %28 ], [ 3, %27 ], [ 2, %.critedge14 ]
  %29 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %.reg2mem25.0
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #59
  ret void
}

define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #43
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 104
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3)
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #52
  ret void
}

define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract12 = extractvalue { ptr, i160 } %1, 1
  %.sroa.214.8.extract.trunc = trunc i160 %.fca.1.extract12 to i64
  %.sroa.415.8.extract.shift = lshr i160 %.fca.1.extract12, 64
  %.sroa.415.8.extract.trunc = trunc i160 %.sroa.415.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.214.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.415.8.extract.trunc to ptr
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7260840641129990118
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #43
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = load ptr, ptr %13, align 8
  %result.i1 = call ptr %14({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  %15 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3)
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 6499063144389013426
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i13, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %22 = sext i32 %offset.i13 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract5, i64 %22
  %24 = getelementptr i8, ptr %23, i64 104
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  %26 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %3)
  %.fca.0.extract = extractvalue { ptr } %26, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #52
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %sext = shl i32 %.sroa.1.8.extract.trunc, 24
  %3 = ashr exact i32 %sext, 24
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #59
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #59
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xBool(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %result.i5.i49.h2s63 = alloca [6 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(6) %result.i5.i49.h2s63, i8 0, i64 6, i1 false)
  %result.i5.i.h2s65 = alloca [5 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i5.i.h2s65, i8 0, i64 5, i1 false)
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %3 = trunc i160 %.fca.1.extract to i1
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  br i1 %3, label %RangeIterator_next_.exit52.i.preheader, label %RangeIterator_next_.exit52.i52.preheader

RangeIterator_next_.exit52.i.preheader:           ; preds = %2
  store i8 116, ptr %result.i5.i.h2s65, align 1
  %scevgep60 = getelementptr inbounds i8, ptr %result.i5.i.h2s65, i64 1
  store <3 x i8> <i8 114, i8 117, i8 101>, ptr %scevgep60, align 1
  br label %String_c_string_.exit

RangeIterator_next_.exit52.i52.preheader:         ; preds = %2
  store i8 102, ptr %result.i5.i49.h2s63, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i49.h2s63, i64 1
  store i32 1702063201, ptr %scevgep, align 1
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %RangeIterator_next_.exit52.i52.preheader, %RangeIterator_next_.exit52.i.preheader
  %5 = phi i64 [ 4, %RangeIterator_next_.exit52.i.preheader ], [ 5, %RangeIterator_next_.exit52.i52.preheader ]
  %result.i5.i49.sink = phi ptr [ %result.i5.i.h2s65, %RangeIterator_next_.exit52.i.preheader ], [ %result.i5.i49.h2s63, %RangeIterator_next_.exit52.i52.preheader ]
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %8 = getelementptr i8, ptr %result.i5.i49.sink, i64 %5
  store i8 0, ptr %8, align 1
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i5.i49.sink) #52
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #59
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
RangeIterator_next_.exit52.i.preheader:
  %result.i5.i.h2s19 = alloca [4 x i8], align 4
  store i32 7104878, ptr %result.i5.i.h2s19, align 4
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i5.i.h2s19) #52
  ret void
}

define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract12 = extractvalue { ptr, i160 } %1, 1
  %.sroa.214.8.extract.trunc = trunc i160 %.fca.1.extract12 to i64
  %.sroa.415.8.extract.shift = lshr i160 %.fca.1.extract12, 64
  %.sroa.415.8.extract.trunc = trunc i160 %.sroa.415.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.214.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.415.8.extract.trunc to ptr
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #43
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3)
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 6499063144389013426
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract5, i64 %23
  %25 = getelementptr i8, ptr %24, i64 104
  %26 = load ptr, ptr %25, align 8
  %result.i = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  %27 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %3)
  %.fca.0.extract = extractvalue { ptr } %27, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #52
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #25

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @String_field_String_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_byte_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #43
  ret ptr @String__Self_from_bytes_source_bytesBufferi8_source_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #43
  ret ptr @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #43
  ret ptr @String__Self_from_c_string_c_stringBufferi8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_empty_(ptr nocapture nofree %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #43
  ret ptr @String__Self_empty_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_iterable_iterableIterableCharacter(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #43
  ret ptr @String__Self_from_iterable_iterableIterableCharacter
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_charCharacter({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_last_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %12) #47
  br i1 %result.i1, label %._crit_edge, label %13

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #47
  %spec.select = select i1 %result.i, i64 67, i64 68
  br label %._crit_edge

._crit_edge:                                      ; preds = %13, %2
  %.reg2mem7.0 = phi i64 [ 69, %2 ], [ %spec.select, %13 ]
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr [314 x ptr], ptr %14, i64 0, i64 %.reg2mem7.0
  %16 = getelementptr i8, ptr %15, i64 80
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 648
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 656
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 664
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 672
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 680
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 688
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 696
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 704
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 712
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 80, i64 81
  %8 = getelementptr [314 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 736
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 84, i64 83
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 86, i64 85
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 88, i64 87
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 89, i64 90
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [314 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 808
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_byte_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  ret i32 %10
}

define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %11 = getelementptr i8, ptr %result.i5, i64 16
  store i32 %2, ptr %11, align 8
  %12 = sext i32 %2 to i64
  %result.i.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %12) #51
  store ptr %result.i.i, ptr %result.i5, align 8
  %13 = getelementptr i8, ptr %result.i5, i64 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #43
  %15 = getelementptr i8, ptr %result.i5, i64 12
  store <2 x i32> zeroinitializer, ptr %13, align 8
  %16 = getelementptr inbounds i8, ptr %7, i64 8
  %17 = getelementptr inbounds i8, ptr %7, i64 16
  %18 = getelementptr inbounds i8, ptr %7, i64 24
  %19 = getelementptr inbounds i8, ptr %8, i64 8
  %20 = getelementptr inbounds i8, ptr %8, i64 16
  %21 = getelementptr inbounds i8, ptr %8, i64 24
  %22 = getelementptr inbounds i8, ptr %9, i64 8
  %23 = getelementptr inbounds i8, ptr %10, i64 8
  %24 = icmp sgt i32 %2, 0
  br i1 %24, label %.lr.ph.preheader, label %._crit_edge3._crit_edge

.lr.ph.preheader:                                 ; preds = %3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode) #60
  %.fca.0.extract10.i = extractvalue { ptr } %1, 0
  br label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge, %.lr.ph.preheader
  %.pre112175 = phi ptr [ %.pre112172, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %26 = phi ptr [ %146, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %27 = phi i32 [ %147, %._crit_edge ], [ %2, %.lr.ph.preheader ]
  %.pre113.pre = phi i32 [ %148, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.013 = phi i32 [ %.1, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.not.i = icmp slt i32 %.013, %2
  br i1 %.not.i, label %._crit_edge.i, label %._crit_edge1.thread

._crit_edge.i:                                    ; preds = %.lr.ph
  %28 = sext i32 %.013 to i64
  %29 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %28
  %30 = load i8, ptr %29, align 1
  %31 = sext i8 %30 to i32
  %32 = icmp sgt i8 %30, -1
  %spec.select.i = zext i1 %32 to i32
  %33 = and i32 %31, -32
  %34 = icmp eq i32 %33, -64
  %.1149.i = select i1 %34, i32 2, i32 %spec.select.i
  %35 = and i32 %31, -16
  %36 = icmp eq i32 %35, -32
  %.2150.i = select i1 %36, i32 3, i32 %.1149.i
  %37 = and i32 %31, -8
  %38 = icmp eq i32 %37, -16
  %.3151.i = select i1 %38, i32 4, i32 %.2150.i
  %39 = icmp eq i32 %.3151.i, 0
  %40 = add i32 %.3151.i, %.013
  %41 = icmp sgt i32 %40, %2
  %.0152.i = or i1 %39, %41
  br i1 %.0152.i, label %._crit_edge1.thread, label %42

42:                                               ; preds = %._crit_edge.i
  %43 = and i32 %31, 7
  %44 = and i32 %31, 15
  %45 = and i32 %31, 31
  %spec.select171.i = select i1 %32, i32 %31, i32 0
  %.1.i = select i1 %34, i32 %45, i32 %spec.select171.i
  %.2.i = select i1 %36, i32 %44, i32 %.1.i
  %.3.i = select i1 %38, i32 %43, i32 %.2.i
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %48

48:                                               ; preds = %42
  %49 = getelementptr i8, ptr %29, i64 1
  %50 = load i8, ptr %49, align 1
  %51 = sext i8 %50 to i32
  %52 = and i32 %51, -64
  %.not15.i = icmp eq i32 %52, -128
  %53 = shl nsw i32 %.3.i, 6
  %54 = and i32 %51, 63
  %55 = or disjoint i32 %54, %53
  br i1 %.not15.i, label %56, label %._crit_edge1.thread

56:                                               ; preds = %48
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %57

57:                                               ; preds = %56
  %58 = add i32 %.013, 2
  %59 = sext i32 %58 to i64
  %60 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = sext i8 %61 to i32
  %63 = and i32 %62, -64
  %.not15.i.1 = icmp eq i32 %63, -128
  %64 = shl i32 %55, 6
  %65 = and i32 %62, 63
  %66 = or disjoint i32 %65, %64
  br i1 %.not15.i.1, label %67, label %._crit_edge1.thread

67:                                               ; preds = %57
  %not. = xor i1 %38, true
  %exitcond.not.2 = and i1 %36, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %68

68:                                               ; preds = %67
  %69 = add i32 %.013, 3
  %70 = sext i32 %69 to i64
  %71 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %70
  %72 = load i8, ptr %71, align 1
  %73 = sext i8 %72 to i32
  %74 = and i32 %73, -64
  %.not15.i.2 = icmp eq i32 %74, -128
  br i1 %.not15.i.2, label %75, label %._crit_edge1.thread

75:                                               ; preds = %68
  %76 = and i32 %73, 63
  %77 = shl i32 %66, 6
  %78 = or disjoint i32 %76, %77
  br i1 %38, label %._crit_edge5.i, label %._crit_edge1.thread

._crit_edge4.i:                                   ; preds = %56
  %79 = icmp slt i32 %55, -128
  br i1 %79, label %._crit_edge1.thread, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %75, %67, %42
  %.4.i.lcssa225 = phi i32 [ %55, %._crit_edge4.i ], [ %78, %75 ], [ %66, %67 ], [ %.3.i, %42 ]
  %not..i = xor i1 %38, true
  %80 = and i1 %36, %not..i
  %81 = icmp slt i32 %.4.i.lcssa225, 2048
  %spec.select173.i = select i1 %80, i1 %81, i1 false
  %82 = icmp slt i32 %.4.i.lcssa225, 65536
  %spec.select174.i = select i1 %38, i1 %82, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %._crit_edge1.thread, label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge5.i
  %83 = and i32 %.4.i.lcssa225, -2048
  %spec.select176.i = icmp eq i32 %83, -10240
  %84 = icmp sgt i32 %.4.i.lcssa225, 1114111
  %spec.select177.i = or i1 %84, %spec.select176.i
  br i1 %spec.select177.i, label %._crit_edge1.thread, label %._crit_edge1

._crit_edge1.thread:                              ; preds = %.critedge175.i, %._crit_edge5.i, %._crit_edge4.i, %75, %68, %57, %48, %._crit_edge.i, %.lr.ph
  call fastcc void @String__Self_from_bytes_source_bytesBufferi8_source_leni32.cold.1(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %5, ptr noalias nocapture nofree noundef nonnull align 8 %4, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %16, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %17, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %19, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %20, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %22, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %10, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %23) #62
  br label %._crit_edge

._crit_edge1:                                     ; preds = %.critedge175.i
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  %85 = add i32 %.3151.i, %.pre113.pre
  %.not.i17 = icmp slt i32 %85, %27
  br i1 %.not.i17, label %._crit_edge.i18, label %86

86:                                               ; preds = %._crit_edge1
  %87 = shl i32 %27, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  %.not.i87 = icmp sgt i32 %87, %27
  br i1 %.not.i87, label %88, label %String_reserve_new_capacityi32.exit

88:                                               ; preds = %86
  store i32 %87, ptr %11, align 8
  %89 = sext i32 %87 to i64
  %result.i5.i88 = call noalias ptr @bump_malloc_wrapper(i64 noundef %89) #51
  store ptr %result.i5.i88, ptr %result.i5, align 8
  %90 = add i32 %.pre113.pre, -1
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %94 = icmp slt i32 %90, 0
  br i1 %94, label %String_reserve_new_capacityi32.exit, label %._crit_edge.i93.lr.ph

._crit_edge.i93.lr.ph:                            ; preds = %88
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %97 = load i8, ptr %26, align 1
  store i8 %97, ptr %result.i5.i88, align 1
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %99 = icmp eq i32 %90, 0
  br i1 %99, label %String_reserve_new_capacityi32.exit, label %RangeIterator_next_.exit198.lr.ph

RangeIterator_next_.exit198.lr.ph:                ; preds = %._crit_edge.i93.lr.ph
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  br label %RangeIterator_next_.exit198

RangeIterator_next_.exit198:                      ; preds = %RangeIterator_next_.exit198, %RangeIterator_next_.exit198.lr.ph
  %101 = phi i32 [ 1, %RangeIterator_next_.exit198.lr.ph ], [ %102, %RangeIterator_next_.exit198 ]
  %102 = add i32 %101, 1
  %103 = sext i32 %101 to i64
  %104 = getelementptr i8, ptr %26, i64 %103
  %105 = load i8, ptr %104, align 1
  %106 = getelementptr i8, ptr %result.i5.i88, i64 %103
  store i8 %105, ptr %106, align 1
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %109 = icmp sgt i32 %102, %90
  br i1 %109, label %String_reserve_new_capacityi32.exit, label %RangeIterator_next_.exit198

String_reserve_new_capacityi32.exit:              ; preds = %RangeIterator_next_.exit198, %._crit_edge.i93.lr.ph, %88, %86
  %.pre112173 = phi ptr [ %.pre112175, %86 ], [ %result.i5.i88, %88 ], [ %result.i5.i88, %._crit_edge.i93.lr.ph ], [ %result.i5.i88, %RangeIterator_next_.exit198 ]
  %110 = phi i32 [ %27, %86 ], [ %87, %88 ], [ %87, %._crit_edge.i93.lr.ph ], [ %87, %RangeIterator_next_.exit198 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  br label %._crit_edge.i18

._crit_edge.i18:                                  ; preds = %String_reserve_new_capacityi32.exit, %._crit_edge1
  %.pre112 = phi ptr [ %.pre112173, %String_reserve_new_capacityi32.exit ], [ %.pre112175, %._crit_edge1 ]
  %111 = phi i32 [ %110, %String_reserve_new_capacityi32.exit ], [ %27, %._crit_edge1 ]
  %112 = add nsw i32 %.3151.i, -1
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %result.i2.i.h2s222 = alloca [12 x i8], align 1
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %115 = getelementptr inbounds i8, ptr %result.i2.i.h2s222, i64 4
  store i32 %112, ptr %115, align 4
  %116 = getelementptr inbounds i8, ptr %result.i2.i.h2s222, i64 8
  store i32 1, ptr %116, align 4
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  store i32 1, ptr %result.i2.i.h2s222, align 4
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %120 = load i8, ptr %29, align 1
  %121 = sext i32 %.pre113.pre to i64
  %122 = getelementptr i8, ptr %.pre112, i64 %121
  store i8 %120, ptr %122, align 1
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %124 = load i32, ptr %result.i2.i.h2s222, align 4
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %126 = load i32, ptr %115, align 4
  %127 = icmp sgt i32 %124, %126
  br i1 %127, label %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit, label %RangeIterator_next_.exit160

RangeIterator_next_.exit160:                      ; preds = %RangeIterator_next_.exit160, %._crit_edge.i18
  %128 = phi i32 [ %139, %RangeIterator_next_.exit160 ], [ %124, %._crit_edge.i18 ]
  %129 = load i32, ptr %116, align 4
  %130 = add i32 %129, %128
  store i32 %130, ptr %result.i2.i.h2s222, align 4
  %131 = add i32 %128, %.pre113.pre
  %132 = add i32 %128, %.013
  %133 = sext i32 %132 to i64
  %134 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %133
  %135 = load i8, ptr %134, align 1
  %136 = sext i32 %131 to i64
  %137 = getelementptr i8, ptr %.pre112, i64 %136
  store i8 %135, ptr %137, align 1
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %4) #43
  %139 = load i32, ptr %result.i2.i.h2s222, align 4
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %141 = load i32, ptr %115, align 4
  %142 = icmp sgt i32 %139, %141
  br i1 %142, label %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit, label %RangeIterator_next_.exit160

String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit: ; preds = %RangeIterator_next_.exit160, %._crit_edge.i18
  %143 = load i32, ptr %15, align 4
  %144 = add i32 %143, 1
  store i32 %144, ptr %15, align 4
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store i32 %85, ptr %13, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %4)
  br label %._crit_edge

._crit_edge:                                      ; preds = %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit, %._crit_edge1.thread
  %.pre112172 = phi ptr [ %.pre112, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %.pre112175, %._crit_edge1.thread ]
  %146 = phi ptr [ %.pre112, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %26, %._crit_edge1.thread ]
  %147 = phi i32 [ %111, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %27, %._crit_edge1.thread ]
  %148 = phi i32 [ %85, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %.pre113.pre, %._crit_edge1.thread ]
  %.1 = phi i32 [ %40, %String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32.exit ], [ %.013, %._crit_edge1.thread ]
  %149 = icmp slt i32 %.1, %2
  br i1 %149, label %.lr.ph, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge, %3
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %150 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %151 = insertvalue { ptr, ptr, ptr, i32 } %150, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %151
}

; Function Attrs: nofree nounwind
define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2) #25 {
  %result.i.i21.h2s514 = alloca [3 x i8], align 1
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %4 = getelementptr i8, ptr %result.i7, i64 16
  store i32 %2, ptr %4, align 8
  %5 = sext i32 %2 to i64
  %result.i.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %5) #51
  store ptr %result.i.i, ptr %result.i7, align 8
  %6 = getelementptr i8, ptr %result.i7, i64 8
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %8 = getelementptr i8, ptr %result.i7, i64 12
  store <2 x i32> zeroinitializer, ptr %6, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  store i8 -17, ptr %result.i.i21.h2s514, align 1
  %10 = getelementptr inbounds i8, ptr %result.i.i21.h2s514, i64 1
  store i8 -65, ptr %10, align 1
  %11 = getelementptr inbounds i8, ptr %result.i.i21.h2s514, i64 2
  store i8 -67, ptr %11, align 1
  %12 = icmp sgt i32 %2, 0
  br i1 %12, label %.lr.ph.preheader, label %._crit_edge1._crit_edge

.lr.ph.preheader:                                 ; preds = %3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %.fca.0.extract10.i = extractvalue { ptr } %1, 0
  br label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge, %.lr.ph.preheader
  %.pre256404 = phi ptr [ %.pre256400, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %14 = phi i32 [ %170, %._crit_edge ], [ %2, %.lr.ph.preheader ]
  %15 = phi ptr [ %.pre254393, %._crit_edge ], [ %result.i.i, %.lr.ph.preheader ]
  %16 = phi i32 [ %171, %._crit_edge ], [ %2, %.lr.ph.preheader ]
  %.pre257.pre = phi i32 [ %.sink, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.017 = phi i32 [ %.1, %._crit_edge ], [ 0, %.lr.ph.preheader ]
  %.not.i = icmp slt i32 %.017, %2
  br i1 %.not.i, label %._crit_edge.i, label %select.unfold

._crit_edge.i:                                    ; preds = %.lr.ph
  %17 = sext i32 %.017 to i64
  %18 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %17
  %19 = load i8, ptr %18, align 1
  %20 = sext i8 %19 to i32
  %21 = icmp sgt i8 %19, -1
  %spec.select.i = zext i1 %21 to i32
  %22 = and i32 %20, -32
  %23 = icmp eq i32 %22, -64
  %.1149.i = select i1 %23, i32 2, i32 %spec.select.i
  %24 = and i32 %20, -16
  %25 = icmp eq i32 %24, -32
  %.2150.i = select i1 %25, i32 3, i32 %.1149.i
  %26 = and i32 %20, -8
  %27 = icmp eq i32 %26, -16
  %.3151.i = select i1 %27, i32 4, i32 %.2150.i
  %28 = icmp eq i32 %.3151.i, 0
  %29 = add i32 %.3151.i, %.017
  %30 = icmp sgt i32 %29, %2
  %.0152.i = or i1 %28, %30
  br i1 %.0152.i, label %select.unfold, label %31

31:                                               ; preds = %._crit_edge.i
  %32 = and i32 %20, 7
  %33 = and i32 %20, 15
  %34 = and i32 %20, 31
  %spec.select171.i = select i1 %21, i32 %20, i32 0
  %.1.i = select i1 %23, i32 %34, i32 %spec.select171.i
  %.2.i = select i1 %25, i32 %33, i32 %.1.i
  %.3.i = select i1 %27, i32 %32, i32 %.2.i
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %36

36:                                               ; preds = %31
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %38 = getelementptr i8, ptr %18, i64 1
  %39 = load i8, ptr %38, align 1
  %40 = sext i8 %39 to i32
  %41 = and i32 %40, -64
  %.not15.i = icmp eq i32 %41, -128
  %42 = shl nsw i32 %.3.i, 6
  %43 = and i32 %40, 63
  %44 = or disjoint i32 %43, %42
  br i1 %.not15.i, label %45, label %select.unfold

45:                                               ; preds = %36
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %46

46:                                               ; preds = %45
  %47 = add i32 %.017, 2
  %48 = sext i32 %47 to i64
  %49 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %48
  %50 = load i8, ptr %49, align 1
  %51 = sext i8 %50 to i32
  %52 = and i32 %51, -64
  %.not15.i.1 = icmp eq i32 %52, -128
  %53 = shl i32 %44, 6
  %54 = and i32 %51, 63
  %55 = or disjoint i32 %54, %53
  br i1 %.not15.i.1, label %56, label %select.unfold

56:                                               ; preds = %46
  %not. = xor i1 %27, true
  %exitcond.not.2 = and i1 %25, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %57

57:                                               ; preds = %56
  %58 = add i32 %.017, 3
  %59 = sext i32 %58 to i64
  %60 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = sext i8 %61 to i32
  %63 = and i32 %62, -64
  %.not15.i.2 = icmp eq i32 %63, -128
  br i1 %.not15.i.2, label %64, label %select.unfold

64:                                               ; preds = %57
  %65 = and i32 %62, 63
  %66 = shl i32 %55, 6
  %67 = or disjoint i32 %65, %66
  br i1 %27, label %._crit_edge5.i, label %select.unfold

._crit_edge4.i:                                   ; preds = %45
  %68 = icmp slt i32 %44, -128
  br i1 %68, label %select.unfold, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %64, %56, %31
  %.4.i.lcssa519 = phi i32 [ %44, %._crit_edge4.i ], [ %67, %64 ], [ %55, %56 ], [ %.3.i, %31 ]
  %not..i = xor i1 %27, true
  %69 = and i1 %25, %not..i
  %70 = icmp slt i32 %.4.i.lcssa519, 2048
  %spec.select173.i = select i1 %69, i1 %70, i1 false
  %71 = icmp slt i32 %.4.i.lcssa519, 65536
  %spec.select174.i = select i1 %27, i1 %71, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %select.unfold, label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge5.i
  %72 = and i32 %.4.i.lcssa519, -2048
  %spec.select176.i = icmp eq i32 %72, -10240
  %73 = icmp sgt i32 %.4.i.lcssa519, 1114111
  %spec.select177.i = or i1 %73, %spec.select176.i
  br i1 %spec.select177.i, label %select.unfold, label %74

74:                                               ; preds = %.critedge175.i
  %75 = add i32 %.3151.i, %.pre257.pre
  %.not.i23 = icmp slt i32 %75, %16
  br i1 %.not.i23, label %._crit_edge.i24, label %76

76:                                               ; preds = %74
  %77 = shl nuw i32 %16, 1
  %.not.i181 = icmp sgt i32 %77, %16
  br i1 %.not.i181, label %78, label %._crit_edge.i24

78:                                               ; preds = %76
  store i32 %77, ptr %4, align 8
  %79 = zext nneg i32 %77 to i64
  %result.i5.i182 = call noalias ptr @bump_malloc_wrapper(i64 noundef %79) #51
  store ptr %result.i5.i182, ptr %result.i7, align 8
  %80 = add i32 %.pre257.pre, -1
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %82 = icmp slt i32 %80, 0
  br i1 %82, label %._crit_edge.i24, label %._crit_edge.i187.lr.ph

._crit_edge.i187.lr.ph:                           ; preds = %78
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %85 = load i8, ptr %15, align 1
  store i8 %85, ptr %result.i5.i182, align 1
  %86 = icmp eq i32 %80, 0
  br i1 %86, label %._crit_edge.i24, label %RangeIterator_next_.exit431.lr.ph

RangeIterator_next_.exit431.lr.ph:                ; preds = %._crit_edge.i187.lr.ph
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  br label %RangeIterator_next_.exit431

RangeIterator_next_.exit431:                      ; preds = %RangeIterator_next_.exit431, %RangeIterator_next_.exit431.lr.ph
  %88 = phi i32 [ 1, %RangeIterator_next_.exit431.lr.ph ], [ %89, %RangeIterator_next_.exit431 ]
  %89 = add i32 %88, 1
  %90 = sext i32 %88 to i64
  %91 = getelementptr i8, ptr %15, i64 %90
  %92 = load i8, ptr %91, align 1
  %93 = getelementptr i8, ptr %result.i5.i182, i64 %90
  store i8 %92, ptr %93, align 1
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %95 = icmp sgt i32 %89, %80
  br i1 %95, label %._crit_edge.i24, label %RangeIterator_next_.exit431

._crit_edge.i24:                                  ; preds = %RangeIterator_next_.exit431, %._crit_edge.i187.lr.ph, %78, %76, %74
  %.pre256403 = phi ptr [ %.pre256404, %74 ], [ %.pre256404, %76 ], [ %result.i5.i182, %78 ], [ %result.i5.i182, %._crit_edge.i187.lr.ph ], [ %result.i5.i182, %RangeIterator_next_.exit431 ]
  %96 = phi i32 [ %14, %74 ], [ %14, %76 ], [ %77, %78 ], [ %77, %._crit_edge.i187.lr.ph ], [ %77, %RangeIterator_next_.exit431 ]
  %.pre254 = phi ptr [ %15, %74 ], [ %15, %76 ], [ %result.i5.i182, %78 ], [ %result.i5.i182, %._crit_edge.i187.lr.ph ], [ %result.i5.i182, %RangeIterator_next_.exit431 ]
  %97 = phi i32 [ %16, %74 ], [ %16, %76 ], [ %77, %78 ], [ %77, %._crit_edge.i187.lr.ph ], [ %77, %RangeIterator_next_.exit431 ]
  %98 = add nsw i32 %.3151.i, -1
  %result.i2.i.h2s515 = alloca [12 x i8], align 1
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %100 = getelementptr inbounds i8, ptr %result.i2.i.h2s515, i64 4
  store i32 %98, ptr %100, align 4
  %101 = getelementptr inbounds i8, ptr %result.i2.i.h2s515, i64 8
  store i32 1, ptr %101, align 4
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  store i32 1, ptr %result.i2.i.h2s515, align 4
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %104 = load i8, ptr %18, align 1
  %105 = sext i32 %.pre257.pre to i64
  %106 = getelementptr i8, ptr %.pre254, i64 %105
  store i8 %104, ptr %106, align 1
  %107 = load i32, ptr %result.i2.i.h2s515, align 4
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %109 = load i32, ptr %100, align 4
  %110 = icmp sgt i32 %107, %109
  br i1 %110, label %._crit_edge, label %RangeIterator_next_.exit305

RangeIterator_next_.exit305:                      ; preds = %RangeIterator_next_.exit305, %._crit_edge.i24
  %111 = phi i32 [ %121, %RangeIterator_next_.exit305 ], [ %107, %._crit_edge.i24 ]
  %112 = load i32, ptr %101, align 4
  %113 = add i32 %112, %111
  store i32 %113, ptr %result.i2.i.h2s515, align 4
  %114 = add i32 %111, %.pre257.pre
  %115 = add i32 %111, %.017
  %116 = sext i32 %115 to i64
  %117 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %116
  %118 = load i8, ptr %117, align 1
  %119 = sext i32 %114 to i64
  %120 = getelementptr i8, ptr %.pre254, i64 %119
  store i8 %118, ptr %120, align 1
  %121 = load i32, ptr %result.i2.i.h2s515, align 4
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %123 = load i32, ptr %100, align 4
  %124 = icmp sgt i32 %121, %123
  br i1 %124, label %._crit_edge, label %RangeIterator_next_.exit305

select.unfold:                                    ; preds = %.critedge175.i, %._crit_edge5.i, %._crit_edge4.i, %64, %57, %46, %36, %._crit_edge.i, %.lr.ph
  %125 = add i32 %.pre257.pre, 3
  %.not.i28 = icmp slt i32 %125, %14
  br i1 %.not.i28, label %._crit_edge1.i42.lr.ph, label %126

126:                                              ; preds = %select.unfold
  %127 = shl nuw i32 %14, 1
  %.not.i190 = icmp sgt i32 %127, %14
  br i1 %.not.i190, label %128, label %._crit_edge1.i42.lr.ph

128:                                              ; preds = %126
  store i32 %127, ptr %4, align 8
  %129 = zext nneg i32 %127 to i64
  %result.i5.i192 = call noalias ptr @bump_malloc_wrapper(i64 noundef %129) #51
  store ptr %result.i5.i192, ptr %result.i7, align 8
  %130 = add i32 %.pre257.pre, -1
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %132 = icmp slt i32 %130, 0
  br i1 %132, label %._crit_edge1.i42.lr.ph, label %._crit_edge.i203.lr.ph

._crit_edge.i203.lr.ph:                           ; preds = %128
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %135 = load i8, ptr %15, align 1
  store i8 %135, ptr %result.i5.i192, align 1
  %136 = icmp eq i32 %130, 0
  br i1 %136, label %._crit_edge1.i42.lr.ph, label %RangeIterator_next_.exit469.lr.ph

RangeIterator_next_.exit469.lr.ph:                ; preds = %._crit_edge.i203.lr.ph
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  br label %RangeIterator_next_.exit469

RangeIterator_next_.exit469:                      ; preds = %RangeIterator_next_.exit469, %RangeIterator_next_.exit469.lr.ph
  %138 = phi i32 [ 1, %RangeIterator_next_.exit469.lr.ph ], [ %139, %RangeIterator_next_.exit469 ]
  %139 = add i32 %138, 1
  %140 = sext i32 %138 to i64
  %141 = getelementptr i8, ptr %15, i64 %140
  %142 = load i8, ptr %141, align 1
  %143 = getelementptr i8, ptr %result.i5.i192, i64 %140
  store i8 %142, ptr %143, align 1
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %145 = icmp sgt i32 %139, %130
  br i1 %145, label %._crit_edge1.i42.lr.ph, label %RangeIterator_next_.exit469

._crit_edge1.i42.lr.ph:                           ; preds = %RangeIterator_next_.exit469, %._crit_edge.i203.lr.ph, %128, %126, %select.unfold
  %.pre256 = phi ptr [ %.pre256404, %select.unfold ], [ %.pre256404, %126 ], [ %result.i5.i192, %128 ], [ %result.i5.i192, %._crit_edge.i203.lr.ph ], [ %result.i5.i192, %RangeIterator_next_.exit469 ]
  %146 = phi i32 [ %14, %select.unfold ], [ %14, %126 ], [ %127, %128 ], [ %127, %._crit_edge.i203.lr.ph ], [ %127, %RangeIterator_next_.exit469 ]
  %result.i2.i177.h2s516 = alloca [12 x i8], align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %148 = getelementptr inbounds i8, ptr %result.i2.i177.h2s516, i64 4
  %149 = getelementptr inbounds i8, ptr %result.i2.i177.h2s516, i64 8
  store i32 1, ptr %149, align 8
  store <2 x i32> <i32 1, i32 2>, ptr %result.i2.i177.h2s516, align 8
  %150 = load i8, ptr %result.i.i21.h2s514, align 1
  %151 = sext i32 %.pre257.pre to i64
  %152 = getelementptr i8, ptr %.pre256, i64 %151
  store i8 %150, ptr %152, align 1
  %153 = load i32, ptr %result.i2.i177.h2s516, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %155 = load i32, ptr %148, align 4
  %156 = icmp sgt i32 %153, %155
  br i1 %156, label %._crit_edge, label %RangeIterator_next_.exit371

RangeIterator_next_.exit371:                      ; preds = %RangeIterator_next_.exit371, %._crit_edge1.i42.lr.ph
  %157 = phi i32 [ %166, %RangeIterator_next_.exit371 ], [ %153, %._crit_edge1.i42.lr.ph ]
  %158 = load i32, ptr %149, align 8
  %159 = add i32 %158, %157
  store i32 %159, ptr %result.i2.i177.h2s516, align 8
  %160 = add i32 %157, %.pre257.pre
  %161 = sext i32 %157 to i64
  %162 = getelementptr i8, ptr %result.i.i21.h2s514, i64 %161
  %163 = load i8, ptr %162, align 1
  %164 = sext i32 %160 to i64
  %165 = getelementptr i8, ptr %.pre256, i64 %164
  store i8 %163, ptr %165, align 1
  %166 = load i32, ptr %result.i2.i177.h2s516, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %168 = load i32, ptr %148, align 4
  %169 = icmp sgt i32 %166, %168
  br i1 %169, label %._crit_edge, label %RangeIterator_next_.exit371

._crit_edge:                                      ; preds = %RangeIterator_next_.exit371, %._crit_edge1.i42.lr.ph, %RangeIterator_next_.exit305, %._crit_edge.i24
  %.pre256400 = phi ptr [ %.pre256403, %._crit_edge.i24 ], [ %.pre256, %._crit_edge1.i42.lr.ph ], [ %.pre256, %RangeIterator_next_.exit371 ], [ %.pre256403, %RangeIterator_next_.exit305 ]
  %170 = phi i32 [ %96, %._crit_edge.i24 ], [ %146, %._crit_edge1.i42.lr.ph ], [ %146, %RangeIterator_next_.exit371 ], [ %96, %RangeIterator_next_.exit305 ]
  %.pre254393 = phi ptr [ %.pre254, %._crit_edge.i24 ], [ %.pre256, %._crit_edge1.i42.lr.ph ], [ %.pre256, %RangeIterator_next_.exit371 ], [ %.pre254, %RangeIterator_next_.exit305 ]
  %171 = phi i32 [ %97, %._crit_edge.i24 ], [ %146, %._crit_edge1.i42.lr.ph ], [ %146, %RangeIterator_next_.exit371 ], [ %97, %RangeIterator_next_.exit305 ]
  %.sink = phi i32 [ %75, %._crit_edge.i24 ], [ %125, %._crit_edge1.i42.lr.ph ], [ %125, %RangeIterator_next_.exit371 ], [ %75, %RangeIterator_next_.exit305 ]
  %.4.vec.extract.pn = phi i32 [ %.3151.i, %._crit_edge.i24 ], [ 1, %._crit_edge1.i42.lr.ph ], [ 1, %RangeIterator_next_.exit371 ], [ %.3151.i, %RangeIterator_next_.exit305 ]
  %storemerge.in = load i32, ptr %8, align 4
  %storemerge = add i32 %storemerge.in, 1
  store i32 %storemerge, ptr %8, align 4
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store i32 %.sink, ptr %6, align 8
  %.1 = add i32 %.4.vec.extract.pn, %.017
  %173 = icmp slt i32 %.1, %2
  br i1 %173, label %.lr.ph, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %174 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %175 = insertvalue { ptr, ptr, ptr, i32 } %174, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %175
}

; Function Attrs: nofree nounwind
define { ptr, ptr, ptr, i32 } @String__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree readnone %0, { ptr } %1) #25 {
  %result.i.i14.h2s510 = alloca [3 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i14.h2s510, i8 0, i64 3, i1 false)
  %.fca.0.extract = extractvalue { ptr } %1, 0
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %2
  %.0 = phi i32 [ 0, %2 ], [ %.1, %._crit_edge ]
  %3 = sext i32 %.0 to i64
  %4 = getelementptr i8, ptr %.fca.0.extract, i64 %3
  %5 = load i8, ptr %4, align 1
  %.not = icmp ne i8 %5, 0
  %6 = zext i1 %.not to i32
  %.1 = add i32 %.0, %6
  br i1 %.not, label %._crit_edge, label %7

7:                                                ; preds = %._crit_edge
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %8 = getelementptr i8, ptr %result.i7.i, i64 16
  store i32 %.1, ptr %8, align 8
  %9 = sext i32 %.1 to i64
  %result.i.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %9) #51
  store ptr %result.i.i, ptr %result.i7.i, align 8
  %10 = getelementptr i8, ptr %result.i7.i, i64 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %12 = getelementptr i8, ptr %result.i7.i, i64 12
  store <2 x i32> zeroinitializer, ptr %10, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  store i8 -17, ptr %result.i.i14.h2s510, align 1
  %14 = getelementptr inbounds i8, ptr %result.i.i14.h2s510, i64 1
  store i8 -65, ptr %14, align 1
  %15 = getelementptr inbounds i8, ptr %result.i.i14.h2s510, i64 2
  store i8 -67, ptr %15, align 1
  %16 = icmp sgt i32 %.1, 0
  br i1 %16, label %.lr.ph.preheader, label %String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32.exit

.lr.ph.preheader:                                 ; preds = %7
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  br label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge.i, %.lr.ph.preheader
  %.pre252400 = phi ptr [ %.pre252396, %._crit_edge.i ], [ %result.i.i, %.lr.ph.preheader ]
  %18 = phi i32 [ %174, %._crit_edge.i ], [ %.1, %.lr.ph.preheader ]
  %19 = phi ptr [ %.pre250389, %._crit_edge.i ], [ %result.i.i, %.lr.ph.preheader ]
  %20 = phi i32 [ %175, %._crit_edge.i ], [ %.1, %.lr.ph.preheader ]
  %.pre253.pre = phi i32 [ %.sink, %._crit_edge.i ], [ 0, %.lr.ph.preheader ]
  %.0.i10 = phi i32 [ %.1.i, %._crit_edge.i ], [ 0, %.lr.ph.preheader ]
  %.not.i = icmp slt i32 %.0.i10, %.1
  br i1 %.not.i, label %._crit_edge.i15, label %select.unfold

._crit_edge.i15:                                  ; preds = %.lr.ph
  %21 = sext i32 %.0.i10 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract, i64 %21
  %23 = load i8, ptr %22, align 1
  %24 = sext i8 %23 to i32
  %25 = icmp sgt i8 %23, -1
  %spec.select.i = zext i1 %25 to i32
  %26 = and i32 %24, -32
  %27 = icmp eq i32 %26, -64
  %.1149.i = select i1 %27, i32 2, i32 %spec.select.i
  %28 = and i32 %24, -16
  %29 = icmp eq i32 %28, -32
  %.2150.i = select i1 %29, i32 3, i32 %.1149.i
  %30 = and i32 %24, -8
  %31 = icmp eq i32 %30, -16
  %.3151.i = select i1 %31, i32 4, i32 %.2150.i
  %32 = icmp eq i32 %.3151.i, 0
  %33 = add i32 %.3151.i, %.0.i10
  %34 = icmp sgt i32 %33, %.1
  %.0152.i = or i1 %32, %34
  br i1 %.0152.i, label %select.unfold, label %35

35:                                               ; preds = %._crit_edge.i15
  %36 = and i32 %24, 7
  %37 = and i32 %24, 15
  %38 = and i32 %24, 31
  %spec.select171.i = select i1 %25, i32 %24, i32 0
  %.1.i16 = select i1 %27, i32 %38, i32 %spec.select171.i
  %.2.i = select i1 %29, i32 %37, i32 %.1.i16
  %.3.i = select i1 %31, i32 %36, i32 %.2.i
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %40

40:                                               ; preds = %35
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %42 = getelementptr i8, ptr %22, i64 1
  %43 = load i8, ptr %42, align 1
  %44 = sext i8 %43 to i32
  %45 = and i32 %44, -64
  %.not15.i = icmp eq i32 %45, -128
  %46 = shl nsw i32 %.3.i, 6
  %47 = and i32 %44, 63
  %48 = or disjoint i32 %47, %46
  br i1 %.not15.i, label %49, label %select.unfold

49:                                               ; preds = %40
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %50

50:                                               ; preds = %49
  %51 = add i32 %.0.i10, 2
  %52 = sext i32 %51 to i64
  %53 = getelementptr i8, ptr %.fca.0.extract, i64 %52
  %54 = load i8, ptr %53, align 1
  %55 = sext i8 %54 to i32
  %56 = and i32 %55, -64
  %.not15.i.1 = icmp eq i32 %56, -128
  %57 = shl i32 %48, 6
  %58 = and i32 %55, 63
  %59 = or disjoint i32 %58, %57
  br i1 %.not15.i.1, label %60, label %select.unfold

60:                                               ; preds = %50
  %not. = xor i1 %31, true
  %exitcond.not.2 = and i1 %29, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %61

61:                                               ; preds = %60
  %62 = add i32 %.0.i10, 3
  %63 = sext i32 %62 to i64
  %64 = getelementptr i8, ptr %.fca.0.extract, i64 %63
  %65 = load i8, ptr %64, align 1
  %66 = sext i8 %65 to i32
  %67 = and i32 %66, -64
  %.not15.i.2 = icmp eq i32 %67, -128
  br i1 %.not15.i.2, label %68, label %select.unfold

68:                                               ; preds = %61
  %69 = and i32 %66, 63
  %70 = shl i32 %59, 6
  %71 = or disjoint i32 %69, %70
  br i1 %31, label %._crit_edge5.i, label %select.unfold

._crit_edge4.i:                                   ; preds = %49
  %72 = icmp slt i32 %48, -128
  br i1 %72, label %select.unfold, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %68, %60, %35
  %.4.i.lcssa515 = phi i32 [ %48, %._crit_edge4.i ], [ %71, %68 ], [ %59, %60 ], [ %.3.i, %35 ]
  %not..i = xor i1 %31, true
  %73 = and i1 %29, %not..i
  %74 = icmp slt i32 %.4.i.lcssa515, 2048
  %spec.select173.i = select i1 %73, i1 %74, i1 false
  %75 = icmp slt i32 %.4.i.lcssa515, 65536
  %spec.select174.i = select i1 %31, i1 %75, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %select.unfold, label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge5.i
  %76 = and i32 %.4.i.lcssa515, -2048
  %spec.select176.i = icmp eq i32 %76, -10240
  %77 = icmp sgt i32 %.4.i.lcssa515, 1114111
  %spec.select177.i = or i1 %77, %spec.select176.i
  br i1 %spec.select177.i, label %select.unfold, label %78

78:                                               ; preds = %.critedge175.i
  %79 = add i32 %.3151.i, %.pre253.pre
  %.not.i18 = icmp slt i32 %79, %20
  br i1 %.not.i18, label %._crit_edge.i19, label %80

80:                                               ; preds = %78
  %81 = shl i32 %20, 1
  %.not.i177 = icmp sgt i32 %81, %20
  br i1 %.not.i177, label %82, label %._crit_edge.i19

82:                                               ; preds = %80
  store i32 %81, ptr %8, align 8
  %83 = sext i32 %81 to i64
  %result.i5.i178 = call noalias ptr @bump_malloc_wrapper(i64 noundef %83) #51
  store ptr %result.i5.i178, ptr %result.i7.i, align 8
  %84 = add i32 %.pre253.pre, -1
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %86 = icmp slt i32 %84, 0
  br i1 %86, label %._crit_edge.i19, label %._crit_edge.i183.lr.ph

._crit_edge.i183.lr.ph:                           ; preds = %82
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %89 = load i8, ptr %19, align 1
  store i8 %89, ptr %result.i5.i178, align 1
  %90 = icmp eq i32 %84, 0
  br i1 %90, label %._crit_edge.i19, label %RangeIterator_next_.exit427.lr.ph

RangeIterator_next_.exit427.lr.ph:                ; preds = %._crit_edge.i183.lr.ph
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  br label %RangeIterator_next_.exit427

RangeIterator_next_.exit427:                      ; preds = %RangeIterator_next_.exit427, %RangeIterator_next_.exit427.lr.ph
  %92 = phi i32 [ 1, %RangeIterator_next_.exit427.lr.ph ], [ %93, %RangeIterator_next_.exit427 ]
  %93 = add i32 %92, 1
  %94 = sext i32 %92 to i64
  %95 = getelementptr i8, ptr %19, i64 %94
  %96 = load i8, ptr %95, align 1
  %97 = getelementptr i8, ptr %result.i5.i178, i64 %94
  store i8 %96, ptr %97, align 1
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %99 = icmp sgt i32 %93, %84
  br i1 %99, label %._crit_edge.i19, label %RangeIterator_next_.exit427

._crit_edge.i19:                                  ; preds = %RangeIterator_next_.exit427, %._crit_edge.i183.lr.ph, %82, %80, %78
  %.pre252399 = phi ptr [ %.pre252400, %78 ], [ %.pre252400, %80 ], [ %result.i5.i178, %82 ], [ %result.i5.i178, %._crit_edge.i183.lr.ph ], [ %result.i5.i178, %RangeIterator_next_.exit427 ]
  %100 = phi i32 [ %18, %78 ], [ %18, %80 ], [ %81, %82 ], [ %81, %._crit_edge.i183.lr.ph ], [ %81, %RangeIterator_next_.exit427 ]
  %.pre250 = phi ptr [ %19, %78 ], [ %19, %80 ], [ %result.i5.i178, %82 ], [ %result.i5.i178, %._crit_edge.i183.lr.ph ], [ %result.i5.i178, %RangeIterator_next_.exit427 ]
  %101 = phi i32 [ %20, %78 ], [ %20, %80 ], [ %81, %82 ], [ %81, %._crit_edge.i183.lr.ph ], [ %81, %RangeIterator_next_.exit427 ]
  %102 = add nsw i32 %.3151.i, -1
  %result.i2.i.h2s511 = alloca [12 x i8], align 1
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %104 = getelementptr inbounds i8, ptr %result.i2.i.h2s511, i64 4
  store i32 %102, ptr %104, align 4
  %105 = getelementptr inbounds i8, ptr %result.i2.i.h2s511, i64 8
  store i32 1, ptr %105, align 4
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  store i32 1, ptr %result.i2.i.h2s511, align 4
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %108 = load i8, ptr %22, align 1
  %109 = sext i32 %.pre253.pre to i64
  %110 = getelementptr i8, ptr %.pre250, i64 %109
  store i8 %108, ptr %110, align 1
  %111 = load i32, ptr %result.i2.i.h2s511, align 4
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %113 = load i32, ptr %104, align 4
  %114 = icmp sgt i32 %111, %113
  br i1 %114, label %._crit_edge.i, label %RangeIterator_next_.exit301

RangeIterator_next_.exit301:                      ; preds = %RangeIterator_next_.exit301, %._crit_edge.i19
  %115 = phi i32 [ %125, %RangeIterator_next_.exit301 ], [ %111, %._crit_edge.i19 ]
  %116 = load i32, ptr %105, align 4
  %117 = add i32 %116, %115
  store i32 %117, ptr %result.i2.i.h2s511, align 4
  %118 = add i32 %115, %.pre253.pre
  %119 = add i32 %115, %.0.i10
  %120 = sext i32 %119 to i64
  %121 = getelementptr i8, ptr %.fca.0.extract, i64 %120
  %122 = load i8, ptr %121, align 1
  %123 = sext i32 %118 to i64
  %124 = getelementptr i8, ptr %.pre250, i64 %123
  store i8 %122, ptr %124, align 1
  %125 = load i32, ptr %result.i2.i.h2s511, align 4
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %127 = load i32, ptr %104, align 4
  %128 = icmp sgt i32 %125, %127
  br i1 %128, label %._crit_edge.i, label %RangeIterator_next_.exit301

select.unfold:                                    ; preds = %.critedge175.i, %._crit_edge5.i, %._crit_edge4.i, %68, %61, %50, %40, %._crit_edge.i15, %.lr.ph
  %129 = add i32 %.pre253.pre, 3
  %.not.i23 = icmp slt i32 %129, %18
  br i1 %.not.i23, label %._crit_edge1.i37.lr.ph, label %130

130:                                              ; preds = %select.unfold
  %131 = shl i32 %18, 1
  %.not.i186 = icmp sgt i32 %131, %18
  br i1 %.not.i186, label %132, label %._crit_edge1.i37.lr.ph

132:                                              ; preds = %130
  store i32 %131, ptr %8, align 8
  %133 = sext i32 %131 to i64
  %result.i5.i188 = call noalias ptr @bump_malloc_wrapper(i64 noundef %133) #51
  store ptr %result.i5.i188, ptr %result.i7.i, align 8
  %134 = add i32 %.pre253.pre, -1
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %136 = icmp slt i32 %134, 0
  br i1 %136, label %._crit_edge1.i37.lr.ph, label %._crit_edge.i199.lr.ph

._crit_edge.i199.lr.ph:                           ; preds = %132
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %139 = load i8, ptr %19, align 1
  store i8 %139, ptr %result.i5.i188, align 1
  %140 = icmp eq i32 %134, 0
  br i1 %140, label %._crit_edge1.i37.lr.ph, label %RangeIterator_next_.exit465.lr.ph

RangeIterator_next_.exit465.lr.ph:                ; preds = %._crit_edge.i199.lr.ph
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  br label %RangeIterator_next_.exit465

RangeIterator_next_.exit465:                      ; preds = %RangeIterator_next_.exit465, %RangeIterator_next_.exit465.lr.ph
  %142 = phi i32 [ 1, %RangeIterator_next_.exit465.lr.ph ], [ %143, %RangeIterator_next_.exit465 ]
  %143 = add i32 %142, 1
  %144 = sext i32 %142 to i64
  %145 = getelementptr i8, ptr %19, i64 %144
  %146 = load i8, ptr %145, align 1
  %147 = getelementptr i8, ptr %result.i5.i188, i64 %144
  store i8 %146, ptr %147, align 1
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %149 = icmp sgt i32 %143, %134
  br i1 %149, label %._crit_edge1.i37.lr.ph, label %RangeIterator_next_.exit465

._crit_edge1.i37.lr.ph:                           ; preds = %RangeIterator_next_.exit465, %._crit_edge.i199.lr.ph, %132, %130, %select.unfold
  %.pre252 = phi ptr [ %.pre252400, %select.unfold ], [ %.pre252400, %130 ], [ %result.i5.i188, %132 ], [ %result.i5.i188, %._crit_edge.i199.lr.ph ], [ %result.i5.i188, %RangeIterator_next_.exit465 ]
  %150 = phi i32 [ %18, %select.unfold ], [ %18, %130 ], [ %131, %132 ], [ %131, %._crit_edge.i199.lr.ph ], [ %131, %RangeIterator_next_.exit465 ]
  %result.i2.i173.h2s512 = alloca [12 x i8], align 8
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %152 = getelementptr inbounds i8, ptr %result.i2.i173.h2s512, i64 4
  %153 = getelementptr inbounds i8, ptr %result.i2.i173.h2s512, i64 8
  store i32 1, ptr %153, align 8
  store <2 x i32> <i32 1, i32 2>, ptr %result.i2.i173.h2s512, align 8
  %154 = load i8, ptr %result.i.i14.h2s510, align 1
  %155 = sext i32 %.pre253.pre to i64
  %156 = getelementptr i8, ptr %.pre252, i64 %155
  store i8 %154, ptr %156, align 1
  %157 = load i32, ptr %result.i2.i173.h2s512, align 8
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %159 = load i32, ptr %152, align 4
  %160 = icmp sgt i32 %157, %159
  br i1 %160, label %._crit_edge.i, label %RangeIterator_next_.exit367

RangeIterator_next_.exit367:                      ; preds = %RangeIterator_next_.exit367, %._crit_edge1.i37.lr.ph
  %161 = phi i32 [ %170, %RangeIterator_next_.exit367 ], [ %157, %._crit_edge1.i37.lr.ph ]
  %162 = load i32, ptr %153, align 8
  %163 = add i32 %162, %161
  store i32 %163, ptr %result.i2.i173.h2s512, align 8
  %164 = add i32 %161, %.pre253.pre
  %165 = sext i32 %161 to i64
  %166 = getelementptr i8, ptr %result.i.i14.h2s510, i64 %165
  %167 = load i8, ptr %166, align 1
  %168 = sext i32 %164 to i64
  %169 = getelementptr i8, ptr %.pre252, i64 %168
  store i8 %167, ptr %169, align 1
  %170 = load i32, ptr %result.i2.i173.h2s512, align 8
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %172 = load i32, ptr %152, align 4
  %173 = icmp sgt i32 %170, %172
  br i1 %173, label %._crit_edge.i, label %RangeIterator_next_.exit367

._crit_edge.i:                                    ; preds = %RangeIterator_next_.exit367, %._crit_edge1.i37.lr.ph, %RangeIterator_next_.exit301, %._crit_edge.i19
  %.pre252396 = phi ptr [ %.pre252399, %._crit_edge.i19 ], [ %.pre252, %._crit_edge1.i37.lr.ph ], [ %.pre252, %RangeIterator_next_.exit367 ], [ %.pre252399, %RangeIterator_next_.exit301 ]
  %174 = phi i32 [ %100, %._crit_edge.i19 ], [ %150, %._crit_edge1.i37.lr.ph ], [ %150, %RangeIterator_next_.exit367 ], [ %100, %RangeIterator_next_.exit301 ]
  %.pre250389 = phi ptr [ %.pre250, %._crit_edge.i19 ], [ %.pre252, %._crit_edge1.i37.lr.ph ], [ %.pre252, %RangeIterator_next_.exit367 ], [ %.pre250, %RangeIterator_next_.exit301 ]
  %175 = phi i32 [ %101, %._crit_edge.i19 ], [ %150, %._crit_edge1.i37.lr.ph ], [ %150, %RangeIterator_next_.exit367 ], [ %101, %RangeIterator_next_.exit301 ]
  %.sink = phi i32 [ %79, %._crit_edge.i19 ], [ %129, %._crit_edge1.i37.lr.ph ], [ %129, %RangeIterator_next_.exit367 ], [ %79, %RangeIterator_next_.exit301 ]
  %.4.vec.extract.i.pn = phi i32 [ %.3151.i, %._crit_edge.i19 ], [ 1, %._crit_edge1.i37.lr.ph ], [ 1, %RangeIterator_next_.exit367 ], [ %.3151.i, %RangeIterator_next_.exit301 ]
  %storemerge.in = load i32, ptr %12, align 4
  %storemerge = add i32 %storemerge.in, 1
  store i32 %storemerge, ptr %12, align 4
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store i32 %.sink, ptr %10, align 8
  %.1.i = add i32 %.4.vec.extract.i.pn, %.0.i10
  %177 = icmp slt i32 %.1.i, %.1
  br i1 %177, label %.lr.ph, label %String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32.exit

String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32.exit: ; preds = %._crit_edge.i, %7
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7.i, 1
  %178 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %179 = insertvalue { ptr, ptr, ptr, i32 } %178, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %179
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %9(ptr %.fca.1.extract, { ptr } %10) #44
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %12 = getelementptr i8, ptr %6, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 1) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #44
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %22 = getelementptr i8, ptr %6, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = getelementptr i8, ptr %23, i64 8
  %25 = load ptr, ptr %24, align 8
  call void %25(ptr %.fca.1.extract, i32 0) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #44
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract) #45
  %16 = sext i32 %15 to i64
  %result.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %16) #51
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %18 = load ptr, ptr %7, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %20(ptr %.fca.1.extract, { ptr } %21) #44
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %23 = getelementptr i8, ptr %7, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  call void %26(ptr %.fca.1.extract, i32 0) #44
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %28 = getelementptr i8, ptr %7, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, i32 0) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5, i32 %6) #5 {
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #43
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract16, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #44
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #46
  %15 = getelementptr i8, ptr %10, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, i32 %4) #44
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #46
  %20 = getelementptr i8, ptr %10, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #44
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #46
  %25 = getelementptr i8, ptr %10, i64 24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %.fca.1.extract, i32 %6) #44
  ret void
}

; Function Attrs: nounwind
define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #29 {
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46) #60
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract46, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract47) #45
  %11 = add i32 %10, 1
  %12 = sext i32 %11 to i64
  %result.i5 = call noalias ptr @bump_malloc_wrapper(i64 noundef %12) #51
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract47) #45
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %18 = call i32 %15(ptr %.fca.1.extract47) #45
  %19 = add i32 %18, -1
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %22 = icmp slt i32 %19, 0
  br i1 %22, label %.critedge, label %._crit_edge.lr.ph

._crit_edge.lr.ph:                                ; preds = %3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %24 = load ptr, ptr %6, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr } %25(ptr %.fca.1.extract47) #45
  %.fca.0.extract6262 = extractvalue { ptr } %26, 0
  %27 = load i8, ptr %.fca.0.extract6262, align 1
  store i8 %27, ptr %result.i5, align 1
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %29 = icmp eq i32 %19, 0
  br i1 %29, label %.critedge, label %RangeIterator_next_.exit52

RangeIterator_next_.exit52:                       ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph
  %30 = phi i32 [ %31, %RangeIterator_next_.exit52 ], [ 1, %._crit_edge.lr.ph ]
  %31 = add i32 %30, 1
  %32 = load ptr, ptr %6, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr } %33(ptr %.fca.1.extract47) #45
  %.fca.0.extract62 = extractvalue { ptr } %34, 0
  %35 = sext i32 %30 to i64
  %36 = getelementptr i8, ptr %.fca.0.extract62, i64 %35
  %37 = load i8, ptr %36, align 1
  %38 = getelementptr i8, ptr %result.i5, i64 %35
  store i8 %37, ptr %38, align 1
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %40 = icmp sgt i32 %31, %19
  br i1 %40, label %.critedge, label %RangeIterator_next_.exit52

.critedge:                                        ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph, %3
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %42 = load ptr, ptr %7, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %.fca.1.extract47) #45
  %45 = sext i32 %44 to i64
  %46 = getelementptr i8, ptr %result.i5, i64 %45
  store i8 0, ptr %46, align 1
  %47 = insertvalue { ptr } undef, ptr %result.i5, 0
  ret { ptr } %47
}

define { ptr, ptr, ptr, i32 } @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #17 {
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract45, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #60
  %10 = sext i32 %offset.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract45, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract) #45
  %16 = add i32 %15, %5
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract45)
  %18 = getelementptr i8, ptr %11, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %.fca.1.extract) #45
  %.not = icmp slt i32 %16, %21
  br i1 %.not, label %._crit_edge, label %22

22:                                               ; preds = %6
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %24 = call i32 %20(ptr %.fca.1.extract) #45
  %25 = shl i32 %24, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %.fca.1.extract, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.2.extract, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %offset.i, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %32 = getelementptr i8, ptr %11, i64 120
  %33 = load ptr, ptr %32, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i4 = call ptr %33({ ptr, ptr, ptr, i32 } %29, ptr nocapture nofree noundef nonnull readonly align 8 %8) #49
  call void %result.i4({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull align 8 dereferenceable(8) %7, i32 %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %6
  %34 = add i32 %5, -1
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %37 = icmp slt i32 %34, 0
  br i1 %37, label %.critedge, label %._crit_edge1.lr.ph

._crit_edge1.lr.ph:                               ; preds = %._crit_edge
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge1, %._crit_edge1.lr.ph
  %result.i2.i.h2s74.sroa.0.0 = phi i32 [ 1, %._crit_edge1.lr.ph ], [ %55, %._crit_edge1 ]
  %.sroa.026.0.insert.ext.i.pn.in = phi i32 [ 0, %._crit_edge1.lr.ph ], [ %result.i2.i.h2s74.sroa.0.0, %._crit_edge1 ]
  %39 = load ptr, ptr %12, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call i32 %40(ptr %.fca.1.extract) #45
  %42 = add i32 %41, %.sroa.026.0.insert.ext.i.pn.in
  %43 = add i32 %.sroa.026.0.insert.ext.i.pn.in, %4
  %44 = sext i32 %43 to i64
  %45 = getelementptr i8, ptr %.fca.0.extract, i64 %44
  %46 = load i8, ptr %45, align 1
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %48 = load ptr, ptr %11, align 8
  %49 = load ptr, ptr %48, align 8
  %50 = call { ptr } %49(ptr %.fca.1.extract) #45
  %.fca.0.extract59 = extractvalue { ptr } %50, 0
  %51 = sext i32 %42 to i64
  %52 = getelementptr i8, ptr %.fca.0.extract59, i64 %51
  store i8 %46, ptr %52, align 1
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %54 = icmp sgt i32 %result.i2.i.h2s74.sroa.0.0, %34
  %55 = add i32 %result.i2.i.h2s74.sroa.0.0, 1
  br i1 %54, label %.critedge, label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1, %._crit_edge
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %57 = getelementptr i8, ptr %11, i64 16
  %58 = load ptr, ptr %57, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call i32 %59(ptr %.fca.1.extract) #45
  %61 = add i32 %60, 1
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %63 = getelementptr i8, ptr %58, i64 8
  %64 = load ptr, ptr %63, align 8
  call void %64(ptr %.fca.1.extract, i32 %61) #44
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %66 = load ptr, ptr %12, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call i32 %67(ptr %.fca.1.extract) #45
  %69 = add i32 %68, %5
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract45)
  %71 = getelementptr i8, ptr %66, i64 8
  %72 = load ptr, ptr %71, align 8
  call void %72(ptr %.fca.1.extract, i32 %69) #44
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 6499063144389013426
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %73 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.1.extract, 1
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %.fca.2.extract, 2
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, i32 %offset.i29, 3
  ret { ptr, ptr, ptr, i32 } %76
}

; Function Attrs: nounwind
define void @String_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #29 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #60
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #45
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %.critedge

12:                                               ; preds = %4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 %3) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr } %18(ptr %.fca.1.extract) #45
  %.fca.0.extract80 = extractvalue { ptr } %19, 0
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call i32 %22(ptr %.fca.1.extract) #45
  %24 = sext i32 %23 to i64
  %result.i5 = call noalias ptr @bump_malloc_wrapper(i64 noundef %24) #51
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %26 = load ptr, ptr %7, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i5, 0
  call void %28(ptr %.fca.1.extract, { ptr } %29) #44
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract) #45
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %36 = call i32 %33(ptr %.fca.1.extract) #45
  %37 = add i32 %36, -1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %40 = icmp slt i32 %37, 0
  br i1 %40, label %.critedge, label %._crit_edge.lr.ph

._crit_edge.lr.ph:                                ; preds = %12
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %42 = load i8, ptr %.fca.0.extract80, align 1
  %43 = load ptr, ptr %7, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr } %44(ptr %.fca.1.extract) #45
  %.fca.0.extract3162 = extractvalue { ptr } %45, 0
  store i8 %42, ptr %.fca.0.extract3162, align 1
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %47 = icmp eq i32 %37, 0
  br i1 %47, label %.critedge, label %RangeIterator_next_.exit52

RangeIterator_next_.exit52:                       ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph
  %48 = phi i32 [ %49, %RangeIterator_next_.exit52 ], [ 1, %._crit_edge.lr.ph ]
  %49 = add i32 %48, 1
  %50 = sext i32 %48 to i64
  %51 = getelementptr i8, ptr %.fca.0.extract80, i64 %50
  %52 = load i8, ptr %51, align 1
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr } %54(ptr %.fca.1.extract) #45
  %.fca.0.extract31 = extractvalue { ptr } %55, 0
  %56 = getelementptr i8, ptr %.fca.0.extract31, i64 %50
  store i8 %52, ptr %56, align 1
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %58 = icmp sgt i32 %49, %37
  br i1 %58, label %.critedge, label %RangeIterator_next_.exit52

.critedge:                                        ; preds = %RangeIterator_next_.exit52, %._crit_edge.lr.ph, %12, %4
  ret void
}

define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i7 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i8 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i7, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i8, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i9, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 6499063144389013426
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #60
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract24, i64 %9
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract25) #45
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %offset.i18, 3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %21 = sext i32 %offset.i18 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract, i64 %21
  %23 = getelementptr i8, ptr %22, i64 40
  %24 = load ptr, ptr %23, align 8
  %result.i5 = call ptr %24({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %25 = call i32 %result.i5({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %5)
  %.not = icmp eq i32 %14, %25
  br i1 %.not, label %26, label %.critedge

26:                                               ; preds = %4
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract24)
  %28 = load ptr, ptr %11, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %.fca.1.extract25) #45
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract24)
  %32 = call i32 %29(ptr %.fca.1.extract25) #45
  %33 = add i32 %32, -1
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %37 = getelementptr i8, ptr %22, i64 144
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  br label %40

40:                                               ; preds = %43, %26
  %41 = phi i32 [ %44, %43 ], [ 0, %26 ]
  %42 = icmp sgt i32 %41, %33
  br i1 %42, label %.critedge, label %43

43:                                               ; preds = %40
  %44 = add i32 %41, 1
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract24)
  %47 = load ptr, ptr %10, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract25) #45
  %.fca.0.extract38 = extractvalue { ptr } %49, 0
  %50 = sext i32 %41 to i64
  %51 = getelementptr i8, ptr %.fca.0.extract38, i64 %50
  %52 = load i8, ptr %51, align 1
  store ptr @_parameterization_i32, ptr %6, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %55 = load ptr, ptr %37, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i1 = call ptr %55({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly %7) #49
  %56 = call i8 %result.i1({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 dereferenceable(8) %6, i32 %41)
  %.not86 = icmp eq i8 %52, %56
  br i1 %.not86, label %40, label %.critedge

.critedge:                                        ; preds = %43, %40, %4
  %.reg2mem20.0 = phi i1 [ false, %4 ], [ %42, %43 ], [ %42, %40 ]
  ret i1 %.reg2mem20.0
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i64 } @String_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr %.fca.1.extract11) #45
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #46
  %12 = getelementptr i8, ptr %7, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract11) #45
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode) #46
  %.fca.0.extract10.i = extractvalue { ptr } %10, 0
  %.not.i = icmp slt i32 %3, %15
  br i1 %.not.i, label %._crit_edge.i, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

._crit_edge.i:                                    ; preds = %4
  %17 = sext i32 %3 to i64
  %18 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %17
  %19 = load i8, ptr %18, align 1
  %20 = sext i8 %19 to i32
  %21 = icmp sgt i8 %19, -1
  %spec.select.i = zext i1 %21 to i32
  %22 = and i32 %20, -32
  %23 = icmp eq i32 %22, -64
  %.1149.i = select i1 %23, i32 2, i32 %spec.select.i
  %24 = and i32 %20, -16
  %25 = icmp eq i32 %24, -32
  %.2150.i = select i1 %25, i32 3, i32 %.1149.i
  %26 = and i32 %20, -8
  %27 = icmp eq i32 %26, -16
  %.3151.i = select i1 %27, i32 4, i32 %.2150.i
  %28 = icmp eq i32 %.3151.i, 0
  %29 = add i32 %.3151.i, %3
  %30 = icmp sgt i32 %29, %15
  %.0152.i = or i1 %28, %30
  br i1 %.0152.i, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit, label %31

31:                                               ; preds = %._crit_edge.i
  %32 = and i32 %20, 7
  %33 = and i32 %20, 15
  %34 = and i32 %20, 31
  %spec.select171.i = select i1 %21, i32 %20, i32 0
  %.1.i = select i1 %23, i32 %34, i32 %spec.select171.i
  %.2.i = select i1 %25, i32 %33, i32 %.1.i
  %.3.i = select i1 %27, i32 %32, i32 %.2.i
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %exitcond.not = icmp eq i32 %.3151.i, 1
  br i1 %exitcond.not, label %._crit_edge5.i, label %37

37:                                               ; preds = %31
  %38 = getelementptr i8, ptr %18, i64 1
  %39 = load i8, ptr %38, align 1
  %40 = sext i8 %39 to i32
  %41 = and i32 %40, -64
  %.not15.i = icmp eq i32 %41, -128
  %42 = shl nsw i32 %.3.i, 6
  %43 = and i32 %40, 63
  %44 = or disjoint i32 %43, %42
  br i1 %.not15.i, label %45, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

45:                                               ; preds = %37
  %exitcond.not.1 = icmp eq i32 %.3151.i, 2
  br i1 %exitcond.not.1, label %._crit_edge4.i, label %46

46:                                               ; preds = %45
  %47 = add i32 %3, 2
  %48 = sext i32 %47 to i64
  %49 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %48
  %50 = load i8, ptr %49, align 1
  %51 = sext i8 %50 to i32
  %52 = and i32 %51, -64
  %.not15.i.1 = icmp eq i32 %52, -128
  %53 = shl i32 %44, 6
  %54 = and i32 %51, 63
  %55 = or disjoint i32 %54, %53
  br i1 %.not15.i.1, label %56, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

56:                                               ; preds = %46
  %not. = xor i1 %27, true
  %exitcond.not.2 = and i1 %25, %not.
  br i1 %exitcond.not.2, label %._crit_edge5.i, label %57

57:                                               ; preds = %56
  %58 = add i32 %3, 3
  %59 = sext i32 %58 to i64
  %60 = getelementptr i8, ptr %.fca.0.extract10.i, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = sext i8 %61 to i32
  %63 = and i32 %62, -64
  %.not15.i.2 = icmp eq i32 %63, -128
  br i1 %.not15.i.2, label %64, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

64:                                               ; preds = %57
  %65 = and i32 %62, 63
  %66 = shl i32 %55, 6
  %67 = or disjoint i32 %65, %66
  br i1 %27, label %._crit_edge5.i, label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

._crit_edge4.i:                                   ; preds = %45
  %68 = icmp slt i32 %44, -128
  br i1 %68, label %.critedge175.i, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %._crit_edge4.i, %64, %56, %31
  %.4.i.lcssa10 = phi i32 [ %44, %._crit_edge4.i ], [ %67, %64 ], [ %55, %56 ], [ %.3.i, %31 ]
  %not..i = xor i1 %27, true
  %69 = and i1 %25, %not..i
  %70 = icmp slt i32 %.4.i.lcssa10, 2048
  %spec.select173.i = select i1 %69, i1 %70, i1 false
  %71 = icmp slt i32 %.4.i.lcssa10, 65536
  %spec.select174.i = select i1 %27, i1 %71, i1 false
  %or.cond.i = select i1 %spec.select173.i, i1 true, i1 %spec.select174.i
  br i1 %or.cond.i, label %.critedge175.i, label %._crit_edge7.i

._crit_edge7.i:                                   ; preds = %._crit_edge5.i
  %72 = and i32 %.4.i.lcssa10, -2048
  %spec.select176.i = icmp eq i32 %72, -10240
  br label %.critedge175.i

.critedge175.i:                                   ; preds = %._crit_edge7.i, %._crit_edge5.i, %._crit_edge4.i
  %.4.i.lcssa11 = phi i32 [ %.4.i.lcssa10, %._crit_edge7.i ], [ %44, %._crit_edge4.i ], [ %.4.i.lcssa10, %._crit_edge5.i ]
  %.0158.i = phi i1 [ %spec.select176.i, %._crit_edge7.i ], [ true, %._crit_edge4.i ], [ true, %._crit_edge5.i ]
  %73 = icmp sgt i32 %.4.i.lcssa11, 1114111
  %spec.select177.i = select i1 %.0158.i, i1 true, i1 %73
  %.0.vec.insert.i = insertelement <2 x i32> poison, i32 %.4.i.lcssa11, i64 0
  %.4.vec.insert.i = insertelement <2 x i32> %.0.vec.insert.i, i32 %.3151.i, i64 1
  %74 = bitcast <2 x i32> %.4.vec.insert.i to i64
  %75 = select i1 %spec.select177.i, ptr @nil_typ, ptr @tuple_typ
  br label %Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit

Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32.exit: ; preds = %.critedge175.i, %64, %57, %46, %37, %._crit_edge.i, %4
  %.reg2mem55.0.i = phi ptr [ @nil_typ, %4 ], [ @nil_typ, %._crit_edge.i ], [ %75, %.critedge175.i ], [ @nil_typ, %57 ], [ @nil_typ, %46 ], [ @nil_typ, %37 ], [ @nil_typ, %64 ]
  %.reg2mem57.sroa.3.0.i = phi i64 [ poison, %4 ], [ poison, %._crit_edge.i ], [ %74, %.critedge175.i ], [ poison, %57 ], [ poison, %46 ], [ poison, %37 ], [ poison, %64 ]
  %.reload54.fca.0.insert.i = insertvalue { ptr, i64 } poison, ptr %.reg2mem55.0.i, 0
  %.reload54.fca.1.insert.i = insertvalue { ptr, i64 } %.reload54.fca.0.insert.i, i64 %.reg2mem57.sroa.3.0.i, 1
  ret { ptr, i64 } %.reload54.fca.1.insert.i
}

; Function Attrs: mustprogress nounwind willreturn
define i8 @String_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr %.fca.1.extract) #45
  %.fca.0.extract = extractvalue { ptr } %10, 0
  %11 = sext i32 %3 to i64
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load i8, ptr %12, align 1
  ret i8 %13
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i8 %4) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract7, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract) #45
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = sext i32 %3 to i64
  %13 = getelementptr i8, ptr %.fca.0.extract, i64 %12
  store i8 %4, ptr %13, align 1
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #29 {
  %.fca.0.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58) #60
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract58, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract59) #45
  %11 = sext i32 %10 to i64
  %result.i8 = call noalias ptr @bump_malloc_wrapper(i64 noundef %11) #51
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract59) #45
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %17 = call i32 %14(ptr %.fca.1.extract59) #45
  %18 = add i32 %17, -1
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %21 = icmp slt i32 %18, 0
  br i1 %21, label %.critedge, label %._crit_edge.lr.ph

._crit_edge.lr.ph:                                ; preds = %3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %23 = load ptr, ptr %6, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call { ptr } %24(ptr %.fca.1.extract59) #45
  %.fca.0.extract8778 = extractvalue { ptr } %25, 0
  %26 = load i8, ptr %.fca.0.extract8778, align 1
  store i8 %26, ptr %result.i8, align 1
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %28 = icmp eq i32 %18, 0
  br i1 %28, label %.critedge, label %RangeIterator_next_.exit68

RangeIterator_next_.exit68:                       ; preds = %RangeIterator_next_.exit68, %._crit_edge.lr.ph
  %29 = phi i32 [ %30, %RangeIterator_next_.exit68 ], [ 1, %._crit_edge.lr.ph ]
  %30 = add i32 %29, 1
  %31 = load ptr, ptr %6, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr } %32(ptr %.fca.1.extract59) #45
  %.fca.0.extract87 = extractvalue { ptr } %33, 0
  %34 = sext i32 %29 to i64
  %35 = getelementptr i8, ptr %.fca.0.extract87, i64 %34
  %36 = load i8, ptr %35, align 1
  %37 = getelementptr i8, ptr %result.i8, i64 %34
  store i8 %36, ptr %37, align 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %39 = icmp sgt i32 %30, %18
  br i1 %39, label %.critedge, label %RangeIterator_next_.exit68

.critedge:                                        ; preds = %RangeIterator_next_.exit68, %._crit_edge.lr.ph, %3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %41 = load ptr, ptr %7, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %.fca.1.extract59) #45
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %45 = getelementptr i8, ptr %6, i64 16
  %46 = load ptr, ptr %45, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call i32 %47(ptr %.fca.1.extract59) #45
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %50 = call i32 %42(ptr %.fca.1.extract59) #45
  %result.i6 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call i32 %53(ptr %.fca.1.extract59) #45
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %56 = load ptr, ptr %45, align 8
  %57 = load ptr, ptr %56, align 8
  %58 = call i32 %57(ptr %.fca.1.extract59) #45
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %60 = call i32 %53(ptr %.fca.1.extract59) #45
  %61 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr undef, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 10, 3
  store ptr %result.i8, ptr %result.i6, align 8
  %64 = getelementptr i8, ptr %result.i6, i64 8
  store i32 %54, ptr %64, align 8
  %65 = getelementptr i8, ptr %result.i6, i64 12
  store i32 %58, ptr %65, align 4
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %67 = getelementptr i8, ptr %result.i6, i64 16
  store i32 %60, ptr %67, align 8
  ret { ptr, ptr, ptr, i32 } %63
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @String__Self_empty_(ptr nocapture nofree readnone %0) #37 {
  %result.i2 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %2 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %3 = insertvalue { ptr, ptr, ptr, i32 } %2, ptr undef, 2
  %result.i.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  store ptr %result.i.i, ptr %result.i2, align 8
  %4 = getelementptr i8, ptr %result.i2, i64 16
  store i32 1, ptr %4, align 8
  %5 = getelementptr i8, ptr %result.i2, i64 8
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  store <2 x i32> zeroinitializer, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %3, i32 102, 3
  ret { ptr, ptr, ptr, i32 } %7
}

define { ptr, ptr, ptr, i32 } @String__Self_from_iterable_iterableIterableCharacter(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #17 {
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i2.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %result.i.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  store ptr %result.i.i, ptr %result.i2.i, align 8
  %3 = getelementptr i8, ptr %result.i2.i, i64 16
  store i32 1, ptr %3, align 8
  %4 = getelementptr i8, ptr %result.i2.i, i64 8
  store <2 x i32> zeroinitializer, ptr %4, align 8
  %5 = alloca [1 x ptr], align 8
  store ptr @_parameterization_IterableCharacter, ptr %5, align 8
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #43
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #43
  %8 = getelementptr i8, ptr %.fca.0.extract25, i64 24
  %9 = getelementptr i8, ptr %.fca.0.extract25, i64 32
  %10 = load i64, ptr %hash_coef_ptr.i, align 4
  %11 = load i64, ptr %tbl_size_ptr.i, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %result.i1.i = call i1 %12(i64 %11, i64 %10, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %13) #47
  br i1 %result.i1.i, label %String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString.exit, label %14

14:                                               ; preds = %2
  %result.i.i26 = call i1 %12(i64 %11, i64 %10, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %13) #47
  %spec.select.i = select i1 %result.i.i26, i64 67, i64 68
  br label %String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString.exit

String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString.exit: ; preds = %14, %2
  %.reg2mem7.0.i = phi i64 [ 69, %2 ], [ %spec.select.i, %14 ]
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2.i, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 10, 3
  %18 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract25, 0
  %.sroa.624.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.624.8.insert.shift = shl nuw i160 %.sroa.624.8.insert.ext, 128
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %19 = ptrtoint ptr %.fca.2.extract27 to i64
  %.sroa.523.8.insert.ext = zext i64 %19 to i160
  %.sroa.523.8.insert.shift = shl nuw nsw i160 %.sroa.523.8.insert.ext, 64
  %.sroa.523.8.insert.insert = or disjoint i160 %.sroa.624.8.insert.shift, %.sroa.523.8.insert.shift
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %20 = ptrtoint ptr %.fca.1.extract26 to i64
  %.sroa.322.8.insert.ext = zext i64 %20 to i160
  %.sroa.322.8.insert.insert = or disjoint i160 %.sroa.523.8.insert.insert, %.sroa.322.8.insert.ext
  %21 = insertvalue { ptr, i160 } %18, i160 %.sroa.322.8.insert.insert, 1
  %22 = getelementptr [314 x ptr], ptr @String, i64 0, i64 %.reg2mem7.0.i
  %23 = getelementptr i8, ptr %22, i64 80
  %24 = load ptr, ptr %23, align 8
  %25 = call { ptr, i160 } %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(8) %5, { ptr, i160 } %21)
  %.fca.0.extract = extractvalue { ptr, i160 } %25, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %25, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %26 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %27 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, -83120161364696977
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %26, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %27, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %offset.i25, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define { ptr, ptr, ptr, i32 } @String_append_charCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract40 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract39, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract39, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract39, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract28 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %3, 1
  %.sroa.231.8.extract.trunc = trunc i160 %.fca.1.extract29 to i64
  %.sroa.432.8.extract.shift = lshr i160 %.fca.1.extract29, 64
  %.sroa.432.8.extract.trunc = trunc i160 %.sroa.432.8.extract.shift to i64
  %6 = inttoptr i64 %.sroa.231.8.extract.trunc to ptr
  %7 = inttoptr i64 %.sroa.432.8.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 6681222582356018452
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %6, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %7, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i13, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract28) #43
  %14 = sext i32 %offset.i13 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract28, i64 %14
  %16 = getelementptr i8, ptr %15, i64 24
  %17 = load ptr, ptr %16, align 8
  %result.i1 = call ptr %17({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %18 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 %5)
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 6499063144389013426
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %19 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract14, 0
  %20 = ptrtoint ptr %.fca.1.extract15 to i64
  %21 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i25 to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.513.8.insert.ext = zext i64 %21 to i160
  %.sroa.513.8.insert.shift = shl nuw nsw i160 %.sroa.513.8.insert.ext, 64
  %.sroa.513.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.513.8.insert.shift
  %.sroa.312.8.insert.ext = zext i64 %20 to i160
  %.sroa.312.8.insert.insert = or disjoint i160 %.sroa.513.8.insert.insert, %.sroa.312.8.insert.ext
  %22 = insertvalue { ptr, i160 } %19, i160 %.sroa.312.8.insert.insert, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract40, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract41, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i, 3
  %27 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract39)
  %30 = sext i32 %offset.i to i64
  %31 = getelementptr ptr, ptr %.fca.0.extract39, i64 %30
  %32 = getelementptr i8, ptr %31, i64 216
  %33 = load ptr, ptr %32, align 8
  %34 = alloca { ptr }, align 8
  store ptr %.fca.0.extract14, ptr %34, align 8
  %result.i = call ptr %33({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %34) #49
  %35 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %27, { ptr, i160 } %22)
  %.fca.0.extract = extractvalue { ptr, i160 } %35, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %35, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %36 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %37 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i29 = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i30 = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i31 = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i32 = mul i64 %hash_coef.i29, -83120161364696977
  %shifted.i.i33 = lshr i64 %product.i.i32, 32
  %xored.i.i34 = xor i64 %shifted.i.i33, %product.i.i32
  %hash.i.i35 = and i64 %xored.i.i34, %tbl_size.i30
  %offset_ptr.i36 = getelementptr i32, ptr %offset_tbl.i31, i64 %hash.i.i35
  %offset.i37 = load i32, ptr %offset_ptr.i36, align 4
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %36, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %37, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %offset.i37, 3
  ret { ptr, ptr, ptr, i32 } %41
}

define i32 @List_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract, i64 %11
  %13 = getelementptr i8, ptr %12, i64 80
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %15 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  ret i32 %15
}

define { ptr, i160 } @List_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract15, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #43
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract14, i64 %11
  %13 = getelementptr i8, ptr %12, i64 88
  %14 = load ptr, ptr %13, align 8
  %result.i2 = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %15 = call i1 %result.i2({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  br i1 %15, label %34, label %16

16:                                               ; preds = %3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %19 = getelementptr i8, ptr %12, i64 96
  %20 = load ptr, ptr %19, align 8
  %result.i1 = call ptr %20({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %21 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %21, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %21, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %21, 2
  %hash_coef_ptr.i3 = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i4 = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i5 = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i3, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i4, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i5, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, 7049076106841707882
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract33, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract34, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i14, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract32)
  %28 = sext i32 %offset.i14 to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract32, i64 %28
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %result.i = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %32 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %4)
  %.fca.0.extract19 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract20 = extractvalue { ptr, i160 } %32, 1
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  br label %34

34:                                               ; preds = %16, %3
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract19, %16 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract20, %16 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

define { ptr, i160 } @List_last_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract12, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #43
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract11, i64 %11
  %13 = getelementptr i8, ptr %12, i64 80
  %14 = load ptr, ptr %13, align 8
  %result.i1 = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %15 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %16 = add i32 %15, -1
  %17 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %20 = getelementptr i8, ptr %12, i64 64
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %22, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %22) #49
  %23 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 dereferenceable(8) %17, i32 %16)
  ret { ptr, i160 } %23
}

define { ptr, i160 } @String_extend_otherCollectionCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract11 = extractvalue { ptr, i160 } %3, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract11 to i64
  %10 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.6.8.extract.shift = lshr i160 %.fca.1.extract11, 64
  %.sroa.6.8.extract.trunc = trunc i160 %.sroa.6.8.extract.shift to i64
  %11 = inttoptr i64 %.sroa.6.8.extract.trunc to ptr
  %hash_coef_ptr.i7 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i8 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i9 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i7, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i8, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i9, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 1375598993350293883
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %11, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i18, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #60
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #60
  %18 = sext i32 %offset.i18 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract10, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i6 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %hash_coef_ptr.i19 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i22 = load i64, ptr %hash_coef_ptr.i19, align 4
  %tbl_size.i23 = load i64, ptr %tbl_size_ptr.i20, align 4
  %offset_tbl.i24 = load ptr, ptr %offset_tbl_ptr.i21, align 8
  %product.i.i25 = mul i64 %hash_coef.i22, 8673632051301757104
  %shifted.i.i26 = lshr i64 %product.i.i25, 32
  %xored.i.i27 = xor i64 %shifted.i.i26, %product.i.i25
  %hash.i.i28 = and i64 %xored.i.i27, %tbl_size.i23
  %offset_ptr.i29 = getelementptr i32, ptr %offset_tbl.i24, i64 %hash.i.i28
  %offset.i30 = load i32, ptr %offset_ptr.i29, align 4
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i30, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %29 = sext i32 %offset.i30 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract, i64 %29
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i569 = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %33 = call { ptr, i160 } %result.i569({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %5)
  %.fca.0.extract8970 = extractvalue { ptr, i160 } %33, 0
  %34 = icmp ne ptr %.fca.0.extract8970, @nil_typ
  %35 = icmp ne ptr %.fca.0.extract8970, null
  %.not9771 = and i1 %34, %35
  br i1 %.not9771, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %4
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.fca.0.extract8973 = phi ptr [ %.fca.0.extract8970, %._crit_edge.lr.ph ], [ %.fca.0.extract89, %._crit_edge ]
  %37 = phi { ptr, i160 } [ %33, %._crit_edge.lr.ph ], [ %52, %._crit_edge ]
  %.072 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %50, %._crit_edge ]
  %.fca.1.extract90 = extractvalue { ptr, i160 } %37, 1
  %.sroa.794.8.extract.shift = lshr i160 %.fca.1.extract90, 64
  %.sroa.794.8.extract.trunc = trunc i160 %.sroa.794.8.extract.shift to i64
  %.sroa.493.8.extract.trunc = trunc i160 %.fca.1.extract90 to i64
  %38 = inttoptr i64 %.sroa.493.8.extract.trunc to ptr
  %39 = inttoptr i64 %.sroa.794.8.extract.trunc to ptr
  %hash_coef_ptr.i31 = getelementptr i8, ptr %.fca.0.extract8973, i64 8
  %tbl_size_ptr.i32 = getelementptr i8, ptr %.fca.0.extract8973, i64 16
  %offset_tbl_ptr.i33 = getelementptr i8, ptr %.fca.0.extract8973, i64 40
  %hash_coef.i34 = load i64, ptr %hash_coef_ptr.i31, align 4
  %tbl_size.i35 = load i64, ptr %tbl_size_ptr.i32, align 4
  %offset_tbl.i36 = load ptr, ptr %offset_tbl_ptr.i33, align 8
  %product.i.i37 = mul i64 %hash_coef.i34, 6681222582356018452
  %shifted.i.i38 = lshr i64 %product.i.i37, 32
  %xored.i.i39 = xor i64 %shifted.i.i38, %product.i.i37
  %hash.i.i40 = and i64 %xored.i.i39, %tbl_size.i35
  %offset_ptr.i41 = getelementptr i32, ptr %offset_tbl.i36, i64 %hash.i.i40
  %offset.i42 = load i32, ptr %offset_ptr.i41, align 4
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8973, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %38, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %39, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %offset.i42, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8973)
  %45 = sext i32 %offset.i42 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract8973, i64 %45
  %47 = getelementptr i8, ptr %46, i64 40
  %48 = load ptr, ptr %47, align 8
  %result.i4 = call ptr %48({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %49 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %5)
  %50 = add i32 %49, %.072
  %51 = load ptr, ptr %31, align 8
  %result.i5 = call ptr %51({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %5) #49
  %52 = call { ptr, i160 } %result.i5({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %5)
  %.fca.0.extract89 = extractvalue { ptr, i160 } %52, 0
  %53 = icmp ne ptr %.fca.0.extract89, @nil_typ
  %54 = icmp ne ptr %.fca.0.extract89, null
  %.not97 = and i1 %53, %54
  br i1 %.not97, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %.0.lcssa = phi i32 [ 0, %4 ], [ %50, %._crit_edge ]
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract14)
  %56 = sext i32 %offset.i to i64
  %57 = getelementptr ptr, ptr %.fca.0.extract14, i64 %56
  %58 = getelementptr i8, ptr %57, i64 8
  %59 = load ptr, ptr %58, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call i32 %60(ptr %.fca.1.extract15) #45
  %62 = add i32 %61, %.0.lcssa
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %.fca.1.extract15, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %.fca.2.extract16, 2
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %offset.i, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract14)
  %69 = getelementptr i8, ptr %57, i64 120
  %70 = load ptr, ptr %69, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i3 = call ptr %70({ ptr, ptr, ptr, i32 } %66, ptr nocapture nofree noundef nonnull readonly %7) #49
  call void %result.i3({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull align 8 dereferenceable(8) %6, i32 %62)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract10)
  %73 = load ptr, ptr %20, align 8
  %result.i2 = call ptr %73({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %74 = call { ptr, ptr, ptr, i32 } %result.i2({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %.fca.0.extract62 = extractvalue { ptr, ptr, ptr, i32 } %74, 0
  %.fca.1.extract63 = extractvalue { ptr, ptr, ptr, i32 } %74, 1
  %.fca.2.extract64 = extractvalue { ptr, ptr, ptr, i32 } %74, 2
  %hash_coef_ptr.i43 = getelementptr i8, ptr %.fca.0.extract62, i64 8
  %tbl_size_ptr.i44 = getelementptr i8, ptr %.fca.0.extract62, i64 16
  %offset_tbl_ptr.i45 = getelementptr i8, ptr %.fca.0.extract62, i64 40
  %hash_coef.i46 = load i64, ptr %hash_coef_ptr.i43, align 4
  %tbl_size.i47 = load i64, ptr %tbl_size_ptr.i44, align 4
  %offset_tbl.i48 = load ptr, ptr %offset_tbl_ptr.i45, align 8
  %product.i.i49 = mul i64 %hash_coef.i46, 8673632051301757104
  %shifted.i.i50 = lshr i64 %product.i.i49, 32
  %xored.i.i51 = xor i64 %shifted.i.i50, %product.i.i49
  %hash.i.i52 = and i64 %xored.i.i51, %tbl_size.i47
  %offset_ptr.i53 = getelementptr i32, ptr %offset_tbl.i48, i64 %hash.i.i52
  %offset.i54 = load i32, ptr %offset_ptr.i53, align 4
  %75 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract62, 0
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %.fca.1.extract63, 1
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.2.extract64, 2
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, i32 %offset.i54, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract62)
  %81 = sext i32 %offset.i54 to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract62, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = getelementptr i8, ptr %57, i64 184
  %85 = load ptr, ptr %83, align 8
  %result.i174 = call ptr %85({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %86 = call { ptr, i160 } %result.i174({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %5)
  %.fca.0.extract4775 = extractvalue { ptr, i160 } %86, 0
  %87 = icmp ne ptr %.fca.0.extract4775, @nil_typ
  %88 = icmp ne ptr %.fca.0.extract4775, null
  %.not9976 = and i1 %87, %88
  br i1 %.not9976, label %._crit_edge2, label %.critedge

._crit_edge2:                                     ; preds = %._crit_edge2, %._crit_edge1._crit_edge
  %.fca.0.extract4777 = phi ptr [ %.fca.0.extract47, %._crit_edge2 ], [ %.fca.0.extract4775, %._crit_edge1._crit_edge ]
  %89 = phi { ptr, i160 } [ %98, %._crit_edge2 ], [ %86, %._crit_edge1._crit_edge ]
  %.fca.1.extract48 = extractvalue { ptr, i160 } %89, 1
  %hash_coef_ptr.i55 = getelementptr i8, ptr %.fca.0.extract4777, i64 8
  %tbl_size_ptr.i56 = getelementptr i8, ptr %.fca.0.extract4777, i64 16
  %offset_tbl_ptr.i57 = getelementptr i8, ptr %.fca.0.extract4777, i64 40
  %hash_coef.i58 = load i64, ptr %hash_coef_ptr.i55, align 4
  %tbl_size.i59 = load i64, ptr %tbl_size_ptr.i56, align 4
  %offset_tbl.i60 = load ptr, ptr %offset_tbl_ptr.i57, align 8
  %product.i.i61 = mul i64 %hash_coef.i58, 6681222582356018452
  %shifted.i.i62 = lshr i64 %product.i.i61, 32
  %xored.i.i63 = xor i64 %shifted.i.i62, %product.i.i61
  %hash.i.i64 = and i64 %xored.i.i63, %tbl_size.i59
  %offset_ptr.i65 = getelementptr i32, ptr %offset_tbl.i60, i64 %hash.i.i64
  %offset.i66 = load i32, ptr %offset_ptr.i65, align 4
  %90 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract4777, 0
  %.sroa.3.0.insert.ext = zext i32 %offset.i66 to i160
  %.sroa.3.0.insert.shift = shl nuw i160 %.sroa.3.0.insert.ext, 128
  %91 = and i160 %.fca.1.extract48, 340282366920938463463374607431768211455
  %.sroa.032.0.insert.insert = or disjoint i160 %.sroa.3.0.insert.shift, %91
  %92 = insertvalue { ptr, i160 } %90, i160 %.sroa.032.0.insert.insert, 1
  store ptr @_parameterization_Character, ptr %8, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %95 = load ptr, ptr %84, align 8
  store ptr %.fca.0.extract4777, ptr %9, align 8
  %result.i = call ptr %95({ ptr, ptr, ptr, i32 } %66, ptr nocapture nofree noundef nonnull readonly %9) #49
  %96 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %92)
  %97 = load ptr, ptr %83, align 8
  %result.i1 = call ptr %97({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly %5) #49
  %98 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %5)
  %.fca.0.extract47 = extractvalue { ptr, i160 } %98, 0
  %99 = icmp ne ptr %.fca.0.extract47, @nil_typ
  %100 = icmp ne ptr %.fca.0.extract47, null
  %.not99 = and i1 %99, %100
  br i1 %.not99, label %._crit_edge2, label %.critedge

.critedge:                                        ; preds = %._crit_edge2, %._crit_edge1._crit_edge
  %101 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract14, 0
  %102 = ptrtoint ptr %.fca.1.extract15 to i64
  %103 = ptrtoint ptr %.fca.2.extract16 to i64
  %.sroa.13.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.13.8.insert.shift = shl nuw i160 %.sroa.13.8.insert.ext, 128
  %.sroa.10.8.insert.ext = zext i64 %103 to i160
  %.sroa.10.8.insert.shift = shl nuw nsw i160 %.sroa.10.8.insert.ext, 64
  %.sroa.10.8.insert.insert = or disjoint i160 %.sroa.13.8.insert.shift, %.sroa.10.8.insert.shift
  %.sroa.5.8.insert.ext = zext i64 %102 to i160
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.10.8.insert.insert, %.sroa.5.8.insert.ext
  %104 = insertvalue { ptr, i160 } %101, i160 %.sroa.5.8.insert.insert, 1
  ret { ptr, i160 } %104
}

define { ptr, ptr, ptr, i32 } @List_extend_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract36 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i4 = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i5 = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i6 = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i7 = load i64, ptr %hash_coef_ptr.i4, align 4
  %tbl_size.i8 = load i64, ptr %tbl_size_ptr.i5, align 4
  %offset_tbl.i9 = load ptr, ptr %offset_tbl_ptr.i6, align 8
  %product.i.i10 = mul i64 %hash_coef.i7, 3037712219555723519
  %shifted.i.i11 = lshr i64 %product.i.i10, 32
  %xored.i.i12 = xor i64 %shifted.i.i11, %product.i.i10
  %hash.i.i13 = and i64 %xored.i.i12, %tbl_size.i8
  %offset_ptr.i14 = getelementptr i32, ptr %offset_tbl.i9, i64 %hash.i.i13
  %offset.i15 = load i32, ptr %offset_ptr.i14, align 4
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract14, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract15, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i15, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #60
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #60
  %14 = sext i32 %offset.i15 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract13, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %result.i3 = call ptr %17({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %18 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %hash_coef_ptr.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i19 = load i64, ptr %hash_coef_ptr.i16, align 4
  %tbl_size.i20 = load i64, ptr %tbl_size_ptr.i17, align 4
  %offset_tbl.i21 = load ptr, ptr %offset_tbl_ptr.i18, align 8
  %product.i.i22 = mul i64 %hash_coef.i19, 8673632051301757104
  %shifted.i.i23 = lshr i64 %product.i.i22, 32
  %xored.i.i24 = xor i64 %shifted.i.i23, %product.i.i22
  %hash.i.i25 = and i64 %xored.i.i24, %tbl_size.i20
  %offset_ptr.i26 = getelementptr i32, ptr %offset_tbl.i21, i64 %hash.i.i25
  %offset.i27 = load i32, ptr %offset_ptr.i26, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %offset.i27, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %25 = sext i32 %offset.i27 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = sext i32 %offset.i to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract34, i64 %28
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.1.extract35, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.2.extract36, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %offset.i, 3
  %34 = getelementptr i8, ptr %29, i64 24
  %35 = load ptr, ptr %27, align 8
  %result.i240 = call ptr %35({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %36 = call { ptr, i160 } %result.i240({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %5)
  %.fca.0.extract6341 = extractvalue { ptr, i160 } %36, 0
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %38 = icmp ne ptr %.fca.0.extract6341, @nil_typ
  %39 = icmp ne ptr %.fca.0.extract6341, null
  %.not6942 = and i1 %38, %39
  br i1 %.not6942, label %._crit_edge.lr.ph, label %.critedge

._crit_edge.lr.ph:                                ; preds = %4
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.fca.0.extract6343 = phi ptr [ %.fca.0.extract6341, %._crit_edge.lr.ph ], [ %.fca.0.extract63, %._crit_edge ]
  %41 = phi { ptr, i160 } [ %36, %._crit_edge.lr.ph ], [ %48, %._crit_edge ]
  %42 = load ptr, ptr %29, align 8
  %result.i = call ptr %42(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #47
  store ptr %result.i, ptr %6, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %45 = load ptr, ptr %34, align 8
  store ptr %.fca.0.extract6343, ptr %7, align 8
  %result.i1 = call ptr %45({ ptr, ptr, ptr, i32 } %33, ptr nocapture nofree noundef nonnull readonly %7) #49
  %46 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull align 8 dereferenceable(8) %6, { ptr, i160 } %41)
  %47 = load ptr, ptr %27, align 8
  %result.i2 = call ptr %47({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %5) #49
  %48 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %5)
  %.fca.0.extract63 = extractvalue { ptr, i160 } %48, 0
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %50 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %51 = icmp ne ptr %.fca.0.extract63, null
  %.not69 = and i1 %50, %51
  br i1 %.not69, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  %hash_coef.i31 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i32 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i33 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i34 = mul i64 %hash_coef.i31, -83120161364696977
  %shifted.i.i35 = lshr i64 %product.i.i34, 32
  %xored.i.i36 = xor i64 %shifted.i.i35, %product.i.i34
  %hash.i.i37 = and i64 %xored.i.i36, %tbl_size.i32
  %offset_ptr.i38 = getelementptr i32, ptr %offset_tbl.i33, i64 %hash.i.i37
  %offset.i39 = load i32, ptr %offset_ptr.i38, align 4
  %52 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %offset.i39, 3
  ret { ptr, ptr, ptr, i32 } %52
}

define { ptr, i160 } @String_extend_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract28 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %3, 1
  %.sroa.4.8.extract.trunc = trunc i160 %.fca.1.extract29 to i64
  %10 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %.sroa.8.8.extract.shift = lshr i160 %.fca.1.extract29, 64
  %.sroa.8.8.extract.trunc = trunc i160 %.sroa.8.8.extract.shift to i64
  %11 = inttoptr i64 %.sroa.8.8.extract.trunc to ptr
  %hash_coef_ptr.i10 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i11 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i10, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i11, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i12, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 6499063144389013426
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %11, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i21, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #60
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract28) #60
  %18 = sext i32 %offset.i21 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract28, i64 %18
  %20 = getelementptr i8, ptr %19, i64 40
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %22 = call i32 %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract32)
  %24 = sext i32 %offset.i to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract32, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = call i32 %28(ptr %.fca.1.extract33) #45
  %30 = add i32 %29, %22
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract33, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract34, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %offset.i, 3
  %35 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract32)
  %38 = getelementptr i8, ptr %25, i64 120
  %39 = load ptr, ptr %38, align 8
  %40 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %40, align 8
  %result.i7 = call ptr %39({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly align 8 %40) #49
  call void %result.i7({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 dereferenceable(8) %35, i32 %30)
  %41 = add i32 %22, -1
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %45 = getelementptr i8, ptr %19, i64 144
  %46 = getelementptr inbounds i8, ptr %8, i64 8
  %47 = getelementptr i8, ptr %25, i64 152
  %48 = getelementptr inbounds i8, ptr %9, i64 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %51 = icmp slt i32 %41, 0
  br i1 %51, label %.critedge, label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %4
  %storemerge = phi i32 [ %63, %._crit_edge ], [ 1, %4 ]
  %.sroa.026.0.insert.ext.i63.pn.in = phi i32 [ %storemerge, %._crit_edge ], [ 0, %4 ]
  %52 = add i32 %.sroa.026.0.insert.ext.i63.pn.in, %29
  store ptr @_parameterization_i32, ptr %6, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %55 = load ptr, ptr %45, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i3 = call ptr %55({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %7) #49
  %56 = call i8 %result.i3({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 dereferenceable(8) %6, i32 %.sroa.026.0.insert.ext.i63.pn.in)
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr @_parameterization_i8, ptr %46, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %59 = load ptr, ptr %47, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr @i8_typ, ptr %48, align 8
  %result.i2 = call ptr %59({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %9) #49
  call void %result.i2({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 dereferenceable(16) %8, i32 %52, i8 %56)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %62 = icmp sgt i32 %storemerge, %41
  %63 = add i32 %storemerge, 1
  br i1 %62, label %.critedge, label %._crit_edge

.critedge:                                        ; preds = %._crit_edge, %4
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %65 = load ptr, ptr %26, align 8
  %66 = getelementptr i8, ptr %65, i64 8
  %67 = load ptr, ptr %66, align 8
  call void %67(ptr %.fca.1.extract33, i32 %30) #44
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %69 = getelementptr i8, ptr %25, i64 16
  %70 = load ptr, ptr %69, align 8
  %71 = load ptr, ptr %70, align 8
  %72 = call i32 %71(ptr %.fca.1.extract33) #45
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %75 = getelementptr i8, ptr %19, i64 240
  %76 = load ptr, ptr %75, align 8
  %result.i1 = call ptr %76({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %77 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %78 = add i32 %77, %72
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %80 = load ptr, ptr %69, align 8
  %81 = getelementptr i8, ptr %80, i64 8
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %.fca.1.extract33, i32 %78) #44
  %83 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract32, 0
  %84 = ptrtoint ptr %.fca.1.extract33 to i64
  %85 = ptrtoint ptr %.fca.2.extract34 to i64
  %.sroa.19.8.insert.ext = zext i32 %offset.i to i160
  %.sroa.19.8.insert.shift = shl nuw i160 %.sroa.19.8.insert.ext, 128
  %.sroa.16.8.insert.ext = zext i64 %85 to i160
  %.sroa.16.8.insert.shift = shl nuw nsw i160 %.sroa.16.8.insert.ext, 64
  %.sroa.16.8.insert.insert = or disjoint i160 %.sroa.19.8.insert.shift, %.sroa.16.8.insert.shift
  %.sroa.871.8.insert.ext = zext i64 %84 to i160
  %.sroa.871.8.insert.insert = or disjoint i160 %.sroa.16.8.insert.insert, %.sroa.871.8.insert.ext
  %86 = insertvalue { ptr, i160 } %83, i160 %.sroa.871.8.insert.insert, 1
  ret { ptr, i160 } %86
}

define { ptr, i160 } @List_get_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract17, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #60
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #60
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract16, i64 %12
  %14 = getelementptr i8, ptr %13, i64 80
  %15 = load ptr, ptr %14, align 8
  %result.i5 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %16 = call i32 %result.i5({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.not = icmp slt i32 %3, %16
  br i1 %.not, label %17, label %.thread53

17:                                               ; preds = %4
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract16)
  %20 = getelementptr i8, ptr %13, i64 136
  %21 = load ptr, ptr %20, align 8
  %result.i4 = call ptr %21({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract56 = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract58 = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract60 = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %hash_coef_ptr.i6 = getelementptr i8, ptr %.fca.0.extract56, i64 8
  %tbl_size_ptr.i7 = getelementptr i8, ptr %.fca.0.extract56, i64 16
  %offset_tbl_ptr.i8 = getelementptr i8, ptr %.fca.0.extract56, i64 40
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i6, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i7, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i8, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, 1375598993350293883
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract56, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract58, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract60, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i17, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract56)
  %29 = sext i32 %offset.i17 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract56, i64 %29
  %31 = getelementptr i8, ptr %30, i64 24
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %33 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %5)
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %hash_coef_ptr.i18 = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i19 = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i20 = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i18, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i19, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i20, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 8673632051301757104
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract43, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract45, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %offset.i29, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract41)
  %40 = sext i32 %offset.i29 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract41, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  br label %43

43:                                               ; preds = %48, %17
  %44 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %44({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %45 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %5)
  %.fca.0.extract30 = extractvalue { ptr, i160 } %45, 0
  %46 = icmp ne ptr %.fca.0.extract30, @nil_typ
  %47 = icmp ne ptr %.fca.0.extract30, null
  %.not70 = and i1 %46, %47
  br i1 %.not70, label %48, label %.thread53

48:                                               ; preds = %43
  %.fca.1.extract31 = extractvalue { ptr, i160 } %45, 1
  %.sroa.382.8.extract.shift = lshr i160 %.fca.1.extract31, 64
  %.sroa.382.8.extract.trunc = trunc i160 %.sroa.382.8.extract.shift to i64
  %.sroa.081.8.extract.trunc = trunc i160 %.fca.1.extract31 to i64
  %49 = inttoptr i64 %.sroa.081.8.extract.trunc to ptr
  %50 = inttoptr i64 %.sroa.382.8.extract.trunc to ptr
  %hash_coef_ptr.i30 = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i31 = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i32 = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i33 = load i64, ptr %hash_coef_ptr.i30, align 4
  %tbl_size.i34 = load i64, ptr %tbl_size_ptr.i31, align 4
  %offset_tbl.i35 = load ptr, ptr %offset_tbl_ptr.i32, align 8
  %product.i.i36 = mul i64 %hash_coef.i33, 9197944775169318296
  %shifted.i.i37 = lshr i64 %product.i.i36, 32
  %xored.i.i38 = xor i64 %shifted.i.i37, %product.i.i36
  %hash.i.i39 = and i64 %xored.i.i38, %tbl_size.i34
  %offset_ptr.i40 = getelementptr i32, ptr %offset_tbl.i35, i64 %hash.i.i39
  %offset.i41 = load i32, ptr %offset_ptr.i40, align 4
  %51 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract30, 0
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %49, 1
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %50, 2
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, i32 %offset.i41, 3
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract30)
  %57 = sext i32 %offset.i41 to i64
  %58 = getelementptr ptr, ptr %.fca.0.extract30, i64 %57
  %59 = getelementptr i8, ptr %58, i64 32
  %60 = load ptr, ptr %59, align 8
  %result.i1 = call ptr %60({ ptr, ptr, ptr, i32 } %54, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %61 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull align 8 %5)
  %.fca.1.extract27 = extractvalue { ptr, i160 } %61, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract27 to i32
  %.not59 = icmp eq i32 %3, %.sroa.1.8.extract.trunc
  br i1 %.not59, label %62, label %43

62:                                               ; preds = %48
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract30)
  %65 = getelementptr i8, ptr %58, i64 40
  %66 = load ptr, ptr %65, align 8
  %result.i = call ptr %66({ ptr, ptr, ptr, i32 } %54, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %67 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull align 8 %5)
  %.fca.0.extract20 = extractvalue { ptr, i160 } %67, 0
  %.fca.1.extract21 = extractvalue { ptr, i160 } %67, 1
  br label %.thread53

.thread53:                                        ; preds = %62, %43, %4
  %.reg2mem36.sroa.0.0 = phi ptr [ @nil_typ, %4 ], [ %.fca.0.extract20, %62 ], [ poison, %43 ]
  %.reg2mem36.sroa.3.0 = phi i160 [ undef, %4 ], [ %.fca.1.extract21, %62 ], [ undef, %43 ]
  %.reload37.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem36.sroa.0.0, 0
  %.reload37.fca.1.insert = insertvalue { ptr, i160 } %.reload37.fca.0.insert, i160 %.reg2mem36.sroa.3.0, 1
  ret { ptr, i160 } %.reload37.fca.1.insert
}

define { ptr, i32 } @List_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #17 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -83120161364696977
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract20, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #60
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef align 8 %.fca.0.extract19) #60
  %13 = sext i32 %offset.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract19, i64 %13
  %15 = getelementptr i8, ptr %14, i64 88
  %16 = load ptr, ptr %15, align 8
  %result.i5 = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %17 = call i1 %result.i5({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6)
  br i1 %17, label %.thread53, label %18

18:                                               ; preds = %5
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract19)
  %21 = getelementptr i8, ptr %14, i64 136
  %22 = load ptr, ptr %21, align 8
  %result.i4 = call ptr %22({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %23 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6)
  %.fca.0.extract67 = extractvalue { ptr, ptr, ptr, i32 } %23, 0
  %.fca.1.extract69 = extractvalue { ptr, ptr, ptr, i32 } %23, 1
  %.fca.2.extract71 = extractvalue { ptr, ptr, ptr, i32 } %23, 2
  %hash_coef_ptr.i6 = getelementptr i8, ptr %.fca.0.extract67, i64 8
  %tbl_size_ptr.i7 = getelementptr i8, ptr %.fca.0.extract67, i64 16
  %offset_tbl_ptr.i8 = getelementptr i8, ptr %.fca.0.extract67, i64 40
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i6, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i7, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i8, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, 1375598993350293883
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract67, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract69, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract71, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %offset.i17, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract67)
  %30 = sext i32 %offset.i17 to i64
  %31 = getelementptr ptr, ptr %.fca.0.extract67, i64 %30
  %32 = getelementptr i8, ptr %31, i64 24
  %33 = load ptr, ptr %32, align 8
  %result.i3 = call ptr %33({ ptr, ptr, ptr, i32 } %27, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %34 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %6)
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract54 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract56 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %hash_coef_ptr.i18 = getelementptr i8, ptr %.fca.0.extract52, i64 8
  %tbl_size_ptr.i19 = getelementptr i8, ptr %.fca.0.extract52, i64 16
  %offset_tbl_ptr.i20 = getelementptr i8, ptr %.fca.0.extract52, i64 40
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i18, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i19, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i20, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 8673632051301757104
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract52, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract54, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract56, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %offset.i29, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract52)
  %41 = sext i32 %offset.i29 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract52, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  br label %44

44:                                               ; preds = %49, %18
  %45 = load ptr, ptr %43, align 8
  %result.i2 = call ptr %45({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %46 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %6)
  %.fca.0.extract41 = extractvalue { ptr, i160 } %46, 0
  %47 = icmp ne ptr %.fca.0.extract41, @nil_typ
  %48 = icmp ne ptr %.fca.0.extract41, null
  %.not84 = and i1 %47, %48
  br i1 %.not84, label %49, label %.thread53

49:                                               ; preds = %44
  %.fca.1.extract42 = extractvalue { ptr, i160 } %46, 1
  %.sroa.396.8.extract.shift = lshr i160 %.fca.1.extract42, 64
  %.sroa.396.8.extract.trunc = trunc i160 %.sroa.396.8.extract.shift to i64
  %.sroa.095.8.extract.trunc = trunc i160 %.fca.1.extract42 to i64
  %50 = inttoptr i64 %.sroa.095.8.extract.trunc to ptr
  %51 = inttoptr i64 %.sroa.396.8.extract.trunc to ptr
  %hash_coef_ptr.i30 = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i31 = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i32 = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i33 = load i64, ptr %hash_coef_ptr.i30, align 4
  %tbl_size.i34 = load i64, ptr %tbl_size_ptr.i31, align 4
  %offset_tbl.i35 = load ptr, ptr %offset_tbl_ptr.i32, align 8
  %product.i.i36 = mul i64 %hash_coef.i33, 9197944775169318296
  %shifted.i.i37 = lshr i64 %product.i.i36, 32
  %xored.i.i38 = xor i64 %shifted.i.i37, %product.i.i36
  %hash.i.i39 = and i64 %xored.i.i38, %tbl_size.i34
  %offset_ptr.i40 = getelementptr i32, ptr %offset_tbl.i35, i64 %hash.i.i39
  %offset.i41 = load i32, ptr %offset_ptr.i40, align 4
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %50, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %51, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %offset.i41, 3
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract41)
  %58 = sext i32 %offset.i41 to i64
  %59 = getelementptr ptr, ptr %.fca.0.extract41, i64 %58
  %60 = getelementptr i8, ptr %59, i64 40
  %61 = load ptr, ptr %60, align 8
  %result.i1 = call ptr %61({ ptr, ptr, ptr, i32 } %55, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %62 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull align 8 %6)
  %63 = call i1 %.fca.0.extract({ ptr, i160 } %62, { ptr, i160 } %3)
  br i1 %63, label %64, label %44

64:                                               ; preds = %49
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract41)
  %67 = getelementptr i8, ptr %59, i64 32
  %68 = load ptr, ptr %67, align 8
  %result.i = call ptr %68({ ptr, ptr, ptr, i32 } %55, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %69 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull align 8 %6)
  %.fca.1.extract27 = extractvalue { ptr, i160 } %69, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract27 to i32
  br label %.thread53

.thread53:                                        ; preds = %64, %44, %5
  %.reg2mem46.sroa.3.0 = phi i32 [ poison, %5 ], [ %.sroa.1.8.extract.trunc, %64 ], [ poison, %44 ]
  %.reg2mem44.0 = phi ptr [ @nil_typ, %5 ], [ @i32_typ, %64 ], [ @nil_typ, %44 ]
  %.reload43.fca.0.insert = insertvalue { ptr, i32 } poison, ptr %.reg2mem44.0, 0
  %.reload43.fca.1.insert = insertvalue { ptr, i32 } %.reload43.fca.0.insert, i32 %.reg2mem46.sroa.3.0, 1
  ret { ptr, i32 } %.reload43.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  ret i32 %10
}

define i1 @Collection_is_empty_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract, i64 %11
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %15 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %16 = icmp eq i32 %15, 0
  ret i1 %16
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %result.i2 = call noalias align 8 dereferenceable_or_null(40) ptr @bump_malloc_wrapper(i64 noundef 40) #51
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  store ptr %.fca.0.extract, ptr %result.i2, align 8
  %6 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %result.i2, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %result.i2, i64 24
  store i32 %offset.i, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 16 dereferenceable(208) @StringIterator) #46
  %10 = getelementptr i8, ptr %result.i2, i64 32
  store i32 0, ptr %10, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 23, 3
  ret { ptr, ptr, ptr, i32 } %11
}

define void @Iterable_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract19, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract20, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #60
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #60
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract18, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %result.i14 = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %27 = call { ptr, i160 } %result.i14({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract3315 = extractvalue { ptr, i160 } %27, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %29 = icmp ne ptr %.fca.0.extract3315, @nil_typ
  %30 = icmp ne ptr %.fca.0.extract3315, null
  %.not3916 = and i1 %29, %30
  br i1 %.not3916, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge, %4
  %31 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %27, %4 ]
  call void %.fca.0.extract8({ ptr, i160 } %31)
  %32 = load ptr, ptr %25, align 8
  %result.i = call ptr %32({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #49
  %33 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract33 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %35 = icmp ne ptr %.fca.0.extract33, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract33, null
  %.not39 = and i1 %35, %36
  br i1 %.not39, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  ret void
}

define { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #17 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract27, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract28, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #60
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract26) #60
  %13 = sext i32 %offset.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract26, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i1 = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %17 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i13, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %24 = sext i32 %offset.i13 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i19 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %28 = call { ptr, i160 } %result.i19({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6)
  %.fca.0.extract5120 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract26)
  %30 = icmp ne ptr %.fca.0.extract5120, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract5120, null
  %.not5921 = and i1 %30, %31
  br i1 %.not5921, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %5
  %32 = phi { ptr, i160 } [ %35, %._crit_edge ], [ %28, %5 ]
  %.pn22 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %3, %5 ]
  %33 = call { ptr, i160 } %.fca.0.extract8({ ptr, i160 } %.pn22, { ptr, i160 } %32)
  %34 = load ptr, ptr %26, align 8
  %result.i = call ptr %34({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #49
  %35 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6)
  %.fca.0.extract51 = extractvalue { ptr, i160 } %35, 0
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract26)
  %37 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %38 = icmp ne ptr %.fca.0.extract51, null
  %.not59 = and i1 %37, %38
  br i1 %.not59, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %5
  %.pn.lcssa = phi { ptr, i160 } [ %3, %5 ], [ %33, %._crit_edge ]
  ret { ptr, i160 } %.pn.lcssa
}

define noundef i1 @Iterable_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract19, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract20, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #60
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #60
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract18, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract36 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %30 = icmp eq ptr %.fca.0.extract36, @nil_typ
  %31 = icmp eq ptr %.fca.0.extract36, null
  %.not39.not = or i1 %30, %31
  br i1 %.not39.not, label %.critedge, label %32

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract8({ ptr, i160 } %28)
  br i1 %33, label %26, label %.critedge

.critedge:                                        ; preds = %32, %26
  ret i1 %.not39.not
}

define noundef i1 @Iterable_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract19, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract20, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #60
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #60
  %12 = sext i32 %offset.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract18, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i13, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i13 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract34 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract18)
  %30 = icmp ne ptr %.fca.0.extract34, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract34, null
  %.not37 = and i1 %30, %31
  br i1 %.not37, label %32, label %.critedge

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract8({ ptr, i160 } %28)
  br i1 %33, label %.critedge, label %26

.critedge:                                        ; preds = %32, %26
  ret i1 %.not37
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Collection_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %result.i6 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %9 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i1, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i6, i64 24
  store ptr null, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i6) #43
  store ptr @Pair, ptr %result.i6, align 8
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i1, ptr %result.i5, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i6, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #43
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 1375598993350293883
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @EnumeratedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @EnumeratedCollection) #43
  %19 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 %offset.i18, ptr %22, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 107, 3
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, { ptr } %3) #37 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store ptr %result.i2, ptr %result.i7, align 8
  %12 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %11, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 1375598993350293883
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MappedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract32, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1064) @MappedCollection) #43
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 108, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, { ptr } %3) #37 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store ptr %result.i2, ptr %result.i7, align 8
  %12 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %11, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Mapped, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract32, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef nonnull align 16 dereferenceable(520) @Mapped) #43
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 40, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #37 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %result.i7 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Filtered, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract32) #43
  %14 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract32, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Filtered) #43
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %19, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %20
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #47
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #51
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Chained, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Chained) #43
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 3037712219555723519
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Chained) #43
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #47
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #51
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 1375598993350293883
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @ChainedCollection) #43
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 1375598993350293883
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @ChainedCollection) #43
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 107, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #47
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #51
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 3037712219555723519
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Interleaved, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Interleaved) #43
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 3037712219555723519
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Interleaved) #43
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #47
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #51
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, 1375598993350293883
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %hash_coef_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleavedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection) #43
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract41, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract42, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract43, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i19, ptr %18, align 8
  %hash_coef.i35 = load i64, ptr %hash_coef_ptr.i20, align 4
  %tbl_size.i36 = load i64, ptr %tbl_size_ptr.i21, align 4
  %offset_tbl.i37 = load ptr, ptr %offset_tbl_ptr.i22, align 8
  %product.i.i38 = mul i64 %hash_coef.i35, 1375598993350293883
  %shifted.i.i39 = lshr i64 %product.i.i38, 32
  %xored.i.i40 = xor i64 %shifted.i.i39, %product.i.i38
  %hash.i.i41 = and i64 %xored.i.i40, %tbl_size.i36
  %offset_ptr.i42 = getelementptr i32, ptr %offset_tbl.i37, i64 %hash.i.i41
  %offset.i43 = load i32, ptr %offset_ptr.i42, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection) #43
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i43, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 107, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #47
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #47
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #43
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #51
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #43
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 3037712219555723519
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Zipped, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @Zipped) #43
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 3037712219555723519
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @Zipped) #43
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 41, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #47
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #47
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #43
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #51
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #43
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 1375598993350293883
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZippedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ZippedCollection) #43
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 1375598993350293883
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ZippedCollection) #43
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 109, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #47
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #47
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #43
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #51
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #43
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 1375598993350293883
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ProductCollection) #43
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 1375598993350293883
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ProductCollection) #43
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 109, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #37 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract64, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #47
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %10 = sext i32 %.fca.3.extract33 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract43, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract44) #47
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #43
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #51
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #43
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 3037712219555723519
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %hash_coef_ptr.i22 = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i23 = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i24 = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Products, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract64) #43
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract43) #43
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @Products) #43
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract64, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract65, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract66, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i21, ptr %30, align 8
  %hash_coef.i37 = load i64, ptr %hash_coef_ptr.i22, align 4
  %tbl_size.i38 = load i64, ptr %tbl_size_ptr.i23, align 4
  %offset_tbl.i39 = load ptr, ptr %offset_tbl_ptr.i24, align 8
  %product.i.i40 = mul i64 %hash_coef.i37, 3037712219555723519
  %shifted.i.i41 = lshr i64 %product.i.i40, 32
  %xored.i.i42 = xor i64 %shifted.i.i41, %product.i.i40
  %hash.i.i43 = and i64 %xored.i.i42, %tbl_size.i38
  %offset_ptr.i44 = getelementptr i32, ptr %offset_tbl.i39, i64 %hash.i.i43
  %offset.i45 = load i32, ptr %offset_ptr.i44, align 4
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @Products) #43
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract43, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract44, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract45, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i45, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 41, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6499063144389013426
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i, 3
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Products(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Products_field_Products_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Products_field_Products_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Products_field_Products_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Products_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Products_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3952308882273721422
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Products_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract103 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3952308882273721422
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract103, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract105) #45
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract66, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract68, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract70, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64) #46
  %18 = sext i32 %.fca.3.extract70 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract64, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract105) #45
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %29 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #47
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i2 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #47
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %result.i11 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %35 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %result.i2, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr null, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i11)
  store ptr @Pair, ptr %result.i11, align 8
  %result.i10 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_wrapper(i64 noundef 152) #51
  store ptr %result.i3, ptr %result.i10, align 8
  %39 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %result.i11, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(152) %result.i10)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract105) #45
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract29, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract31, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract33, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract27)
  %52 = sext i32 %.fca.3.extract33 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract27, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract105) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Productizer, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr undef, 2
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer) #43
  %69 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.0.extract19, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.1.extract21, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store ptr %.fca.2.extract23, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %result.i10, i64 48
  store i32 %offset.i23, ptr %72, align 8
  %hash_coef.i17.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i18.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i19.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i20.i = mul i64 %hash_coef.i17.i, 3037712219555723519
  %shifted.i.i21.i = lshr i64 %product.i.i20.i, 32
  %xored.i.i22.i = xor i64 %shifted.i.i21.i, %product.i.i20.i
  %hash.i.i23.i = and i64 %xored.i.i22.i, %tbl_size.i18.i
  %offset_ptr.i24.i = getelementptr i32, ptr %offset_tbl.i19.i, i64 %hash.i.i23.i
  %offset.i25.i = load i32, ptr %offset_ptr.i24.i, align 4
  %73 = getelementptr inbounds i8, ptr %result.i10, i64 88
  store ptr %.fca.0.extract, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %result.i10, i64 96
  store ptr %.fca.1.extract, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %result.i10, i64 104
  store ptr %.fca.2.extract, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i10, i64 112
  store i32 %offset.i25.i, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer) #46
  %78 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %offset.i25.i, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %81 = sext i32 %offset.i25.i to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  %result.i1.i = call ptr %84({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %85 = call { ptr, ptr, ptr, i32 } %result.i1.i({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %4)
  %.fca.0.extract11.i = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract13.i = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract15.i = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %hash_coef_ptr.i26.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 8
  %tbl_size_ptr.i27.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 16
  %offset_tbl_ptr.i28.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 40
  %hash_coef.i29.i = load i64, ptr %hash_coef_ptr.i26.i, align 4
  %tbl_size.i30.i = load i64, ptr %tbl_size_ptr.i27.i, align 4
  %offset_tbl.i31.i = load ptr, ptr %offset_tbl_ptr.i28.i, align 8
  %product.i.i32.i = mul i64 %hash_coef.i29.i, 8673632051301757104
  %shifted.i.i33.i = lshr i64 %product.i.i32.i, 32
  %xored.i.i34.i = xor i64 %shifted.i.i33.i, %product.i.i32.i
  %hash.i.i35.i = and i64 %xored.i.i34.i, %tbl_size.i30.i
  %offset_ptr.i36.i = getelementptr i32, ptr %offset_tbl.i31.i, i64 %hash.i.i35.i
  %offset.i37.i = load i32, ptr %offset_ptr.i36.i, align 4
  %86 = getelementptr inbounds i8, ptr %result.i10, i64 56
  store ptr %.fca.0.extract11.i, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i10, i64 64
  store ptr %.fca.1.extract13.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i10, i64 72
  store ptr %.fca.2.extract15.i, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i10, i64 80
  store i32 %offset.i37.i, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer)
  %91 = load ptr, ptr %69, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %70, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %71, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %72, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %result.i.i = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %105 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %4)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer)
  %107 = getelementptr inbounds i8, ptr %result.i10, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %105, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %105, 1
  store ptr %.fca.0.extract.i, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %result.i10, i64 128
  store i160 %.fca.1.extract.i, ptr %108, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %109 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %109
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Iterable_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %result.i6 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %9 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i1, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i6, i64 24
  store ptr null, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i6) #43
  store ptr @Pair, ptr %result.i6, align 8
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i1, ptr %result.i5, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i6, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #43
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 3037712219555723519
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerated, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Enumerated) #43
  %19 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 %offset.i18, ptr %22, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumerated(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerated_field_Enumerated_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerated_field_Enumerated_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerated_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Enumerated_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6044713360068526275
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Enumerated_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6044713360068526275
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract63, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract65) #45
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract39) #46
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i5 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %24 = load ptr, ptr %7, align 8
  %result.i1 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #47
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %result.i8 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %26 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i1, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr null, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i8)
  store ptr @Pair, ptr %result.i8, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store ptr %result.i1, ptr %result.i7, align 8
  %30 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i8, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %33 = load ptr, ptr %8, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr nonnull %.fca.1.extract65) #45
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract15, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract16, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %.fca.3.extract17, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract14)
  %42 = sext i32 %.fca.3.extract17 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract14, i64 %42
  %44 = getelementptr i8, ptr %43, i64 8
  %45 = load ptr, ptr %44, align 8
  %result.i4 = call ptr %45({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %46 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 2
  %hash_coef_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i12 = load i64, ptr %hash_coef_ptr.i9, align 4
  %tbl_size.i13 = load i64, ptr %tbl_size_ptr.i10, align 4
  %offset_tbl.i14 = load ptr, ptr %offset_tbl_ptr.i11, align 8
  %product.i.i15 = mul i64 %hash_coef.i12, 8673632051301757104
  %shifted.i.i16 = lshr i64 %product.i.i15, 32
  %xored.i.i17 = xor i64 %shifted.i.i16, %product.i.i15
  %hash.i.i18 = and i64 %xored.i.i17, %tbl_size.i13
  %offset_ptr.i19 = getelementptr i32, ptr %offset_tbl.i14, i64 %hash.i.i18
  %offset.i20 = load i32, ptr %offset_ptr.i19, align 4
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %50 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i20, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator) #46
  %55 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store i32 0, ptr %55, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %56
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumerator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Enumerator_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -3435222131909153872
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %15) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #46
  %17 = getelementptr i8, ptr %7, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract18, i32 0) #44
  ret void
}

define { ptr, i160 } @Enumerator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -3435222131909153872
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract33) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract33, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract35) #45
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i4 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, i160 } %result.i4({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract33)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not62 = and i1 %24, %25
  br i1 %.not62, label %26, label %75

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr nonnull %.fca.1.extract35) #45
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %33 = call i32 %30(ptr nonnull %.fca.1.extract35) #45
  %34 = add i32 %33, 1
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %36 = getelementptr i8, ptr %29, i64 8
  %37 = load ptr, ptr %36, align 8
  call void %37(ptr nonnull %.fca.1.extract35, i32 %34) #44
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %39 = load ptr, ptr %7, align 8
  %result.i1 = call align 8 ptr %39(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #47
  %40 = load ptr, ptr %result.i1, align 8, !alias.scope !18
  %41 = getelementptr i8, ptr %40, i64 72
  %42 = load ptr, ptr %41, align 8, !alias.scope !18
  %result.i.i = call { i64, i64 } %42(ptr nocapture nofree nonnull readonly align 8 %result.i1) #47, !alias.scope !18
  %43 = extractvalue { i64, i64 } %result.i.i, 0
  %44 = extractvalue { i64, i64 } %result.i.i, 1
  %45 = call i64 @llvm.umax.i64(i64 %44, i64 noundef 8), !range !5
  %46 = urem i64 20, %44
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %44, %46
  %49 = select i1 %47, i64 0, i64 %48
  %50 = add i64 %43, 20
  %51 = add i64 %50, %49
  %52 = urem i64 %51, %45
  %53 = icmp eq i64 %52, 0
  %54 = sub i64 %45, %52
  %55 = select i1 %53, i64 0, i64 %54
  %56 = add i64 %55, %51
  %result.i5 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %56) #51
  store ptr @_parameterization_i32, ptr %result.i5, align 8
  %57 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i1, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i5)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %60 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store i32 %31, ptr %60, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Pair) #46
  %62 = load ptr, ptr %result.i1, align 8
  %63 = getelementptr i8, ptr %62, i64 72
  %64 = load ptr, ptr %63, align 8
  %result.i.i8 = call { i64, i64 } %64(ptr nocapture nofree nonnull readonly align 8 %result.i1) #47
  %65 = extractvalue { i64, i64 } %result.i.i8, 1
  %66 = urem i64 20, %65
  %67 = icmp eq i64 %66, 0
  %68 = sub i64 %65, %66
  %69 = select i1 %67, i64 0, i64 %68
  %70 = getelementptr inbounds i8, ptr %result.i5, i64 20
  %71 = getelementptr i8, ptr %70, i64 %69
  %72 = getelementptr i8, ptr %62, i64 64
  %73 = load ptr, ptr %72, align 8
  call void %73({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly align 8 %result.i1, ptr nocapture nofree writeonly %71) #48
  %74 = ptrtoint ptr %result.i5 to i64
  %.sroa.351.8.insert.ext = zext i64 %74 to i160
  %.sroa.351.8.insert.insert = or disjoint i160 %.sroa.351.8.insert.ext, 3402823669209384634633746074317682114560
  br label %75

75:                                               ; preds = %26, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @Pair, %26 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.351.8.insert.insert, %26 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #38 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #47
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #47
  %20 = extractvalue { i64, i64 } %result.i, 0
  %21 = extractvalue { i64, i64 } %result.i, 1
  %22 = call i64 @llvm.umax.i64(i64 %8, i64 %21) #61
  %23 = call i64 @llvm.umax.i64(i64 %22, i64 noundef 8) #61, !range !5
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %33, %29
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i32, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i32 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i32_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(4) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  store i32 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readnone %0, ptr nocapture nofree readnone %1) #1 {
  ret { ptr, i160 } { ptr @nil_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nil_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree readnone %2) #1 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Enumerator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumerator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumerated_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerated_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Productizer(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Productizer_B_init_first_iteratorIteratorT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Productizer_field_Productizer_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Productizer_field_Productizer_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Productizer_field_Productizer_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Productizer_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Productizer_init_first_iteratorIteratorT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #17 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract92 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract94 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract92, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract92, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract92, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4237829454682536209
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract61 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract63 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract65 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract61, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract61, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract61, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 8673632051301757104
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract92, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract61, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract63, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract65, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i13, 3
  call void %13(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %17) #44
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract39, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract39, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract39, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 3037712219555723519
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92) #46
  %19 = getelementptr i8, ptr %9, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract41, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract43, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i25, 3
  call void %22(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %26) #44
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92) #46
  %28 = load ptr, ptr %19, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr, ptr, ptr, i32 } %29(ptr %.fca.1.extract94) #45
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %30, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %30, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %30, 2
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %30, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract23, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract25, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %.fca.3.extract27, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #46
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract21) #46
  %37 = sext i32 %.fca.3.extract27 to i64
  %38 = getelementptr ptr, ptr %.fca.0.extract21, i64 %37
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %result.i1 = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %41 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %6)
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i29 = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i30 = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i31 = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i32 = mul i64 %hash_coef.i29, 8673632051301757104
  %shifted.i.i33 = lshr i64 %product.i.i32, 32
  %xored.i.i34 = xor i64 %shifted.i.i33, %product.i.i32
  %hash.i.i35 = and i64 %xored.i.i34, %tbl_size.i30
  %offset_ptr.i36 = getelementptr i32, ptr %offset_tbl.i31, i64 %hash.i.i35
  %offset.i37 = load i32, ptr %offset_ptr.i36, align 4
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92)
  %43 = getelementptr i8, ptr %9, i64 32
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract13, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract15, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i37, 3
  call void %46(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %50) #44
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92)
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract94) #45
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.1.extract2, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.2.extract, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %.fca.3.extract, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %61 = sext i32 %.fca.3.extract to i64
  %62 = getelementptr ptr, ptr %.fca.0.extract1, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %result.i = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %65 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %6)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract92)
  %67 = getelementptr i8, ptr %9, i64 48
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %.fca.1.extract94, { ptr, i160 } %65) #44
  ret void
}

define { ptr, i160 } @Productizer_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4237829454682536209
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract47) #60
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract47, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract48) #45
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract47)
  %13 = getelementptr i8, ptr %7, i64 32
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = getelementptr i8, ptr %7, i64 24
  %16 = getelementptr i8, ptr %7, i64 40
  %.056 = extractvalue { ptr, i160 } %11, 0
  %17 = icmp ne ptr %.056, @nil_typ
  %18 = icmp ne ptr %.056, null
  %.not13257 = and i1 %17, %18
  br i1 %.not13257, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  br label %20

20:                                               ; preds = %39, %.lr.ph
  %.pn58 = phi { ptr, i160 } [ %11, %.lr.ph ], [ %84, %39 ]
  %21 = load ptr, ptr %13, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call { ptr, ptr, ptr, i32 } %22(ptr %.fca.1.extract48) #45
  %.fca.0.extract113 = extractvalue { ptr, ptr, ptr, i32 } %23, 0
  %.fca.1.extract115 = extractvalue { ptr, ptr, ptr, i32 } %23, 1
  %.fca.2.extract117 = extractvalue { ptr, ptr, ptr, i32 } %23, 2
  %.fca.3.extract119 = extractvalue { ptr, ptr, ptr, i32 } %23, 3
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract113, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract115, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract117, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %.fca.3.extract119, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract113)
  %30 = sext i32 %.fca.3.extract119 to i64
  %31 = getelementptr ptr, ptr %.fca.0.extract113, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %result.i8 = call ptr %33({ ptr, ptr, ptr, i32 } %27, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %34 = call { ptr, i160 } %result.i8({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4)
  %.fca.0.extract106 = extractvalue { ptr, i160 } %34, 0
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %36 = icmp eq ptr %.fca.0.extract106, @nil_typ
  %37 = icmp eq ptr %.fca.0.extract106, null
  %.not134.not = or i1 %36, %37
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  br i1 %.not134.not, label %39, label %87

39:                                               ; preds = %20
  %40 = load ptr, ptr %15, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract48) #45
  %.fca.0.extract87 = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract89 = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract91 = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract93 = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract87, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract89, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract91, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract93, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract87)
  %49 = sext i32 %.fca.3.extract93 to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract87, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i7 = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %53 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %55 = load ptr, ptr %8, align 8
  %56 = getelementptr i8, ptr %55, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %.fca.1.extract48, { ptr, i160 } %53) #44
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %59 = load ptr, ptr %16, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %.fca.1.extract48) #45
  %.fca.0.extract77 = extractvalue { ptr, ptr, ptr, i32 } %61, 0
  %.fca.1.extract78 = extractvalue { ptr, ptr, ptr, i32 } %61, 1
  %.fca.2.extract79 = extractvalue { ptr, ptr, ptr, i32 } %61, 2
  %.fca.3.extract80 = extractvalue { ptr, ptr, ptr, i32 } %61, 3
  %62 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract77, 0
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.1.extract78, 1
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %.fca.2.extract79, 2
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 %.fca.3.extract80, 3
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract77)
  %68 = sext i32 %.fca.3.extract80 to i64
  %69 = getelementptr ptr, ptr %.fca.0.extract77, i64 %68
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  %result.i6 = call ptr %71({ ptr, ptr, ptr, i32 } %65, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %72 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } %65, ptr nonnull align 8 %4)
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %72, 0
  %.fca.1.extract70 = extractvalue { ptr, ptr, ptr, i32 } %72, 1
  %.fca.2.extract71 = extractvalue { ptr, ptr, ptr, i32 } %72, 2
  %hash_coef_ptr.i10 = getelementptr i8, ptr %.fca.0.extract69, i64 8
  %tbl_size_ptr.i11 = getelementptr i8, ptr %.fca.0.extract69, i64 16
  %offset_tbl_ptr.i12 = getelementptr i8, ptr %.fca.0.extract69, i64 40
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i10, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i11, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i12, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 8673632051301757104
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %74 = load ptr, ptr %13, align 8
  %75 = getelementptr i8, ptr %74, i64 8
  %76 = load ptr, ptr %75, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.fca.1.extract70, 1
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %.fca.2.extract71, 2
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 %offset.i21, 3
  call void %76(ptr %.fca.1.extract48, { ptr, ptr, ptr, i32 } %80) #44
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %82 = load ptr, ptr %8, align 8
  %83 = load ptr, ptr %82, align 8
  %84 = call { ptr, i160 } %83(ptr %.fca.1.extract48) #45
  %.0 = extractvalue { ptr, i160 } %84, 0
  %85 = icmp ne ptr %.0, @nil_typ
  %86 = icmp ne ptr %.0, null
  %.not132 = and i1 %85, %86
  br i1 %.not132, label %20, label %.loopexit

87:                                               ; preds = %20
  %88 = load ptr, ptr %7, align 8
  %result.i3 = call align 8 ptr %88(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #47
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %90 = load ptr, ptr %14, align 8
  %result.i2 = call align 8 ptr %90(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #47
  %91 = load ptr, ptr %result.i3, align 8, !alias.scope !21
  %92 = getelementptr i8, ptr %91, i64 72
  %93 = load ptr, ptr %92, align 8, !alias.scope !21
  %result.i1.i = call { i64, i64 } %93(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47, !alias.scope !21
  %94 = extractvalue { i64, i64 } %result.i1.i, 0
  %95 = extractvalue { i64, i64 } %result.i1.i, 1
  %96 = urem i64 16, %95
  %97 = icmp eq i64 %96, 0
  %98 = sub i64 %95, %96
  %99 = select i1 %97, i64 0, i64 %98
  %100 = add i64 %94, 16
  %101 = add i64 %100, %99
  %102 = load ptr, ptr %result.i2, align 8, !alias.scope !21
  %103 = getelementptr i8, ptr %102, i64 72
  %104 = load ptr, ptr %103, align 8, !alias.scope !21
  %result.i.i = call { i64, i64 } %104(ptr nocapture nofree nonnull readonly align 8 %result.i2) #47, !alias.scope !21
  %105 = extractvalue { i64, i64 } %result.i.i, 0
  %106 = extractvalue { i64, i64 } %result.i.i, 1
  %107 = call i64 @llvm.umax.i64(i64 %95, i64 %106) #61
  %108 = call i64 @llvm.umax.i64(i64 %107, i64 noundef 8) #61, !range !5
  %109 = urem i64 %101, %106
  %110 = icmp eq i64 %109, 0
  %111 = sub i64 %106, %109
  %112 = select i1 %110, i64 0, i64 %111
  %113 = add i64 %105, %101
  %114 = add i64 %113, %112
  %115 = urem i64 %114, %108
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %108, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = add i64 %118, %114
  %result.i9 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %119) #51
  store ptr %result.i3, ptr %result.i9, align 8
  %120 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i2, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i9)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract47)
  %124 = load ptr, ptr %result.i3, align 8
  %125 = getelementptr i8, ptr %124, i64 72
  %126 = load ptr, ptr %125, align 8
  %result.i.i69 = call { i64, i64 } %126(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47
  %127 = extractvalue { i64, i64 } %result.i.i69, 1
  %128 = urem i64 16, %127
  %129 = icmp eq i64 %128, 0
  %reass.sub86 = sub i64 %127, %128
  %130 = add i64 %reass.sub86, 16
  %131 = select i1 %129, i64 16, i64 %130
  %132 = getelementptr i8, ptr %result.i9, i64 %131
  %133 = getelementptr i8, ptr %124, i64 64
  %134 = load ptr, ptr %133, align 8
  call void %134({ ptr, i160 } %.pn58, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %132) #48
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Pair) #46
  %136 = load ptr, ptr %result.i9, align 8
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr i8, ptr %137, i64 72
  %139 = load ptr, ptr %138, align 8
  %result.i1.i70 = call { i64, i64 } %139(ptr nocapture nofree nonnull readonly align 8 %136) #47
  %140 = extractvalue { i64, i64 } %result.i1.i70, 0
  %141 = extractvalue { i64, i64 } %result.i1.i70, 1
  %142 = urem i64 16, %141
  %143 = icmp eq i64 %142, 0
  %144 = sub i64 %141, %142
  %145 = select i1 %143, i64 0, i64 %144
  %146 = add i64 %140, 16
  %147 = add i64 %146, %145
  %148 = load ptr, ptr %120, align 8
  %149 = load ptr, ptr %148, align 8
  %150 = getelementptr i8, ptr %149, i64 72
  %151 = load ptr, ptr %150, align 8
  %result.i.i71 = call { i64, i64 } %151(ptr nocapture nofree nonnull readonly align 8 %148) #47
  %152 = extractvalue { i64, i64 } %result.i.i71, 1
  %153 = urem i64 %147, %152
  %154 = icmp eq i64 %153, 0
  %155 = sub i64 %152, %153
  %156 = select i1 %154, i64 0, i64 %155
  %157 = getelementptr i8, ptr %result.i9, i64 %147
  %158 = getelementptr i8, ptr %157, i64 %156
  %159 = getelementptr i8, ptr %149, i64 64
  %160 = load ptr, ptr %159, align 8
  call void %160({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly align 8 %148, ptr nocapture nofree writeonly %158) #48
  %161 = ptrtoint ptr %result.i9 to i64
  %.sroa.3.8.insert.ext = zext i64 %161 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.loopexit

.loopexit:                                        ; preds = %87, %39, %3
  %.reg2mem12.sroa.0.0 = phi ptr [ @Pair, %87 ], [ @nil_typ, %3 ], [ @nil_typ, %39 ]
  %.reg2mem12.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %87 ], [ undef, %3 ], [ undef, %39 ]
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem12.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.reg2mem12.sroa.3.0, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @Productizer_getter_current_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 8
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Productizer_setter_current_first(ptr nocapture nofree writeonly align 8 %0, { ptr, i160 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Productizer_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Productizer_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Productizer_getter_second_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Productizer_setter_second_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Productizer_getter_first_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Productizer_setter_first_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Products_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Products_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Products_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Products_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B__set_first_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B__set_second_valueU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #45
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #45
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair__set_first_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #5 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract8, { ptr, i160 } %3) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair__set_second_valueU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #5 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract8, { ptr, i160 } %3) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9197944775169318296
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract19, { ptr, i160 } %3) #44
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #46
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract19, { ptr, i160 } %4) #44
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_second(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #38 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i1 = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #47
  %6 = extractvalue { i64, i64 } %result.i1, 0
  %7 = extractvalue { i64, i64 } %result.i1, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 16
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %15) #47
  %19 = extractvalue { i64, i64 } %result.i, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly align 8 %15) #47
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_second(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #39 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #47
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #47
  %20 = extractvalue { i64, i64 } %result.i, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %16, ptr nocapture nofree writeonly %26) #48
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_first(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #38 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #47
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 16, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 16
  %10 = select i1 %8, i64 16, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly align 8 %2) #47
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_first(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #39 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #47
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %3, ptr nocapture nofree writeonly %12) #48
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 29, i64 30
  %8 = getelementptr [124 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 38, i64 39
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -310975631771072937
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define i32 @ProductCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -310975631771072937
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract19) #45
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract3) #46
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract17)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract19) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = mul i32 %38, %22
  ret i32 %39
}

define { ptr, ptr, ptr, i32 } @ProductCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract103 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract103, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -310975631771072937
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract103, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract105) #45
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract66, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract68, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract70, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64) #46
  %18 = sext i32 %.fca.3.extract70 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract64, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract105) #45
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %29 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #47
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i2 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract105) #47
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %result.i11 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %35 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %result.i2, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr null, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i11)
  store ptr @Pair, ptr %result.i11, align 8
  %result.i10 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_wrapper(i64 noundef 152) #51
  store ptr %result.i3, ptr %result.i10, align 8
  %39 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %result.i11, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(152) %result.i10)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract105) #45
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract29, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract31, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract33, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract27)
  %52 = sext i32 %.fca.3.extract33 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract27, i64 %52
  %54 = getelementptr i8, ptr %53, i64 24
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract105) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Productizer, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr undef, 2
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract103)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer) #43
  %69 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.0.extract19, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.1.extract21, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store ptr %.fca.2.extract23, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %result.i10, i64 48
  store i32 %offset.i23, ptr %72, align 8
  %hash_coef.i17.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i18.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i19.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i20.i = mul i64 %hash_coef.i17.i, 3037712219555723519
  %shifted.i.i21.i = lshr i64 %product.i.i20.i, 32
  %xored.i.i22.i = xor i64 %shifted.i.i21.i, %product.i.i20.i
  %hash.i.i23.i = and i64 %xored.i.i22.i, %tbl_size.i18.i
  %offset_ptr.i24.i = getelementptr i32, ptr %offset_tbl.i19.i, i64 %hash.i.i23.i
  %offset.i25.i = load i32, ptr %offset_ptr.i24.i, align 4
  %73 = getelementptr inbounds i8, ptr %result.i10, i64 88
  store ptr %.fca.0.extract, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %result.i10, i64 96
  store ptr %.fca.1.extract, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %result.i10, i64 104
  store ptr %.fca.2.extract, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i10, i64 112
  store i32 %offset.i25.i, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer) #46
  %78 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %offset.i25.i, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %81 = sext i32 %offset.i25.i to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  %result.i1.i = call ptr %84({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %85 = call { ptr, ptr, ptr, i32 } %result.i1.i({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %4)
  %.fca.0.extract11.i = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract13.i = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract15.i = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %hash_coef_ptr.i26.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 8
  %tbl_size_ptr.i27.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 16
  %offset_tbl_ptr.i28.i = getelementptr i8, ptr %.fca.0.extract11.i, i64 40
  %hash_coef.i29.i = load i64, ptr %hash_coef_ptr.i26.i, align 4
  %tbl_size.i30.i = load i64, ptr %tbl_size_ptr.i27.i, align 4
  %offset_tbl.i31.i = load ptr, ptr %offset_tbl_ptr.i28.i, align 8
  %product.i.i32.i = mul i64 %hash_coef.i29.i, 8673632051301757104
  %shifted.i.i33.i = lshr i64 %product.i.i32.i, 32
  %xored.i.i34.i = xor i64 %shifted.i.i33.i, %product.i.i32.i
  %hash.i.i35.i = and i64 %xored.i.i34.i, %tbl_size.i30.i
  %offset_ptr.i36.i = getelementptr i32, ptr %offset_tbl.i31.i, i64 %hash.i.i35.i
  %offset.i37.i = load i32, ptr %offset_ptr.i36.i, align 4
  %86 = getelementptr inbounds i8, ptr %result.i10, i64 56
  store ptr %.fca.0.extract11.i, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i10, i64 64
  store ptr %.fca.1.extract13.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i10, i64 72
  store ptr %.fca.2.extract15.i, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i10, i64 80
  store i32 %offset.i37.i, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer)
  %91 = load ptr, ptr %69, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %70, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %71, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %72, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %result.i.i = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %105 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %4)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Productizer)
  %107 = getelementptr inbounds i8, ptr %result.i10, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %105, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %105, 1
  store ptr %.fca.0.extract.i, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %result.i10, i64 128
  store i160 %.fca.1.extract.i, ptr %108, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %109 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %109
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_function_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_function_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Collection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZippedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 29, i64 30
  %8 = getelementptr [124 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 37, i64 36
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 38, i64 39
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [124 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZippedCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 880335312586431241
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define i32 @ZippedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 880335312586431241
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract20, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract22) #45
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract7, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract9, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract11, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract5) #46
  %18 = sext i32 %.fca.3.extract11 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract5, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract20)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract22) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %.sroa.speculated = call i32 @llvm.smin.i32(i32 %22, i32 %38)
  ret i32 %.sroa.speculated
}

define { ptr, ptr, ptr, i32 } @ZippedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract129 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract131 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 880335312586431241
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract129, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract131) #45
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract90) #46
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i9 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i9({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract131) #45
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %result.i8 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %40 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #47
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #47
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %result.i13 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %46 = getelementptr inbounds i8, ptr %result.i13, i64 16
  store ptr %result.i2, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i13, i64 8
  store ptr %result.i3, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i13, i64 24
  store ptr null, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i13)
  store ptr @Pair, ptr %result.i13, align 8
  %result.i12 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #51
  store ptr %result.i3, ptr %result.i12, align 8
  %50 = getelementptr inbounds i8, ptr %result.i12, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i12, i64 16
  store ptr %result.i13, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i12)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr nonnull %.fca.1.extract131) #45
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %56, 3
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract42, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract44, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %.fca.3.extract46, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract40)
  %63 = sext i32 %.fca.3.extract46 to i64
  %64 = getelementptr ptr, ptr %.fca.0.extract40, i64 %63
  %65 = getelementptr i8, ptr %64, i64 24
  %66 = load ptr, ptr %65, align 8
  %result.i7 = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %67 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %69 = load ptr, ptr %24, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr, ptr, ptr, i32 } %70(ptr nonnull %.fca.1.extract131) #45
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %71, 3
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.1.extract20, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.2.extract21, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %.fca.3.extract22, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract19)
  %78 = sext i32 %.fca.3.extract22 to i64
  %79 = getelementptr ptr, ptr %.fca.0.extract19, i64 %78
  %80 = getelementptr i8, ptr %79, i64 24
  %81 = load ptr, ptr %80, align 8
  %result.i6 = call ptr %81({ ptr, ptr, ptr, i32 } %75, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %82 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 8673632051301757104
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %83 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Zipper, ptr undef, ptr undef, i32 undef }, ptr %result.i12, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr undef, 2
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @Zipper) #43
  %88 = getelementptr inbounds i8, ptr %result.i12, i64 24
  store ptr %.fca.0.extract28, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i12, i64 32
  store ptr %.fca.1.extract30, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i12, i64 40
  store ptr %.fca.2.extract32, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i12, i64 48
  store i32 %offset.i25, ptr %91, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @Zipper) #46
  %93 = getelementptr inbounds i8, ptr %result.i12, i64 56
  store ptr %.fca.0.extract, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i12, i64 64
  store ptr %.fca.1.extract, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i12, i64 72
  store ptr %.fca.2.extract, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %result.i12, i64 80
  store i32 %offset.i24.i, ptr %96, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Zipper(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Zipper_field_Zipper_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Zipper_field_Zipper_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Zipper_field_Zipper_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipper_B_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipper_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Zipper_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -502732402311247874
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 8673632051301757104
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define { ptr, i160 } @Zipper_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract46, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -502732402311247874
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract46) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract46, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract48) #45
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract18 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract12, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract14, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract16, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract18, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract12) #46
  %18 = sext i32 %.fca.3.extract18 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract12, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract5 = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract46)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract48) #45
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract4, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract3)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract3, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i6 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, i160 } %result.i6({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = icmp eq ptr %.fca.0.extract5, @nil_typ
  %40 = icmp eq ptr %.fca.0.extract5, null
  %41 = or i1 %39, %40
  br i1 %41, label %.critedge, label %42

42:                                               ; preds = %3
  %.fca.0.extract = extractvalue { ptr, i160 } %38, 0
  %43 = icmp eq ptr %.fca.0.extract, @nil_typ
  %44 = icmp eq ptr %.fca.0.extract, null
  %45 = or i1 %43, %44
  br i1 %45, label %.critedge, label %46

46:                                               ; preds = %42
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %48 = load ptr, ptr %7, align 8
  %result.i3 = call align 8 ptr %48(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #47
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %50 = getelementptr i8, ptr %7, i64 8
  %51 = load ptr, ptr %50, align 8
  %result.i2 = call align 8 ptr %51(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #47
  %52 = load ptr, ptr %result.i3, align 8, !alias.scope !24
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8, !alias.scope !24
  %result.i1.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47, !alias.scope !24
  %55 = extractvalue { i64, i64 } %result.i1.i, 0
  %56 = extractvalue { i64, i64 } %result.i1.i, 1
  %57 = urem i64 16, %56
  %58 = icmp eq i64 %57, 0
  %59 = sub i64 %56, %57
  %60 = select i1 %58, i64 0, i64 %59
  %61 = add i64 %55, 16
  %62 = add i64 %61, %60
  %63 = load ptr, ptr %result.i2, align 8, !alias.scope !24
  %64 = getelementptr i8, ptr %63, i64 72
  %65 = load ptr, ptr %64, align 8, !alias.scope !24
  %result.i.i = call { i64, i64 } %65(ptr nocapture nofree nonnull readonly align 8 %result.i2) #47, !alias.scope !24
  %66 = extractvalue { i64, i64 } %result.i.i, 0
  %67 = extractvalue { i64, i64 } %result.i.i, 1
  %68 = call i64 @llvm.umax.i64(i64 %56, i64 %67) #61
  %69 = call i64 @llvm.umax.i64(i64 %68, i64 noundef 8) #61, !range !5
  %70 = urem i64 %62, %67
  %71 = icmp eq i64 %70, 0
  %72 = sub i64 %67, %70
  %73 = select i1 %71, i64 0, i64 %72
  %74 = add i64 %66, %62
  %75 = add i64 %74, %73
  %76 = urem i64 %75, %69
  %77 = icmp eq i64 %76, 0
  %78 = sub i64 %69, %76
  %79 = select i1 %77, i64 0, i64 %78
  %80 = add i64 %79, %75
  %result.i8 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %80) #51
  store ptr %result.i3, ptr %result.i8, align 8
  %81 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i8)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract46)
  %85 = load ptr, ptr %result.i3, align 8
  %86 = getelementptr i8, ptr %85, i64 72
  %87 = load ptr, ptr %86, align 8
  %result.i.i14 = call { i64, i64 } %87(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47
  %88 = extractvalue { i64, i64 } %result.i.i14, 1
  %89 = urem i64 16, %88
  %90 = icmp eq i64 %89, 0
  %reass.sub17 = sub i64 %88, %89
  %91 = add i64 %reass.sub17, 16
  %92 = select i1 %90, i64 16, i64 %91
  %93 = getelementptr i8, ptr %result.i8, i64 %92
  %94 = getelementptr i8, ptr %85, i64 64
  %95 = load ptr, ptr %94, align 8
  call void %95({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %93) #48
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Pair) #46
  %97 = load ptr, ptr %result.i8, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i1.i15 = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly align 8 %97) #47
  %101 = extractvalue { i64, i64 } %result.i1.i15, 0
  %102 = extractvalue { i64, i64 } %result.i1.i15, 1
  %103 = urem i64 16, %102
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %102, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %101, 16
  %108 = add i64 %107, %106
  %109 = load ptr, ptr %81, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i.i16 = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly align 8 %109) #47
  %113 = extractvalue { i64, i64 } %result.i.i16, 1
  %114 = urem i64 %108, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = getelementptr i8, ptr %result.i8, i64 %108
  %119 = getelementptr i8, ptr %118, i64 %117
  %120 = getelementptr i8, ptr %110, i64 64
  %121 = load ptr, ptr %120, align 8
  call void %121({ ptr, i160 } %38, ptr nocapture nofree nonnull readonly align 8 %109, ptr nocapture nofree writeonly %119) #48
  %122 = ptrtoint ptr %result.i8 to i64
  %.sroa.361.8.insert.ext = zext i64 %122 to i160
  %.sroa.361.8.insert.insert = or disjoint i160 %.sroa.361.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.critedge

.critedge:                                        ; preds = %46, %42, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @Pair, %46 ], [ @nil_typ, %42 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.361.8.insert.insert, %46 ], [ undef, %42 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Zipper_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Zipper_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Zipper_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Zipper_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #9

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Zipped(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Zipped_field_Zipped_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Zipped_field_Zipped_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Zipped_field_Zipped_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Zipped_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Zipped_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7357168971761641759
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Zipped_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract129 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract131 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract129, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7357168971761641759
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract129, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract131) #45
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract90) #46
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i9 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i9({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract131) #45
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i8 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %40 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #47
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract131) #47
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %result.i13 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %46 = getelementptr inbounds i8, ptr %result.i13, i64 16
  store ptr %result.i2, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i13, i64 8
  store ptr %result.i3, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i13, i64 24
  store ptr null, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i13)
  store ptr @Pair, ptr %result.i13, align 8
  %result.i12 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #51
  store ptr %result.i3, ptr %result.i12, align 8
  %50 = getelementptr inbounds i8, ptr %result.i12, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i12, i64 16
  store ptr %result.i13, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i12)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr nonnull %.fca.1.extract131) #45
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %56, 3
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract42, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract44, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %.fca.3.extract46, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract40)
  %63 = sext i32 %.fca.3.extract46 to i64
  %64 = getelementptr ptr, ptr %.fca.0.extract40, i64 %63
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %result.i7 = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %67 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %69 = load ptr, ptr %24, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr, ptr, ptr, i32 } %70(ptr nonnull %.fca.1.extract131) #45
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %71, 3
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.1.extract20, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.2.extract21, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %.fca.3.extract22, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract19)
  %78 = sext i32 %.fca.3.extract22 to i64
  %79 = getelementptr ptr, ptr %.fca.0.extract19, i64 %78
  %80 = getelementptr i8, ptr %79, i64 8
  %81 = load ptr, ptr %80, align 8
  %result.i6 = call ptr %81({ ptr, ptr, ptr, i32 } %75, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %82 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 2
  %hash_coef_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i15 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i16 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i17 = load i64, ptr %hash_coef_ptr.i14, align 4
  %tbl_size.i18 = load i64, ptr %tbl_size_ptr.i15, align 4
  %offset_tbl.i19 = load ptr, ptr %offset_tbl_ptr.i16, align 8
  %product.i.i20 = mul i64 %hash_coef.i17, 8673632051301757104
  %shifted.i.i21 = lshr i64 %product.i.i20, 32
  %xored.i.i22 = xor i64 %shifted.i.i21, %product.i.i20
  %hash.i.i23 = and i64 %xored.i.i22, %tbl_size.i18
  %offset_ptr.i24 = getelementptr i32, ptr %offset_tbl.i19, i64 %hash.i.i23
  %offset.i25 = load i32, ptr %offset_ptr.i24, align 4
  %hash_coef_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i27 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i28 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %83 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Zipper, ptr undef, ptr undef, i32 undef }, ptr %result.i12, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr undef, 2
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract129)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @Zipper) #43
  %88 = getelementptr inbounds i8, ptr %result.i12, i64 24
  store ptr %.fca.0.extract28, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i12, i64 32
  store ptr %.fca.1.extract30, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i12, i64 40
  store ptr %.fca.2.extract32, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i12, i64 48
  store i32 %offset.i25, ptr %91, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i26, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i27, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i28, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @Zipper) #46
  %93 = getelementptr inbounds i8, ptr %result.i12, i64 56
  store ptr %.fca.0.extract, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i12, i64 64
  store ptr %.fca.1.extract, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i12, i64 72
  store ptr %.fca.2.extract, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %result.i12, i64 80
  store i32 %offset.i24.i, ptr %96, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Zipped_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Zipped_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Zipped_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Zipped_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleavedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleavedCollection_field_InterleavedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 28, i64 27
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 36, i64 37
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleavedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8589355597059143861
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define i32 @InterleavedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8589355597059143861
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract19) #45
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract3) #46
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract19) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = add i32 %38, %22
  ret i32 %39
}

define { ptr, ptr, ptr, i32 } @InterleavedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 8589355597059143861
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #45
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract90) #46
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #45
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #47
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #51
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 24
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 24
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Interleaver, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Interleaver) #43
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Interleaver) #46
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Interleaver(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Interleaver_field_Interleaver_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaver_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaver_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Interleaver_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -325516585209011365
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract38, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract21, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract22, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 8673632051301757104
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %25) #44
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #46
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract39, i1 true) #44
  ret void
}

define { ptr, i160 } @Interleaver_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -325516585209011365
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract32, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i1 %10(ptr %.fca.1.extract33) #45
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32) #46
  %13 = getelementptr i8, ptr %9, i64 8
  %14 = load ptr, ptr %13, align 8
  br i1 %11, label %15, label %35

15:                                               ; preds = %3
  call void %14(ptr %.fca.1.extract33, i1 false) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32) #46
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr, ptr, ptr, i32 } %19(ptr %.fca.1.extract33) #45
  %.fca.0.extract101 = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  %.fca.1.extract103 = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.2.extract105 = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %.fca.3.extract107 = extractvalue { ptr, ptr, ptr, i32 } %20, 3
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract101, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract103, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract105, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %.fca.3.extract107, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract101) #46
  %27 = sext i32 %.fca.3.extract107 to i64
  %28 = getelementptr ptr, ptr %.fca.0.extract101, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %31 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %4)
  %.fca.0.extract95 = extractvalue { ptr, i160 } %31, 0
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %33 = icmp eq ptr %.fca.0.extract95, @nil_typ
  %34 = icmp eq ptr %.fca.0.extract95, null
  %.not114.not = or i1 %33, %34
  br i1 %.not114.not, label %55, label %72

35:                                               ; preds = %3
  call void %14(ptr %.fca.1.extract33, i1 true) #44
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %37 = getelementptr i8, ptr %7, i64 16
  %38 = load ptr, ptr %37, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract33) #45
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract71, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract73, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract75, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract69)
  %47 = sext i32 %.fca.3.extract75 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract69, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i1 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %51 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract54 = extractvalue { ptr, i160 } %51, 0
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %53 = icmp eq ptr %.fca.0.extract54, @nil_typ
  %54 = icmp eq ptr %.fca.0.extract54, null
  %.not111.not = or i1 %53, %54
  br i1 %.not111.not, label %55, label %72

55:                                               ; preds = %35, %15
  %.sink145 = phi i64 [ 16, %15 ], [ 8, %35 ]
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract32)
  %57 = getelementptr i8, ptr %7, i64 %.sink145
  %58 = load ptr, ptr %57, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract33) #45
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract40 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract41 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract38, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract39, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract40, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract41, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract38)
  %67 = sext i32 %.fca.3.extract41 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract38, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %71 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract34 = extractvalue { ptr, i160 } %71, 0
  br label %72

72:                                               ; preds = %55, %35, %15
  %.pn = phi { ptr, i160 } [ %71, %55 ], [ %51, %35 ], [ %31, %15 ]
  %73 = phi ptr [ %.fca.0.extract34, %55 ], [ %.fca.0.extract54, %35 ], [ %.fca.0.extract95, %15 ]
  %74 = extractvalue { ptr, i160 } %.pn, 1
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %73, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %74, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @Interleaver_getter_on_first(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Interleaver_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Interleaver_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Interleaver_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Interleaver_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Interleaver_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Interleaved(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Interleaved_field_Interleaved_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Interleaved_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Interleaved_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1225269988638598324
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Interleaved_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1225269988638598324
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #45
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract90) #46
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #45
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #47
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #51
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Interleaver, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Interleaver) #43
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Interleaver) #46
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Interleaved_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Interleaved_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Interleaved_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Interleaved_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainedCollection_field_ChainedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 28, i64 27
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 36, i64 37
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4136536984535342799
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 1375598993350293883
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define i32 @ChainedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4136536984535342799
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract19) #45
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract3) #46
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract17)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract19) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = add i32 %38, %22
  ret i32 %39
}

define { ptr, ptr, ptr, i32 } @ChainedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4136536984535342799
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #45
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract90) #46
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #45
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #47
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #51
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 24
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 24
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Chainer, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Chainer) #43
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Chainer) #46
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Chainer(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Chainer_field_Chainer_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chainer_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chainer_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Chainer_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract38, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1602305534081450710
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract38, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract21, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract22, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 8673632051301757104
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %25) #44
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract38) #46
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract39, i1 true) #44
  ret void
}

define { ptr, i160 } @Chainer_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1602305534081450710
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract18, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i1 %10(ptr %.fca.1.extract19) #45
  br i1 %11, label %12, label %37

12:                                               ; preds = %3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18) #46
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract19) #45
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract40 = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract42 = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract44 = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract38, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract40, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract42, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract44, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract38) #46
  %24 = sext i32 %.fca.3.extract44 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract38, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i1 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %28 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract32 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18)
  %30 = icmp ne ptr %.fca.0.extract32, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract32, null
  %.not47.not.not = and i1 %30, %31
  br i1 %.not47.not.not, label %54, label %32

32:                                               ; preds = %12
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18)
  %34 = load ptr, ptr %8, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr %.fca.1.extract19, i1 false) #44
  br label %37

37:                                               ; preds = %32, %3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract18)
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract19) #45
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract26 = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract24, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract25, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract26, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract27, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract24)
  %49 = sext i32 %.fca.3.extract27 to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract24, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %53 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4)
  %.fca.0.extract20 = extractvalue { ptr, i160 } %53, 0
  br label %54

54:                                               ; preds = %37, %12
  %.reg2mem11.sroa.0.0 = phi ptr [ %.fca.0.extract20, %37 ], [ %.fca.0.extract32, %12 ]
  %.pn = phi { ptr, i160 } [ %53, %37 ], [ %28, %12 ]
  %.reg2mem11.sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reload12.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem11.sroa.0.0, 0
  %.reload12.fca.1.insert = insertvalue { ptr, i160 } %.reload12.fca.0.insert, i160 %.reg2mem11.sroa.3.0, 1
  ret { ptr, i160 } %.reload12.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @Chainer_getter_on_first(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Chainer_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Chainer_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Chainer_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Chainer_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Chainer_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Chained(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Chained_field_Chained_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Chained_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Chained_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4211902305383154752
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract34, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract20, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract21, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %16) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 3037712219555723519
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i24, 3
  call void %21(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %25) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Chained_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract120, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4211902305383154752
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract120, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract122) #45
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract90, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract92, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract94, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract96, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract90) #46
  %18 = sext i32 %.fca.3.extract96 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract90, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract122) #45
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract71, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract73, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract75, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract69)
  %34 = sext i32 %.fca.3.extract75 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract69, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract122) #47
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #51
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract42, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract44, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract46, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract40)
  %52 = sext i32 %.fca.3.extract46 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract40, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr nonnull %.fca.1.extract122) #45
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract20, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract21, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract22, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract19)
  %67 = sext i32 %.fca.3.extract22 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract19, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %hash_coef_ptr.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Chainer, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract120)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Chainer) #43
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract28, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract30, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i23, ptr %80, align 8
  %hash_coef.i16.i = load i64, ptr %hash_coef_ptr.i24, align 4
  %tbl_size.i17.i = load i64, ptr %tbl_size_ptr.i25, align 4
  %offset_tbl.i18.i = load ptr, ptr %offset_tbl_ptr.i26, align 8
  %product.i.i19.i = mul i64 %hash_coef.i16.i, 8673632051301757104
  %shifted.i.i20.i = lshr i64 %product.i.i19.i, 32
  %xored.i.i21.i = xor i64 %shifted.i.i20.i, %product.i.i19.i
  %hash.i.i22.i = and i64 %xored.i.i21.i, %tbl_size.i17.i
  %offset_ptr.i23.i = getelementptr i32, ptr %offset_tbl.i18.i, i64 %hash.i.i22.i
  %offset.i24.i = load i32, ptr %offset_ptr.i23.i, align 4
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i24.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Chainer) #46
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Chained_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Chained_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Chained_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Chained_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Filtered(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Filtered_field_Filtered_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filtered_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Filtered_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -1080024301579294453
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Filtered_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract73, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract73, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract73, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -1080024301579294453
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract73, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract75) #45
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43) #46
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i6 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract75) #45
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %29 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract75) #47
  %result.i9 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i2, ptr %result.i9, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i9)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr nonnull %.fca.1.extract75) #45
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract17, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract18, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract19, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract16)
  %41 = sext i32 %.fca.3.extract19 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract16, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i5 = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %45 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr nonnull %.fca.1.extract75) #45
  %hash_coef_ptr.i10 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i11 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i12 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i13 = load i64, ptr %hash_coef_ptr.i10, align 4
  %tbl_size.i14 = load i64, ptr %tbl_size_ptr.i11, align 4
  %offset_tbl.i15 = load ptr, ptr %offset_tbl_ptr.i12, align 8
  %product.i.i16 = mul i64 %hash_coef.i13, 8673632051301757104
  %shifted.i.i17 = lshr i64 %product.i.i16, 32
  %xored.i.i18 = xor i64 %shifted.i.i17, %product.i.i16
  %hash.i.i19 = and i64 %xored.i.i18, %tbl_size.i14
  %offset_ptr.i20 = getelementptr i32, ptr %offset_tbl.i15, i64 %hash.i.i19
  %offset.i21 = load i32, ptr %offset_ptr.i20, align 4
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Filterer, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract73)
  %54 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %.fca.0.extract15, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %.fca.1.extract, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr %.fca.2.extract, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %result.i9, i64 32
  store i32 %offset.i21, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Filterer) #46
  %59 = getelementptr inbounds i8, ptr %result.i9, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i, ptr %59, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %60
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Filterer(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filterer_B_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Filterer_field_Filterer_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Filterer_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Filterer_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3681499794063910215
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #44
  ret void
}

define { ptr, i160 } @Filterer_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3681499794063910215
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract25) #60
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract25, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract27) #45
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract25)
  %24 = getelementptr i8, ptr %7, i64 16
  %.sroa.0.014 = extractvalue { ptr, i160 } %22, 0
  %25 = icmp ne ptr %.sroa.0.014, @nil_typ
  %26 = icmp ne ptr %.sroa.0.014, null
  %.not6316 = and i1 %25, %26
  br i1 %.not6316, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %28 = load ptr, ptr %24, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr } %29(ptr %.fca.1.extract27) #45
  %.fca.0.extract5024 = extractvalue { ptr } %30, 0
  %31 = call i1 %.fca.0.extract5024({ ptr, i160 } %22)
  br i1 %31, label %._crit_edge.loopexit, label %.lr.ph26.preheader

.lr.ph26.preheader:                               ; preds = %.lr.ph
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  br label %.lr.ph26

33:                                               ; preds = %.lr.ph26
  %34 = load ptr, ptr %24, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract27) #45
  %.fca.0.extract50 = extractvalue { ptr } %36, 0
  %37 = call i1 %.fca.0.extract50({ ptr, i160 } %51)
  br i1 %37, label %._crit_edge.loopexit, label %.lr.ph26

.lr.ph26:                                         ; preds = %33, %.lr.ph26.preheader
  %.pn1725 = phi { ptr, i160 } [ %51, %33 ], [ %22, %.lr.ph26.preheader ]
  %38 = load ptr, ptr %8, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract27) #45
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract47 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract43, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract45, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract47, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract41)
  %47 = sext i32 %.fca.3.extract47 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract41, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %51 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.sroa.0.0 = extractvalue { ptr, i160 } %51, 0
  %52 = icmp ne ptr %.sroa.0.0, @nil_typ
  %53 = icmp ne ptr %.sroa.0.0, null
  %.not63 = and i1 %52, %53
  br i1 %.not63, label %33, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph26, %33, %.lr.ph
  %.pn17.lcssa = phi { ptr, i160 } [ %22, %.lr.ph ], [ %51, %33 ], [ %.pn1725, %.lr.ph26 ]
  %.reg2mem22.0.ph.ph = phi ptr [ %.sroa.0.014, %.lr.ph ], [ %.sroa.0.0, %33 ], [ @nil_typ, %.lr.ph26 ]
  %.sroa.3.019.le = extractvalue { ptr, i160 } %.pn17.lcssa, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.reg2mem22.0.ph = phi ptr [ @nil_typ, %3 ], [ %.reg2mem22.0.ph.ph, %._crit_edge.loopexit ]
  %.1.ph = phi i160 [ undef, %3 ], [ %.sroa.3.019.le, %._crit_edge.loopexit ]
  %.reload19.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem22.0.ph, 0
  %.reload19.fca.1.insert = insertvalue { ptr, i160 } %.reload19.fca.0.insert, i160 %.1.ph, 1
  ret { ptr, i160 } %.reload19.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Filterer_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Filterer_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Filterer_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Filterer_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Filtered_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Filtered_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Filtered_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Filtered_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Mapped(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Mapped_field_Mapped_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Mapped_field_Mapped_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapped_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Mapped_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 638460123129944711
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 3037712219555723519
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #46
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Mapped_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract79 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract81 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 638460123129944711
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract79, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract81) #45
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43) #46
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract81) #45
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %29 = load ptr, ptr %7, align 8
  %result.i4 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #47
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #47
  %result.i11 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store ptr %result.i4, ptr %result.i11, align 8
  %33 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i11)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr nonnull %.fca.1.extract81) #45
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract17, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract18, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract19, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract16)
  %45 = sext i32 %.fca.3.extract19 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract16, i64 %45
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %result.i7 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %49 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr nonnull %.fca.1.extract81) #45
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Mapper, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %59 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.0.extract15, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.1.extract, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store ptr %.fca.2.extract, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store i32 %offset.i23, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Mapper) #46
  %64 = getelementptr inbounds i8, ptr %result.i11, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %64, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %65
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Mapper(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapper_B_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Mapper_field_Mapper_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Mapper_field_Mapper_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Mapper_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Mapper_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7249237032859699974
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #46
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #44
  ret void
}

define { ptr, i160 } @Mapper_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7249237032859699974
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract21, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract23) #45
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract21)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not46 = and i1 %24, %25
  br i1 %.not46, label %26, label %33

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract21)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %.fca.1.extract23) #45
  %.fca.0.extract38 = extractvalue { ptr } %31, 0
  %32 = call { ptr, i160 } %.fca.0.extract38({ ptr, i160 } %22)
  %.fca.0.extract32 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract34 = extractvalue { ptr, i160 } %32, 1
  br label %33

33:                                               ; preds = %26, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract32, %26 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract34, %26 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Mapper_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Mapper_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Mapper_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Mapper_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Mapped_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Mapped_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Mapped_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Mapped_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MappedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_init_iterableCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 29, i64 28
  %8 = getelementptr [123 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 32, i64 31
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 34, i64 33
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 36, i64 35
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 37, i64 38
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [123 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MappedCollection_init_iterableCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5460697656559120915
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract18, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i12, 3
  call void %12(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %16) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract18) #46
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract19, { ptr } %4) #44
  ret void
}

define i32 @MappedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5460697656559120915
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @MappedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract79 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract81 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract79, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5460697656559120915
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract79, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract81) #45
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43) #46
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract81) #45
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %29 = load ptr, ptr %7, align 8
  %result.i4 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #47
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract81) #47
  %result.i11 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store ptr %result.i4, ptr %result.i11, align 8
  %33 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i11)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr nonnull %.fca.1.extract81) #45
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract17, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract18, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract19, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract16)
  %45 = sext i32 %.fca.3.extract19 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract16, i64 %45
  %47 = getelementptr i8, ptr %46, i64 24
  %48 = load ptr, ptr %47, align 8
  %result.i7 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %49 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr nonnull %.fca.1.extract81) #45
  %hash_coef_ptr.i12 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i13 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i14 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i15 = load i64, ptr %hash_coef_ptr.i12, align 4
  %tbl_size.i16 = load i64, ptr %tbl_size_ptr.i13, align 4
  %offset_tbl.i17 = load ptr, ptr %offset_tbl_ptr.i14, align 8
  %product.i.i18 = mul i64 %hash_coef.i15, 8673632051301757104
  %shifted.i.i19 = lshr i64 %product.i.i18, 32
  %xored.i.i20 = xor i64 %shifted.i.i19, %product.i.i18
  %hash.i.i21 = and i64 %xored.i.i20, %tbl_size.i16
  %offset_ptr.i22 = getelementptr i32, ptr %offset_tbl.i17, i64 %hash.i.i21
  %offset.i23 = load i32, ptr %offset_ptr.i22, align 4
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Mapper, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef align 8 %.fca.0.extract79)
  %59 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.0.extract15, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.1.extract, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store ptr %.fca.2.extract, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store i32 %offset.i23, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Mapper) #46
  %64 = getelementptr inbounds i8, ptr %result.i11, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %64, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %65
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MappedCollection_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MappedCollection_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_EnumeratedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_init_iterableCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 28, i64 27
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 36, i64 37
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @EnumeratedCollection_init_iterableCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7081690788784801875
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #44
  ret void
}

define i32 @EnumeratedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7081690788784801875
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @EnumeratedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract63, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7081690788784801875
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract63, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract65) #45
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract39) #46
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 24
  %21 = load ptr, ptr %20, align 8
  %result.i5 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %24 = load ptr, ptr %7, align 8
  %result.i1 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract65) #47
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %result.i8 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %26 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i1, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr null, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i8)
  store ptr @Pair, ptr %result.i8, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store ptr %result.i1, ptr %result.i7, align 8
  %30 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i8, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %33 = load ptr, ptr %8, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr nonnull %.fca.1.extract65) #45
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract15, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract16, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %.fca.3.extract17, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract14)
  %42 = sext i32 %.fca.3.extract17 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract14, i64 %42
  %44 = getelementptr i8, ptr %43, i64 24
  %45 = load ptr, ptr %44, align 8
  %result.i4 = call ptr %45({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %46 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 2
  %hash_coef_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i12 = load i64, ptr %hash_coef_ptr.i9, align 4
  %tbl_size.i13 = load i64, ptr %tbl_size_ptr.i10, align 4
  %offset_tbl.i14 = load ptr, ptr %offset_tbl_ptr.i11, align 8
  %product.i.i15 = mul i64 %hash_coef.i12, 8673632051301757104
  %shifted.i.i16 = lshr i64 %product.i.i15, 32
  %xored.i.i17 = xor i64 %shifted.i.i16, %product.i.i15
  %hash.i.i18 = and i64 %xored.i.i17, %tbl_size.i13
  %offset_ptr.i19 = getelementptr i32, ptr %offset_tbl.i14, i64 %hash.i.i18
  %offset.i20 = load i32, ptr %offset_ptr.i19, align 4
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract63)
  %50 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i20, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator) #46
  %55 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store i32 0, ptr %55, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %56
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @EnumeratedCollection_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @EnumeratedCollection_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @StringIterator_field_StringIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7260570988945952630
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 6499063144389013426
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i12, 3
  call void %10(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %14) #44
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #46
  %16 = getelementptr i8, ptr %7, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract18, i32 0) #44
  ret void
}

define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -7260570988945952630
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract33) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract33, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract35) #45
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract33) #46
  %15 = load ptr, ptr %9, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract35) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract) #46
  %24 = sext i32 %.fca.3.extract to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 40
  %27 = load ptr, ptr %26, align 8
  %result.i3 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %28 = call i32 %result.i3({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.not = icmp slt i32 %13, %28
  br i1 %.not, label %29, label %62

29:                                               ; preds = %3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %31 = load ptr, ptr %10, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call i32 %32(ptr %.fca.1.extract35) #45
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %35 = load ptr, ptr %9, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call { ptr, ptr, ptr, i32 } %36(ptr %.fca.1.extract35) #45
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %37, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %37, 1
  %.fca.2.extract61 = extractvalue { ptr, ptr, ptr, i32 } %37, 2
  %.fca.3.extract63 = extractvalue { ptr, ptr, ptr, i32 } %37, 3
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.1.extract59, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.2.extract61, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %.fca.3.extract63, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract57)
  %44 = sext i32 %.fca.3.extract63 to i64
  %45 = getelementptr ptr, ptr %.fca.0.extract57, i64 %44
  %46 = getelementptr i8, ptr %45, i64 136
  %47 = load ptr, ptr %46, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i2 = call ptr %47({ ptr, ptr, ptr, i32 } %41, ptr nocapture nofree noundef nonnull readonly %6) #49
  %48 = call { ptr, i64 } %result.i2({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 dereferenceable(8) %5, i32 %33)
  %.fca.0.extract51 = extractvalue { ptr, i64 } %48, 0
  %49 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %50 = icmp ne ptr %.fca.0.extract51, null
  %.not70 = and i1 %49, %50
  br i1 %.not70, label %51, label %62

51:                                               ; preds = %29
  %.fca.1.extract53 = extractvalue { ptr, i64 } %48, 1
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %53 = load ptr, ptr %10, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call i32 %54(ptr %.fca.1.extract35) #45
  %extelt.offset = lshr i64 %.fca.1.extract53, 32
  %.4.vec.extract = trunc nuw i64 %extelt.offset to i32
  %56 = add i32 %55, %.4.vec.extract
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract33)
  %58 = getelementptr i8, ptr %53, i64 8
  %59 = load ptr, ptr %58, align 8
  call void %59(ptr %.fca.1.extract35, i32 %56) #44
  %result.i4 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #51
  %.0.vec.extract = trunc i64 %.fca.1.extract53 to i32
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Character) #43
  store i32 %.0.vec.extract, ptr %result.i4, align 4
  %61 = ptrtoint ptr %result.i4 to i64
  %.sroa.3.8.insert.ext = zext i64 %61 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %62

62:                                               ; preds = %51, %29, %3
  %.reg2mem9.sroa.0.0 = phi ptr [ @nil_typ, %3 ], [ @Character, %51 ], [ @nil_typ, %29 ]
  %.reg2mem9.sroa.3.0 = phi i160 [ undef, %3 ], [ %.sroa.3.8.insert.insert, %51 ], [ undef, %29 ]
  %.reload10.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem9.sroa.0.0, 0
  %.reload10.fca.1.insert = insertvalue { ptr, i160 } %.reload10.fca.0.insert, i160 %.reg2mem9.sroa.3.0, 1
  ret { ptr, i160 } %.reload10.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_codepointi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_byte_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_byte_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ConstantTimeIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_List(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i8_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_RangeIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @RangeIterator_field_RangeIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @RangeIterator_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4, i32 %5) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -913562485944406675
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #44
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 %4) #44
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 %5) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @RangeIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -913562485944406675
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract23, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract24) #45
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #46
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract24) #45
  %15 = icmp sgt i32 %9, %14
  br i1 %15, label %30, label %16

16:                                               ; preds = %3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #46
  %18 = call i32 %8(ptr %.fca.1.extract24) #45
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #46
  %20 = call i32 %8(ptr %.fca.1.extract24) #45
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #46
  %22 = getelementptr i8, ptr %6, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call i32 %24(ptr %.fca.1.extract24) #45
  %26 = add i32 %25, %20
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract23) #46
  %28 = getelementptr i8, ptr %7, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %.fca.1.extract24, i32 %26) #44
  %.sroa.026.0.insert.ext = zext i32 %18 to i160
  br label %30

30:                                               ; preds = %16, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @i32_typ, %16 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.026.0.insert.ext, %16 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_step(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_step(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_end(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_end(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_counter(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_counter(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Range(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @Range_field_Range_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_endi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_step_stepi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 33, i64 32
  %8 = getelementptr [127 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 36, i64 35
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 38, i64 37
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 40, i64 39
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 41, i64 42
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [127 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Range_init_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #44
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %13 = load ptr, ptr %7, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 0) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 1) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Range_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #44
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 %4) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract, i32 1) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Range_step_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #44
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 5490049236840671069
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  ret { ptr, ptr, ptr, i32 } %15
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Range_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  %11 = icmp eq i32 %10, 1
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #45
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr %.fca.1.extract) #45
  %21 = sub i32 %16, %20
  br i1 %11, label %26, label %22

22:                                               ; preds = %3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %24 = call i32 %9(ptr %.fca.1.extract) #45
  %25 = sdiv i32 %21, %24
  br label %26

26:                                               ; preds = %22, %3
  %.reg2mem5.0.in = phi i32 [ %25, %22 ], [ %21, %3 ]
  %.reg2mem5.0 = add i32 %.reg2mem5.0.in, 1
  ret i32 %.reg2mem5.0
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Range_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5490049236840671069
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #45
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract) #45
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %16 = getelementptr i8, ptr %6, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #45
  %result.i2 = call noalias align 4 dereferenceable_or_null(12) ptr @bump_malloc_wrapper(i64 noundef 12) #51
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call i32 %22(ptr %.fca.1.extract) #45
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %25 = load ptr, ptr %11, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract) #45
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr %.fca.1.extract) #45
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @RangeIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  store i32 %23, ptr %result.i2, align 4
  %34 = getelementptr i8, ptr %result.i2, i64 4
  store i32 %27, ptr %34, align 4
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %36 = getelementptr i8, ptr %result.i2, i64 8
  store i32 %31, ptr %36, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %37
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_step(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_step(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_end(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_end(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_start(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_start(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #43
  ret ptr @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i64 } @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2, i32 %3) #7 {
  %.fca.0.extract10 = extractvalue { ptr } %1, 0
  %.not = icmp slt i32 %2, %3
  br i1 %.not, label %._crit_edge, label %.loopexit

._crit_edge:                                      ; preds = %4
  %5 = sext i32 %2 to i64
  %6 = getelementptr i8, ptr %.fca.0.extract10, i64 %5
  %7 = load i8, ptr %6, align 1
  %8 = sext i8 %7 to i32
  %9 = icmp sgt i8 %7, -1
  %spec.select = zext i1 %9 to i32
  %10 = and i32 %8, -32
  %11 = icmp eq i32 %10, -64
  %.1149 = select i1 %11, i32 2, i32 %spec.select
  %12 = and i32 %8, -16
  %13 = icmp eq i32 %12, -32
  %.2150 = select i1 %13, i32 3, i32 %.1149
  %14 = and i32 %8, -8
  %15 = icmp eq i32 %14, -16
  %.3151 = select i1 %15, i32 4, i32 %.2150
  %16 = icmp eq i32 %.3151, 0
  %17 = add i32 %.3151, %2
  %18 = icmp sgt i32 %17, %3
  %.0152 = or i1 %16, %18
  br i1 %.0152, label %.loopexit, label %19

19:                                               ; preds = %._crit_edge
  %20 = and i32 %8, 7
  %21 = and i32 %8, 15
  %22 = and i32 %8, 31
  %spec.select171 = select i1 %9, i32 %8, i32 0
  %.1 = select i1 %11, i32 %22, i32 %spec.select171
  %.2 = select i1 %13, i32 %21, i32 %.1
  %.3 = select i1 %15, i32 %20, i32 %.2
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %.not48 = icmp ugt i32 %.3151, 1
  br i1 %.not48, label %25, label %._crit_edge5

25:                                               ; preds = %19
  %26 = getelementptr i8, ptr %6, i64 1
  %27 = load i8, ptr %26, align 1
  %28 = sext i8 %27 to i32
  %29 = and i32 %28, -64
  %.not15 = icmp eq i32 %29, -128
  %30 = shl nsw i32 %.3, 6
  %31 = and i32 %28, 63
  %32 = or disjoint i32 %31, %30
  br i1 %.not15, label %33, label %.loopexit

33:                                               ; preds = %25
  %.not48.1.not = icmp eq i32 %.3151, 2
  br i1 %.not48.1.not, label %._crit_edge4, label %34

34:                                               ; preds = %33
  %35 = add i32 %2, 2
  %36 = sext i32 %35 to i64
  %37 = getelementptr i8, ptr %.fca.0.extract10, i64 %36
  %38 = load i8, ptr %37, align 1
  %39 = sext i8 %38 to i32
  %40 = and i32 %39, -64
  %.not15.1 = icmp eq i32 %40, -128
  %41 = shl i32 %32, 6
  %42 = and i32 %39, 63
  %43 = or disjoint i32 %42, %41
  br i1 %.not15.1, label %44, label %.loopexit

44:                                               ; preds = %34
  br i1 %15, label %45, label %._crit_edge5

45:                                               ; preds = %44
  %46 = add i32 %2, 3
  %47 = sext i32 %46 to i64
  %48 = getelementptr i8, ptr %.fca.0.extract10, i64 %47
  %49 = load i8, ptr %48, align 1
  %50 = sext i8 %49 to i32
  %51 = and i32 %50, -64
  %.not15.2 = icmp eq i32 %51, -128
  br i1 %.not15.2, label %52, label %.loopexit

52:                                               ; preds = %45
  %53 = and i32 %50, 63
  %54 = shl i32 %43, 6
  %55 = or disjoint i32 %53, %54
  br label %._crit_edge5

._crit_edge4:                                     ; preds = %33
  %56 = icmp slt i32 %32, -128
  br i1 %56, label %.critedge175, label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge4, %52, %44, %19
  %.4.lcssa55 = phi i32 [ %32, %._crit_edge4 ], [ %55, %52 ], [ %43, %44 ], [ %.3, %19 ]
  %not. = xor i1 %15, true
  %57 = and i1 %13, %not.
  %58 = icmp slt i32 %.4.lcssa55, 2048
  %spec.select173 = select i1 %57, i1 %58, i1 false
  %59 = icmp slt i32 %.4.lcssa55, 65536
  %spec.select174 = select i1 %15, i1 %59, i1 false
  %or.cond = select i1 %spec.select173, i1 true, i1 %spec.select174
  br i1 %or.cond, label %.critedge175, label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5
  %60 = and i32 %.4.lcssa55, -2048
  %spec.select176 = icmp eq i32 %60, -10240
  br label %.critedge175

.critedge175:                                     ; preds = %._crit_edge7, %._crit_edge5, %._crit_edge4
  %.4.lcssa56 = phi i32 [ %.4.lcssa55, %._crit_edge7 ], [ %32, %._crit_edge4 ], [ %.4.lcssa55, %._crit_edge5 ]
  %.0158 = phi i1 [ %spec.select176, %._crit_edge7 ], [ true, %._crit_edge4 ], [ true, %._crit_edge5 ]
  %61 = icmp sgt i32 %.4.lcssa56, 1114111
  %spec.select177 = select i1 %.0158, i1 true, i1 %61
  %.0.vec.insert = insertelement <2 x i32> poison, i32 %.4.lcssa56, i64 0
  %.4.vec.insert = insertelement <2 x i32> %.0.vec.insert, i32 %.3151, i64 1
  %62 = bitcast <2 x i32> %.4.vec.insert to i64
  %63 = select i1 %spec.select177, ptr @nil_typ, ptr @tuple_typ
  br label %.loopexit

.loopexit:                                        ; preds = %.critedge175, %45, %34, %25, %._crit_edge, %4
  %.reg2mem55.0 = phi ptr [ @nil_typ, %4 ], [ @nil_typ, %._crit_edge ], [ %63, %.critedge175 ], [ @nil_typ, %45 ], [ @nil_typ, %34 ], [ @nil_typ, %25 ]
  %.reg2mem57.sroa.3.0 = phi i64 [ poison, %4 ], [ poison, %._crit_edge ], [ %62, %.critedge175 ], [ poison, %45 ], [ poison, %34 ], [ poison, %25 ]
  %.reload54.fca.0.insert = insertvalue { ptr, i64 } poison, ptr %.reg2mem55.0, 0
  %.reload54.fca.1.insert = insertvalue { ptr, i64 } %.reload54.fca.0.insert, i64 %.reg2mem57.sroa.3.0, 1
  ret { ptr, i64 } %.reload54.fca.1.insert
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, i160 } @_box_tuple_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly align 4 %1) #37 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = getelementptr i8, ptr %1, i64 8
  %4 = load i64, ptr %3, align 4
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %.lr.ph.i, %2
  %.in.i = phi i64 [ %23, %.lr.ph.i ], [ %4, %2 ]
  %6 = phi i64 [ %21, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.i = phi i64 [ %20, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem20.010.i = phi i64 [ %14, %.lr.ph.i ], [ 1, %2 ]
  %7 = inttoptr i64 %.in.i to ptr
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %11 = call { i64, i64 } %10(ptr nonnull align 8 %7) #52
  %12 = extractvalue { i64, i64 } %11, 0
  %13 = extractvalue { i64, i64 } %11, 1
  %14 = call i64 @llvm.umax.i64(i64 %13, i64 %.reg2mem20.010.i)
  %15 = urem i64 %.reg2mem22.011.i, %13
  %16 = icmp eq i64 %15, 0
  %17 = sub nuw i64 %13, %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add nuw i64 %12, %.reg2mem22.011.i
  %20 = add nuw i64 %19, %18
  %21 = add nuw i64 %6, 1
  %22 = getelementptr ptr, ptr %1, i64 %21
  %23 = load i64, ptr %22, align 4
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %2
  %.reg2mem20.0.lcssa.i = phi i64 [ 1, %2 ], [ %14, %.lr.ph.i ]
  %.reg2mem22.0.lcssa.i = phi i64 [ 0, %2 ], [ %20, %.lr.ph.i ]
  %25 = urem i64 %.reg2mem22.0.lcssa.i, %.reg2mem20.0.lcssa.i
  %26 = icmp eq i64 %25, 0
  %27 = sub nuw i64 %.reg2mem20.0.lcssa.i, %25
  %28 = select i1 %26, i64 0, i64 %27
  %29 = add nuw i64 %28, %.reg2mem22.0.lcssa.i
  %30 = icmp slt i64 %29, 17
  br i1 %30, label %32, label %31

31:                                               ; preds = %_data_size_tuple_typ.exit
  %result.i1 = call noalias ptr @bump_malloc_wrapper(i64 noundef %29) #51
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i1, ptr nocapture nofree readonly align 1 %0, i64 %29, i1 noundef false) #43
  store ptr %result.i1, ptr %.sroa.2, align 8
  br label %33

32:                                               ; preds = %_data_size_tuple_typ.exit
  call void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %29, i1 noundef false) #43
  br label %33

33:                                               ; preds = %32, %31
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %34 = insertvalue { ptr, i160 } { ptr @tuple_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %34
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define void @_unbox_tuple_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %2) #40 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %.lr.ph.i, %3
  %.in.i = phi i64 [ %25, %.lr.ph.i ], [ %6, %3 ]
  %8 = phi i64 [ %23, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.i = phi i64 [ %22, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem20.010.i = phi i64 [ %16, %.lr.ph.i ], [ 1, %3 ]
  %9 = inttoptr i64 %.in.i to ptr
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 72
  %12 = load ptr, ptr %11, align 8
  %13 = call { i64, i64 } %12(ptr nonnull align 8 %9) #52
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = extractvalue { i64, i64 } %13, 1
  %16 = call i64 @llvm.umax.i64(i64 %15, i64 %.reg2mem20.010.i)
  %17 = urem i64 %.reg2mem22.011.i, %15
  %18 = icmp eq i64 %17, 0
  %19 = sub nuw i64 %15, %17
  %20 = select i1 %18, i64 0, i64 %19
  %21 = add nuw i64 %14, %.reg2mem22.011.i
  %22 = add nuw i64 %21, %20
  %23 = add nuw i64 %8, 1
  %24 = getelementptr ptr, ptr %1, i64 %23
  %25 = load i64, ptr %24, align 4
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %3
  %.reg2mem20.0.lcssa.i = phi i64 [ 1, %3 ], [ %16, %.lr.ph.i ]
  %.reg2mem22.0.lcssa.i = phi i64 [ 0, %3 ], [ %22, %.lr.ph.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %.reg2mem22.0.lcssa.i, %.reg2mem20.0.lcssa.i
  %30 = icmp eq i64 %29, 0
  %31 = sub nuw i64 %.reg2mem20.0.lcssa.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add nuw i64 %32, %.reg2mem22.0.lcssa.i
  %34 = icmp slt i64 %33, 17
  %35 = select i1 %34, ptr %.fca.1.gep, ptr %28
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %35, i64 %33, i1 noundef false) #43
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Unicode(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_codepoint_(ptr nocapture nofree %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #43
  ret ptr @Unicode__Self_replacement_codepoint_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_str_(ptr nocapture nofree %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #43
  ret ptr @Unicode__Self_replacement_str_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_buf_(ptr nocapture nofree %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #43
  ret ptr @Unicode__Self_replacement_buf_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_encode_one_cpi32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #43
  ret ptr @Unicode__Self_encode_one_cpi32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @Unicode__Self_replacement_codepoint_(ptr nocapture nofree readnone %0) #1 {
  ret i32 -3
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Unicode__Self_replacement_str_(ptr nocapture nofree readnone %0) #37 {
  %result.i4 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %result.i.i5 = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #51
  store i8 -17, ptr %result.i.i5, align 1
  %3 = getelementptr i8, ptr %result.i.i5, i64 1
  store i8 -65, ptr %3, align 1
  %4 = getelementptr i8, ptr %result.i.i5, i64 2
  store i8 -67, ptr %4, align 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i4, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr undef, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 10, 3
  store ptr %result.i.i5, ptr %result.i4, align 8
  %8 = getelementptr i8, ptr %result.i4, i64 8
  store <2 x i32> <i32 3, i32 1>, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %10 = getelementptr i8, ptr %result.i4, i64 16
  store i32 4, ptr %10, align 8
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr } @Unicode__Self_replacement_buf_(ptr nocapture nofree readnone %0) #37 {
  %result.i = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #51
  store i8 -17, ptr %result.i, align 1
  %2 = getelementptr i8, ptr %result.i, i64 1
  store i8 -65, ptr %2, align 1
  %3 = getelementptr i8, ptr %result.i, i64 2
  store i8 -67, ptr %3, align 1
  %4 = insertvalue { ptr } undef, ptr %result.i, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Unicode__Self_encode_one_cpi32(ptr nocapture nofree readnone %0, i32 %1) #37 {
  %result.i10 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #51
  %3 = icmp slt i32 %1, 128
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = trunc i32 %1 to i8
  store i8 %5, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10, ptr %result.i9, align 8
  br label %40

6:                                                ; preds = %2
  %7 = icmp ult i32 %1, 2048
  br i1 %7, label %8, label %16

8:                                                ; preds = %6
  %9 = lshr i32 %1, 6
  %10 = trunc nuw nsw i32 %9 to i8
  %11 = or disjoint i8 %10, -64
  store i8 %11, ptr %result.i10, align 1
  %12 = trunc i32 %1 to i8
  %13 = and i8 %12, 63
  %14 = or disjoint i8 %13, -128
  %15 = getelementptr i8, ptr %result.i10, i64 1
  store i8 %14, ptr %15, align 1
  %result.i8 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10, ptr %result.i8, align 8
  br label %40

16:                                               ; preds = %6
  %17 = icmp ult i32 %1, 1114112
  br i1 %17, label %18, label %36

18:                                               ; preds = %16
  %19 = lshr i32 %1, 18
  %20 = trunc nuw nsw i32 %19 to i8
  %21 = or disjoint i8 %20, -16
  store i8 %21, ptr %result.i10, align 1
  %22 = lshr i32 %1, 12
  %23 = trunc i32 %22 to i8
  %24 = and i8 %23, 63
  %25 = or disjoint i8 %24, -128
  %26 = getelementptr i8, ptr %result.i10, i64 1
  store i8 %25, ptr %26, align 1
  %27 = lshr i32 %1, 6
  %28 = trunc i32 %27 to i8
  %29 = and i8 %28, 63
  %30 = or disjoint i8 %29, -128
  %31 = getelementptr i8, ptr %result.i10, i64 2
  store i8 %30, ptr %31, align 1
  %32 = trunc i32 %1 to i8
  %33 = and i8 %32, 63
  %34 = or disjoint i8 %33, -128
  %35 = getelementptr i8, ptr %result.i10, i64 3
  store i8 %34, ptr %35, align 1
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10, ptr %result.i7, align 8
  br label %40

36:                                               ; preds = %16
  %result.i4.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %result.i.i51 = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #51
  store i8 -17, ptr %result.i.i51, align 1
  %38 = getelementptr i8, ptr %result.i.i51, i64 1
  store i8 -65, ptr %38, align 1
  %39 = getelementptr i8, ptr %result.i.i51, i64 2
  store i8 -67, ptr %39, align 1
  store ptr %result.i.i51, ptr %result.i4.i, align 8
  br label %40

40:                                               ; preds = %36, %18, %8, %4
  %result.i4.i.sink54 = phi ptr [ %result.i4.i, %36 ], [ %result.i7, %18 ], [ %result.i8, %8 ], [ %result.i9, %4 ]
  %.sink = phi i32 [ 3, %36 ], [ 4, %18 ], [ 2, %8 ], [ 1, %4 ]
  %41 = getelementptr i8, ptr %result.i4.i.sink54, i64 8
  store i32 %.sink, ptr %41, align 8
  %42 = getelementptr i8, ptr %result.i4.i.sink54, i64 12
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  store <2 x i32> <i32 1, i32 4>, ptr %42, align 4
  %.reload18.fca.1.insert = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr poison, ptr poison, i32 poison }, ptr %result.i4.i.sink54, 1
  %.reload18.fca.2.insert = insertvalue { ptr, ptr, ptr, i32 } %.reload18.fca.1.insert, ptr undef, 2
  %.reload18.fca.3.insert = insertvalue { ptr, ptr, ptr, i32 } %.reload18.fca.2.insert, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %.reload18.fca.3.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InvalidUTF8Error(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #17 {
  %.fca.0.extract56 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract56, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract56, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract56, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i7 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i8 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i9 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i10 = load i64, ptr %hash_coef_ptr.i7, align 4
  %tbl_size.i11 = load i64, ptr %tbl_size_ptr.i8, align 4
  %offset_tbl.i12 = load ptr, ptr %offset_tbl_ptr.i9, align 8
  %product.i.i13 = mul i64 %hash_coef.i10, 6499063144389013426
  %shifted.i.i14 = lshr i64 %product.i.i13, 32
  %xored.i.i15 = xor i64 %shifted.i.i14, %product.i.i13
  %hash.i.i16 = and i64 %xored.i.i15, %tbl_size.i11
  %offset_ptr.i17 = getelementptr i32, ptr %offset_tbl.i12, i64 %hash.i.i16
  %offset.i18 = load i32, ptr %offset_ptr.i17, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract56, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i18, 3
  call void %11(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %15) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56) #46
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract57, i32 0) #44
  %result.i6 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  store ptr %result.i6, ptr %result.i5, align 8
  %23 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> zeroinitializer, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %25 = getelementptr i8, ptr %result.i5, i64 16
  store i32 1, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56) #46
  %27 = getelementptr i8, ptr %7, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %22) #44
  %result.i4 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %31 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i4, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr undef, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  store ptr %result.i.i, ptr %result.i4, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #46
  %35 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %36 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %35)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %38 = getelementptr i8, ptr %result.i4, i64 8
  store i64 %36, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract56)
  %40 = getelementptr i8, ptr %7, i64 24
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr i8, ptr %41, i64 8
  %43 = load ptr, ptr %42, align 8
  call void %43(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %33) #44
  ret void
}

define void @InvalidUTF8Error_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4104693287331019315
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i10 = call noalias dereferenceable_or_null(61) ptr @bump_malloc_wrapper(i64 noundef 61) #51
  store <60 x i8> <i8 73, i8 110, i8 118, i8 97, i8 108, i8 105, i8 100, i8 32, i8 85, i8 84, i8 70, i8 45, i8 56, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 99, i8 101, i8 32, i8 101, i8 110, i8 99, i8 111, i8 117, i8 110, i8 116, i8 101, i8 114, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 116, i8 114, i8 105, i8 110, i8 103, i8 32, i8 99, i8 111, i8 110, i8 118, i8 101, i8 114, i8 115, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i10, ptr %result.i9, align 8
  %7 = getelementptr i8, ptr %result.i9, i64 8
  store <2 x i32> <i32 60, i32 60>, ptr %7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #43
  %9 = getelementptr i8, ptr %result.i9, i64 16
  store i32 61, ptr %9, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract, i64 %11
  %13 = getelementptr i8, ptr %12, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %6) #44
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %18 = load ptr, ptr %12, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #44
  %result.i8 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i8, ptr %result.i7, align 8
  %24 = getelementptr i8, ptr %result.i7, i64 8
  store <2 x i32> zeroinitializer, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %26 = getelementptr i8, ptr %result.i7, i64 16
  store i32 1, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %28 = getelementptr i8, ptr %12, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #44
  %result.i6 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  store ptr %result.i.i, ptr %result.i6, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #46
  %36 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %37 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %36)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %39 = getelementptr i8, ptr %result.i6, i64 8
  store i64 %37, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %41 = getelementptr i8, ptr %12, i64 24
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract17, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract18, i32 %3) #44
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 6499063144389013426
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #46
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i12, 3
  call void %16(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %20) #44
  ret void
}

define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
._crit_edge.i.lr.ph:
  %3 = alloca [0 x ptr], align 8
  %result.i5.i130.h2s828 = alloca [10 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(10) %result.i5.i130.h2s828, i8 0, i64 10, i1 false)
  %result.i5.i109.h2s830 = alloca [13 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(13) %result.i5.i109.h2s830, i8 0, i64 13, i1 false)
  %result.i5.i88.h2s832 = alloca [13 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(13) %result.i5.i88.h2s832, i8 0, i64 13, i1 false)
  %result.i5.i67.h2s834 = alloca [8 x i8], align 8
  store i64 0, ptr %result.i5.i67.h2s834, align 8
  %result.i5.i46.h2s836 = alloca [27 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(27) %result.i5.i46.h2s836, i8 0, i64 27, i1 false)
  %result.i5.i.h2s838 = alloca [10 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(10) %result.i5.i.h2s838, i8 0, i64 10, i1 false)
  %.fca.0.extract180 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract182 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract180, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract180, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract180, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #43
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store i8 45, ptr %result.i5.i.h2s838, align 1
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s838, i64 1
  store i64 3255307777713450285, ptr %scevgep, align 1
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %16 = getelementptr inbounds i8, ptr %result.i5.i.h2s838, i64 9
  store i8 0, ptr %16, align 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #43
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(10) %result.i5.i.h2s838) #59
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #60
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store <16 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110>, ptr %result.i5.i46.h2s836, align 16
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %37 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 16
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store <8 x i8> <i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105>, ptr %37, align 16
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %46 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 24
  store i8 108, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %48 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 25
  store i8 101, ptr %48, align 1
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #60
  %52 = getelementptr inbounds i8, ptr %result.i5.i46.h2s836, i64 26
  store i8 0, ptr %52, align 2
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #60
  %puts189 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(27) %result.i5.i46.h2s836) #59
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180) #60
  %54 = sext i32 %offset.i to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract180, i64 %54
  %56 = getelementptr i8, ptr %55, i64 8
  %57 = load ptr, ptr %56, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, ptr, ptr, i32 } %58(ptr %.fca.1.extract182) #45
  %.fca.0.extract104 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %.fca.1.extract106 = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  %.fca.2.extract108 = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  %.fca.3.extract110 = extractvalue { ptr, ptr, ptr, i32 } %59, 3
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract104, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract106, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract108, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %.fca.3.extract110, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract104)
  %66 = sext i32 %.fca.3.extract110 to i64
  %67 = getelementptr ptr, ptr %.fca.0.extract104, i64 %66
  %68 = getelementptr i8, ptr %67, i64 104
  %69 = load ptr, ptr %68, align 8
  %result.i16 = call ptr %69({ ptr, ptr, ptr, i32 } %63, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  %70 = call { ptr } %result.i16({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull align 8 %3)
  %.fca.0.extract101 = extractvalue { ptr } %70, 0
  %puts190 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract101) #52
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store <8 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101, i8 0>, ptr %result.i5.i67.h2s834, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts191 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(8) %result.i5.i67.h2s834) #52
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180)
  %85 = load ptr, ptr %55, align 8
  %86 = load ptr, ptr %85, align 8
  %87 = call i32 %86(ptr %.fca.1.extract182) #45
  %88 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %87) #52
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store <8 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115>, ptr %result.i5.i88.h2s832, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %101 = getelementptr inbounds i8, ptr %result.i5.i88.h2s832, i64 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store <4 x i8> <i8 115, i8 97, i8 103, i8 101>, ptr %101, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %.fca.2.extract184 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %108 = getelementptr inbounds i8, ptr %result.i5.i88.h2s832, i64 12
  store i8 0, ptr %108, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts192 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(13) %result.i5.i88.h2s832) #52
  %109 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract180, 0
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %.fca.1.extract182, 1
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %.fca.2.extract184, 2
  %112 = insertvalue { ptr, ptr, ptr, i32 } %111, i32 %offset.i, 3
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180)
  %115 = getelementptr i8, ptr %55, i64 64
  %116 = load ptr, ptr %115, align 8
  %result.i11 = call ptr %116({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  call void %result.i11({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 %3)
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store <8 x i8> <i8 83, i8 116, i8 97, i8 99, i8 107, i8 32, i8 116, i8 114>, ptr %result.i5.i109.h2s830, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %129 = getelementptr inbounds i8, ptr %result.i5.i109.h2s830, i64 8
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store <4 x i8> <i8 97, i8 99, i8 101, i8 58>, ptr %129, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %136 = getelementptr inbounds i8, ptr %result.i5.i109.h2s830, i64 12
  store i8 0, ptr %136, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts193 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(13) %result.i5.i109.h2s830) #52
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract180)
  %138 = getelementptr i8, ptr %55, i64 24
  %139 = load ptr, ptr %138, align 8
  %140 = load ptr, ptr %139, align 8
  %141 = call { ptr, ptr, ptr, i32 } %140(ptr %.fca.1.extract182) #45
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %141, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 3
  %142 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %143 = insertvalue { ptr, ptr, ptr, i32 } %142, ptr %.fca.1.extract, 1
  %144 = insertvalue { ptr, ptr, ptr, i32 } %143, ptr %.fca.2.extract, 2
  %145 = insertvalue { ptr, ptr, ptr, i32 } %144, i32 %.fca.3.extract, 3
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract18)
  %148 = sext i32 %.fca.3.extract to i64
  %149 = getelementptr ptr, ptr %.fca.0.extract18, i64 %148
  %150 = getelementptr i8, ptr %149, i64 24
  %151 = load ptr, ptr %150, align 8
  %result.i8 = call ptr %151({ ptr, ptr, ptr, i32 } %145, ptr nocapture nofree noundef nonnull readonly align 8 %3) #49
  call void %result.i8({ ptr, ptr, ptr, i32 } %145, { ptr, ptr, ptr, i32 } %145, ptr nonnull align 8 %3)
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  store <8 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i5.i130.h2s828, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %164 = getelementptr inbounds i8, ptr %result.i5.i130.h2s828, i64 8
  store i8 45, ptr %164, align 8
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #43
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %168 = getelementptr inbounds i8, ptr %result.i5.i130.h2s828, i64 9
  store i8 0, ptr %168, align 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %puts194 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(10) %result.i5.i130.h2s828) #52
  ret void
}

define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract7) #45
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract1) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 104
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #52
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  call void %9(ptr %.fca.1.extract, i32 0) #44
  %result.i10 = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #51
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  store ptr %result.i10, ptr %result.i9, align 8
  %13 = getelementptr i8, ptr %result.i9, i64 8
  store <2 x i32> <i32 6, i32 6>, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %15 = getelementptr i8, ptr %result.i9, i64 16
  store i32 7, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %17 = getelementptr i8, ptr %6, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %12) #44
  %result.i8 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %result.i7 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i8, ptr %result.i7, align 8
  %24 = getelementptr i8, ptr %result.i7, i64 8
  store <2 x i32> zeroinitializer, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %26 = getelementptr i8, ptr %result.i7, i64 16
  store i32 1, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %28 = getelementptr i8, ptr %6, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #44
  %result.i6 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  store ptr %result.i.i, ptr %result.i6, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #46
  %36 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %37 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %36)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %39 = getelementptr i8, ptr %result.i6, i64 8
  store i64 %37, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %41 = getelementptr i8, ptr %6, i64 24
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #44
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Stacktrace(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Stacktrace_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Stacktrace_B_print_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Stacktrace_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -59384212523717097
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract15, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %9(ptr %.fca.1.extract, { ptr } %10) #44
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #46
  %12 = load ptr, ptr %6, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call { ptr } %13(ptr %.fca.1.extract) #45
  %15 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %14)
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract15)
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i64 %15) #44
  ret void
}

define void @Stacktrace_print_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -59384212523717097
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract8, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call { ptr } %8(ptr %.fca.1.extract) #45
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #46
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i64 %13(ptr %.fca.1.extract) #45
  call void @print_backtrace({ ptr } %9, i64 %14)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @Stacktrace_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Stacktrace_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Stacktrace_getter_stacktrace(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Stacktrace_setter_stacktrace(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #3 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @InvalidUTF8Error_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_char_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_char_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_byte_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_byte_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #3 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %result.i3 = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #51
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %result.i3, align 1
  %result.i2 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i3, ptr %result.i2, align 8
  %7 = getelementptr i8, ptr %result.i2, i64 8
  store <2 x i32> <i32 6, i32 6>, ptr %7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %9 = getelementptr i8, ptr %result.i2, i64 16
  store i32 7, ptr %9, align 8
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_codepoint_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_to_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_n_bytes_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Character_codepoint_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #45
  ret i32 %9
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Character_init_codepointi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  call void %10(ptr %.fca.1.extract, i32 %3) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Character_to_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract14, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract15) #45
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode) #46
  %result.i10.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #51
  %11 = icmp slt i32 %9, 128
  br i1 %11, label %12, label %14

12:                                               ; preds = %3
  %13 = trunc i32 %9 to i8
  store i8 %13, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

14:                                               ; preds = %3
  %15 = icmp ult i32 %9, 2048
  br i1 %15, label %16, label %24

16:                                               ; preds = %14
  %17 = lshr i32 %9, 6
  %18 = trunc nuw nsw i32 %17 to i8
  %19 = or disjoint i8 %18, -64
  store i8 %19, ptr %result.i10.i, align 1
  %20 = trunc i32 %9 to i8
  %21 = and i8 %20, 63
  %22 = or disjoint i8 %21, -128
  %23 = getelementptr i8, ptr %result.i10.i, i64 1
  store i8 %22, ptr %23, align 1
  %result.i8.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10.i, ptr %result.i8.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

24:                                               ; preds = %14
  %25 = icmp ult i32 %9, 1114112
  br i1 %25, label %26, label %44

26:                                               ; preds = %24
  %27 = lshr i32 %9, 18
  %28 = trunc nuw nsw i32 %27 to i8
  %29 = or disjoint i8 %28, -16
  store i8 %29, ptr %result.i10.i, align 1
  %30 = lshr i32 %9, 12
  %31 = trunc i32 %30 to i8
  %32 = and i8 %31, 63
  %33 = or disjoint i8 %32, -128
  %34 = getelementptr i8, ptr %result.i10.i, i64 1
  store i8 %33, ptr %34, align 1
  %35 = lshr i32 %9, 6
  %36 = trunc i32 %35 to i8
  %37 = and i8 %36, 63
  %38 = or disjoint i8 %37, -128
  %39 = getelementptr i8, ptr %result.i10.i, i64 2
  store i8 %38, ptr %39, align 1
  %40 = trunc i32 %9 to i8
  %41 = and i8 %40, 63
  %42 = or disjoint i8 %41, -128
  %43 = getelementptr i8, ptr %result.i10.i, i64 3
  store i8 %42, ptr %43, align 1
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10.i, ptr %result.i7.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

44:                                               ; preds = %24
  %result.i4.i.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %result.i.i51.i = call noalias dereferenceable_or_null(3) ptr @bump_malloc_wrapper(i64 noundef 3) #51
  store i8 -17, ptr %result.i.i51.i, align 1
  %46 = getelementptr i8, ptr %result.i.i51.i, i64 1
  store i8 -65, ptr %46, align 1
  %47 = getelementptr i8, ptr %result.i.i51.i, i64 2
  store i8 -67, ptr %47, align 1
  store ptr %result.i.i51.i, ptr %result.i4.i.i, align 8
  br label %Unicode__Self_encode_one_cpi32.exit

Unicode__Self_encode_one_cpi32.exit:              ; preds = %44, %26, %16, %12
  %result.i4.i.sink54.i = phi ptr [ %result.i4.i.i, %44 ], [ %result.i7.i, %26 ], [ %result.i8.i, %16 ], [ %result.i9.i, %12 ]
  %.sink.i = phi i32 [ 3, %44 ], [ 4, %26 ], [ 2, %16 ], [ 1, %12 ]
  %48 = getelementptr i8, ptr %result.i4.i.sink54.i, i64 8
  store i32 %.sink.i, ptr %48, align 8
  %49 = getelementptr i8, ptr %result.i4.i.sink54.i, i64 12
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  store <2 x i32> <i32 1, i32 4>, ptr %49, align 4
  %51 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i4.i.sink54.i, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %52
}

define i1 @Character__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 6681222582356018452
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract11, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract12) #45
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %18 = sext i32 %offset.i12 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %5)
  %23 = icmp eq i32 %11, %22
  ret i1 %23
}

; Function Attrs: mustprogress nounwind willreturn
define noundef range(i32 1, 5) i32 @Character_n_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 6681222582356018452
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #45
  %10 = icmp slt i32 %9, 128
  %11 = icmp slt i32 %9, 2048
  %12 = icmp slt i32 %9, 1114112
  %13 = select i1 %12, i32 4, i32 3
  %.reg2mem22.0 = select i1 %11, i32 2, i32 %13
  %.reg2mem18.0 = select i1 %10, i32 1, i32 %.reg2mem22.0
  ret i32 %.reg2mem18.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Character_getter_codepoint(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_codepoint(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i64_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_f64_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_SwissTable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @SwissTable_field_SwissTable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @SwissTable_field_SwissTable_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @SwissTable_field_SwissTable_8(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_hash_to_metadata_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_find_slot_keyK_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_resize_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_ensure_capacity_required_sizei32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_keys_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_indices_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_values_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 59, i64 60
  %8 = getelementptr [1130 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 63, i64 62
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1130 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 65, i64 64
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1130 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 67, i64 66
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1130 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTable_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 68, i64 69
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [1130 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define range(i8 0, -128) i8 @SwissTable_hash_to_metadata_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #1 {
  %5 = trunc i32 %3 to i8
  %6 = and i8 %5, 127
  ret i8 %6
}

define i32 @SwissTable_find_slot_keyK_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4) #17 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #60
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract29, i64 %8
  %10 = getelementptr i8, ptr %9, i64 40
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract30) #45
  %14 = add i32 %13, -1
  %15 = and i32 %14, %4
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract29, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract30, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i, 3
  %20 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29)
  %23 = getelementptr i8, ptr %9, i64 72
  %24 = load ptr, ptr %23, align 8
  %25 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %25, align 8
  %result.i2 = call ptr %24({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly align 8 %25) #49
  %26 = call i8 %result.i2({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 dereferenceable(8) %20, i32 %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29)
  %28 = getelementptr i8, ptr %9, i64 32
  %29 = getelementptr i8, ptr %9, i64 24
  %30 = getelementptr i8, ptr %9, i64 64
  br label %31

31:                                               ; preds = %78, %5
  %.031 = phi i32 [ %15, %5 ], [ %80, %78 ]
  %.0 = phi i32 [ -1, %5 ], [ %.1, %78 ]
  %.0..0..0..0..0..0.84 = phi i32 [ -1, %5 ], [ %spec.store.select9216, %78 ]
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr } %33(ptr %.fca.1.extract30) #45
  %.fca.0.extract73 = extractvalue { ptr } %34, 0
  %35 = sext i32 %.031 to i64
  %36 = getelementptr i8, ptr %.fca.0.extract73, i64 %35
  %37 = load i8, ptr %36, align 1
  switch i8 %37, label %._crit_edge [
    i8 0, label %81
    i8 -128, label %._crit_edge.thread
  ]

._crit_edge.thread:                               ; preds = %31
  %38 = icmp eq i32 %.0..0..0..0..0..0.84, -1
  %spec.store.select = select i1 %38, i32 %.031, i32 %.0..0..0..0..0..0.84
  br label %78

._crit_edge:                                      ; preds = %31
  %39 = icmp sgt i8 %37, 0
  br i1 %39, label %40, label %78

40:                                               ; preds = %._crit_edge
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %42 = load ptr, ptr %29, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract30) #45
  %.fca.0.extract57 = extractvalue { ptr } %44, 0
  %45 = shl nsw i64 %35, 5
  %46 = getelementptr i8, ptr %.fca.0.extract57, i64 %45
  %47 = load ptr, ptr %46, align 8
  %48 = icmp ne ptr %47, @nil_typ
  %49 = icmp ne ptr %47, null
  %.not82 = and i1 %48, %49
  br i1 %.not82, label %50, label %78

50:                                               ; preds = %40
  %51 = getelementptr i8, ptr %46, i64 8
  %52 = load i64, ptr %51, align 4
  %.sroa_idx = getelementptr i8, ptr %46, i64 16
  %53 = load i64, ptr %.sroa_idx, align 4
  %54 = inttoptr i64 %52 to ptr
  %55 = inttoptr i64 %53 to ptr
  %hash_coef_ptr.i3 = getelementptr i8, ptr %47, i64 8
  %tbl_size_ptr.i4 = getelementptr i8, ptr %47, i64 16
  %offset_tbl_ptr.i5 = getelementptr i8, ptr %47, i64 40
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i3, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i4, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i5, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, 4015701072841558310
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %54, 1
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %55, 2
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %offset.i14, 3
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %47)
  %62 = sext i32 %offset.i14 to i64
  %63 = getelementptr ptr, ptr %47, i64 %62
  %64 = getelementptr i8, ptr %63, i64 40
  %65 = load ptr, ptr %64, align 8
  %result.i1 = call ptr %65({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %66 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 %6)
  %67 = icmp eq i32 %66, %4
  br i1 %67, label %._crit_edge2, label %78

._crit_edge2:                                     ; preds = %50
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %47)
  %70 = getelementptr i8, ptr %63, i64 48
  %71 = load ptr, ptr %70, align 8
  %result.i = call ptr %71({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  %72 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 %6)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %74 = load ptr, ptr %30, align 8
  %75 = load ptr, ptr %74, align 8
  %76 = call { ptr } %75(ptr %.fca.1.extract30) #45
  %.fca.0.extract37 = extractvalue { ptr } %76, 0
  %77 = call i1 %.fca.0.extract37({ ptr, i160 } %72, { ptr, i160 } %3)
  br i1 %77, label %.thread21, label %78

78:                                               ; preds = %._crit_edge2, %50, %40, %._crit_edge, %._crit_edge.thread
  %.1 = phi i32 [ %.0, %._crit_edge2 ], [ %.0, %50 ], [ %.0, %40 ], [ %.0, %._crit_edge ], [ %spec.store.select, %._crit_edge.thread ]
  %spec.store.select9216 = phi i32 [ %.0..0..0..0..0..0.84, %._crit_edge2 ], [ %.0..0..0..0..0..0.84, %50 ], [ %.0..0..0..0..0..0.84, %40 ], [ %.0..0..0..0..0..0.84, %._crit_edge ], [ %spec.store.select, %._crit_edge.thread ]
  %79 = add i32 %.031, 1
  %80 = and i32 %79, %14
  br label %31

81:                                               ; preds = %31
  %.not = icmp eq i32 %.0..0..0..0..0..0.84, -1
  %.pre = select i1 %.not, i32 %.031, i32 %.0
  br label %.thread21

.thread21:                                        ; preds = %81, %._crit_edge2
  %82 = phi i32 [ %.pre, %81 ], [ %.031, %._crit_edge2 ]
  ret i32 %82
}

define void @SwissTable_resize_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract78 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract79 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract80 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract78, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract78, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract78, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78) #60
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract78, i64 %9
  %11 = getelementptr i8, ptr %10, i64 24
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call { ptr } %13(ptr %.fca.1.extract79) #45
  %.fca.0.extract31 = extractvalue { ptr } %14, 0
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %16 = getelementptr i8, ptr %10, i64 32
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr } %18(ptr %.fca.1.extract79) #45
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %21 = getelementptr i8, ptr %10, i64 40
  %22 = load ptr, ptr %21, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = call i32 %23(ptr %.fca.1.extract79) #45
  %25 = sext i32 %3 to i64
  %26 = shl nsw i64 %25, 5
  %result.i10 = call noalias ptr @bump_malloc_wrapper(i64 noundef %26) #51
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %28 = load ptr, ptr %11, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr } undef, ptr %result.i10, 0
  call void %30(ptr %.fca.1.extract79, { ptr } %31) #44
  %result.i9 = call noalias ptr @bump_malloc_wrapper(i64 noundef %25) #51
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %33 = load ptr, ptr %16, align 8
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  %36 = insertvalue { ptr } undef, ptr %result.i9, 0
  call void %35(ptr %.fca.1.extract79, { ptr } %36) #44
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %38 = load ptr, ptr %21, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  call void %40(ptr %.fca.1.extract79, i32 %3) #44
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %42 = getelementptr i8, ptr %10, i64 48
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr i8, ptr %43, i64 8
  %45 = load ptr, ptr %44, align 8
  call void %45(ptr %.fca.1.extract79, i32 0) #44
  %46 = add i32 %24, -1
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %49 = getelementptr i8, ptr %10, i64 56
  %50 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract78, 0
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %.fca.1.extract79, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %.fca.2.extract80, 2
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %offset.i, 3
  %54 = getelementptr inbounds i8, ptr %6, i64 8
  %55 = getelementptr i8, ptr %10, i64 80
  %56 = getelementptr inbounds i8, ptr %7, i64 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %59 = icmp slt i32 %46, 0
  br i1 %59, label %.critedge, label %.lr.ph

.lr.ph:                                           ; preds = %._crit_edge2.backedge, %4
  %storemerge = phi i32 [ %120, %._crit_edge2.backedge ], [ 1, %4 ]
  %.sroa.026.0.insert.ext.i64.pn.in = phi i32 [ %storemerge, %._crit_edge2.backedge ], [ 0, %4 ]
  %.sroa.0.8.extract.trunc = zext i32 %.sroa.026.0.insert.ext.i64.pn.in to i64
  %sext = shl nuw i64 %.sroa.0.8.extract.trunc, 32
  %60 = ashr exact i64 %sext, 27
  %61 = getelementptr i8, ptr %.fca.0.extract31, i64 %60
  %62 = load ptr, ptr %61, align 8
  %63 = icmp ne ptr %62, @nil_typ
  %64 = icmp ne ptr %62, null
  %.not158 = and i1 %63, %64
  br i1 %.not158, label %65, label %._crit_edge2.backedge

65:                                               ; preds = %.lr.ph
  %66 = getelementptr i8, ptr %61, i64 8
  %67 = load i160, ptr %66, align 4
  %.sroa.3.0.extract.shift = lshr i160 %67, 64
  %.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.0.extract.shift to i64
  %.sroa.0146.0.extract.trunc = trunc i160 %67 to i64
  %68 = inttoptr i64 %.sroa.0146.0.extract.trunc to ptr
  %69 = inttoptr i64 %.sroa.3.0.extract.trunc to ptr
  %hash_coef_ptr.i23 = getelementptr i8, ptr %62, i64 8
  %tbl_size_ptr.i24 = getelementptr i8, ptr %62, i64 16
  %offset_tbl_ptr.i25 = getelementptr i8, ptr %62, i64 40
  %hash_coef.i26 = load i64, ptr %hash_coef_ptr.i23, align 4
  %tbl_size.i27 = load i64, ptr %tbl_size_ptr.i24, align 4
  %offset_tbl.i28 = load ptr, ptr %offset_tbl_ptr.i25, align 8
  %product.i.i29 = mul i64 %hash_coef.i26, 4015701072841558310
  %shifted.i.i30 = lshr i64 %product.i.i29, 32
  %xored.i.i31 = xor i64 %shifted.i.i30, %product.i.i29
  %hash.i.i32 = and i64 %xored.i.i31, %tbl_size.i27
  %offset_ptr.i33 = getelementptr i32, ptr %offset_tbl.i28, i64 %hash.i.i32
  %offset.i34 = load i32, ptr %offset_ptr.i33, align 4
  %70 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %68, 1
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %69, 2
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, i32 %offset.i34, 3
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %62)
  %76 = sext i32 %offset.i34 to i64
  %77 = getelementptr ptr, ptr %62, i64 %76
  %78 = getelementptr i8, ptr %77, i64 48
  %79 = load ptr, ptr %78, align 8
  %result.i4 = call ptr %79({ ptr, ptr, ptr, i32 } %73, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %80 = call { ptr, i160 } %result.i4({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull align 8 %5)
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %82 = load ptr, ptr %49, align 8
  %83 = load ptr, ptr %82, align 8
  %84 = call { ptr } %83(ptr %.fca.1.extract79) #45
  %.fca.0.extract109 = extractvalue { ptr } %84, 0
  %85 = call i32 %.fca.0.extract109({ ptr, i160 } %80)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %62)
  %88 = load ptr, ptr %78, align 8
  %result.i3 = call ptr %88({ ptr, ptr, ptr, i32 } %73, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %89 = call { ptr, i160 } %result.i3({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull align 8 %5)
  %.fca.0.extract104 = extractvalue { ptr, i160 } %89, 0
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %91 = load ptr, ptr %10, align 8
  %result.i = call ptr %91(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract79) #47
  store ptr %result.i, ptr %6, align 8
  store ptr @_parameterization_i32, ptr %54, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %94 = load ptr, ptr %55, align 8
  store ptr %.fca.0.extract104, ptr %7, align 8
  store ptr @i32_typ, ptr %56, align 8
  %result.i2 = call ptr %94({ ptr, ptr, ptr, i32 } %53, ptr nocapture nofree noundef nonnull readonly %7) #49
  %95 = call i32 %result.i2({ ptr, ptr, ptr, i32 } %53, { ptr, ptr, ptr, i32 } %53, ptr nonnull align 8 dereferenceable(16) %6, { ptr, i160 } %89, i32 %85)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %97 = load ptr, ptr %11, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = call { ptr } %98(ptr nonnull %.fca.1.extract79) #45
  %.fca.0.extract96 = extractvalue { ptr } %99, 0
  %100 = sext i32 %95 to i64
  %101 = shl nsw i64 %100, 5
  %102 = getelementptr i8, ptr %.fca.0.extract96, i64 %101
  store ptr %62, ptr %102, align 8
  %103 = getelementptr i8, ptr %102, i64 8
  store i64 %.sroa.0146.0.extract.trunc, ptr %103, align 4
  %.sroa_idx120 = getelementptr i8, ptr %102, i64 16
  store i64 %.sroa.3.0.extract.trunc, ptr %.sroa_idx120, align 4
  %.sroa_idx121 = getelementptr i8, ptr %102, i64 24
  store i32 %offset.i34, ptr %.sroa_idx121, align 4
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %105 = load ptr, ptr %16, align 8
  %106 = load ptr, ptr %105, align 8
  %107 = call { ptr } %106(ptr nonnull %.fca.1.extract79) #45
  %.fca.0.extract92 = extractvalue { ptr } %107, 0
  %108 = getelementptr i8, ptr %.fca.0.extract92, i64 %100
  store i8 1, ptr %108, align 1
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %110 = load ptr, ptr %42, align 8
  %111 = load ptr, ptr %110, align 8
  %112 = call i32 %111(ptr nonnull %.fca.1.extract79) #45
  %113 = add i32 %112, 1
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract78)
  %115 = getelementptr i8, ptr %110, i64 8
  %116 = load ptr, ptr %115, align 8
  call void %116(ptr nonnull %.fca.1.extract79, i32 %113) #44
  br label %._crit_edge2.backedge

._crit_edge2.backedge:                            ; preds = %65, %.lr.ph
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %5) #43
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %119 = icmp sgt i32 %storemerge, %46
  %120 = add i32 %storemerge, 1
  br i1 %119, label %.critedge, label %.lr.ph

.critedge:                                        ; preds = %._crit_edge2.backedge, %4
  ret void
}

define void @SwissTable_ensure_capacity_required_sizei32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #17 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = getelementptr i8, ptr %9, i64 40
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract) #45
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %._crit_edge1, label %15

15:                                               ; preds = %4
  %16 = mul i32 %13, 7
  %17 = sdiv i32 %16, 10
  %.not = icmp slt i32 %3, %17
  br i1 %.not, label %._crit_edge, label %._crit_edge1

._crit_edge1:                                     ; preds = %15, %4
  %18 = shl i32 %13, 1
  %spec.select = call i32 @llvm.smax.i32(i32 %18, i32 noundef 8) #46
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %offset.i, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #46
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %25 = getelementptr i8, ptr %9, i64 88
  %26 = load ptr, ptr %25, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %26({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  call void %result.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 dereferenceable(8) %5, i32 %spec.select)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge1, %15
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @SwissTable_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #6 {
  %.fca.0.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract29, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, { ptr } %3) #44
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #46
  %14 = getelementptr i8, ptr %8, i64 64
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, { ptr } %4) #44
  %result.i1 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #46
  %19 = getelementptr i8, ptr %8, i64 24
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr } undef, ptr %result.i1, 0
  call void %22(ptr %.fca.1.extract, { ptr } %23) #44
  %result.i = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #46
  %25 = getelementptr i8, ptr %8, i64 32
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %28(ptr %.fca.1.extract, { ptr } %29) #44
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #46
  %31 = getelementptr i8, ptr %8, i64 40
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %.fca.1.extract, i32 8) #44
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #46
  %36 = getelementptr i8, ptr %8, i64 48
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  call void %39(ptr %.fca.1.extract, i32 0) #44
  ret void
}

define { ptr, i160 } @SwissTable_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract19 = extractvalue { ptr, i160 } %3, 0
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract41) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract41, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr %.fca.1.extract42) #45
  %.fca.0.extract11 = extractvalue { ptr } %12, 0
  %13 = call i32 %.fca.0.extract11({ ptr, i160 } %3)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract42, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract41)
  %19 = load ptr, ptr %8, align 8
  %result.i = call ptr %19(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #47
  %20 = alloca [2 x ptr], align 8
  store ptr %result.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @_parameterization_i32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %20)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract41)
  %24 = getelementptr i8, ptr %8, i64 80
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract19, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr @i32_typ, ptr %27, align 8
  %result.i2 = call ptr %25({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly align 8 %26) #49
  %28 = call i32 %result.i2({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(16) %20, { ptr, i160 } %3, i32 %13)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract41)
  %30 = getelementptr i8, ptr %8, i64 32
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr } %32(ptr nonnull %.fca.1.extract42) #45
  %.fca.0.extract = extractvalue { ptr } %33, 0
  %34 = sext i32 %28 to i64
  %35 = getelementptr i8, ptr %.fca.0.extract, i64 %34
  %36 = load i8, ptr %35, align 1
  switch i8 %36, label %37 [
    i8 -128, label %64
    i8 0, label %64
  ]

37:                                               ; preds = %4
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract41)
  %39 = getelementptr i8, ptr %8, i64 24
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr } %41(ptr nonnull %.fca.1.extract42) #45
  %.fca.0.extract65 = extractvalue { ptr } %42, 0
  %43 = shl nsw i64 %34, 5
  %44 = getelementptr i8, ptr %.fca.0.extract65, i64 %43
  %45 = load ptr, ptr %44, align 8
  %46 = icmp ne ptr %45, @nil_typ
  %47 = icmp ne ptr %45, null
  %.not74 = and i1 %46, %47
  br i1 %.not74, label %48, label %64

48:                                               ; preds = %37
  %49 = getelementptr i8, ptr %44, i64 8
  %50 = load i160, ptr %49, align 4
  %.sroa.262.0.extract.shift = lshr i160 %50, 64
  %.sroa.262.0.extract.trunc = trunc i160 %.sroa.262.0.extract.shift to i64
  %.sroa.061.0.extract.trunc = trunc i160 %50 to i64
  %51 = inttoptr i64 %.sroa.061.0.extract.trunc to ptr
  %52 = inttoptr i64 %.sroa.262.0.extract.trunc to ptr
  %hash_coef_ptr.i3 = getelementptr i8, ptr %45, i64 8
  %tbl_size_ptr.i4 = getelementptr i8, ptr %45, i64 16
  %offset_tbl_ptr.i5 = getelementptr i8, ptr %45, i64 40
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i3, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i4, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i5, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, 4015701072841558310
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %53 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %51, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %52, 2
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 %offset.i14, 3
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %45)
  %59 = sext i32 %offset.i14 to i64
  %60 = getelementptr ptr, ptr %45, i64 %59
  %61 = getelementptr i8, ptr %60, i64 56
  %62 = load ptr, ptr %61, align 8
  %result.i1 = call ptr %62({ ptr, ptr, ptr, i32 } %56, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %63 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull align 8 %5)
  %.fca.0.extract49 = extractvalue { ptr, i160 } %63, 0
  %.fca.1.extract50 = extractvalue { ptr, i160 } %63, 1
  br label %64

64:                                               ; preds = %48, %37, %4, %4
  %.reg2mem9.sroa.0.0 = phi ptr [ @nil_typ, %4 ], [ %.fca.0.extract49, %48 ], [ @nil_typ, %37 ], [ @nil_typ, %4 ]
  %.reg2mem9.sroa.3.0 = phi i160 [ undef, %4 ], [ %.fca.1.extract50, %48 ], [ undef, %37 ], [ undef, %4 ]
  %.reload10.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem9.sroa.0.0, 0
  %.reload10.fca.1.insert = insertvalue { ptr, i160 } %.reload10.fca.0.insert, i160 %.reg2mem9.sroa.3.0, 1
  ret { ptr, i160 } %.reload10.fca.1.insert
}

define void @SwissTable_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #17 {
  %.fca.0.extract91 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract91, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract91, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract91, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract44 = extractvalue { ptr, i160 } %3, 0
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract91) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract91, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call i32 %11(ptr %.fca.1.extract92) #45
  %13 = add i32 %12, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract91, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract92, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i, 3
  %18 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18) #46
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract91) #46
  %21 = getelementptr i8, ptr %8, i64 96
  %22 = load ptr, ptr %21, align 8
  %23 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %23, align 8
  %result.i8 = call ptr %22({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly align 8 %23) #49
  call void %result.i8({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(8) %18, i32 %13)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract91)
  %25 = getelementptr i8, ptr %8, i64 56
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr } %27(ptr %.fca.1.extract92) #45
  %.fca.0.extract26 = extractvalue { ptr } %28, 0
  %29 = call i32 %.fca.0.extract26({ ptr, i160 } %3)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract91)
  %31 = load ptr, ptr %8, align 8
  %result.i4 = call ptr %31(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract92) #47
  %32 = alloca [2 x ptr], align 8
  store ptr %result.i4, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %32, i64 8
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %32)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract91)
  %36 = getelementptr i8, ptr %8, i64 80
  %37 = load ptr, ptr %36, align 8
  %38 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract44, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr @i32_typ, ptr %39, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly align 8 %38) #49
  %40 = call i32 %result.i7({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(16) %32, { ptr, i160 } %3, i32 %29)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %42 = getelementptr i8, ptr %8, i64 32
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr } %44(ptr nonnull %.fca.1.extract92) #45
  %.fca.0.extract = extractvalue { ptr } %45, 0
  %46 = sext i32 %40 to i64
  %47 = getelementptr i8, ptr %.fca.0.extract, i64 %46
  %48 = load i8, ptr %47, align 1
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %50 = load ptr, ptr %8, align 8
  %result.i3 = call align 8 ptr %50(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract92) #47
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %52 = getelementptr i8, ptr %8, i64 8
  %53 = load ptr, ptr %52, align 8
  %result.i2 = call align 8 ptr %53(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract92) #47
  %54 = load ptr, ptr %result.i3, align 8, !alias.scope !27
  %55 = getelementptr i8, ptr %54, i64 72
  %56 = load ptr, ptr %55, align 8, !alias.scope !27
  %result.i1.i = call { i64, i64 } %56(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47, !alias.scope !27
  %57 = extractvalue { i64, i64 } %result.i1.i, 0
  %58 = extractvalue { i64, i64 } %result.i1.i, 1
  %59 = urem i64 20, %58
  %60 = icmp eq i64 %59, 0
  %61 = sub i64 %58, %59
  %62 = select i1 %60, i64 0, i64 %61
  %63 = add i64 %57, 20
  %64 = add i64 %63, %62
  %65 = load ptr, ptr %result.i2, align 8, !alias.scope !27
  %66 = getelementptr i8, ptr %65, i64 72
  %67 = load ptr, ptr %66, align 8, !alias.scope !27
  %result.i.i = call { i64, i64 } %67(ptr nocapture nofree nonnull readonly align 8 %result.i2) #47, !alias.scope !27
  %68 = extractvalue { i64, i64 } %result.i.i, 0
  %69 = extractvalue { i64, i64 } %result.i.i, 1
  %70 = call i64 @llvm.umax.i64(i64 %58, i64 %69) #61
  %71 = call i64 @llvm.umax.i64(i64 %70, i64 noundef 8) #61, !range !5
  %72 = urem i64 %64, %69
  %73 = icmp eq i64 %72, 0
  %74 = sub i64 %69, %72
  %75 = select i1 %73, i64 0, i64 %74
  %76 = add i64 %68, %64
  %77 = add i64 %76, %75
  %78 = urem i64 %77, %71
  %79 = icmp eq i64 %78, 0
  %80 = sub i64 %71, %78
  %81 = select i1 %79, i64 0, i64 %80
  %82 = add i64 %81, %77
  %result.i9 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %82) #51
  store ptr %result.i3, ptr %result.i9, align 8
  %83 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i2, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %87 = load ptr, ptr %result.i3, align 8
  %88 = getelementptr i8, ptr %87, i64 72
  %89 = load ptr, ptr %88, align 8
  %result.i.i10 = call { i64, i64 } %89(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47
  %90 = extractvalue { i64, i64 } %result.i.i10, 1
  %91 = urem i64 20, %90
  %92 = icmp eq i64 %91, 0
  %reass.sub13 = sub i64 %90, %91
  %93 = add i64 %reass.sub13, 20
  %94 = select i1 %92, i64 20, i64 %93
  %95 = getelementptr i8, ptr %result.i9, i64 %94
  %96 = getelementptr i8, ptr %87, i64 64
  %97 = load ptr, ptr %96, align 8
  call void %97({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %95) #48
  %98 = load ptr, ptr %result.i9, align 8
  %99 = load ptr, ptr %98, align 8
  %100 = getelementptr i8, ptr %99, i64 72
  %101 = load ptr, ptr %100, align 8
  %result.i1.i11 = call { i64, i64 } %101(ptr nocapture nofree nonnull readonly align 8 %98) #47
  %102 = extractvalue { i64, i64 } %result.i1.i11, 0
  %103 = extractvalue { i64, i64 } %result.i1.i11, 1
  %104 = urem i64 20, %103
  %105 = icmp eq i64 %104, 0
  %106 = sub i64 %103, %104
  %107 = select i1 %105, i64 0, i64 %106
  %108 = add i64 %102, 20
  %109 = add i64 %108, %107
  %110 = load ptr, ptr %83, align 8
  %111 = load ptr, ptr %110, align 8
  %112 = getelementptr i8, ptr %111, i64 72
  %113 = load ptr, ptr %112, align 8
  %result.i.i12 = call { i64, i64 } %113(ptr nocapture nofree nonnull readonly align 8 %110) #47
  %114 = extractvalue { i64, i64 } %result.i.i12, 1
  %115 = urem i64 %109, %114
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %114, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = getelementptr i8, ptr %result.i9, i64 %109
  %120 = getelementptr i8, ptr %119, i64 %118
  %121 = getelementptr i8, ptr %111, i64 64
  %122 = load ptr, ptr %121, align 8
  call void %122({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %110, ptr nocapture nofree writeonly %120) #48
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #46
  %124 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store i32 %29, ptr %124, align 8
  %125 = icmp eq i8 %48, 0
  br i1 %125, label %126, label %._crit_edge

126:                                              ; preds = %5
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %128 = load ptr, ptr %42, align 8
  %129 = load ptr, ptr %128, align 8
  %130 = call { ptr } %129(ptr nonnull %.fca.1.extract92) #45
  %.fca.0.extract104 = extractvalue { ptr } %130, 0
  %131 = getelementptr i8, ptr %.fca.0.extract104, i64 %46
  store i8 1, ptr %131, align 1
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %133 = load ptr, ptr %9, align 8
  %134 = load ptr, ptr %133, align 8
  %135 = call i32 %134(ptr nonnull %.fca.1.extract92) #45
  %136 = add i32 %135, 1
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %138 = getelementptr i8, ptr %133, i64 8
  %139 = load ptr, ptr %138, align 8
  call void %139(ptr nonnull %.fca.1.extract92, i32 %136) #44
  br label %._crit_edge

._crit_edge:                                      ; preds = %126, %5
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract91)
  %141 = getelementptr i8, ptr %8, i64 24
  %142 = load ptr, ptr %141, align 8
  %143 = load ptr, ptr %142, align 8
  %144 = call { ptr } %143(ptr nonnull %.fca.1.extract92) #45
  %.fca.0.extract98 = extractvalue { ptr } %144, 0
  %145 = shl nsw i64 %46, 5
  %146 = getelementptr i8, ptr %.fca.0.extract98, i64 %145
  store ptr @Entry, ptr %146, align 8
  %147 = getelementptr i8, ptr %146, i64 8
  %148 = ptrtoint ptr %result.i9 to i64
  store i64 %148, ptr %147, align 4
  %.sroa_idx3 = getelementptr i8, ptr %146, i64 24
  store i32 10, ptr %.sroa_idx3, align 4
  ret void
}

define { ptr, i160 } @SwissTable_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract60 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract61 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract60, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract60, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract60, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract21 = extractvalue { ptr, i160 } %3, 0
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract60) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract60, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr %.fca.1.extract61) #45
  %.fca.0.extract13 = extractvalue { ptr } %12, 0
  %13 = call i32 %.fca.0.extract13({ ptr, i160 } %3)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract60, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract61, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract60)
  %19 = load ptr, ptr %8, align 8
  %result.i1 = call ptr %19(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract61) #47
  %20 = alloca [2 x ptr], align 8
  store ptr %result.i1, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @_parameterization_i32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %20)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract60)
  %24 = getelementptr i8, ptr %8, i64 80
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract21, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr @i32_typ, ptr %27, align 8
  %result.i3 = call ptr %25({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly align 8 %26) #49
  %28 = call i32 %result.i3({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(16) %20, { ptr, i160 } %3, i32 %13)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract60)
  %30 = getelementptr i8, ptr %8, i64 32
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr } %32(ptr nonnull %.fca.1.extract61) #45
  %.fca.0.extract = extractvalue { ptr } %33, 0
  %34 = sext i32 %28 to i64
  %35 = getelementptr i8, ptr %.fca.0.extract, i64 %34
  %36 = load i8, ptr %35, align 1
  switch i8 %36, label %37 [
    i8 -128, label %98
    i8 0, label %98
  ]

37:                                               ; preds = %4
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract60)
  %39 = getelementptr i8, ptr %8, i64 24
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr } %41(ptr nonnull %.fca.1.extract61) #45
  %.fca.0.extract106 = extractvalue { ptr } %42, 0
  %43 = shl nsw i64 %34, 5
  %44 = getelementptr i8, ptr %.fca.0.extract106, i64 %43
  %45 = load ptr, ptr %44, align 8
  %46 = icmp eq ptr %45, @nil_typ
  %47 = icmp eq ptr %45, null
  %.not115.not = or i1 %46, %47
  br i1 %.not115.not, label %98, label %48

48:                                               ; preds = %37
  %49 = getelementptr i8, ptr %44, i64 8
  %50 = load i160, ptr %49, align 4
  %.sroa.2103.0.extract.shift = lshr i160 %50, 64
  %.sroa.2103.0.extract.trunc = trunc i160 %.sroa.2103.0.extract.shift to i64
  %.sroa.0102.0.extract.trunc = trunc i160 %50 to i64
  %51 = inttoptr i64 %.sroa.0102.0.extract.trunc to ptr
  %52 = inttoptr i64 %.sroa.2103.0.extract.trunc to ptr
  %hash_coef_ptr.i5 = getelementptr i8, ptr %45, i64 8
  %tbl_size_ptr.i6 = getelementptr i8, ptr %45, i64 16
  %offset_tbl_ptr.i7 = getelementptr i8, ptr %45, i64 40
  %hash_coef.i8 = load i64, ptr %hash_coef_ptr.i5, align 4
  %tbl_size.i9 = load i64, ptr %tbl_size_ptr.i6, align 4
  %offset_tbl.i10 = load ptr, ptr %offset_tbl_ptr.i7, align 8
  %product.i.i11 = mul i64 %hash_coef.i8, 4015701072841558310
  %shifted.i.i12 = lshr i64 %product.i.i11, 32
  %xored.i.i13 = xor i64 %shifted.i.i12, %product.i.i11
  %hash.i.i14 = and i64 %xored.i.i13, %tbl_size.i9
  %offset_ptr.i15 = getelementptr i32, ptr %offset_tbl.i10, i64 %hash.i.i14
  %offset.i16 = load i32, ptr %offset_ptr.i15, align 4
  %53 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %51, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %52, 2
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 %offset.i16, 3
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %45)
  %59 = sext i32 %offset.i16 to i64
  %60 = getelementptr ptr, ptr %45, i64 %59
  %61 = getelementptr i8, ptr %60, i64 56
  %62 = load ptr, ptr %61, align 8
  %result.i2 = call ptr %62({ ptr, ptr, ptr, i32 } %56, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %63 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull align 8 %5)
  %.fca.0.extract86 = extractvalue { ptr, i160 } %63, 0
  %.fca.1.extract87 = extractvalue { ptr, i160 } %63, 1
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract60)
  %65 = getelementptr i8, ptr %8, i64 8
  %66 = load ptr, ptr %65, align 8
  %result.i = call align 8 ptr %66(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract61) #47
  %67 = load ptr, ptr %result.i, align 8
  %68 = ptrtoint ptr %67 to i64
  %69 = getelementptr i8, ptr %.fca.0.extract86, i64 8
  %70 = getelementptr i8, ptr %.fca.0.extract86, i64 16
  %71 = getelementptr i8, ptr %.fca.0.extract86, i64 24
  %72 = getelementptr i8, ptr %.fca.0.extract86, i64 32
  %73 = load i64, ptr %69, align 4
  %74 = load i64, ptr %70, align 4
  %75 = load ptr, ptr %71, align 8
  %76 = load ptr, ptr %72, align 8
  %77 = load i64, ptr %67, align 4
  %result.i4 = call i1 %75(i64 %74, i64 %73, i64 %77, i64 %68, ptr readonly %76) #47
  br i1 %result.i4, label %78, label %98

78:                                               ; preds = %48
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract60)
  %80 = load ptr, ptr %30, align 8
  %81 = load ptr, ptr %80, align 8
  %82 = call { ptr } %81(ptr nonnull %.fca.1.extract61) #45
  %.fca.0.extract73 = extractvalue { ptr } %82, 0
  %83 = getelementptr i8, ptr %.fca.0.extract73, i64 %34
  store i8 -128, ptr %83, align 1
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract60)
  %85 = load ptr, ptr %39, align 8
  %86 = load ptr, ptr %85, align 8
  %87 = call { ptr } %86(ptr nonnull %.fca.1.extract61) #45
  %.fca.0.extract70 = extractvalue { ptr } %87, 0
  %88 = getelementptr i8, ptr %.fca.0.extract70, i64 %43
  store ptr @nil_typ, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract60)
  %90 = getelementptr i8, ptr %8, i64 48
  %91 = load ptr, ptr %90, align 8
  %92 = load ptr, ptr %91, align 8
  %93 = call i32 %92(ptr nonnull %.fca.1.extract61) #45
  %94 = add i32 %93, -1
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract60)
  %96 = getelementptr i8, ptr %91, i64 8
  %97 = load ptr, ptr %96, align 8
  call void %97(ptr nonnull %.fca.1.extract61, i32 %94) #44
  br label %98

98:                                               ; preds = %78, %48, %37, %4, %4
  %.reg2mem13.sroa.0.0 = phi ptr [ @nil_typ, %4 ], [ @nil_typ, %37 ], [ %.fca.0.extract86, %78 ], [ @nil_typ, %48 ], [ @nil_typ, %4 ]
  %.reg2mem13.sroa.3.0 = phi i160 [ undef, %4 ], [ undef, %37 ], [ %.fca.1.extract87, %78 ], [ %.fca.1.extract87, %48 ], [ undef, %4 ]
  %.reload14.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem13.sroa.0.0, 0
  %.reload14.fca.1.insert = insertvalue { ptr, i160 } %.reload14.fca.0.insert, i160 %.reg2mem13.sroa.3.0, 1
  ret { ptr, i160 } %.reload14.fca.1.insert
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Map_keys_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %10 = load ptr, ptr %6, align 8
  %result.i2 = call ptr %10(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %result.i7 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i3, ptr %result.i7, align 8
  %11 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i2, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, -5249855671126779970
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapKeys, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr undef, 2
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @MapKeys) #43
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 48, 3
  ret { ptr, ptr, ptr, i32 } %22
}

; Function Attrs: mustprogress nounwind willreturn
define void @SwissTable_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i1 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #51
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr } undef, ptr %result.i1, 0
  call void %10(ptr %.fca.1.extract, { ptr } %11) #44
  %result.i = call noalias dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %13 = getelementptr i8, ptr %6, i64 32
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %16(ptr %.fca.1.extract, { ptr } %17) #44
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %19 = getelementptr i8, ptr %6, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 8) #44
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %24 = getelementptr i8, ptr %6, i64 48
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr %.fca.1.extract, i32 0) #44
  ret void
}

define { ptr, ptr, ptr, i32 } @Map_indices_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract15, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract16, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #43
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #43
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract14, i64 %11
  %13 = getelementptr i8, ptr %12, i64 48
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %15 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 1375598993350293883
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i12, 3
  ret { ptr, ptr, ptr, i32 } %19
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Map_values_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i3 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %9 = getelementptr i8, ptr %6, i64 8
  %10 = load ptr, ptr %9, align 8
  %result.i2 = call ptr %10(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %result.i7 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i3, ptr %result.i7, align 8
  %11 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i2, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i7) #43
  %hash_coef.i11 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i12 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i13 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i14 = mul i64 %hash_coef.i11, -5249855671126779970
  %shifted.i.i15 = lshr i64 %product.i.i14, 32
  %xored.i.i16 = xor i64 %shifted.i.i15, %product.i.i14
  %hash.i.i17 = and i64 %xored.i.i16, %tbl_size.i12
  %offset_ptr.i18 = getelementptr i32, ptr %offset_tbl.i13, i64 %hash.i.i17
  %offset.i19 = load i32, ptr %offset_ptr.i18, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapValues, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr undef, 2
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @MapValues) #43
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i19, ptr %21, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 48, 3
  ret { ptr, ptr, ptr, i32 } %22
}

define { ptr, i160 } @Map__index_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %10 = alloca [2 x ptr], align 8
  %11 = alloca { ptr, ptr }, align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract4 = extractvalue { ptr, i160 } %3, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract23, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #43
  %17 = sext i32 %offset.i to i64
  %18 = getelementptr ptr, ptr %.fca.0.extract21, i64 %17
  %19 = load ptr, ptr %18, align 8
  %result.i = call ptr %19(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract23) #47
  %20 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20) #43
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #43
  %23 = getelementptr i8, ptr %18, i64 24
  %24 = load ptr, ptr %23, align 8
  %25 = alloca { ptr }, align 8
  store ptr %.fca.0.extract4, ptr %25, align 8
  %result.i1 = call ptr %24({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %25) #49
  %26 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 dereferenceable(8) %20, { ptr, i160 } %3)
  %.fca.0.extract = extractvalue { ptr, i160 } %26, 0
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract21)
  %28 = icmp ne ptr %.fca.0.extract, @nil_typ
  %29 = icmp ne ptr %.fca.0.extract, null
  %.not67 = and i1 %28, %29
  br i1 %.not67, label %30, label %codeRepl

30:                                               ; preds = %4
  ret { ptr, i160 } %26

codeRepl:                                         ; preds = %4
  call fastcc void @Map__index_keyK.cold.1(ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %9, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %10, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %11, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr noalias nocapture nofree noundef nonnull align 8 %5, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %7) #63
  unreachable
}

define void @Map__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #17 {
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5249855671126779970
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract7 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract21, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #43
  %11 = sext i32 %offset.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract20, i64 %11
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #47
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #43
  %15 = getelementptr i8, ptr %12, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i = call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #47
  %17 = alloca [2 x ptr], align 8
  store ptr %result.i1, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %result.i, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %17) #43
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef align 8 %.fca.0.extract20) #43
  %21 = getelementptr i8, ptr %12, i64 32
  %22 = load ptr, ptr %21, align 8
  %23 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract7, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %23, i64 8
  store ptr %.fca.0.extract, ptr %24, align 8
  %result.i2 = call ptr %22({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %23) #49
  call void %result.i2({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 dereferenceable(16) %17, { ptr, i160 } %3, { ptr, i160 } %4)
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @SwissTable_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 48
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @SwissTable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4490338885899135281
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract49, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr nonnull %.fca.1.extract) #45
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr } %14(ptr nonnull %.fca.1.extract) #45
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %17 = getelementptr i8, ptr %6, i64 40
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr nonnull %.fca.1.extract) #45
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %22 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %22(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %24 = getelementptr i8, ptr %6, i64 8
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %result.i6 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #51
  %28 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr %result.i1, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i6, i64 24
  store ptr null, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i6) #46
  store ptr @Pair, ptr %result.i6, align 8
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i1, ptr %result.i5, align 8
  %32 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %result.i6, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #46
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %36 = load ptr, ptr %7, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr nonnull %.fca.1.extract) #45
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %40 = load ptr, ptr %12, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr } %41(ptr nonnull %.fca.1.extract) #45
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 9040, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #46
  %44 = load ptr, ptr %17, align 8
  %45 = load ptr, ptr %44, align 8
  %46 = call i32 %45(ptr nonnull %.fca.1.extract) #45
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @SwissTableIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = getelementptr inbounds i8, ptr %result.i5, i64 24
  %.fca.0.extract.i = extractvalue { ptr } %38, 0
  store ptr %.fca.0.extract.i, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i5, i64 32
  %.fca.0.extract.i7 = extractvalue { ptr } %42, 0
  store ptr %.fca.0.extract.i7, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i5, i64 44
  %52 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 0, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @SwissTableIterator) #46
  store i32 %46, ptr %51, align 4
  %54 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %54
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_SwissTableIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTableIterator_B_init_map_entriesBufferEntryK._V_or_Nil_map_metadataBufferi8_lengthi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @SwissTableIterator_field_SwissTableIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @SwissTableIterator_field_SwissTableIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @SwissTableIterator_field_SwissTableIterator_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @SwissTableIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define void @SwissTableIterator_init_map_entriesBufferEntryK._V_or_Nil_map_metadataBufferi8_lengthi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4, i32 %5) #6 {
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract24, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7015872805459348650
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract24, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #44
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #46
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, { ptr } %4) #44
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #46
  %20 = getelementptr i8, ptr %9, i64 48
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #44
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #46
  %25 = getelementptr i8, ptr %9, i64 40
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %.fca.1.extract, i32 0) #44
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #46
  %30 = load ptr, ptr %20, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = call i32 %31(ptr %.fca.1.extract) #45
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract24) #46
  %34 = getelementptr i8, ptr %30, i64 8
  %35 = load ptr, ptr %34, align 8
  call void %35(ptr %.fca.1.extract, i32 %32) #44
  ret void
}

define { ptr, i160 } @SwissTableIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract27, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7015872805459348650
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27) #60
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract27, i64 %6
  %8 = getelementptr i8, ptr %7, i64 40
  %9 = getelementptr i8, ptr %7, i64 48
  %10 = getelementptr i8, ptr %7, i64 32
  %11 = getelementptr i8, ptr %7, i64 24
  br label %12

12:                                               ; preds = %21, %3
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract28) #45
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27)
  %17 = load ptr, ptr %9, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract28) #45
  %20 = icmp slt i32 %15, %19
  br i1 %20, label %21, label %.thread34

21:                                               ; preds = %12
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27)
  %23 = call i32 %14(ptr %.fca.1.extract28) #45
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27)
  %25 = load ptr, ptr %10, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %.fca.1.extract28) #45
  %.fca.0.extract70 = extractvalue { ptr } %27, 0
  %28 = sext i32 %23 to i64
  %29 = getelementptr i8, ptr %.fca.0.extract70, i64 %28
  %30 = load i8, ptr %29, align 1
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27)
  %32 = call i32 %14(ptr %.fca.1.extract28) #45
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27)
  %34 = load ptr, ptr %11, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract28) #45
  %.fca.0.extract64 = extractvalue { ptr } %36, 0
  %37 = sext i32 %32 to i64
  %38 = shl nsw i64 %37, 5
  %39 = getelementptr i8, ptr %.fca.0.extract64, i64 %38
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr i8, ptr %39, i64 8
  %42 = load i160, ptr %41, align 4
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27)
  %44 = call i32 %14(ptr %.fca.1.extract28) #45
  %45 = add i32 %44, 1
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract27)
  %47 = getelementptr i8, ptr %13, i64 8
  %48 = load ptr, ptr %47, align 8
  call void %48(ptr %.fca.1.extract28, i32 %45) #44
  %49 = and i8 %30, 127
  %spec.select = icmp ne i8 %49, 0
  %50 = icmp ne ptr %40, @nil_typ
  %51 = icmp ne ptr %40, null
  %.not80 = and i1 %50, %51
  %.reg2mem22.0.off0.not = select i1 %spec.select, i1 %.not80, i1 false
  br i1 %.reg2mem22.0.off0.not, label %52, label %12

52:                                               ; preds = %21
  %.sroa.261.0.extract.shift.le = lshr i160 %42, 64
  %.sroa.261.0.extract.trunc.le = trunc i160 %.sroa.261.0.extract.shift.le to i64
  %.sroa.060.0.extract.trunc.le = trunc i160 %42 to i64
  %53 = inttoptr i64 %.sroa.060.0.extract.trunc.le to ptr
  %54 = inttoptr i64 %.sroa.261.0.extract.trunc.le to ptr
  %hash_coef_ptr.i1 = getelementptr i8, ptr %40, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %40, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %40, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 4015701072841558310
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %40, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %53, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %54, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %offset.i12, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %40)
  %61 = sext i32 %offset.i12 to i64
  %62 = getelementptr ptr, ptr %40, i64 %61
  %63 = getelementptr i8, ptr %62, i64 72
  %64 = load ptr, ptr %63, align 8
  %result.i = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %65 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %4)
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %65, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %65, 1
  %.fca.2.extract36 = extractvalue { ptr, ptr, ptr, i32 } %65, 2
  %hash_coef_ptr.i13 = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i14 = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i15 = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i16 = load i64, ptr %hash_coef_ptr.i13, align 4
  %tbl_size.i17 = load i64, ptr %tbl_size_ptr.i14, align 4
  %offset_tbl.i18 = load ptr, ptr %offset_tbl_ptr.i15, align 8
  %product.i.i19 = mul i64 %hash_coef.i16, 9197944775169318296
  %shifted.i.i20 = lshr i64 %product.i.i19, 32
  %xored.i.i21 = xor i64 %shifted.i.i20, %product.i.i19
  %hash.i.i22 = and i64 %xored.i.i21, %tbl_size.i17
  %offset_ptr.i23 = getelementptr i32, ptr %offset_tbl.i18, i64 %hash.i.i22
  %offset.i24 = load i32, ptr %offset_ptr.i23, align 4
  %66 = ptrtoint ptr %.fca.1.extract35 to i64
  %67 = ptrtoint ptr %.fca.2.extract36 to i64
  %.sroa.633.8.insert.ext = zext i32 %offset.i24 to i160
  %.sroa.633.8.insert.shift = shl nuw i160 %.sroa.633.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %67 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.633.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext = zext i64 %66 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext
  br label %.thread34

.thread34:                                        ; preds = %52, %12
  %.reg2mem16.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %52 ], [ undef, %12 ]
  %.reg2mem16.sroa.0.0 = phi ptr [ %.fca.0.extract34, %52 ], [ @nil_typ, %12 ]
  %.reload17.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem16.sroa.0.0, 0
  %.reload17.fca.1.insert = insertvalue { ptr, i160 } %.reload17.fca.0.insert, i160 %.reg2mem16.sroa.3.0, 1
  ret { ptr, i160 } %.reload17.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #38 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #47
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #47
  %20 = extractvalue { i64, i64 } %result.i, 0
  %21 = extractvalue { i64, i64 } %result.i, 1
  %22 = call i64 @llvm.umax.i64(i64 %8, i64 %21) #61
  %23 = call i64 @llvm.umax.i64(i64 %22, i64 noundef 8) #61, !range !5
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %33, %29
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_init_keyK_valueV_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_to_pair_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Entry_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #45
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract7, i64 %5
  %7 = getelementptr i8, ptr %6, i64 32
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract8) #45
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_init_keyK_valueV_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #5 {
  %.fca.0.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract22, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract22, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract22, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract22) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract22, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract23, { ptr, i160 } %3) #44
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract22) #46
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract23, { ptr, i160 } %4) #44
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract22) #46
  %20 = getelementptr i8, ptr %9, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract23, i32 %5) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Entry_to_pair_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract57, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract57, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract57, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4015701072841558310
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract57, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr nonnull %.fca.1.extract58) #45
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #46
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr, i160 } %14(ptr nonnull %.fca.1.extract58) #45
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #46
  %17 = load ptr, ptr %6, align 8
  %result.i3 = call align 8 ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract58) #47
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #46
  %19 = getelementptr i8, ptr %6, i64 8
  %20 = load ptr, ptr %19, align 8
  %result.i2 = call align 8 ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract58) #47
  %21 = load ptr, ptr %result.i3, align 8, !alias.scope !30
  %22 = getelementptr i8, ptr %21, i64 72
  %23 = load ptr, ptr %22, align 8, !alias.scope !30
  %result.i1.i = call { i64, i64 } %23(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47, !alias.scope !30
  %24 = extractvalue { i64, i64 } %result.i1.i, 0
  %25 = extractvalue { i64, i64 } %result.i1.i, 1
  %26 = urem i64 16, %25
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %25, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %24, 16
  %31 = add i64 %30, %29
  %32 = load ptr, ptr %result.i2, align 8, !alias.scope !30
  %33 = getelementptr i8, ptr %32, i64 72
  %34 = load ptr, ptr %33, align 8, !alias.scope !30
  %result.i.i = call { i64, i64 } %34(ptr nocapture nofree nonnull readonly align 8 %result.i2) #47, !alias.scope !30
  %35 = extractvalue { i64, i64 } %result.i.i, 0
  %36 = extractvalue { i64, i64 } %result.i.i, 1
  %37 = call i64 @llvm.umax.i64(i64 %25, i64 %36) #61
  %38 = call i64 @llvm.umax.i64(i64 %37, i64 noundef 8) #61, !range !5
  %39 = urem i64 %31, %36
  %40 = icmp eq i64 %39, 0
  %41 = sub i64 %36, %39
  %42 = select i1 %40, i64 0, i64 %41
  %43 = add i64 %35, %31
  %44 = add i64 %43, %42
  %45 = urem i64 %44, %38
  %46 = icmp eq i64 %45, 0
  %47 = sub i64 %38, %45
  %48 = select i1 %46, i64 0, i64 %47
  %49 = add i64 %48, %44
  %result.i6 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %49) #51
  store ptr %result.i3, ptr %result.i6, align 8
  %50 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i6) #46
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #46
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr, i160 } %54(ptr nonnull %.fca.1.extract58) #45
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #46
  %57 = load ptr, ptr %12, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, i160 } %58(ptr nonnull %.fca.1.extract58) #45
  %60 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr undef, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 10, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #46
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract57) #46
  %65 = load ptr, ptr %result.i3, align 8
  %66 = getelementptr i8, ptr %65, i64 72
  %67 = load ptr, ptr %66, align 8
  %result.i.i7 = call { i64, i64 } %67(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47
  %68 = extractvalue { i64, i64 } %result.i.i7, 1
  %69 = urem i64 16, %68
  %70 = icmp eq i64 %69, 0
  %reass.sub10 = sub i64 %68, %69
  %71 = add i64 %reass.sub10, 16
  %72 = select i1 %70, i64 16, i64 %71
  %73 = getelementptr i8, ptr %result.i6, i64 %72
  %74 = getelementptr i8, ptr %65, i64 64
  %75 = load ptr, ptr %74, align 8
  call void %75({ ptr, i160 } %55, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %73) #48
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Pair) #46
  %77 = load ptr, ptr %result.i6, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr i8, ptr %78, i64 72
  %80 = load ptr, ptr %79, align 8
  %result.i1.i8 = call { i64, i64 } %80(ptr nocapture nofree nonnull readonly align 8 %77) #47
  %81 = extractvalue { i64, i64 } %result.i1.i8, 0
  %82 = extractvalue { i64, i64 } %result.i1.i8, 1
  %83 = urem i64 16, %82
  %84 = icmp eq i64 %83, 0
  %85 = sub i64 %82, %83
  %86 = select i1 %84, i64 0, i64 %85
  %87 = add i64 %81, 16
  %88 = add i64 %87, %86
  %89 = load ptr, ptr %50, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = getelementptr i8, ptr %90, i64 72
  %92 = load ptr, ptr %91, align 8
  %result.i.i9 = call { i64, i64 } %92(ptr nocapture nofree nonnull readonly align 8 %89) #47
  %93 = extractvalue { i64, i64 } %result.i.i9, 1
  %94 = urem i64 %88, %93
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %93, %94
  %97 = select i1 %95, i64 0, i64 %96
  %98 = getelementptr i8, ptr %result.i6, i64 %88
  %99 = getelementptr i8, ptr %98, i64 %97
  %100 = getelementptr i8, ptr %90, i64 64
  %101 = load ptr, ptr %100, align 8
  call void %101({ ptr, i160 } %59, ptr nocapture nofree nonnull readonly align 8 %89, ptr nocapture nofree writeonly %99) #48
  ret { ptr, ptr, ptr, i32 } %62
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_value(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #38 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i1 = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #47
  %6 = extractvalue { i64, i64 } %result.i1, 0
  %7 = extractvalue { i64, i64 } %result.i1, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 20
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %15) #47
  %19 = extractvalue { i64, i64 } %result.i, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly align 8 %15) #47
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_value(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #39 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #47
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #47
  %20 = extractvalue { i64, i64 } %result.i, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %16, ptr nocapture nofree writeonly %26) #48
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_key(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #38 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #47
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 20, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 20
  %10 = select i1 %8, i64 20, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly align 8 %2) #47
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_key(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #39 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #47
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %3, ptr nocapture nofree writeonly %12) #48
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_hash(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_hash(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @SwissTableIterator_getter_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTableIterator_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @SwissTableIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTableIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @SwissTableIterator_getter_map_metadata(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTableIterator_setter_map_metadata(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @SwissTableIterator_getter_map_entries(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTableIterator_setter_map_entries(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Map(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IndexableCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Indexable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_KeyNotFound(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @KeyNotFound_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapValues(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValues_field_MapValues_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValues_field_MapValues_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 28, i64 27
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 36, i64 37
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapValues_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 2074062704914054732
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, -5249855671126779970
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #44
  ret void
}

define i32 @MapValues_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 2074062704914054732
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 96
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @MapValues_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 2074062704914054732
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract66, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract68) #45
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract39) #46
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %24 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #47
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %26 = getelementptr i8, ptr %7, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call ptr %27(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #47
  %result.i10 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i3, ptr %result.i10, align 8
  %28 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i10)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, ptr, ptr, i32 } %32(ptr nonnull %.fca.1.extract68) #45
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract15, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract16, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %.fca.3.extract17, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract14)
  %40 = sext i32 %.fca.3.extract17 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract14, i64 %40
  %42 = getelementptr i8, ptr %41, i64 112
  %43 = load ptr, ptr %42, align 8
  %result.i6 = call ptr %43({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %44 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %hash_coef_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i12 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i14 = load i64, ptr %hash_coef_ptr.i11, align 4
  %tbl_size.i15 = load i64, ptr %tbl_size_ptr.i12, align 4
  %offset_tbl.i16 = load ptr, ptr %offset_tbl_ptr.i13, align 8
  %product.i.i17 = mul i64 %hash_coef.i14, 8673632051301757104
  %shifted.i.i18 = lshr i64 %product.i.i17, 32
  %xored.i.i19 = xor i64 %shifted.i.i18, %product.i.i17
  %hash.i.i20 = and i64 %xored.i.i19, %tbl_size.i15
  %offset_ptr.i21 = getelementptr i32, ptr %offset_tbl.i16, i64 %hash.i.i20
  %offset.i22 = load i32, ptr %offset_ptr.i21, align 4
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapValueIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @MapValueIterator) #43
  %50 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store i32 %offset.i22, ptr %53, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %54
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapValueIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValueIterator_B_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValueIterator_field_MapValueIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValueIterator_field_MapValueIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValueIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapValueIterator_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4981803053484113385
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #44
  ret void
}

define { ptr, i160 } @MapValueIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -4981803053484113385
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract15, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract17) #45
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = icmp ne ptr %.fca.0.extract, @nil_typ
  %24 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %23, %24
  br i1 %.not43, label %25, label %39

25:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %22, 1
  %.sroa.3.sroa.2.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.sroa.2.0.extract.trunc = trunc i160 %.sroa.3.sroa.2.0.extract.shift to i64
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %26 = inttoptr i64 %.sroa.3.sroa.0.0.extract.trunc to ptr
  %27 = inttoptr i64 %.sroa.3.sroa.2.0.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 9197944775169318296
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %26, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %27, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %offset.i13, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %34 = sext i32 %offset.i13 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 40
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %38, 0
  %.fca.1.extract30 = extractvalue { ptr, i160 } %38, 1
  br label %39

39:                                               ; preds = %25, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract28, %25 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract30, %25 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapValueIterator_getter_map_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapValueIterator_setter_map_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapValues_getter_map(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapValues_setter_map(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapKeys(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeys_field_MapKeys_1(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeys_field_MapKeys_0(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 28, i64 27
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 36, i64 37
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [122 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapKeys_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -6755415596079746205
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, -5249855671126779970
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #44
  ret void
}

define i32 @MapKeys_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -6755415596079746205
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract6) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 96
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  ret i32 %22
}

define { ptr, ptr, ptr, i32 } @MapKeys_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract66, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -6755415596079746205
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract66, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract68) #45
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract41, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract43, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract45, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract39) #46
  %18 = sext i32 %.fca.3.extract45 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract39, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %24 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #47
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %26 = getelementptr i8, ptr %7, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call ptr %27(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract68) #47
  %result.i10 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i3, ptr %result.i10, align 8
  %28 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i10)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, ptr, ptr, i32 } %32(ptr nonnull %.fca.1.extract68) #45
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract15, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract16, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %.fca.3.extract17, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract14)
  %40 = sext i32 %.fca.3.extract17 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract14, i64 %40
  %42 = getelementptr i8, ptr %41, i64 112
  %43 = load ptr, ptr %42, align 8
  %result.i6 = call ptr %43({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %44 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %hash_coef_ptr.i11 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i12 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i13 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i14 = load i64, ptr %hash_coef_ptr.i11, align 4
  %tbl_size.i15 = load i64, ptr %tbl_size_ptr.i12, align 4
  %offset_tbl.i16 = load ptr, ptr %offset_tbl_ptr.i13, align 8
  %product.i.i17 = mul i64 %hash_coef.i14, 8673632051301757104
  %shifted.i.i18 = lshr i64 %product.i.i17, 32
  %xored.i.i19 = xor i64 %shifted.i.i18, %product.i.i17
  %hash.i.i20 = and i64 %xored.i.i19, %tbl_size.i15
  %offset_ptr.i21 = getelementptr i32, ptr %offset_tbl.i16, i64 %hash.i.i20
  %offset.i22 = load i32, ptr %offset_ptr.i21, align 4
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapKeyIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef align 8 %.fca.0.extract66)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @MapKeyIterator) #43
  %50 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store i32 %offset.i22, ptr %53, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %54
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapKeyIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeyIterator_B_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeyIterator_field_MapKeyIterator_1(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeyIterator_field_MapKeyIterator_0(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeyIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapKeyIterator_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7211362081012783701
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, 8673632051301757104
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #44
  ret void
}

define { ptr, i160 } @MapKeyIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 7211362081012783701
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract15, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract17) #45
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = icmp ne ptr %.fca.0.extract, @nil_typ
  %24 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %23, %24
  br i1 %.not43, label %25, label %39

25:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %22, 1
  %.sroa.3.sroa.2.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.sroa.2.0.extract.trunc = trunc i160 %.sroa.3.sroa.2.0.extract.shift to i64
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %26 = inttoptr i64 %.sroa.3.sroa.0.0.extract.trunc to ptr
  %27 = inttoptr i64 %.sroa.3.sroa.2.0.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 9197944775169318296
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %26, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %27, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %offset.i13, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %34 = sext i32 %offset.i13 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 32
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %38 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %38, 0
  %.fca.1.extract30 = extractvalue { ptr, i160 } %38, 1
  br label %39

39:                                               ; preds = %25, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract28, %25 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract30, %25 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapKeyIterator_getter_map_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapKeyIterator_setter_map_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapKeys_getter_map(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapKeys_setter_map(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @SwissTable_getter_eq(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTable_setter_eq(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @SwissTable_getter_hasher(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTable_setter_hasher(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @SwissTable_getter_size(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTable_setter_size(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @SwissTable_getter_entries_len(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTable_setter_entries_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @SwissTable_getter_metadata(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTable_setter_metadata(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @SwissTable_getter_entries(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @SwissTable_setter_entries(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @Array_field_Array_2(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_bounds_check_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_insert_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_empty_(ptr nocapture nofree %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #43
  ret ptr @Array__Self_empty_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterableT(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #36 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #43
  ret ptr @Array__Self_from_iterable_iterableIterableT
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_last_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_extend_otherCollectionT_extend_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 55, i64 56
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_indices_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_values_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__set_index_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 616
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 624
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 632
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 71, i64 72
  %8 = getelementptr [529 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 664
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 75, i64 74
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_interleave_otherIterableT_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 77, i64 76
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 79, i64 78
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #47
  %12 = select i1 %result.i, i64 80, i64 81
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [529 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 736
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %8 = load ptr, ptr %result.i, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %result.i1 = call { i64, i64 } %10(ptr nocapture nofree nonnull readonly align 8 %result.i) #47
  %11 = extractvalue { i64, i64 } %result.i1, 0
  %result.i2 = call noalias ptr @bump_malloc_wrapper(i64 noundef %11) #51
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %16(ptr nonnull %.fca.1.extract, { ptr } %17) #44
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %19 = getelementptr i8, ptr %6, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr nonnull %.fca.1.extract, i32 0) #44
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %24 = getelementptr i8, ptr %6, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr nonnull %.fca.1.extract, i32 1) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr nonnull %.fca.1.extract, i32 %3) #44
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr nonnull %.fca.1.extract) #45
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %17 = load ptr, ptr %7, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %18 = sext i32 %15 to i64
  %19 = load ptr, ptr %result.i, align 8
  %20 = getelementptr i8, ptr %19, i64 72
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call { i64, i64 } %21(ptr nocapture nofree nonnull readonly align 8 %result.i) #47
  %22 = extractvalue { i64, i64 } %result.i1, 0
  %23 = mul i64 %22, %18
  %result.i2 = call noalias ptr @bump_malloc_wrapper(i64 noundef %23) #51
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %25 = getelementptr i8, ptr %7, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %28(ptr nonnull %.fca.1.extract, { ptr } %29) #44
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %31 = getelementptr i8, ptr %7, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr nonnull %.fca.1.extract, i32 0) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #5 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract12, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #44
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #46
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, i32 %4) #44
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #46
  %20 = getelementptr i8, ptr %9, i64 24
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #44
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #45
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %.loopexit

12:                                               ; preds = %4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr nonnull %.fca.1.extract, i32 %3) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr } %19(ptr nonnull %.fca.1.extract) #45
  %.fca.0.extract56 = extractvalue { ptr } %20, 0
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %22 = load ptr, ptr %8, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = call i32 %23(ptr nonnull %.fca.1.extract) #45
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %26 = load ptr, ptr %7, align 8
  %result.i3 = call nonnull align 8 dereferenceable(8) ptr %26(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %27 = sext i32 %24 to i64
  %28 = load ptr, ptr %result.i3, align 8
  %29 = getelementptr i8, ptr %28, i64 72
  %30 = load ptr, ptr %29, align 8
  %result.i6 = call { i64, i64 } %30(ptr nocapture nofree nonnull readonly align 8 %result.i3) #47
  %31 = extractvalue { i64, i64 } %result.i6, 0
  %32 = mul i64 %31, %27
  %result.i8 = call noalias ptr @bump_malloc_wrapper(i64 noundef %32) #51
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %34 = load ptr, ptr %17, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %result.i8, 0
  call void %36(ptr nonnull %.fca.1.extract, { ptr } %37) #44
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr nonnull %.fca.1.extract) #45
  %43 = icmp sgt i32 %42, 0
  br i1 %43, label %._crit_edge.lr.ph, label %.loopexit

._crit_edge.lr.ph:                                ; preds = %12
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %46 = load ptr, ptr %7, align 8
  %result.i2 = call nonnull align 8 dereferenceable(8) ptr %46(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %47 = load ptr, ptr %result.i2, align 8
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i5 = call { i64, i64 } %49(ptr nocapture nofree nonnull readonly align 8 %result.i2) #47
  %50 = extractvalue { i64, i64 } %result.i5, 0
  %51 = mul i64 %50, %indvars.iv
  %52 = getelementptr i8, ptr %.fca.0.extract56, i64 %51
  %53 = getelementptr i8, ptr %47, i64 56
  %54 = load ptr, ptr %53, align 8
  %result.i7 = call { ptr, i160 } %54(ptr nocapture nofree readonly %52, ptr nocapture nofree nonnull readonly align 8 %result.i2) #47
  %55 = load ptr, ptr %17, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = call { ptr } %56(ptr nonnull %.fca.1.extract) #45
  %.fca.0.extract39 = extractvalue { ptr } %57, 0
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #46
  %59 = getelementptr i8, ptr %.fca.0.extract39, i64 %51
  %60 = getelementptr i8, ptr %47, i64 64
  %61 = load ptr, ptr %60, align 8
  call void %61({ ptr, i160 } %result.i7, ptr nocapture nofree nonnull readonly align 8 %result.i2, ptr nocapture nofree writeonly %59) #48
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %62 = load ptr, ptr %39, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call i32 %63(ptr nonnull %.fca.1.extract) #45
  %65 = sext i32 %64 to i64
  %66 = icmp slt i64 %indvars.iv.next, %65
  br i1 %66, label %._crit_edge, label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %12, %4
  ret void
}

define void @Array_bounds_check_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #17 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca [4 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %14 = sext i32 %offset.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract, i64 %14
  %16 = getelementptr i8, ptr %15, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #45
  %20 = add i32 %19, -1
  %21 = icmp sgt i32 %3, %20
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %23 = call i32 %18(ptr %.fca.1.extract) #45
  %24 = add i32 %23, %3
  %25 = icmp slt i32 %24, 0
  %.0 = select i1 %21, i1 true, i1 %25
  br i1 %.0, label %codeRepl, label %._crit_edge

codeRepl:                                         ; preds = %4
  call fastcc void @Array_bounds_check_indexi32.cold.1(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract, ptr %.fca.1.extract, ptr nocapture nofree noundef nonnull readonly %18, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %5, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7, i32 %3, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %12) #62
  br label %._crit_edge

._crit_edge:                                      ; preds = %codeRepl, %4
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Array_unchecked_index_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract12, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr nonnull %.fca.1.extract13) #45
  %.fca.0.extract2 = extractvalue { ptr } %11, 0
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #46
  %13 = load ptr, ptr %7, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract13) #47
  %14 = sext i32 %3 to i64
  %15 = load ptr, ptr %result.i, align 8
  %16 = getelementptr i8, ptr %15, i64 72
  %17 = load ptr, ptr %16, align 8
  %result.i1 = call { i64, i64 } %17(ptr nocapture nofree nonnull readonly align 8 %result.i) #47
  %18 = extractvalue { i64, i64 } %result.i1, 0
  %19 = mul i64 %18, %14
  %20 = getelementptr i8, ptr %.fca.0.extract2, i64 %19
  %21 = getelementptr i8, ptr %15, i64 56
  %22 = load ptr, ptr %21, align 8
  %result.i2 = call { ptr, i160 } %22(ptr nocapture nofree readonly %20, ptr nocapture nofree nonnull readonly align 8 %result.i) #47
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_unchecked_insert_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #6 {
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract14, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr nonnull %.fca.1.extract15) #45
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #46
  %14 = load ptr, ptr %8, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %14(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract15) #47
  %15 = sext i32 %3 to i64
  %16 = load ptr, ptr %result.i, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %result.i) #47
  %19 = extractvalue { i64, i64 } %result.i1, 0
  %20 = mul i64 %19, %15
  %21 = getelementptr i8, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %16, i64 64
  %23 = load ptr, ptr %22, align 8
  call void %23({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %result.i, ptr nocapture nofree writeonly %21) #48
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Array__Self_empty_(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %result.i2 = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %2, ptr %result.i2, align 8
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i2) #43
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %result.i1.i = call { i64, i64 } %9(ptr nocapture nofree nonnull readonly align 8 %2) #47
  %10 = extractvalue { i64, i64 } %result.i1.i, 0
  %result.i2.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %10) #51
  %11 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr %result.i2.i, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i2, i64 16
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  store <2 x i32> <i32 0, i32 1>, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 93, 3
  ret { ptr, ptr, ptr, i32 } %14
}

define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterableT(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #17 {
  %.fca.0.extract47 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract47, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3037712219555723519
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract47, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract48, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract49, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i, 3
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract47) #43
  %8 = sext i32 %.fca.3.extract32 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract47, i64 %8
  %10 = load ptr, ptr %9, align 8
  %result.i1 = call align 8 ptr %10(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #47
  %result.i2.i = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i1, ptr %result.i2.i, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i2.i) #43
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i2.i, 1
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  %14 = load ptr, ptr %result.i1, align 8
  %15 = getelementptr i8, ptr %14, i64 72
  %16 = load ptr, ptr %15, align 8
  %result.i1.i = call { i64, i64 } %16(ptr nocapture nofree nonnull readonly align 8 %result.i1) #47
  %17 = extractvalue { i64, i64 } %result.i1.i, 0
  %result.i2.i29 = call noalias ptr @bump_malloc_wrapper(i64 noundef %17) #51
  %18 = getelementptr inbounds i8, ptr %result.i2.i, i64 8
  store ptr %result.i2.i29, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i2.i, i64 16
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  store <2 x i32> <i32 0, i32 1>, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 10, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract47) #43
  %23 = load ptr, ptr %9, align 8
  %result.i = call ptr %23(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract48) #47
  %result.i4 = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %24 = getelementptr inbounds i8, ptr %result.i4, i64 8
  store ptr %result.i, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %result.i4, i64 16
  store ptr null, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i4) #43
  store ptr @Iterable, ptr %result.i4, align 8
  %27 = alloca [1 x ptr], align 8
  store ptr %result.i4, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27) #43
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array) #43
  %30 = getelementptr i8, ptr %.fca.0.extract47, i64 24
  %31 = getelementptr i8, ptr %.fca.0.extract47, i64 32
  %32 = load i64, ptr %hash_coef_ptr.i, align 4
  %33 = load i64, ptr %tbl_size_ptr.i, align 4
  %34 = load ptr, ptr %30, align 8
  %35 = load ptr, ptr %31, align 8
  %result.i.i30 = call i1 %34(i64 %33, i64 %32, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %35) #47
  %36 = select i1 %result.i.i30, i64 55, i64 56
  %37 = getelementptr [529 x ptr], ptr @Array, i64 0, i64 %36
  %38 = getelementptr i8, ptr %37, i64 80
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 dereferenceable(8) %27, { ptr, ptr, ptr, i32 } %6)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %hash_coef_ptr.i17 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i18 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i19 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i20 = load i64, ptr %hash_coef_ptr.i17, align 4
  %tbl_size.i21 = load i64, ptr %tbl_size_ptr.i18, align 4
  %offset_tbl.i22 = load ptr, ptr %offset_tbl_ptr.i19, align 8
  %product.i.i23 = mul i64 %hash_coef.i20, -83120161364696977
  %shifted.i.i24 = lshr i64 %product.i.i23, 32
  %xored.i.i25 = xor i64 %shifted.i.i24, %product.i.i23
  %hash.i.i26 = and i64 %xored.i.i25, %tbl_size.i21
  %offset_ptr.i27 = getelementptr i32, ptr %offset_tbl.i22, i64 %hash.i.i26
  %offset.i28 = load i32, ptr %offset_ptr.i27, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %offset.i28, 3
  ret { ptr, ptr, ptr, i32 } %44
}

define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract37, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract37, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract38) #45
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #46
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %.fca.1.extract38) #45
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract37, 0
  %.pre17 = insertvalue { ptr, ptr, ptr, i32 } %.pre16, ptr %.fca.1.extract38, 1
  %.pre19 = insertvalue { ptr, ptr, ptr, i32 } %.pre17, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #46
  %21 = call i32 %17(ptr %.fca.1.extract38) #45
  %22 = shl i32 %21, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract37, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract38, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #46
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37) #46
  %29 = getelementptr i8, ptr %9, i64 72
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %6) #49
  call void %result.i2({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %22)
  %.pre = load ptr, ptr %10, align 8
  %.pre15 = load ptr, ptr %.pre, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %19, %.._crit_edge_crit_edge
  %.pre-phi20 = phi { ptr, ptr, ptr, i32 } [ %.pre19, %.._crit_edge_crit_edge ], [ %25, %19 ]
  %31 = phi ptr [ %12, %.._crit_edge_crit_edge ], [ %.pre15, %19 ]
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %33 = call i32 %31(ptr nonnull %.fca.1.extract38) #45
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %35 = getelementptr i8, ptr %9, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr nonnull %.fca.1.extract38) #45
  %.fca.0.extract52 = extractvalue { ptr } %38, 0
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %40 = load ptr, ptr %9, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract38) #47
  %41 = sext i32 %33 to i64
  %42 = load ptr, ptr %result.i, align 8
  %43 = getelementptr i8, ptr %42, i64 72
  %44 = load ptr, ptr %43, align 8
  %result.i1 = call { i64, i64 } %44(ptr nocapture nofree nonnull readonly align 8 %result.i) #47
  %45 = extractvalue { i64, i64 } %result.i1, 0
  %46 = mul i64 %45, %41
  %47 = getelementptr i8, ptr %.fca.0.extract52, i64 %46
  %48 = getelementptr i8, ptr %42, i64 64
  %49 = load ptr, ptr %48, align 8
  call void %49({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i, ptr nocapture nofree writeonly %47) #48
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %51 = load ptr, ptr %10, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr nonnull %.fca.1.extract38) #45
  %54 = add i32 %53, 1
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract37)
  %56 = getelementptr i8, ptr %51, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr nonnull %.fca.1.extract38, i32 %54) #44
  %hash_coef.i6 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i7 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i8 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i9 = mul i64 %hash_coef.i6, -83120161364696977
  %shifted.i.i10 = lshr i64 %product.i.i9, 32
  %xored.i.i11 = xor i64 %shifted.i.i10, %product.i.i9
  %hash.i.i12 = and i64 %xored.i.i11, %tbl_size.i7
  %offset_ptr.i13 = getelementptr i32, ptr %offset_tbl.i8, i64 %hash.i.i12
  %offset.i14 = load i32, ptr %offset_ptr.i13, align 4
  %58 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi20, i32 %offset.i14, 3
  ret { ptr, ptr, ptr, i32 } %58
}

define { ptr, ptr, ptr, i32 } @Array_extend_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #17 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract60 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract58, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i6 = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i7 = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i8 = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i6, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i7, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i8, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, 1375598993350293883
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract58) #60
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract58, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract59) #45
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract25, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract26, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract27, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %offset.i17, 3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract25)
  %21 = sext i32 %offset.i17 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract25, i64 %21
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %result.i5 = call ptr %24({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %25 = call i32 %result.i5({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %5)
  %26 = add i32 %25, %14
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract58, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract59, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract60, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %offset.i, 3
  %31 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract58)
  %34 = getelementptr i8, ptr %10, i64 72
  %35 = load ptr, ptr %34, align 8
  %36 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %36, align 8
  %result.i4 = call ptr %35({ ptr, ptr, ptr, i32 } %30, ptr nocapture nofree noundef nonnull readonly align 8 %36) #49
  call void %result.i4({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 dereferenceable(8) %31, i32 %26)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef align 8 %.fca.0.extract25)
  %39 = getelementptr i8, ptr %22, i64 24
  %40 = load ptr, ptr %39, align 8
  %result.i3 = call ptr %40({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %41 = call { ptr, ptr, ptr, i32 } %result.i3({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i18 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i19 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i20 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i21 = load i64, ptr %hash_coef_ptr.i18, align 4
  %tbl_size.i22 = load i64, ptr %tbl_size_ptr.i19, align 4
  %offset_tbl.i23 = load ptr, ptr %offset_tbl_ptr.i20, align 8
  %product.i.i24 = mul i64 %hash_coef.i21, 8673632051301757104
  %shifted.i.i25 = lshr i64 %product.i.i24, 32
  %xored.i.i26 = xor i64 %shifted.i.i25, %product.i.i24
  %hash.i.i27 = and i64 %xored.i.i26, %tbl_size.i22
  %offset_ptr.i28 = getelementptr i32, ptr %offset_tbl.i23, i64 %hash.i.i27
  %offset.i29 = load i32, ptr %offset_ptr.i28, align 4
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.1.extract, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.2.extract, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %offset.i29, 3
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %48 = sext i32 %offset.i29 to i64
  %49 = getelementptr ptr, ptr %.fca.0.extract, i64 %48
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = getelementptr inbounds i8, ptr %6, i64 8
  %52 = getelementptr i8, ptr %10, i64 96
  %53 = getelementptr inbounds i8, ptr %7, i64 8
  %54 = load ptr, ptr %50, align 8
  %result.i243 = call ptr %54({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly align 8 %5) #49
  %55 = call { ptr, i160 } %result.i243({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %5)
  %.fca.0.extract8144 = extractvalue { ptr, i160 } %55, 0
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %57 = icmp ne ptr %.fca.0.extract8144, @nil_typ
  %58 = icmp ne ptr %.fca.0.extract8144, null
  %.not8745 = and i1 %57, %58
  br i1 %.not8745, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %4
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.fca.0.extract8147 = phi ptr [ %.fca.0.extract8144, %._crit_edge.lr.ph ], [ %.fca.0.extract81, %._crit_edge ]
  %60 = phi { ptr, i160 } [ %55, %._crit_edge.lr.ph ], [ %68, %._crit_edge ]
  %.046 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %66, %._crit_edge ]
  %61 = load ptr, ptr %10, align 8
  %62 = add i32 %.046, %14
  %result.i = call ptr %61(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract59) #47
  store ptr @_parameterization_i32, ptr %6, align 8
  store ptr %result.i, ptr %51, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %65 = load ptr, ptr %52, align 8
  store ptr @i32_typ, ptr %7, align 8
  store ptr %.fca.0.extract8147, ptr %53, align 8
  %result.i1 = call ptr %65({ ptr, ptr, ptr, i32 } %30, ptr nocapture nofree noundef nonnull readonly %7) #49
  call void %result.i1({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 dereferenceable(16) %6, i32 %62, { ptr, i160 } %60)
  %66 = add i32 %.046, 1
  %67 = load ptr, ptr %50, align 8
  %result.i2 = call ptr %67({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly %5) #49
  %68 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %5)
  %.fca.0.extract81 = extractvalue { ptr, i160 } %68, 0
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %70 = icmp ne ptr %.fca.0.extract81, @nil_typ
  %71 = icmp ne ptr %.fca.0.extract81, null
  %.not87 = and i1 %70, %71
  br i1 %.not87, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract58)
  %73 = load ptr, ptr %11, align 8
  %74 = getelementptr i8, ptr %73, i64 8
  %75 = load ptr, ptr %74, align 8
  call void %75(ptr %.fca.1.extract59, i32 %26) #44
  %hash_coef.i33 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i34 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i35 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i36 = mul i64 %hash_coef.i33, -83120161364696977
  %shifted.i.i37 = lshr i64 %product.i.i36, 32
  %xored.i.i38 = xor i64 %shifted.i.i37, %product.i.i36
  %hash.i.i39 = and i64 %xored.i.i38, %tbl_size.i34
  %offset_ptr.i40 = getelementptr i32, ptr %offset_tbl.i35, i64 %hash.i.i39
  %offset.i41 = load i32, ptr %offset_ptr.i40, align 4
  %76 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %offset.i41, 3
  ret { ptr, ptr, ptr, i32 } %76
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Array_indices_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  %result.i2 = call noalias align 4 dereferenceable_or_null(12) ptr @bump_malloc_wrapper(i64 noundef 12) #51
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %12 = load ptr, ptr %7, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract) #45
  %15 = add i32 %14, -1
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  store i32 0, ptr %result.i2, align 4
  %18 = getelementptr i8, ptr %result.i2, i64 4
  store i32 %15, ptr %18, align 4
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  %20 = getelementptr i8, ptr %result.i2, i64 8
  store i32 1, ptr %20, align 4
  %21 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 53, 3
  ret { ptr, ptr, ptr, i32 } %21
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_values_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 1375598993350293883
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i, 3
  ret { ptr, ptr, ptr, i32 } %7
}

define { ptr, i160 } @Array__index_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #17 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.1.extract = extractvalue { ptr, i160 } %3, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract18, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i, 3
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11) #43
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %14 = sext i32 %offset.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract17, i64 %14
  %16 = getelementptr i8, ptr %15, i64 80
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %18, align 8
  %result.i1 = call ptr %17({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %18) #49
  call void %result.i1({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %11, i32 %.sroa.1.8.extract.trunc)
  %19 = icmp slt i32 %.sroa.1.8.extract.trunc, 0
  br i1 %19, label %20, label %._crit_edge

20:                                               ; preds = %4
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract17)
  %22 = getelementptr i8, ptr %15, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call i32 %24(ptr %.fca.1.extract18) #45
  %26 = add i32 %25, %.sroa.1.8.extract.trunc
  br label %._crit_edge

._crit_edge:                                      ; preds = %20, %4
  %.0 = phi i32 [ %26, %20 ], [ %.sroa.1.8.extract.trunc, %4 ]
  store ptr @_parameterization_i32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract17)
  %29 = getelementptr i8, ptr %15, i64 88
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %6) #49
  %31 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %5, i32 %.0)
  ret { ptr, i160 } %31
}

define void @Array__set_index_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #17 {
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.1.extract8 = extractvalue { ptr, i160 } %3, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract8 to i32
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract25, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract26, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i, 3
  %12 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract25) #43
  %15 = sext i32 %offset.i to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract25, i64 %15
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  %19 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %19, align 8
  %result.i2 = call ptr %18({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly align 8 %19) #49
  call void %result.i2({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 dereferenceable(8) %12, i32 %.sroa.1.8.extract.trunc)
  %20 = icmp slt i32 %.sroa.1.8.extract.trunc, 0
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %5
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %23 = getelementptr i8, ptr %16, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr nonnull %.fca.1.extract26) #45
  %27 = add i32 %26, %.sroa.1.8.extract.trunc
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %5
  %.0 = phi i32 [ %27, %21 ], [ %.sroa.1.8.extract.trunc, %5 ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %29 = load ptr, ptr %16, align 8
  %result.i = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract26) #47
  store ptr @_parameterization_i32, ptr %6, align 8
  %30 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %result.i, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract25)
  %33 = getelementptr i8, ptr %16, i64 96
  %34 = load ptr, ptr %33, align 8
  store ptr @i32_typ, ptr %7, align 8
  %35 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.0.extract, ptr %35, align 8
  %result.i1 = call ptr %34({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly %7) #49
  call void %result.i1({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 dereferenceable(16) %6, i32 %.0, { ptr, i160 } %4)
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #45
  ret i32 %10
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, -5261542750394134544
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %5 = sext i32 %offset.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #47
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #51
  store ptr %result.i1, ptr %result.i5, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #43
  %hash_coef.i9 = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i10 = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i11 = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i12 = mul i64 %hash_coef.i9, -5261542750394134544
  %shifted.i.i13 = lshr i64 %product.i.i12, 32
  %xored.i.i14 = xor i64 %shifted.i.i13, %product.i.i12
  %hash.i.i15 = and i64 %xored.i.i14, %tbl_size.i10
  %offset_ptr.i16 = getelementptr i32, ptr %offset_tbl.i11, i64 %hash.i.i15
  %offset.i17 = load i32, ptr %offset_ptr.i16, align 4
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %12 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %.fca.0.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.1.extract, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.2.extract, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store i32 %offset.i17, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 16 dereferenceable(208) @ArrayIterator) #43
  %17 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 0, ptr %17, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 23, 3
  ret { ptr, ptr, ptr, i32 } %18
}

; Function Attrs: mustprogress nofree nounwind willreturn
define { ptr, ptr, ptr, i32 } @Array_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #37 {
  %result.i3 = call noalias dereferenceable_or_null(6) ptr @bump_malloc_wrapper(i64 noundef 6) #51
  store <5 x i8> <i8 65, i8 114, i8 114, i8 97, i8 121>, ptr %result.i3, align 1
  %result.i2 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i3, ptr %result.i2, align 8
  %7 = getelementptr i8, ptr %result.i2, i64 8
  store <2 x i32> <i32 5, i32 5>, ptr %7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %9 = getelementptr i8, ptr %result.i2, i64 16
  store i32 6, ptr %9, align 8
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3447345754186651411
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i1 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i4 = load i64, ptr %hash_coef_ptr.i1, align 4
  %tbl_size.i5 = load i64, ptr %tbl_size_ptr.i2, align 4
  %offset_tbl.i6 = load ptr, ptr %offset_tbl_ptr.i3, align 8
  %product.i.i7 = mul i64 %hash_coef.i4, -5261542750394134544
  %shifted.i.i8 = lshr i64 %product.i.i7, 32
  %xored.i.i9 = xor i64 %shifted.i.i8, %product.i.i7
  %hash.i.i10 = and i64 %xored.i.i9, %tbl_size.i5
  %offset_ptr.i11 = getelementptr i32, ptr %offset_tbl.i6, i64 %hash.i.i10
  %offset.i12 = load i32, ptr %offset_ptr.i11, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i12, 3
  call void %11(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %15) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract17) #46
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract18, i32 0) #44
  ret void
}

define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract29, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 3447345754186651411
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #43
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract29, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract31) #45
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef align 8 %.fca.0.extract29) #46
  %15 = getelementptr i8, ptr %9, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract31) #45
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract) #46
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 128
  %28 = load ptr, ptr %27, align 8
  %result.i1 = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %29 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4)
  %.not = icmp slt i32 %13, %29
  br i1 %.not, label %30, label %56

30:                                               ; preds = %3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %32 = load ptr, ptr %10, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract31) #45
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %36 = call i32 %33(ptr %.fca.1.extract31) #45
  %37 = add i32 %36, 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %39 = getelementptr i8, ptr %32, i64 8
  %40 = load ptr, ptr %39, align 8
  call void %40(ptr %.fca.1.extract31, i32 %37) #44
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract29)
  %42 = load ptr, ptr %15, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr, ptr, ptr, i32 } %43(ptr %.fca.1.extract31) #45
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %.fca.3.extract51 = extractvalue { ptr, ptr, ptr, i32 } %44, 3
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.1.extract47, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.2.extract49, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %.fca.3.extract51, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract45)
  %51 = sext i32 %.fca.3.extract51 to i64
  %52 = getelementptr ptr, ptr %.fca.0.extract45, i64 %51
  %53 = getelementptr i8, ptr %52, i64 88
  %54 = load ptr, ptr %53, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %54({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %6) #49
  %55 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(8) %5, i32 %34)
  %.fca.0.extract39 = extractvalue { ptr, i160 } %55, 0
  %.fca.1.extract41 = extractvalue { ptr, i160 } %55, 1
  br label %56

56:                                               ; preds = %30, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract39, %30 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract41, %30 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBounds(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 136, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @OutOfBounds_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #17 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5348403617834207535
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %result.i13 = call noalias align 4 dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  store i32 %3, ptr %result.i13, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails) #43
  %7 = getelementptr i8, ptr %result.i13, i64 4
  store i32 %4, ptr %7, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %9 = sext i32 %offset.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = ptrtoint ptr %result.i13 to i64
  %.sroa.3.8.insert.ext = zext i64 %14 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %15 = insertvalue { ptr, i160 } { ptr @OutOfBoundsDetails, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  call void %13(ptr %.fca.1.extract, { ptr, i160 } %15) #44
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %17 = getelementptr i8, ptr %10, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #44
  %result.i12 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %result.i11 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i12, ptr %result.i11, align 8
  %24 = getelementptr i8, ptr %result.i11, i64 8
  store <2 x i32> zeroinitializer, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %26 = getelementptr i8, ptr %result.i11, i64 16
  store i32 1, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %28 = getelementptr i8, ptr %10, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #44
  %result.i10 = call noalias dereferenceable_or_null(66) ptr @bump_malloc_wrapper(i64 noundef 66) #51
  store <65 x i8> <i8 65, i8 110, i8 32, i8 111, i8 117, i8 116, i8 45, i8 111, i8 102, i8 45, i8 98, i8 111, i8 117, i8 110, i8 100, i8 115, i8 32, i8 101, i8 114, i8 114, i8 111, i8 114, i8 32, i8 111, i8 99, i8 99, i8 117, i8 114, i8 114, i8 101, i8 100, i8 32, i8 119, i8 104, i8 105, i8 108, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 116, i8 111, i8 32, i8 97, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10, align 1
  %result.i9 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  store ptr %result.i10, ptr %result.i9, align 8
  %35 = getelementptr i8, ptr %result.i9, i64 8
  store <2 x i32> <i32 65, i32 65>, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %37 = getelementptr i8, ptr %result.i9, i64 16
  store i32 66, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %39 = getelementptr i8, ptr %10, i64 24
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  call void %42(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #44
  %result.i8 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %43 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr undef, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 10, 3
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  store ptr %result.i.i, ptr %result.i8, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #46
  %47 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %48 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %47)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %50 = getelementptr i8, ptr %result.i8, i64 8
  store i64 %48, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %52 = getelementptr i8, ptr %10, i64 32
  %53 = load ptr, ptr %52, align 8
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  call void %55(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %45) #44
  ret void
}

define void @OutOfBounds_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #17 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 5348403617834207535
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #43
  %6 = sext i32 %offset.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract16) #45
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract6, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #46
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract5) #46
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract5, i64 %18
  %20 = getelementptr i8, ptr %19, i64 104
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  %22 = call { ptr } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4)
  %.fca.0.extract3 = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract3) #52
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef align 8 %.fca.0.extract14)
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr, i160 } %25(ptr %.fca.1.extract16) #45
  %.fca.0.extract = extractvalue { ptr, i160 } %26, 0
  %27 = icmp ne ptr %.fca.0.extract, @nil_typ
  %28 = icmp ne ptr %.fca.0.extract, null
  %.not41 = and i1 %27, %28
  br i1 %.not41, label %29, label %._crit_edge

29:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %26, 1
  %.sroa.3.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.0.extract.shift to i64
  %.sroa.039.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %30 = inttoptr i64 %.sroa.039.0.extract.trunc to ptr
  %31 = inttoptr i64 %.sroa.3.0.extract.trunc to ptr
  %hash_coef_ptr.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i5 = load i64, ptr %hash_coef_ptr.i2, align 4
  %tbl_size.i6 = load i64, ptr %tbl_size_ptr.i3, align 4
  %offset_tbl.i7 = load ptr, ptr %offset_tbl_ptr.i4, align 8
  %product.i.i8 = mul i64 %hash_coef.i5, 4650630525701360429
  %shifted.i.i9 = lshr i64 %product.i.i8, 32
  %xored.i.i10 = xor i64 %shifted.i.i9, %product.i.i8
  %hash.i.i11 = and i64 %xored.i.i10, %tbl_size.i6
  %offset_ptr.i12 = getelementptr i32, ptr %offset_tbl.i7, i64 %hash.i.i11
  %offset.i13 = load i32, ptr %offset_ptr.i12, align 4
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %30, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %31, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %offset.i13, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %38 = sext i32 %offset.i13 to i64
  %39 = getelementptr ptr, ptr %.fca.0.extract, i64 %38
  %40 = getelementptr i8, ptr %39, i64 24
  %41 = load ptr, ptr %40, align 8
  %result.i = call ptr %41({ ptr, ptr, ptr, i32 } %35, ptr nocapture nofree noundef nonnull readonly align 8 %4) #49
  call void %result.i({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull align 8 %4)
  br label %._crit_edge

._crit_edge:                                      ; preds = %29, %3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBoundsDetails(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #43
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @OutOfBoundsDetails_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4650630525701360429
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract) #43
  %7 = sext i32 %offset.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #44
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract) #46
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 %4) #44
  ret void
}

; Function Attrs: nounwind
define void @OutOfBoundsDetails_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #29 {
RangeIterator_next_.exit52.i.preheader:
  %result.i5.i49.h2s60 = alloca [26 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i5.i49.h2s60, i8 0, i64 26, i1 false)
  %result.i5.i.h2s62 = alloca [45 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(45) %result.i5.i.h2s62, i8 0, i64 45, i1 false)
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %hash_coef_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %.fca.0.extract49, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, 4650630525701360429
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #43
  store i8 84, ptr %result.i5.i.h2s62, align 1
  %scevgep = getelementptr inbounds i8, ptr %result.i5.i.h2s62, i64 1
  store <43 x i8> <i8 104, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 32, i8 111, i8 102, i8 32, i8 116, i8 104, i8 101, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 32, i8 98, i8 101, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 101, i8 100, i8 32, i8 119, i8 97, i8 115>, ptr %scevgep, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #43
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #43
  %6 = getelementptr inbounds i8, ptr %result.i5.i.h2s62, i64 44
  store i8 0, ptr %6, align 1
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(45) %result.i5.i.h2s62) #59
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract49) #60
  %8 = sext i32 %offset.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract49, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call i32 %11(ptr %.fca.1.extract) #45
  %13 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %12) #52
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1096) @Range) #46
  store i8 84, ptr %result.i5.i49.h2s60, align 1
  %scevgep57 = getelementptr inbounds i8, ptr %result.i5.i49.h2s60, i64 1
  store <24 x i8> <i8 104, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 97, i8 114, i8 103, i8 117, i8 109, i8 101, i8 110, i8 116, i8 32, i8 119, i8 97, i8 115>, ptr %scevgep57, align 1
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator) #46
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %17 = getelementptr inbounds i8, ptr %result.i5.i49.h2s60, i64 25
  store i8 0, ptr %17, align 1
  %puts51 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(26) %result.i5.i49.h2s60) #52
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract49)
  %19 = getelementptr i8, ptr %9, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i32 %21(ptr %.fca.1.extract) #45
  %23 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %22) #52
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_bounds(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_bounds(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 104
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 112
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 120
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 128
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 104
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 112
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 120
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 128
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBounds_getter_line_number(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_line_number(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @OutOfBounds_getter_details(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, i160 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load i160, ptr %4, align 8
  %6 = insertvalue { ptr, i160 } %3, i160 %5, 1
  ret { ptr, i160 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_details(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, i160 } %1) #3 {
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store i160 %.fca.1.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

define void @report_exception({ ptr } %0) local_unnamed_addr #17 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 9027164862567808692, i64 ptrtoint (ptr @Exception to i64), ptr readonly %12) #47
  br i1 %result.i1, label %13, label %._crit_edge

13:                                               ; preds = %1
  %14 = getelementptr i8, ptr %.fca.0.extract2, i64 56
  %15 = load i160, ptr %14, align 4
  %.sroa.4.sroa.3.0.extract.shift = lshr i160 %15, 64
  %.sroa.4.sroa.3.0.extract.trunc = trunc i160 %.sroa.4.sroa.3.0.extract.shift to i64
  %.sroa.4.sroa.0.0.extract.trunc = trunc i160 %15 to i64
  %16 = inttoptr i64 %.sroa.4.sroa.0.0.extract.trunc to ptr
  %17 = inttoptr i64 %.sroa.4.sroa.3.0.extract.trunc to ptr
  %offset_tbl_ptr.i = getelementptr i8, ptr %4, i64 40
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %9, 9027164862567808692
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %10
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %4, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %16, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %17, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #43
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %4) #43
  %24 = sext i32 %offset.i to i64
  %25 = getelementptr ptr, ptr %4, i64 %24
  %26 = getelementptr i8, ptr %25, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %2) #49
  call void %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %2)
  br label %._crit_edge

._crit_edge:                                      ; preds = %13, %1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #1 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #1 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

; Function Attrs: cold minsize
define internal fastcc void @String__Self_from_bytes_source_bytesBufferi8_source_leni32.cold.1(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, ptr noalias nocapture nofree noundef nonnull align 8 %1, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %3, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %4, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %5, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %8, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(16) %9, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %13, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %14) unnamed_addr #41 section "__llvm_cold" {
newFuncRoot:
  store ptr @InvalidUTF8Error, ptr %0, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(104) ptr @bump_malloc_wrapper(i64 noundef 104) #51
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %1) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %1) #43
  %result.i10.i = call noalias dereferenceable_or_null(61) ptr @bump_malloc_wrapper(i64 noundef 61) #51
  store <60 x i8> <i8 73, i8 110, i8 118, i8 97, i8 108, i8 105, i8 100, i8 32, i8 85, i8 84, i8 70, i8 45, i8 56, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 99, i8 101, i8 32, i8 101, i8 110, i8 99, i8 111, i8 117, i8 110, i8 116, i8 101, i8 114, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 116, i8 114, i8 105, i8 110, i8 103, i8 32, i8 99, i8 111, i8 110, i8 118, i8 101, i8 114, i8 115, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  %17 = getelementptr i8, ptr %result.i9.i, i64 8
  store <2 x i32> <i32 60, i32 60>, ptr %17, align 8
  %18 = getelementptr i8, ptr %result.i9.i, i64 16
  store i32 61, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i7, i64 40
  store ptr @String, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i7, i64 48
  store ptr %result.i9.i, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i7, i64 64
  store i32 10, ptr %21, align 8
  store i32 0, ptr %result.i7, align 8
  %result.i8.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i8.i, ptr %result.i7.i, align 8
  %22 = getelementptr i8, ptr %result.i7.i, i64 8
  store <2 x i32> zeroinitializer, ptr %22, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #43
  %24 = getelementptr i8, ptr %result.i7.i, i64 16
  store i32 1, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error) #43
  %26 = getelementptr i8, ptr %result.i7, i64 8
  store ptr @String, ptr %26, align 8
  %27 = getelementptr i8, ptr %result.i7, i64 16
  store ptr %result.i7.i, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i7, i64 32
  store i32 10, ptr %28, align 8
  %result.i6.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %result.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  store ptr %result.i.i, ptr %result.i6.i, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #43
  %30 = insertvalue { ptr } undef, ptr %result.i.i, 0
  %31 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %30)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %33 = getelementptr i8, ptr %result.i6.i, i64 8
  store i64 %31, ptr %33, align 8
  %34 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @Stacktrace, ptr %34, align 8
  %35 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i6.i, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %36, align 8
  %result.i6 = call noalias dereferenceable_or_null(56) ptr @bump_malloc_wrapper(i64 noundef 56) #51
  store <55 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 99, i8 111, i8 114, i8 101, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i6, align 1
  store ptr @String, ptr %2, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr @_parameterization_Bufferi8, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %4, align 8
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %6, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %3)
  store ptr @buffer_typ, ptr %7, align 8
  store ptr @i32_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr @i32_typ, ptr %10, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %7) #43
  store ptr %result.i6, ptr %result.i5, align 8
  %39 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> <i32 55, i32 55>, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %41 = getelementptr i8, ptr %result.i5, i64 16
  store i32 56, ptr %41, align 8
  store ptr @_parameterization_i32, ptr %11, align 8
  store ptr @_parameterization_String, ptr %12, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error)
  store ptr @i32_typ, ptr %13, align 8
  store ptr @String, ptr %14, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %13) #43
  store i32 141, ptr %result.i7, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error) #46
  store ptr @String, ptr %26, align 8
  store ptr %result.i5, ptr %27, align 8
  store i32 10, ptr %28, align 8
  %46 = ptrtoint ptr %result.i7 to i64
  %.sroa.475.8.insert.ext = zext i64 %46 to i160
  %.sroa.475.8.insert.insert = or disjoint i160 %.sroa.475.8.insert.ext, 3402823669209384634633746074317682114560
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %47 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @InvalidUTF8Error, ptr %47, align 8
  %48 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i160 %.sroa.475.8.insert.insert, ptr %48, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #52
  ret void
}

; Function Attrs: cold minsize noreturn
define internal fastcc void @Map__index_keyK.cold.1(ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %0, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %1, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %2, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %3, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %4, ptr noalias nocapture nofree noundef nonnull align 8 %5, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6) unnamed_addr #42 section "__llvm_cold" {
newFuncRoot:
  %7 = getelementptr inbounds i8, ptr %0, i64 8
  %8 = getelementptr inbounds i8, ptr %0, i64 16
  %9 = getelementptr inbounds i8, ptr %0, i64 24
  %10 = getelementptr inbounds i8, ptr %1, i64 8
  %11 = getelementptr inbounds i8, ptr %1, i64 16
  %12 = getelementptr inbounds i8, ptr %1, i64 24
  %13 = getelementptr inbounds i8, ptr %2, i64 8
  %14 = getelementptr inbounds i8, ptr %3, i64 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %newFuncRoot
  store ptr @KeyNotFound, ptr %4, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(104) ptr @bump_malloc_wrapper(i64 noundef 104) #51
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %5) #60
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound) #60
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %5) #43
  store i32 0, ptr %result.i7, align 8
  %result.i10.i = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #51
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  %18 = getelementptr i8, ptr %result.i9.i, i64 8
  store <2 x i32> <i32 6, i32 6>, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i9.i, i64 16
  store i32 7, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i7, i64 40
  store ptr @String, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i7, i64 48
  store ptr %result.i9.i, ptr %21, align 8
  %22 = getelementptr i8, ptr %result.i7, i64 64
  store i32 10, ptr %22, align 8
  %result.i8.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %result.i7.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i8.i, ptr %result.i7.i, align 8
  %23 = getelementptr i8, ptr %result.i7.i, i64 8
  store <2 x i32> zeroinitializer, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #43
  %25 = getelementptr i8, ptr %result.i7.i, i64 16
  store i32 1, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound) #60
  %27 = getelementptr i8, ptr %result.i7, i64 8
  store ptr @String, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i7, i64 16
  store ptr %result.i7.i, ptr %28, align 8
  %29 = getelementptr i8, ptr %result.i7, i64 32
  store i32 10, ptr %29, align 8
  %result.i6.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %result.i.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  store ptr %result.i.i.i, ptr %result.i6.i, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #43
  %31 = insertvalue { ptr } undef, ptr %result.i.i.i, 0
  %32 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %31)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %34 = getelementptr i8, ptr %result.i6.i, i64 8
  store i64 %32, ptr %34, align 8
  %35 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @Stacktrace, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i6.i, ptr %36, align 8
  %37 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %37, align 8
  %result.i6 = call noalias dereferenceable_or_null(55) ptr @bump_malloc_wrapper(i64 noundef 55) #51
  store <54 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 109, i8 97, i8 112, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i6, align 1
  store ptr @String, ptr %6, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr @_parameterization_Bufferi8, ptr %0, align 8
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr @_parameterization_i32, ptr %9, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %0)
  store ptr @buffer_typ, ptr %1, align 8
  store ptr @i32_typ, ptr %10, align 8
  store ptr @i32_typ, ptr %11, align 8
  store ptr @i32_typ, ptr %12, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr noalias nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %1) #43
  store ptr %result.i6, ptr %result.i5, align 8
  %40 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> <i32 54, i32 54>, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %42 = getelementptr i8, ptr %result.i5, i64 16
  store i32 55, ptr %42, align 8
  store ptr @_parameterization_i32, ptr %2, align 8
  store ptr @_parameterization_String, ptr %13, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %2)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound)
  store ptr @i32_typ, ptr %3, align 8
  store ptr @String, ptr %14, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %3) #43
  store i32 26, ptr %result.i7, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound) #46
  store ptr @String, ptr %27, align 8
  store ptr %result.i5, ptr %28, align 8
  store i32 10, ptr %29, align 8
  %47 = ptrtoint ptr %result.i7 to i64
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %48 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @KeyNotFound, ptr %48, align 8
  %49 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i64 %47, ptr %49, align 4
  %.sroa_idx68 = getelementptr i8, ptr %current_coroutine.i, i64 64
  store i96 184467440737095516160, ptr %.sroa_idx68, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #52
  br label %._crit_edge
}

; Function Attrs: cold minsize
define internal fastcc void @Array_bounds_check_indexi32.cold.1(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract, ptr %.fca.1.extract, ptr nocapture nofree noundef nonnull readonly %0, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %4, i32 %5, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %10) unnamed_addr #41 section "__llvm_cold" {
newFuncRoot:
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract) #64
  %12 = call i32 %0(ptr %.fca.1.extract) #65
  store ptr @OutOfBounds, ptr %1, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(136) ptr @bump_malloc_wrapper(i64 noundef 136) #51
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.fca.0.extract) #46
  %14 = load ptr, ptr %2, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #65
  store ptr @_parameterization_i32, ptr %3, align 8
  %17 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3) #46
  store ptr @i32_typ, ptr %4, align 8
  %19 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %4) #43
  %result.i13.i = call noalias align 4 dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #51
  store i32 %16, ptr %result.i13.i, align 4
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails) #46
  %22 = getelementptr i8, ptr %result.i13.i, i64 4
  store i32 %5, ptr %22, align 4
  %23 = ptrtoint ptr %result.i13.i to i64
  %.sroa.3.8.insert.ext.i = zext i64 %23 to i160
  %.sroa.3.8.insert.insert.i = or disjoint i160 %.sroa.3.8.insert.ext.i, 3402823669209384634633746074317682114560
  store ptr @OutOfBoundsDetails, ptr %result.i7, align 8
  %24 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store i160 %.sroa.3.8.insert.insert.i, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i7, i64 32
  store i32 0, ptr %25, align 8
  %result.i12.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #51
  %result.i11.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i12.i, ptr %result.i11.i, align 8
  %26 = getelementptr i8, ptr %result.i11.i, i64 8
  store <2 x i32> zeroinitializer, ptr %26, align 8
  %27 = getelementptr i8, ptr %result.i11.i, i64 16
  store i32 1, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i7, i64 40
  store ptr @String, ptr %28, align 8
  %29 = getelementptr i8, ptr %result.i7, i64 48
  store ptr %result.i11.i, ptr %29, align 8
  %30 = getelementptr i8, ptr %result.i7, i64 64
  store i32 10, ptr %30, align 8
  %result.i10.i = call noalias dereferenceable_or_null(66) ptr @bump_malloc_wrapper(i64 noundef 66) #51
  store <65 x i8> <i8 65, i8 110, i8 32, i8 111, i8 117, i8 116, i8 45, i8 111, i8 102, i8 45, i8 98, i8 111, i8 117, i8 110, i8 100, i8 115, i8 32, i8 101, i8 114, i8 114, i8 111, i8 114, i8 32, i8 111, i8 99, i8 99, i8 117, i8 114, i8 114, i8 101, i8 100, i8 32, i8 119, i8 104, i8 105, i8 108, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 116, i8 111, i8 32, i8 97, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 46>, ptr %result.i10.i, align 1
  %result.i9.i = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr %result.i10.i, ptr %result.i9.i, align 8
  %31 = getelementptr i8, ptr %result.i9.i, i64 8
  store <2 x i32> <i32 65, i32 65>, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %33 = getelementptr i8, ptr %result.i9.i, i64 16
  store i32 66, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef nonnull align 16 dereferenceable(328) @OutOfBounds) #46
  %35 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @String, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i9.i, ptr %36, align 8
  %37 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %37, align 8
  %result.i8.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #51
  %result.i.i.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #51
  store ptr %result.i.i.i, ptr %result.i8.i, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace) #46
  %39 = insertvalue { ptr } undef, ptr %result.i.i.i, 0
  %40 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %39)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %42 = getelementptr i8, ptr %result.i8.i, i64 8
  store i64 %40, ptr %42, align 8
  %43 = getelementptr i8, ptr %result.i7, i64 104
  store ptr @Stacktrace, ptr %43, align 8
  %44 = getelementptr i8, ptr %result.i7, i64 112
  store ptr %result.i8.i, ptr %44, align 8
  %45 = getelementptr i8, ptr %result.i7, i64 128
  store i32 10, ptr %45, align 8
  %result.i6 = call noalias dereferenceable_or_null(57) ptr @bump_malloc_wrapper(i64 noundef 57) #51
  store <56 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 97, i8 114, i8 114, i8 97, i8 121, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i6, align 1
  store ptr @String, ptr %6, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #51
  store ptr @_parameterization_Bufferi8, ptr %7, align 8
  %46 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  store ptr @buffer_typ, ptr %8, align 8
  %50 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @i32_typ, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %8) #43
  store ptr %result.i6, ptr %result.i5, align 8
  %54 = getelementptr i8, ptr %result.i5, i64 8
  store <2 x i32> <i32 56, i32 56>, ptr %54, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #46
  %56 = getelementptr i8, ptr %result.i5, i64 16
  store i32 57, ptr %56, align 8
  store ptr @_parameterization_i32, ptr %9, align 8
  %57 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @_parameterization_String, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef nonnull align 16 dereferenceable(328) @OutOfBounds)
  store ptr @i32_typ, ptr %10, align 8
  %60 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr @String, ptr %60, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %10) #43
  store i32 99, ptr %25, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(328) @OutOfBounds) #46
  store ptr @String, ptr %28, align 8
  store ptr %result.i5, ptr %29, align 8
  store i32 10, ptr %30, align 8
  %63 = ptrtoint ptr %result.i7 to i64
  %.sroa.460.8.insert.ext = zext i64 %63 to i160
  %.sroa.460.8.insert.insert = or disjoint i160 %.sroa.460.8.insert.ext, 3402823669209384634633746074317682114560
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %64 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @OutOfBounds, ptr %64, align 8
  %65 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i160 %.sroa.460.8.insert.insert, ptr %65, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #52
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #20

attributes #0 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "disable-tail-calls"="true" }
attributes #2 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #3 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "disable-tail-calls"="true" }
attributes #4 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #5 = { mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #6 = { mustprogress nounwind willreturn "disable-tail-calls"="true" }
attributes #7 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #8 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #10 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #11 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #12 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #13 = { alwaysinline mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #14 = { nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #15 = { alwaysinline mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #16 = { mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #17 = { "disable-tail-calls"="true" }
attributes #18 = { noinline optnone "disable-tail-calls"="true" }
attributes #19 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #20 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #21 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #22 = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #23 = { noreturn nounwind }
attributes #24 = { nocallback nofree nosync nounwind willreturn }
attributes #25 = { nofree nounwind "disable-tail-calls"="true" }
attributes #26 = { mustprogress noinline optnone uwtable "disable-tail-calls"="true" }
attributes #27 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #28 = { noinline nounwind memory(readwrite) "disable-tail-calls"="true" }
attributes #29 = { nounwind "disable-tail-calls"="true" }
attributes #30 = { cold minsize noinline nounwind "disable-tail-calls"="true" }
attributes #31 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #32 = { mustprogress nounwind willreturn memory(argmem: readwrite, inaccessiblemem: readwrite) "disable-tail-calls"="true" }
attributes #33 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "disable-tail-calls"="true" }
attributes #34 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #35 = { mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #36 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #37 = { mustprogress nofree nounwind willreturn "disable-tail-calls"="true" }
attributes #38 = { mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #39 = { mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #40 = { mustprogress nofree nosync nounwind willreturn "disable-tail-calls"="true" }
attributes #41 = { cold minsize "disable-tail-calls"="true" }
attributes #42 = { cold minsize noreturn "disable-tail-calls"="true" }
attributes #43 = { nofree willreturn }
attributes #44 = { nounwind willreturn memory(argmem: readwrite) }
attributes #45 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #46 = { willreturn }
attributes #47 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #48 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #49 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #50 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #51 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #52 = { nounwind }
attributes #53 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #54 = { nofree nosync nounwind willreturn memory(read) }
attributes #55 = { mustprogress nofree nosync nounwind willreturn }
attributes #56 = { nounwind memory(read) }
attributes #57 = { nounwind memory(readwrite) }
attributes #58 = { nounwind willreturn }
attributes #59 = { nofree nounwind }
attributes #60 = { nofree }
attributes #61 = { nofree nosync willreturn }
attributes #62 = { noinline }
attributes #63 = { noinline noreturn }
attributes #64 = { nofree willreturn memory(readwrite) }
attributes #65 = { nounwind willreturn memory(readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 8, i32 -2147483648}
!2 = !{!3}
!3 = distinct !{!3, !4, !"size_wrapper: argument 0"}
!4 = distinct !{!4, !"size_wrapper"}
!5 = !{i64 8, i64 0}
!6 = !{!7}
!7 = distinct !{!7, !8, !"size_wrapper: argument 0"}
!8 = distinct !{!8, !"size_wrapper"}
!9 = !{!10}
!10 = distinct !{!10, !11, !"size_wrapper: argument 0"}
!11 = distinct !{!11, !"size_wrapper"}
!12 = !{!13}
!13 = distinct !{!13, !14, !"size_wrapper: argument 0"}
!14 = distinct !{!14, !"size_wrapper"}
!15 = !{!16}
!16 = distinct !{!16, !17, !"size_wrapper: argument 0"}
!17 = distinct !{!17, !"size_wrapper"}
!18 = !{!19}
!19 = distinct !{!19, !20, !"size_wrapper: argument 0"}
!20 = distinct !{!20, !"size_wrapper"}
!21 = !{!22}
!22 = distinct !{!22, !23, !"size_wrapper: argument 0"}
!23 = distinct !{!23, !"size_wrapper"}
!24 = !{!25}
!25 = distinct !{!25, !26, !"size_wrapper: argument 0"}
!26 = distinct !{!26, !"size_wrapper"}
!27 = !{!28}
!28 = distinct !{!28, !29, !"size_wrapper: argument 0"}
!29 = distinct !{!29, !"size_wrapper"}
!30 = !{!31}
!31 = distinct !{!31, !32, !"size_wrapper: argument 0"}
!32 = distinct !{!32, !"size_wrapper"}
