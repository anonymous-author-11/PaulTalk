; ModuleID = 'C:\Users\PaulK\OneDrive\Documents\PL\PyPL\build\build\out_optimized.dbg.ll'
source_filename = "llvm-link"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "aarch64-windows-msvc"

%struct._CONTEXT = type { i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i16, i16, i16, i16, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %union.anon, [26 x %struct._M128A], i64, i64, i64, i64, i64, i64 }
%union.anon = type { %struct._XSAVE_FORMAT }
%struct._XSAVE_FORMAT = type { i16, i16, i8, i8, i16, i32, i16, i16, i32, i16, i16, i32, i32, [8 x %struct._M128A], [16 x %struct._M128A], [96 x i8] }
%struct._M128A = type { i64, i64 }

@string_string = internal constant [4 x i8] c"%s\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local local_unnamed_addr global ptr null
@always_one = linkonce thread_local local_unnamed_addr global i1 true
@current_ptr = thread_local global ptr null
@backtrace_string = constant [16 x i8] c"%i: %s - 0x%0X\0A\00"
@wovqv_Warning_Remove_returned_Nil_for_key_ = internal unnamed_addr constant [37 x i8] c"Warning: Remove returned Nil for key ", align 64
@hnbwj_Warning_Remove_returned_wrong_value_for_key_ = internal unnamed_addr constant [45 x i8] c"Warning: Remove returned wrong value for key ", align 64
@khbst_Error_Nil_returned_during_random_hit_test_for_key_ = internal unnamed_addr constant [51 x i8] c"Error: Nil returned during random hit test for key ", align 64
@yylhu__unique_keys_for_random_hit_test = internal unnamed_addr constant [33 x i8] c" unique keys for random hit test.", align 64
@lwoib_Error_Nil_returned_during_sequential_hit_test_for_key_ = internal unnamed_addr constant [55 x i8] c"Error: Nil returned during sequential hit test for key ", align 64
@_parameterization_Pairi32._Bool = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_Bool, ptr null]
@_parameterization_Pairi32._i32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedi32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedi32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@_parameterization_Bool = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 0]
@Container_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @any_typ, ptr @Container, ptr @Object]
@Iterator_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 13, i32 13]
@Iterable_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 35, i32 35]
@Enumeration_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @Enumeration, ptr @Object]
@Enumeration_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 0, i32 64, i32 0, i32 10, i32 64]
@Enumeration = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2805197119131967777, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumeration_hashtbl, ptr @Enumeration_offset_tbl, ptr @_data_size_Enumeration, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Enumeration_field_Enumeration_0, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_field_iterable, ptr @Enumeration_B_init_iterableIterableT, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_init_iterableIterableT, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Enumerator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @Enumerator]
@Enumerator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@MapIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@MapIterable_offset_tbl = constant [8 x i32] [i32 0, i32 65, i32 10, i32 40, i32 65, i32 0, i32 0, i32 10]
@MapIterable = constant { [3 x i64], [7 x ptr], [55 x ptr] } { [3 x i64] [i64 -7488770571603291722, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterable_hashtbl, ptr @MapIterable_offset_tbl, ptr @_data_size_MapIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [55 x ptr] [ptr @MapIterable_field_MapIterable_0, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_field_iterable, ptr @MapIterable_field_f, ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterator, ptr @Container, ptr null, ptr @Iterator, ptr null, ptr null]
@MapIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 10, i32 21, i32 0, i32 18, i32 0, i32 0]
@FilterIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @FilterIterable, ptr null, ptr @Container, ptr @Iterable, ptr null]
@FilterIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 10, i32 0, i32 64, i32 39, i32 0]
@FilterIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 8498466713076104350, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterable_hashtbl, ptr @FilterIterable_offset_tbl, ptr @_data_size_FilterIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_field_iterable, ptr @FilterIterable_field_f, ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@FilterIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @FilterIterator, ptr null]
@FilterIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@FilterIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -1221365496900303883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterator_hashtbl, ptr @FilterIterator_offset_tbl, ptr @_data_size_FilterIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_field_iterator, ptr @FilterIterator_field_f, ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_B_next_, ptr @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_next_, ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_B_next_, ptr @FilterIterator_next_] }
@ChainIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ChainIterable, ptr @Container, ptr null, ptr null, ptr @Object]
@ChainIterable_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 10, i32 64, i32 0, i32 0, i32 64]
@ChainIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2370247058431047815, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterable_hashtbl, ptr @ChainIterable_offset_tbl, ptr @_data_size_ChainIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_field_first, ptr @ChainIterable_field_second, ptr @ChainIterable_B_init_firstIterableT_secondIterableT, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_init_firstIterableT_secondIterableT, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ChainIterator]
@ChainIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@InterleaveIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @InterleaveIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@InterleaveIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 39, i32 64, i32 0, i32 0, i32 10]
@InterleaveIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 4936782714255954462, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterable_hashtbl, ptr @InterleaveIterable_offset_tbl, ptr @_data_size_InterleaveIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_field_first, ptr @InterleaveIterable_field_second, ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleaveIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleaveIterator, ptr @Iterator, ptr null, ptr null]
@InterleaveIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 0, i32 21, i32 10, i32 18, i32 0, i32 0]
@ZipIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @ZipIterable, ptr @Object]
@ZipIterable_offset_tbl = constant [8 x i32] [i32 10, i32 41, i32 0, i32 0, i32 66, i32 0, i32 10, i32 66]
@ZipIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 35232740166152944, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterable_hashtbl, ptr @ZipIterable_offset_tbl, ptr @_data_size_ZipIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ZipIterable_field_ZipIterable_0, ptr @ZipIterable_field_ZipIterable_1, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_field_first, ptr @ZipIterable_field_second, ptr @ZipIterable_B_init_firstIterableT_secondIterableU, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_init_firstIterableT_secondIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZipIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ZipIterator]
@ZipIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 22, i32 19, i32 22, i32 0, i32 10, i32 10]
@ProductIterable_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ProductIterable, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr null]
@ProductIterable_offset_tbl = constant [8 x i32] [i32 66, i32 10, i32 10, i32 66, i32 0, i32 41, i32 0, i32 0]
@ProductIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 4128338911757318636, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterable_hashtbl, ptr @ProductIterable_offset_tbl, ptr @_data_size_ProductIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ProductIterable_field_ProductIterable_0, ptr @ProductIterable_field_ProductIterable_1, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_field_first, ptr @ProductIterable_field_second, ptr @ProductIterable_B_init_firstIterableT_secondIterableU, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_init_firstIterableT_secondIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr null, ptr @Container, ptr @Object, ptr null, ptr @ProductIterator]
@ProductIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 21, i32 0, i32 24, i32 24, i32 0, i32 10]
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Enumeration_field_iterable = internal constant { ptr, ptr } { ptr @Enumeration_getter_iterable, ptr @Enumeration_setter_iterable }
@Enumerator_field_iterator = internal constant { ptr, ptr } { ptr @Enumerator_getter_iterator, ptr @Enumerator_setter_iterator }
@Enumerator_field_index = internal constant { ptr, ptr } { ptr @Enumerator_getter_index, ptr @Enumerator_setter_index }
@MapIterable_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable_getter_iterable, ptr @MapIterable_setter_iterable }
@MapIterable_field_f = internal constant { ptr, ptr } { ptr @MapIterable_getter_f, ptr @MapIterable_setter_f }
@MapIterator_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator_getter_iterator, ptr @MapIterator_setter_iterator }
@MapIterator_field_f = internal constant { ptr, ptr } { ptr @MapIterator_getter_f, ptr @MapIterator_setter_f }
@FilterIterable_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable_getter_iterable, ptr @FilterIterable_setter_iterable }
@FilterIterable_field_f = internal constant { ptr, ptr } { ptr @FilterIterable_getter_f, ptr @FilterIterable_setter_f }
@FilterIterator_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator_getter_iterator, ptr @FilterIterator_setter_iterator }
@FilterIterator_field_f = internal constant { ptr, ptr } { ptr @FilterIterator_getter_f, ptr @FilterIterator_setter_f }
@ChainIterable_field_first = internal constant { ptr, ptr } { ptr @ChainIterable_getter_first, ptr @ChainIterable_setter_first }
@ChainIterable_field_second = internal constant { ptr, ptr } { ptr @ChainIterable_getter_second, ptr @ChainIterable_setter_second }
@ChainIterator_field_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_first, ptr @ChainIterator_setter_first }
@ChainIterator_field_second = internal constant { ptr, ptr } { ptr @ChainIterator_getter_second, ptr @ChainIterator_setter_second }
@ChainIterator_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_on_first, ptr @ChainIterator_setter_on_first }
@InterleaveIterable_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_first, ptr @InterleaveIterable_setter_first }
@InterleaveIterable_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_second, ptr @InterleaveIterable_setter_second }
@InterleaveIterator_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_first, ptr @InterleaveIterator_setter_first }
@InterleaveIterator_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_second, ptr @InterleaveIterator_setter_second }
@InterleaveIterator_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_on_first, ptr @InterleaveIterator_setter_on_first }
@ZipIterable_field_first = internal constant { ptr, ptr } { ptr @ZipIterable_getter_first, ptr @ZipIterable_setter_first }
@ZipIterable_field_second = internal constant { ptr, ptr } { ptr @ZipIterable_getter_second, ptr @ZipIterable_setter_second }
@ZipIterator_field_first = internal constant { ptr, ptr } { ptr @ZipIterator_getter_first, ptr @ZipIterator_setter_first }
@ZipIterator_field_second = internal constant { ptr, ptr } { ptr @ZipIterator_getter_second, ptr @ZipIterator_setter_second }
@ProductIterable_field_first = internal constant { ptr, ptr } { ptr @ProductIterable_getter_first, ptr @ProductIterable_setter_first }
@ProductIterable_field_second = internal constant { ptr, ptr } { ptr @ProductIterable_getter_second, ptr @ProductIterable_setter_second }
@ProductIterator_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_first_iterator, ptr @ProductIterator_setter_first_iterator }
@ProductIterator_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterator, ptr @ProductIterator_setter_second_iterator }
@ProductIterator_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterable, ptr @ProductIterator_setter_second_iterable }
@ProductIterator_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator_getter_current_first, ptr @ProductIterator_setter_current_first }
@Enumerator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3435222131909153872, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumerator_hashtbl, ptr @Enumerator_offset_tbl, ptr @_data_size_Enumerator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Enumerator_field_Enumerator_0, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_field_iterator, ptr @Enumerator_field_index, ptr @Enumerator_B_init_iteratorIteratorT, ptr @Enumerator_B_next_, ptr @Enumerator_init_iteratorIteratorT, ptr @Enumerator_next_, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_B_next_, ptr @Enumerator_next_] }
@MapIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -146553482626734782, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterator_hashtbl, ptr @MapIterator_offset_tbl, ptr @_data_size_MapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @MapIterator_field_MapIterator_0, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_field_iterator, ptr @MapIterator_field_f, ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_B_next_, ptr @MapIterator_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_next_, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_B_next_, ptr @MapIterator_next_] }
@ChainIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6043157723929225452, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterator_hashtbl, ptr @ChainIterator_offset_tbl, ptr @_data_size_ChainIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_field_first, ptr @ChainIterator_field_second, ptr @ChainIterator_field_on_first, ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_B_next_, ptr @ChainIterator_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_next_, ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_B_next_, ptr @ChainIterator_next_] }
@InterleaveIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3924664358248524505, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterator_hashtbl, ptr @InterleaveIterator_offset_tbl, ptr @_data_size_InterleaveIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_field_first, ptr @InterleaveIterator_field_second, ptr @InterleaveIterator_field_on_first, ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_next_, ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_next_] }
@ZipIterator = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 -2141114445739585318, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterator_hashtbl, ptr @ZipIterator_offset_tbl, ptr @_data_size_ZipIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @ZipIterator_field_ZipIterator_0, ptr @ZipIterator_field_ZipIterator_1, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_field_first, ptr @ZipIterator_field_second, ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_B_next_, ptr @ZipIterator_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_next_, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_B_next_, ptr @ZipIterator_next_] }
@ProductIterator = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 1697250377212095568, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterator_hashtbl, ptr @ProductIterator_offset_tbl, ptr @_data_size_ProductIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @ProductIterator_field_ProductIterator_0, ptr @ProductIterator_field_ProductIterator_1, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_field_first_iterator, ptr @ProductIterator_field_second_iterator, ptr @ProductIterator_field_second_iterable, ptr @ProductIterator_field_current_first, ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_B_next_, ptr @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_next_, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_B_next_, ptr @ProductIterator_next_] }
@Collection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr @Collection]
@Collection_offset_tbl = constant [8 x i32] [i32 67, i32 10, i32 0, i32 67, i32 0, i32 42, i32 0, i32 10]
@EnumeratedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr @EnumeratedCollection, ptr null, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@EnumeratedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 103, i32 10, i32 0, i32 128, i32 0, i32 46, i32 128]
@EnumeratedCollection = constant { [3 x i64], [7 x ptr], [118 x ptr] } { [3 x i64] [i64 7081690788784801875, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @EnumeratedCollection_hashtbl, ptr @EnumeratedCollection_offset_tbl, ptr @_data_size_EnumeratedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [118 x ptr] [ptr @EnumeratedCollection_field_EnumeratedCollection_0, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_field_collection, ptr @EnumeratedCollection_B_init_collectionCollectionT, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_init_collectionCollectionT, ptr @EnumeratedCollection_size_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_size_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MappedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr @MappedCollection, ptr @Collection]
@MappedCollection_offset_tbl = constant [8 x i32] [i32 129, i32 10, i32 0, i32 129, i32 0, i32 104, i32 10, i32 47]
@MappedCollection = constant { [3 x i64], [7 x ptr], [119 x ptr] } { [3 x i64] [i64 5460697656559120915, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MappedCollection_hashtbl, ptr @MappedCollection_offset_tbl, ptr @_data_size_MappedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [119 x ptr] [ptr @MappedCollection_field_MappedCollection_0, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_field_collection, ptr @MappedCollection_field_f, ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_size_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_size_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainedCollection_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr @ChainedCollection, ptr @Container, ptr @Iterable, ptr null]
@ChainedCollection_offset_tbl = constant [8 x i32] [i32 0, i32 128, i32 10, i32 46, i32 10, i32 128, i32 103, i32 0]
@ChainedCollection = constant { [3 x i64], [7 x ptr], [118 x ptr] } { [3 x i64] [i64 -4136536984535342799, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainedCollection_hashtbl, ptr @ChainedCollection_offset_tbl, ptr @_data_size_ChainedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [118 x ptr] [ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_field_first, ptr @ChainedCollection_field_second, ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_size_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_size_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleavedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleavedCollection, ptr @Iterable, ptr null, ptr @Collection]
@InterleavedCollection_offset_tbl = constant [8 x i32] [i32 128, i32 10, i32 0, i32 128, i32 10, i32 103, i32 0, i32 46]
@InterleavedCollection = constant { [3 x i64], [7 x ptr], [118 x ptr] } { [3 x i64] [i64 8589355597059143861, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleavedCollection_hashtbl, ptr @InterleavedCollection_offset_tbl, ptr @_data_size_InterleavedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [118 x ptr] [ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_field_first, ptr @InterleavedCollection_field_second, ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_size_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_size_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZippedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Collection, ptr @Object, ptr @Container, ptr @ZippedCollection, ptr @Iterable, ptr null, ptr null]
@ZippedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 48, i32 130, i32 130, i32 10, i32 105, i32 0, i32 0]
@ZippedCollection = constant { [3 x i64], [7 x ptr], [120 x ptr] } { [3 x i64] [i64 880335312586431241, i64 4611686018427388513, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZippedCollection_hashtbl, ptr @ZippedCollection_offset_tbl, ptr @_data_size_ZippedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [120 x ptr] [ptr @ZippedCollection_field_ZippedCollection_0, ptr @ZippedCollection_field_ZippedCollection_1, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_field_first, ptr @ZippedCollection_field_second, ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_size_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_size_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ProductCollection, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@ProductCollection_offset_tbl = constant [8 x i32] [i32 10, i32 105, i32 0, i32 10, i32 130, i32 0, i32 48, i32 130]
@ProductCollection = constant { [3 x i64], [7 x ptr], [120 x ptr] } { [3 x i64] [i64 -310975631771072937, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductCollection_hashtbl, ptr @ProductCollection_offset_tbl, ptr @_data_size_ProductCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [120 x ptr] [ptr @ProductCollection_field_ProductCollection_0, ptr @ProductCollection_field_ProductCollection_1, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_field_first, ptr @ProductCollection_field_second, ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_size_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_size_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@EnumeratedCollection_field_collection = internal constant { ptr, ptr } { ptr @EnumeratedCollection_getter_collection, ptr @EnumeratedCollection_setter_collection }
@MappedCollection_field_collection = internal constant { ptr, ptr } { ptr @MappedCollection_getter_collection, ptr @MappedCollection_setter_collection }
@MappedCollection_field_f = internal constant { ptr, ptr } { ptr @MappedCollection_getter_f, ptr @MappedCollection_setter_f }
@ChainedCollection_field_first = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_first, ptr @ChainedCollection_setter_first }
@ChainedCollection_field_second = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_second, ptr @ChainedCollection_setter_second }
@InterleavedCollection_field_first = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_first, ptr @InterleavedCollection_setter_first }
@InterleavedCollection_field_second = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_second, ptr @InterleavedCollection_setter_second }
@ZippedCollection_field_first = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_first, ptr @ZippedCollection_setter_first }
@ZippedCollection_field_second = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_second, ptr @ZippedCollection_setter_second }
@ProductCollection_field_first = internal constant { ptr, ptr } { ptr @ProductCollection_getter_first, ptr @ProductCollection_setter_first }
@ProductCollection_field_second = internal constant { ptr, ptr } { ptr @ProductCollection_getter_second, ptr @ProductCollection_setter_second }
@_parameterization_Character = linkonce_odr constant [2 x ptr] [ptr @Character, ptr null]
@modls_The_size_of_the_collection_being_indexed_was = internal unnamed_addr constant [44 x i8] c"The size of the collection being indexed was", align 64
@wapia_An_outofbounds_error_occurred_while_indexing_into_a_collection = internal unnamed_addr constant [65 x i8] c"An out-of-bounds error occurred while indexing into a collection.", align 128
@_parameterization_i8 = linkonce_odr constant [2 x ptr] [ptr @i8_typ, ptr null]
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [16 x ptr] [ptr @String, ptr @Representable, ptr @Collection, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr null, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr null, ptr null, ptr null]
@String_offset_tbl = constant [16 x i32] [i32 10, i32 157, i32 75, i32 10, i32 0, i32 157, i32 0, i32 0, i32 0, i32 132, i32 157, i32 0, i32 0, i32 0, i32 0, i32 0]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 15, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @StringIterator, ptr null]
@StringIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 27, i32 0, i32 10, i32 10]
@OutOfBounds_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @OutOfBounds, ptr @Object]
@OutOfBounds_offset_tbl = constant [4 x i32] [i32 10, i32 30, i32 10, i32 47]
@OutOfBoundsDetails_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @OutOfBoundsDetails]
@OutOfBoundsDetails_offset_tbl = constant [4 x i32] [i32 16, i32 0, i32 10, i32 10]
@OutOfBoundsDetails = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 4650630525701360429, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBoundsDetails_hashtbl, ptr @OutOfBoundsDetails_offset_tbl, ptr @_data_size_OutOfBoundsDetails, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @OutOfBoundsDetails_field_bounds, ptr @OutOfBoundsDetails_field_index, ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_B_report_, ptr @OutOfBoundsDetails_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_report_] }
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_length = internal constant { ptr, ptr } { ptr @String_getter_length, ptr @String_setter_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_byte = internal constant { ptr, ptr } { ptr @Character_getter_byte, ptr @Character_setter_byte }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_index, ptr @StringIterator_setter_index }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@Exception_field_stacktrace = internal constant { ptr, ptr } { ptr @Exception_getter_stacktrace, ptr @Exception_setter_stacktrace }
@Exception_field_n_frames = internal constant { ptr, ptr } { ptr @Exception_getter_n_frames, ptr @Exception_setter_n_frames }
@OutOfBounds_field_details = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_details, ptr @OutOfBounds_setter_details }
@OutOfBounds_field_line_number = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_line_number, ptr @OutOfBounds_setter_line_number }
@OutOfBounds_field_file_name = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_file_name, ptr @OutOfBounds_setter_file_name }
@OutOfBounds_field_message = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_message, ptr @OutOfBounds_setter_message }
@OutOfBounds_field_stacktrace = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_stacktrace, ptr @OutOfBounds_setter_stacktrace }
@OutOfBounds_field_n_frames = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_n_frames, ptr @OutOfBounds_setter_n_frames }
@OutOfBoundsDetails_field_bounds = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_bounds, ptr @OutOfBoundsDetails_setter_bounds }
@OutOfBoundsDetails_field_index = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_index, ptr @OutOfBoundsDetails_setter_index }
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xBool__Self_print_xi32__Self_print_xf64__Self_print_xi8__Self_print_xi64__Self_print_xNil__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xString, ptr @IO__Self_print_xBool, ptr @IO__Self_print_xi32, ptr @IO__Self_print_xf64, ptr @IO__Self_print_xi8, ptr @IO__Self_print_xi64, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xString] }
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@uagtt_CUsersPaulKOneDriveDocumentsPLPyPLlibarraymini = internal unnamed_addr constant [56 x i8] c"C:\\Users\\PaulK\\OneDrive\\Documents\\PL\\PyPL\\lib\\array.mini", align 64
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@Collection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 1375598993350293883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Collection_hashtbl, ptr @Collection_offset_tbl, ptr @_data_size_Collection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@OutOfBounds = constant { [3 x i64], [7 x ptr], [37 x ptr] } { [3 x i64] [i64 5348403617834207535, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBounds_hashtbl, ptr @OutOfBounds_offset_tbl, ptr @_data_size_OutOfBounds, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [37 x ptr] [ptr @OutOfBounds_field_details, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_field_n_frames, ptr @OutOfBounds_B_init_boundsi32_indexi32, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_print_stacktrace_, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @OutOfBounds_init_boundsi32_indexi32, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @OutOfBounds_print_message_, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_field_n_frames, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_print_stacktrace_, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @OutOfBounds_print_message_] }
@Array_hashtbl = constant [16 x ptr] [ptr null, ptr @Representable, ptr @Collection, ptr @any_typ, ptr null, ptr @Container, ptr @Array, ptr null, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr null, ptr null, ptr null]
@Array_offset_tbl = constant [16 x i32] [i32 0, i32 157, i32 75, i32 10, i32 0, i32 157, i32 10, i32 0, i32 0, i32 132, i32 157, i32 0, i32 0, i32 0, i32 0, i32 0]
@Array = constant { [3 x i64], [7 x ptr], [149 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427389773, i64 15], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [149 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_init_, ptr @Array_B_init_capacityi32, ptr @Array_B_init_lengthi32_capacityi32, ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_B_length_, ptr @Array_B_capacity_, ptr @Array_B_append_xT, ptr @Array_B_extend_otherArrayT, ptr @Array_B_reserve_new_capacityi32, ptr @Array_B__index_xi32, ptr @Array_B__set_index_xi32_valueT, ptr @Array_B_unchecked_index_xi32, ptr @Array_B_unchecked_insert_xi32_valueT, ptr @Array_B_size_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_B_repr_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_init_, ptr @Array_init_capacityi32, ptr @Array_init_lengthi32_capacityi32, ptr @Array_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_length_, ptr @Array_capacity_, ptr @Array_append_xT, ptr @Array_extend_otherArrayT, ptr @Array_reserve_new_capacityi32, ptr @Array__index_xi32, ptr @Array__set_index_xi32_valueT, ptr @Array_unchecked_index_xi32, ptr @Array_unchecked_insert_xi32_valueT, ptr @Array_size_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_repr_, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_size_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_repr_] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr @Iterator, ptr null, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 10, i32 17, i32 0, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@_parameterization_Bufferi8 = linkonce_odr constant [2 x ptr] [ptr @buffer_typ, ptr null]
@fsifx_CUsersPaulKOneDriveDocumentsPLPyPLlibmapmini = internal unnamed_addr constant [54 x i8] c"C:\\Users\\PaulK\\OneDrive\\Documents\\PL\\PyPL\\lib\\map.mini", align 64
@String = constant { [3 x i64], [7 x ptr], [149 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427389773, i64 15], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [149 x ptr] [ptr @String_field_bytes, ptr @String_field_length, ptr @String_field_capacity, ptr @String_field_String_0, ptr @String_B__Self_from_c_string_c_stringBufferi8, ptr @String_B_init_, ptr @String_B_init_lengthi32_capacityi32, ptr @String_B_init_bytesBufferi8_lengthi32_capacityi32, ptr @String_B_length_, ptr @String_B_capacity_, ptr @String_B_c_string_, ptr @String_B_append_xi8, ptr @String_B_extend_otherString, ptr @String_B_reserve_new_capacityi32, ptr @String_B__EQ_otherString, ptr @String_B_unchecked_index_xi32, ptr @String_B_unchecked_insert_xi32_valuei8, ptr @String_B_copy_, ptr @String_B_size_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_B_repr_, ptr @String__Self_from_c_string_c_stringBufferi8, ptr @String_init_, ptr @String_init_lengthi32_capacityi32, ptr @String_init_bytesBufferi8_lengthi32_capacityi32, ptr @String_length_, ptr @String_capacity_, ptr @String_c_string_, ptr @String_append_xi8, ptr @String_extend_otherString, ptr @String_reserve_new_capacityi32, ptr @String__EQ_otherString, ptr @String_unchecked_index_xi32, ptr @String_unchecked_insert_xi32_valuei8, ptr @String_copy_, ptr @String_size_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_repr_, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_size_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_B_repr_, ptr @String_repr_] }
@Character = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @Character_field_byte, ptr @Character_B_init_bytei8, ptr @Character_B_byte_, ptr @Character_init_bytei8, ptr @Character_byte_] }
@StringIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_index, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_] }
@Exception = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_field_stacktrace, ptr @Exception_field_n_frames, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberi32_file_nameString, ptr @Exception_B_print_stacktrace_, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @Exception_print_message_] }
@KeyNotFound_hashtbl = constant [4 x ptr] [ptr @Object, ptr @KeyNotFound, ptr @any_typ, ptr @Exception]
@KeyNotFound_offset_tbl = constant [4 x i32] [i32 44, i32 10, i32 10, i32 27]
@KeyNotFound = constant { [3 x i64], [7 x ptr], [34 x ptr] } { [3 x i64] [i64 2946564862774055400, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @KeyNotFound_hashtbl, ptr @KeyNotFound_offset_tbl, ptr @_data_size_KeyNotFound, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [34 x ptr] [ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_field_n_frames, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_print_stacktrace_, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @Exception_print_message_, ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_field_n_frames, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_print_stacktrace_, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @Exception_print_message_] }
@Map_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr null, ptr @Object]
@Map_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 49, i32 10, i32 74, i32 10, i32 0, i32 74]
@HashMap_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr @HashMap, ptr @Object]
@HashMap_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 113, i32 10, i32 138, i32 49, i32 10, i32 138]
@KeyNotFound_field_line_number = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_line_number, ptr @KeyNotFound_setter_line_number }
@KeyNotFound_field_file_name = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_file_name, ptr @KeyNotFound_setter_file_name }
@KeyNotFound_field_message = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_message, ptr @KeyNotFound_setter_message }
@KeyNotFound_field_stacktrace = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_stacktrace, ptr @KeyNotFound_setter_stacktrace }
@KeyNotFound_field_n_frames = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_n_frames, ptr @KeyNotFound_setter_n_frames }
@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Pair = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_init_firstT_secondU, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_] }
@Container = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_data_size_Container, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388349, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388477, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Map = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5249855671126779970, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Map_hashtbl, ptr @Map_offset_tbl, ptr @_data_size_Map, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@HashMap = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 25, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [15 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [15 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_primary_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueV_primary_hashi32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_primary_hash_, ptr @Entry_B_to_pair_, ptr @Entry_init_keyK_valueV_primary_hashi32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_primary_hash_, ptr @Entry_to_pair_] }
@CuckooMap_hashtbl = constant [8 x ptr] [ptr null, ptr @CuckooMap, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr @HashMap, ptr @Object]
@CuckooMap_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 273, i32 10, i32 298, i32 209, i32 81, i32 298]
@CuckooMap = constant { [3 x i64], [7 x ptr], [288 x ptr] } { [3 x i64] [i64 3547150501766965522, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMap_hashtbl, ptr @CuckooMap_offset_tbl, ptr @_data_size_CuckooMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [288 x ptr] [ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_field_table1, ptr @CuckooMap_field_table2, ptr @CuckooMap_field_table_len, ptr @CuckooMap_field_size, ptr @CuckooMap_field_hasher, ptr @CuckooMap_field_eq, ptr @CuckooMap_B__Self_max_displacements_, ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_B_hash1_keyK, ptr @CuckooMap_B_hash2_from_primary_primary_hashi32, ptr @CuckooMap_B_index1_primary_hashi32, ptr @CuckooMap_B_index2_primary_hashi32, ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_B_resize_, ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap__Self_max_displacements_, ptr @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_hash1_keyK, ptr @CuckooMap_hash2_from_primary_primary_hashi32, ptr @CuckooMap_index1_primary_hashi32, ptr @CuckooMap_index2_primary_hashi32, ptr @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_resize_, ptr @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@CuckooMapIterator_hashtbl = constant [8 x ptr] [ptr @CuckooMapIterator, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr null]
@CuckooMapIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 27, i32 24, i32 27, i32 0, i32 10, i32 0]
@CuckooMapIterator = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 -1975748647346050920, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMapIterator_hashtbl, ptr @CuckooMapIterator_offset_tbl, ptr @_data_size_CuckooMapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @CuckooMapIterator_field_CuckooMapIterator_0, ptr @CuckooMapIterator_field_CuckooMapIterator_1, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_field_map_table1, ptr @CuckooMapIterator_field_map_table2, ptr @CuckooMapIterator_field_table_len, ptr @CuckooMapIterator_field_index, ptr @CuckooMapIterator_field_on_second, ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_next_, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_next_] }
@Entry_field_primary_hash = internal constant { ptr, ptr } { ptr @Entry_getter_primary_hash, ptr @Entry_setter_primary_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@CuckooMap_field_table1 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table1, ptr @CuckooMap_setter_table1 }
@CuckooMap_field_table2 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table2, ptr @CuckooMap_setter_table2 }
@CuckooMap_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table_len, ptr @CuckooMap_setter_table_len }
@CuckooMap_field_size = internal constant { ptr, ptr } { ptr @CuckooMap_getter_size, ptr @CuckooMap_setter_size }
@CuckooMap_field_hasher = internal constant { ptr, ptr } { ptr @CuckooMap_getter_hasher, ptr @CuckooMap_setter_hasher }
@CuckooMap_field_eq = internal constant { ptr, ptr } { ptr @CuckooMap_getter_eq, ptr @CuckooMap_setter_eq }
@CuckooMapIterator_field_map_table1 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table1, ptr @CuckooMapIterator_setter_map_table1 }
@CuckooMapIterator_field_map_table2 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table2, ptr @CuckooMapIterator_setter_map_table2 }
@CuckooMapIterator_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_table_len, ptr @CuckooMapIterator_setter_table_len }
@CuckooMapIterator_field_index = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_index, ptr @CuckooMapIterator_setter_index }
@CuckooMapIterator_field_on_second = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_on_second, ptr @CuckooMapIterator_setter_on_second }

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nocapture nofree readonly %supertype_tbl) #0 {
  %product.i = mul i64 %cand_id, %hash_coef
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash.i
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_Default(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %fat_ptr, ptr nocapture nofree readnone %parameterization) #2 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr inbounds i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr nocapture nofree readnone %parameterization, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %destination) #3 {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr inbounds i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Default(ptr nocapture nofree readnone %parameterization) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @PRNG_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %. = call i32 @llvm.smax.i32(i32 %3, i32 noundef 1) #41
  call void %10(ptr %.fca.1.extract, i32 %.) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !4
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i32 %8(ptr %.fca.1.extract) #43
  %10 = mul i32 %9, 1103515245
  %11 = add i32 %10, 12345
  %12 = and i32 %11, 2147483647
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 %12) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %17 = load ptr, ptr %6, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #43
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @set_offset(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(8) %id_ptr) local_unnamed_addr #4 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id.i = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr.i = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %vptr, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, %id.i
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %destination = getelementptr i8, ptr %fat_ptr, i64 24
  store i32 %offset.i, ptr %destination, align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #7

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define i32 @get_offset(ptr nocapture nofree readonly align 8 %vptr, ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(8) %id_ptr) local_unnamed_addr #8 {
  %id = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr = getelementptr i8, ptr %vptr, i64 40
  %hash_coef = load i64, ptr %hash_coef_ptr, align 8
  %tbl_size = load i64, ptr %tbl_size_ptr, align 8
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %product.i = mul i64 %hash_coef, %id
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %hash.i
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) local_unnamed_addr #1 {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %shifted, %product
  %hash = and i64 %xored, %tbl_size
  ret i64 %hash
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #9

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #10 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #44
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0) local_unnamed_addr #10 {
  %result = call { i64, i64 } %f(ptr nocapture nofree readonly %0) #44
  ret { i64, i64 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) local_unnamed_addr #10 {
  %result = call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #44
  ret { ptr, i160 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @unbox_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) local_unnamed_addr #11 {
  call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #45
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull readonly %1) local_unnamed_addr #12 {
  %result = call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #46
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #12 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull %0) #46
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @adjust_trampoline(ptr nofree readonly %tramp) local_unnamed_addr #13 {
  %ret = call ptr @llvm.adjust.trampoline(ptr nofree readonly %tramp) #47
  ret ptr %ret
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #14

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, inaccessiblemem: none)
define noalias ptr @bump_malloc(i64 noundef %size) local_unnamed_addr #15 {
  %result = call noalias ptr @bump_malloc_wrapper(i64 noundef %size) #48
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none)
define noalias ptr @bump_malloc_wrapper(i64 noundef %size) local_unnamed_addr #16 {
  %result = call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #48
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %current_ptr) local_unnamed_addr #17 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_data_size_tuple_typ(ptr nocapture nofree readonly align 4 %0) local_unnamed_addr #18 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull align 8 %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add nuw i64 %11, %.reg2mem22.011
  %19 = add nuw i64 %18, %17
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem20.0.lcssa = phi i64 [ 1, %1 ], [ %13, %.lr.ph ]
  %.reg2mem22.0.lcssa = phi i64 [ 0, %1 ], [ %19, %.lr.ph ]
  %24 = urem i64 %.reg2mem22.0.lcssa, %.reg2mem20.0.lcssa
  %25 = icmp eq i64 %24, 0
  %26 = sub nuw i64 %.reg2mem20.0.lcssa, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add nuw i64 %27, %.reg2mem22.0.lcssa
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa, 1
  ret { i64, i64 } %30
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #9

define { i64, i64 } @_data_size_union_typ(ptr nocapture nofree readonly align 4 %0) local_unnamed_addr #18 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge.thread, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull align 8 %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 noundef %12, i64 noundef %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = call i64 @llvm.umax.i64(i64 noundef %11, i64 noundef %.reg2mem22.011)
  %19 = call i64 @llvm.umax.i64(i64 noundef %18, i64 noundef %17)
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph
  %right_size = icmp eq i64 %19, 32
  %spec.select6 = select i1 %right_size, i64 0, i64 8
  %24 = add i64 %spec.select6, %19
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %1
  %.reg2mem20.0.lcssa4 = phi i64 [ 1, %1 ], [ %13, %._crit_edge ]
  %final_size = phi i64 [ 8, %1 ], [ %24, %._crit_edge ]
  %25 = urem i64 %final_size, %.reg2mem20.0.lcssa4
  %26 = icmp eq i64 %25, 0
  %27 = sub nuw i64 %.reg2mem20.0.lcssa4, %25
  %28 = select i1 %26, i64 0, i64 %27
  %29 = add nuw i64 %28, %final_size
  %30 = insertvalue { i64, i64 } undef, i64 %29, 0
  %31 = insertvalue { i64, i64 } %30, i64 %.reg2mem20.0.lcssa4, 1
  ret { i64, i64 } %31
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %dest) local_unnamed_addr #18 {
  %3 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %3, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %4 = getelementptr i8, ptr %1, i64 8
  %5 = load i64, ptr %4, align 4
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %.lr.ph.i, %2
  %.in.i = phi i64 [ %24, %.lr.ph.i ], [ %5, %2 ]
  %7 = phi i64 [ %22, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem20.010.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %2 ]
  %8 = inttoptr i64 %.in.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = call { i64, i64 } %11(ptr nonnull align 8 %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = call i64 @llvm.umax.i64(i64 noundef %14, i64 noundef %.reg2mem20.010.i)
  %16 = urem i64 %.reg2mem22.011.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub nuw i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = call i64 @llvm.umax.i64(i64 noundef %13, i64 noundef %.reg2mem22.011.i)
  %21 = call i64 @llvm.umax.i64(i64 noundef %20, i64 noundef %19)
  %22 = add nuw i64 %7, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %21, 32
  %spec.select6.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select6.i, %21
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %._crit_edge.i, %2
  %.reg2mem20.0.lcssa4.i = phi i64 [ 1, %2 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %2 ], [ %26, %._crit_edge.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %final_size.i, %.reg2mem20.0.lcssa4.i
  %30 = icmp eq i64 %29, 0
  %31 = sub nuw i64 %.reg2mem20.0.lcssa4.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add nuw i64 %32, %final_size.i
  %34 = icmp slt i64 %33, 17
  %35 = icmp eq i64 %33, 32
  %36 = select i1 %34, ptr %.fca.1.gep, ptr %28
  %source = select i1 %35, ptr %3, ptr %36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %dest, ptr nocapture nofree readonly align 1 %source, i64 %33, i1 noundef false)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #19

define noundef nonnull ptr @coroutine_create(ptr nofree %func, ptr nofree %arg_passer) local_unnamed_addr #18 {
  %result.i = call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #49
  store ptr %func, ptr %result.i, align 8
  %stack_top = getelementptr inbounds i8, ptr %result.i, i64 8388512
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr inbounds i8, ptr %result.i, i64 8
  %arg_passer_slot = getelementptr inbounds i8, ptr %result.i, i64 32
  %into_callee_second_word = getelementptr inbounds i8, ptr %result.i, i64 16
  %into_callee_third_word = getelementptr inbounds i8, ptr %result.i, i64 24
  store i64 %stack_top_aligned, ptr %into_callee_buf, align 8
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 8
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr inbounds i8, ptr %result.i, i64 40
  store i1 false, ptr %is_finished, align 8
  call void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8388592) %into_callee_second_word)
  ret ptr %result.i
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @virtual_reserve(i64 %size) local_unnamed_addr #20 {
  %result = call noalias ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 %size, i32 noundef 12288, i32 noundef 4) #49
  ret ptr %result
}

define void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %into_callee_second_word) #18 {
  store ptr blockaddress(@coroutine_trampoline, %trampoline), ptr %into_callee_second_word, align 8
  %result = call i1 @returns_one() #50
  br i1 %result, label %exit, label %trampoline

trampoline:                                       ; preds = %0
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  %arg_passer_ptr = getelementptr i8, ptr %current_coroutine, i64 32
  %arg_passer = load ptr, ptr %arg_passer_ptr, align 8
  call void %arg_passer(ptr %current_coroutine)
  %current_coroutine2 = load ptr, ptr @current_coroutine, align 8
  %is_finished_ptr = getelementptr i8, ptr %current_coroutine2, i64 40
  store i1 true, ptr %is_finished_ptr, align 1
  call void @llvm.eh.sjlj.longjmp(ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #22
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define i1 @returns_one() local_unnamed_addr #21 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #22

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) local_unnamed_addr #23

define void @setup_landing_pad() #18 {
  %result.i = call noalias dereferenceable_or_null(5368709120) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 5368709120, i32 noundef 12288, i32 noundef 4) #49
  store ptr %result.i, ptr @current_ptr, align 8
  %sp = call ptr @llvm.stacksave.p0() #51
  store ptr %sp, ptr @into_caller_buf, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %sp, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %result.i.i = call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #49
  store ptr @setup_landing_pad, ptr %result.i.i, align 8
  %stack_top.i = getelementptr inbounds i8, ptr %result.i.i, i64 8388512
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr inbounds i8, ptr %result.i.i, i64 8
  %arg_passer_slot.i = getelementptr inbounds i8, ptr %result.i.i, i64 32
  %into_callee_second_word.i = getelementptr inbounds i8, ptr %result.i.i, i64 16
  %into_callee_third_word.i = getelementptr inbounds i8, ptr %result.i.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 8
  store ptr @arg_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr inbounds i8, ptr %result.i.i, i64 40
  store i1 false, ptr %is_finished.i, align 8
  call void @coroutine_trampoline(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8388592) %into_callee_second_word.i)
  store ptr %result.i.i, ptr @current_coroutine, align 8
  %result = call i1 @returns_one() #52
  br i1 %result, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = call i32 @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @string_string, ptr nofree noundef nonnull align 16 dereferenceable(45) @exception_message) #53
  %cc.unpack = load ptr, ptr @current_coroutine, align 8
  %cc1 = insertvalue { ptr } poison, ptr %cc.unpack, 0
  call void @report_exception({ ptr } %cc1) #53
  call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #24

define void @arg_passer(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %current_coroutine) #18 {
  %func = load ptr, ptr %current_coroutine, align 8
  call void %func()
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #25

declare void @exit() local_unnamed_addr #18

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @assume_offset(ptr nocapture nofree noundef nonnull readnone align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readnone align 4 %id_ptr) local_unnamed_addr #1 {
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr nocapture nofree noundef nonnull readonly %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nofree readonly %supertype_tbl) local_unnamed_addr #10 {
  %result = call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #44
  ret i1 %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @arg_buffer_filler(ptr nocapture nofree readnone %coroutine) local_unnamed_addr #1 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define ptr @get_current_coroutine() local_unnamed_addr #26 {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %from_buf, ptr %to_buf) #27 {
  %from_buf_second_word = getelementptr inbounds i8, ptr %from_buf, i64 8
  %from_buf_third_word = getelementptr inbounds i8, ptr %from_buf, i64 16
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = call ptr @llvm.stacksave.p0() #51
  store ptr %sp, ptr %from_buf, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %is_first_time = call i1 @returns_one() #50
  br i1 %is_first_time, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #22
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

; Function Attrs: nounwind
define void @coroutine_yield(ptr nocapture nofree nonnull writeonly align 8 dereferenceable(24) %current_coroutine) local_unnamed_addr #28 {
  %into_callee_buf = getelementptr inbounds i8, ptr %current_coroutine, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %into_callee_buf, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #54
  ret void
}

; Function Attrs: cold minsize noinline nounwind
define void @coroutine_yield_cold(ptr nocapture nofree nonnull writeonly align 8 dereferenceable(24) %current_coroutine) local_unnamed_addr #29 {
  %into_callee_buf.i = getelementptr inbounds i8, ptr %current_coroutine, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #54
  ret void
}

; Function Attrs: nounwind
define void @coroutine_call(ptr %coroutine) local_unnamed_addr #28 {
  %old_into_caller.unpack2 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr i8, ptr %coroutine, i64 8
  %1 = load <2 x ptr>, ptr @into_caller_buf, align 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr %into_callee_buf) #54
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store <2 x ptr> %1, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack2, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr nofree %tramp) local_unnamed_addr #30 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr nofree %tramp, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect) #53
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) local_unnamed_addr #30

define void @print_backtrace(ptr nocapture nofree readonly %backtrace, i64 %n_frames) local_unnamed_addr #18 {
  %handle = tail call ptr @GetCurrentProcess()
  %1 = tail call i32 @SymInitialize(ptr noundef %handle, ptr noundef align 4294967296 null, i32 noundef 1)
  %2 = alloca [344 x i8], align 1
  %3 = getelementptr inbounds i8, ptr %2, i64 4
  call void @llvm.memset.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(344) %3, i8 noundef 0, i64 noundef 340, i1 noundef false)
  %4 = getelementptr inbounds i8, ptr %2, i64 80
  store i32 255, ptr %4, align 4
  store i32 88, ptr %2, align 4
  %.not = icmp eq i64 %n_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %0
  %5 = getelementptr inbounds i8, ptr %2, i64 56
  %6 = getelementptr inbounds i8, ptr %2, i64 84
  br label %7

7:                                                ; preds = %7, %.lr.ph
  %indvars.iv.in = phi i64 [ %n_frames, %.lr.ph ], [ %indvars.iv, %7 ]
  %indvars.iv = add i64 %indvars.iv.in, -1
  %8 = getelementptr inbounds [100 x ptr], ptr %backtrace, i64 0, i64 %indvars.iv
  %9 = load ptr, ptr %8, align 8
  %10 = ptrtoint ptr %9 to i64
  %11 = call i32 @SymFromAddr(ptr noundef %handle, i64 noundef %10, ptr noundef align 4294967296 null, ptr noundef nonnull align 4 dereferenceable(344) %2)
  %12 = load i64, ptr %5, align 8
  %13 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(16) @backtrace_string, i64 noundef %indvars.iv, ptr nofree nonnull dereferenceable(260) %6, i64 %12) #53
  %exitcond.not = icmp slt i64 %indvars.iv, 1
  br i1 %exitcond.not, label %._crit_edge, label %7

._crit_edge:                                      ; preds = %7, %0
  %14 = call i32 @SymCleanup(ptr noundef %handle)
  ret void
}

declare ptr @GetCurrentProcess() local_unnamed_addr #18

declare i32 @SymInitialize(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #18

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #31

declare i32 @SymFromAddr(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #18

declare i32 @SymCleanup(ptr) local_unnamed_addr #18

define i64 @capture_backtrace(i64 %max_frames, ptr nocapture nofree writeonly %backtrace) local_unnamed_addr #18 {
entry:
  %context = alloca %struct._CONTEXT, align 16
  call void @RtlCaptureContext(ptr noundef nonnull align 16 dereferenceable(1232) %context)
  %rip = getelementptr inbounds i8, ptr %context, i64 248
  %img_base_ptr = alloca i64, align 8
  %0 = alloca ptr, align 8
  %1 = alloca i64, align 8
  %.not = icmp eq i64 %max_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %entry
  %.pre = load i64, ptr %rip, align 8
  br label %.lr.ph

.lr.ph:                                           ; preds = %3, %.lr.ph.preheader
  %2 = phi i64 [ %.pre, %.lr.ph.preheader ], [ %6, %3 ]
  %indvars.iv = phi i64 [ 0, %.lr.ph.preheader ], [ %indvars.iv.next, %3 ]
  %fentry = call ptr @RtlLookupFunctionEntry(i64 %2, ptr noundef nonnull align 8 dereferenceable(8) %img_base_ptr, ptr noundef align 4294967296 null)
  %img_base = load i64, ptr %img_base_ptr, align 8
  %fentry_null = icmp eq ptr %fentry, null
  %img_base_null = icmp eq i64 %img_base, 0
  %either = or i1 %fentry_null, %img_base_null
  br i1 %either, label %._crit_edge.loopexit.split.loop.exit, label %3

3:                                                ; preds = %.lr.ph
  %4 = load i64, ptr %rip, align 8
  %5 = call ptr @RtlVirtualUnwind(i32 noundef 0, i64 %img_base, i64 %4, ptr nonnull %fentry, ptr noundef nonnull align 16 dereferenceable(1232) %context, ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1, ptr noundef align 4294967296 null)
  %6 = load i64, ptr %rip, align 8
  %7 = inttoptr i64 %6 to ptr
  %8 = getelementptr inbounds ptr, ptr %backtrace, i64 %indvars.iv
  store ptr %7, ptr %8, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %max_frames
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge.loopexit.split.loop.exit:             ; preds = %.lr.ph
  %n_captured.le = add nsw i64 %indvars.iv, -4
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit.split.loop.exit, %3, %entry
  %.0.lcssa = phi i64 [ 0, %entry ], [ %n_captured.le, %._crit_edge.loopexit.split.loop.exit ], [ %max_frames, %3 ]
  ret i64 %.0.lcssa
}

declare void @RtlCaptureContext(ptr) local_unnamed_addr #18

declare ptr @RtlLookupFunctionEntry(i64, ptr, ptr) local_unnamed_addr #18

declare ptr @RtlVirtualUnwind(i32, i64, i64, ptr, ptr, ptr, ptr, ptr) local_unnamed_addr #18

define i1 @sxmbvaaqjx(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @axlhmwbuwo(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ytebrvjgff(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @nivqqmixpq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @hnbsvmhnda(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @agkclrhtzs(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @pvnidioudp(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @hbaqvtggfm(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @cfjkgytwfj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @hkbtwjjhqj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @vaxeopwwdi(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @oxgghllhom(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @uvhofywczn(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @drgmnjsbrc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @weyllhhkpb(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @nyfuylfwaq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @genyhirpvr(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @vimoiwpapu(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ewafwzhivv(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #18 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @egohsgumaa(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #18 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

; Function Attrs: nounwind
define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #28 {
  %result.i.i364.h2s379 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i364.h2s379, align 4
  %result.i.i344.h2s381 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i344.h2s381, i8 0, i64 16, i1 false)
  %result.i.i324.h2s383 = alloca [4 x i8], align 4
  %result.i.i304.h2s385 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i304.h2s385, i8 0, i64 15, i1 false)
  %result.i.i.h2s387 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i.h2s387, i8 0, i64 15, i1 false)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !7
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !7
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !7
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !7
  %4 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %5 = ptrtoint ptr %.fca.1.extract to i64
  %6 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %6 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext133 = zext i64 %5 to i160
  %.sroa.3.8.insert.insert134 = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext133
  %7 = insertvalue { ptr, i160 } %4, i160 %.sroa.3.8.insert.insert134, 1
  %8 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8) #40
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #40
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %13 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %14 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %result.i6.i = call i1 %15(i64 %14, i64 %13, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %16) #44
  br i1 %result.i6.i, label %17, label %.critedge.i

17:                                               ; preds = %3
  %result.i5.i = call i1 %15(i64 %14, i64 %13, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %16) #44
  br i1 %result.i5.i, label %.critedge.i, label %18

18:                                               ; preds = %17
  %result.i4.i = call i1 %15(i64 %14, i64 %13, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %16) #44
  br i1 %result.i4.i, label %.critedge.i, label %._crit_edge.lr.ph.i

.critedge.i:                                      ; preds = %18, %17, %3
  %result.i3.i = call i1 %15(i64 %14, i64 %13, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %16) #44
  br i1 %result.i3.i, label %19, label %.critedge15.i

19:                                               ; preds = %.critedge.i
  %result.i2.i = call i1 %15(i64 %14, i64 %13, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %16) #44
  br i1 %result.i2.i, label %.critedge15.i, label %._crit_edge.lr.ph.i

.critedge15.i:                                    ; preds = %19, %.critedge.i
  %20 = icmp eq ptr %.fca.0.extract, @i32_typ
  br i1 %20, label %._crit_edge.lr.ph.i, label %21

21:                                               ; preds = %.critedge15.i
  %22 = icmp eq ptr %.fca.0.extract, @nil_typ
  %23 = icmp eq ptr %.fca.0.extract, null
  %24 = or i1 %22, %23
  br i1 %24, label %._crit_edge.lr.ph.i, label %25

25:                                               ; preds = %21
  %26 = icmp eq ptr %.fca.0.extract, @bool_typ
  br i1 %26, label %._crit_edge.lr.ph.i, label %27

27:                                               ; preds = %25
  %28 = icmp eq ptr %.fca.0.extract, @f64_typ
  br i1 %28, label %._crit_edge.lr.ph.i, label %29

29:                                               ; preds = %27
  %result.i1.i = call i1 %15(i64 %14, i64 %13, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %16) #44
  %result.i1.not.i = xor i1 %result.i1.i, true
  %brmerge.i = or i1 %result.i3.i, %result.i1.not.i
  br i1 %brmerge.i, label %.critedge17.i, label %._crit_edge.lr.ph.i

.critedge17.i:                                    ; preds = %29
  %30 = icmp eq ptr %.fca.0.extract, @i64_typ
  %31 = select i1 %30, i64 5, i64 4
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %.critedge17.i, %29, %27, %25, %21, %.critedge15.i, %19, %18
  %.reg2mem27.0.i = phi i64 [ 2, %.critedge15.i ], [ 6, %21 ], [ 1, %25 ], [ 3, %27 ], [ %31, %.critedge17.i ], [ 7, %19 ], [ 8, %18 ], [ 9, %29 ]
  %32 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %.reg2mem27.0.i
  %33 = getelementptr i8, ptr %32, i64 80
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %7) #53
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i.i.h2s387, align 16
  %35 = getelementptr inbounds i8, ptr %result.i.i.h2s387, i64 14
  store i8 0, ptr %35, align 2
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.h2s387) #55
  %36 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1) #55
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i.i304.h2s385, align 16
  %37 = getelementptr inbounds i8, ptr %result.i.i304.h2s385, i64 14
  store i8 0, ptr %37, align 2
  %puts.i229 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.h2s385) #55
  %38 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2) #55
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #56
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i.i324.h2s383, align 4
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #56
  %41 = getelementptr inbounds i8, ptr %result.i.i324.h2s383, i64 3
  store i8 0, ptr %41, align 1
  %puts.i249 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.h2s383) #55
  %42 = icmp sgt i32 %1, 0
  br i1 %42, label %._crit_edge.lr.ph.i345, label %._crit_edge

._crit_edge.lr.ph.i345:                           ; preds = %._crit_edge.lr.ph.i
  %43 = zext nneg i32 %1 to i64
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i.i344.h2s381, align 16
  %44 = mul i64 %2, 1000000
  %45 = sdiv i64 %44, %43
  %46 = getelementptr inbounds i8, ptr %result.i.i344.h2s381, i64 15
  store i8 0, ptr %46, align 1
  %puts.i269 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.h2s381) #55
  %47 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %45) #55
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #56
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i.i364.h2s379, align 4
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #56
  %50 = getelementptr inbounds i8, ptr %result.i.i364.h2s379, i64 3
  store i8 0, ptr %50, align 1
  %puts.i289 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.h2s379) #55
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph.i345, %._crit_edge.lr.ph.i
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr #18 {
  %2 = alloca {}, align 8
  %result.i.i707.h2s1552 = alloca [5 x i8], align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(5) %result.i.i707.h2s1552, i8 0, i64 5, i1 false)
  %result.i.i687.h2s1553 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i.i687.h2s1553, i8 0, i64 19, i1 false)
  %result.i.i364.i.h2s1555 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i364.i.h2s1555, align 4
  %result.i.i344.i.h2s1557 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i344.i.h2s1557, i8 0, i64 16, i1 false)
  %result.i.i324.i.h2s1559 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i324.i.h2s1559, align 4
  %result.i.i304.i.h2s1561 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i304.i.h2s1561, i8 0, i64 15, i1 false)
  %result.i.i.i.h2s1563 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i.i.h2s1563, i8 0, i64 15, i1 false)
  %result.i.i672.h2s1565 = alloca [18 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i672.h2s1565, i8 0, i64 18, i1 false)
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca { ptr }, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca { ptr }, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [1 x ptr], align 8
  %34 = alloca { ptr }, align 8
  %oldProtect.i33 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %35 = alloca [3 x ptr], align 8
  %36 = alloca { ptr, ptr, ptr }, align 8
  %37 = alloca [1 x ptr], align 8
  %38 = alloca { ptr }, align 8
  %39 = alloca [3 x ptr], align 8
  %40 = alloca { ptr, ptr, ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %result.i31 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i31, align 8
  %43 = getelementptr inbounds i8, ptr %result.i31, i64 8
  store ptr @_parameterization_i32, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %result.i31, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i31) #40
  %result.i30 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  %result.i32 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i30, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i30, ptr noalias nofree noundef nonnull readnone @egohsgumaa, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i22 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i30) #47
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i30) #40
  %result.i29 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i33) #40
  %result.i34 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i29, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i33) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i33) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i29, ptr noalias nofree noundef nonnull readnone @ewafwzhivv, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i29) #47
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i29) #40
  %48 = getelementptr inbounds i8, ptr %result.i31, i64 48
  store ptr %ret.i22, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %result.i31, i64 56
  store ptr %ret.i, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i31, i64 40
  store i32 8, ptr %50, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %51 = getelementptr inbounds i8, ptr %result.i31, i64 24
  store ptr %result.i1.i, ptr %51, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %52 = getelementptr inbounds i8, ptr %result.i31, i64 32
  store ptr %result.i.i, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %54 = getelementptr inbounds i8, ptr %result.i31, i64 44
  store i32 0, ptr %54, align 4
  %55 = call i64 @clock()
  %56 = icmp sgt i32 %0, 0
  br i1 %56, label %._crit_edge.preheader, label %949

._crit_edge.preheader:                            ; preds = %1
  %57 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i31, 1
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr undef, 2
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 10, 3
  %60 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 10, 3
  br label %._crit_edge

._crit_edge:                                      ; preds = %CuckooMap_insert_keyK_valueV.exit, %._crit_edge.preheader
  %.066 = phi i32 [ %61, %CuckooMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %61 = add nuw nsw i32 %.066, 1
  %.sroa.0138.0.insert.ext = zext nneg i32 %.066 to i160
  %62 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0138.0.insert.ext, 1
  %.sroa.0135.0.insert.ext = zext nneg i32 %61 to i160
  %63 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0135.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %64 = load ptr, ptr %48, align 8
  %65 = call i32 %64({ ptr, i160 } %62) #53
  %66 = load i32, ptr %50, align 8
  %67 = add i32 %66, -1
  %68 = and i32 %67, %65
  %69 = load ptr, ptr %51, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %71 = sext i32 %68 to i64
  %72 = shl nsw i64 %71, 5
  %73 = getelementptr i8, ptr %69, i64 %72
  %74 = load ptr, ptr %73, align 8
  %75 = getelementptr i8, ptr %73, i64 8
  %76 = icmp ne ptr %74, @nil_typ
  %77 = icmp ne ptr %74, null
  %.not66.i = and i1 %76, %77
  br i1 %.not66.i, label %78, label %176

78:                                               ; preds = %._crit_edge
  %79 = load i64, ptr %75, align 4
  %.sroa_idx.i = getelementptr i8, ptr %73, i64 16
  %80 = load i64, ptr %.sroa_idx.i, align 4
  %81 = inttoptr i64 %79 to ptr
  %82 = inttoptr i64 %80 to ptr
  %hash_coef_ptr.i.i11.i = getelementptr i8, ptr %74, i64 8
  %tbl_size_ptr.i.i12.i = getelementptr i8, ptr %74, i64 16
  %offset_tbl_ptr.i.i13.i = getelementptr i8, ptr %74, i64 40
  %hash_coef.i.i14.i = load i64, ptr %hash_coef_ptr.i.i11.i, align 4, !noalias !10
  %tbl_size.i.i15.i = load i64, ptr %tbl_size_ptr.i.i12.i, align 4, !noalias !10
  %offset_tbl.i.i16.i = load ptr, ptr %offset_tbl_ptr.i.i13.i, align 8, !noalias !10
  %product.i.i.i17.i = mul i64 %hash_coef.i.i14.i, 4015701072841558310
  %shifted.i.i.i18.i = lshr i64 %product.i.i.i17.i, 32
  %xored.i.i.i19.i = xor i64 %shifted.i.i.i18.i, %product.i.i.i17.i
  %hash.i.i.i20.i = and i64 %xored.i.i.i19.i, %tbl_size.i.i15.i
  %offset_ptr.i.i21.i = getelementptr i32, ptr %offset_tbl.i.i16.i, i64 %hash.i.i.i20.i
  %offset.i.i22.i = load i32, ptr %offset_ptr.i.i21.i, align 4, !noalias !10
  %83 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %74, 0
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %81, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %82, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %offset.i.i22.i, 3
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %74) #40
  %89 = sext i32 %offset.i.i22.i to i64
  %90 = getelementptr ptr, ptr %74, i64 %89
  %91 = getelementptr i8, ptr %90, i64 64
  %92 = load ptr, ptr %91, align 8
  %result.i8.i = call ptr %92({ ptr, ptr, ptr, i32 } %86, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %93 = call i32 %result.i8.i({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull align 8 %2) #53
  %94 = icmp eq i32 %93, %65
  br i1 %94, label %._crit_edge.i294, label %176

._crit_edge.i294:                                 ; preds = %78
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %74)
  %97 = getelementptr i8, ptr %90, i64 48
  %98 = load ptr, ptr %97, align 8
  %result.i7.i = call ptr %98({ ptr, ptr, ptr, i32 } %86, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %99 = call { ptr, i160 } %result.i7.i({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull align 8 %2) #53
  %100 = load ptr, ptr %49, align 8
  %101 = call i1 %100({ ptr, i160 } %99, { ptr, i160 } %62) #53
  br i1 %101, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %176

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i294
  %102 = load ptr, ptr %result.i31, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %104 = load ptr, ptr %43, align 8
  %105 = load ptr, ptr %102, align 8, !alias.scope !13
  %106 = getelementptr i8, ptr %105, i64 72
  %107 = load ptr, ptr %106, align 8, !alias.scope !13
  %result.i1.i.i = call { i64, i64 } %107(ptr nocapture nofree nonnull readonly align 8 %102) #44, !alias.scope !13
  %108 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %109 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %110 = urem i64 20, %109
  %111 = icmp eq i64 %110, 0
  %112 = sub i64 %109, %110
  %113 = select i1 %111, i64 0, i64 %112
  %114 = add i64 %108, 20
  %115 = add i64 %114, %113
  %116 = load ptr, ptr %104, align 8, !alias.scope !13
  %117 = getelementptr i8, ptr %116, i64 72
  %118 = load ptr, ptr %117, align 8, !alias.scope !13
  %result.i.i.i295 = call { i64, i64 } %118(ptr nocapture nofree nonnull readonly align 8 %104) #44, !alias.scope !13
  %119 = extractvalue { i64, i64 } %result.i.i.i295, 0
  %120 = extractvalue { i64, i64 } %result.i.i.i295, 1
  %121 = call i64 @llvm.umax.i64(i64 %109, i64 %120) #41
  %122 = call i64 @llvm.umax.i64(i64 %121, i64 noundef 8) #41, !range !16
  %123 = urem i64 %115, %120
  %124 = icmp eq i64 %123, 0
  %125 = sub i64 %120, %123
  %126 = select i1 %124, i64 0, i64 %125
  %127 = add i64 %119, %115
  %128 = add i64 %127, %126
  %129 = urem i64 %128, %122
  %130 = icmp eq i64 %129, 0
  %131 = sub i64 %122, %129
  %132 = select i1 %130, i64 0, i64 %131
  %133 = add i64 %132, %128
  %result.i9.i = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %133) #48
  store ptr %102, ptr %result.i9.i, align 8
  %134 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr %104, ptr %134, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i)
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %137 = load ptr, ptr %102, align 8
  %138 = getelementptr i8, ptr %137, i64 72
  %139 = load ptr, ptr %138, align 8
  %result.i.i38.i = call { i64, i64 } %139(ptr nocapture nofree nonnull readonly align 8 %102) #44
  %140 = extractvalue { i64, i64 } %result.i.i38.i, 1
  %141 = urem i64 20, %140
  %142 = icmp eq i64 %141, 0
  %reass.sub = sub i64 %140, %141
  %143 = add i64 %reass.sub, 20
  %144 = select i1 %142, i64 20, i64 %143
  %145 = getelementptr i8, ptr %result.i9.i, i64 %144
  %146 = getelementptr i8, ptr %137, i64 64
  %147 = load ptr, ptr %146, align 8
  call void %147({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %102, ptr nocapture nofree writeonly %145) #45
  %148 = load ptr, ptr %result.i9.i, align 8
  %149 = load ptr, ptr %148, align 8
  %150 = getelementptr i8, ptr %149, i64 72
  %151 = load ptr, ptr %150, align 8
  %result.i1.i39.i = call { i64, i64 } %151(ptr nocapture nofree nonnull readonly align 8 %148) #44
  %152 = extractvalue { i64, i64 } %result.i1.i39.i, 0
  %153 = extractvalue { i64, i64 } %result.i1.i39.i, 1
  %154 = urem i64 20, %153
  %155 = icmp eq i64 %154, 0
  %156 = sub i64 %153, %154
  %157 = select i1 %155, i64 0, i64 %156
  %158 = add i64 %152, 20
  %159 = add i64 %158, %157
  %160 = load ptr, ptr %134, align 8
  %161 = load ptr, ptr %160, align 8
  %162 = getelementptr i8, ptr %161, i64 72
  %163 = load ptr, ptr %162, align 8
  %result.i.i40.i = call { i64, i64 } %163(ptr nocapture nofree nonnull readonly align 8 %160) #44
  %164 = extractvalue { i64, i64 } %result.i.i40.i, 1
  %165 = urem i64 %159, %164
  %166 = icmp eq i64 %165, 0
  %167 = sub i64 %164, %165
  %168 = select i1 %166, i64 0, i64 %167
  %169 = getelementptr i8, ptr %result.i9.i, i64 %159
  %170 = getelementptr i8, ptr %169, i64 %168
  %171 = getelementptr i8, ptr %161, i64 64
  %172 = load ptr, ptr %171, align 8
  call void %172({ ptr, i160 } %63, ptr nocapture nofree nonnull readonly align 8 %160, ptr nocapture nofree writeonly %170) #45
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %174 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %65, ptr %174, align 8
  store ptr @Entry, ptr %73, align 8
  %175 = ptrtoint ptr %result.i9.i to i64
  store i64 %175, ptr %75, align 4
  %.sroa_idx30.i = getelementptr i8, ptr %73, i64 24
  store i32 10, ptr %.sroa_idx30.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

176:                                              ; preds = %._crit_edge.i294, %78, %._crit_edge
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %177 = add i32 %65, 2127912214
  %178 = shl i32 %65, 12
  %179 = add i32 %177, %178
  %180 = ashr i32 %179, 19
  %181 = xor i32 %179, %180
  %182 = xor i32 %181, -949894596
  %183 = add i32 %182, 374761393
  %184 = shl i32 %182, 5
  %185 = add i32 %183, %184
  %186 = add i32 %185, -744332180
  %187 = shl i32 %185, 9
  %188 = xor i32 %186, %187
  %189 = add i32 %188, -42973499
  %190 = shl i32 %188, 3
  %191 = add i32 %189, %190
  %192 = ashr i32 %191, 16
  %193 = xor i32 %191, %192
  %194 = xor i32 %193, -1252372727
  %195 = load i32, ptr %50, align 8
  %196 = add i32 %195, -1
  %197 = and i32 %196, %194
  %198 = load ptr, ptr %52, align 8
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %200 = sext i32 %197 to i64
  %201 = shl nsw i64 %200, 5
  %202 = getelementptr i8, ptr %198, i64 %201
  %203 = load ptr, ptr %202, align 8
  %204 = getelementptr i8, ptr %202, i64 8
  %205 = icmp ne ptr %203, @nil_typ
  %206 = icmp ne ptr %203, null
  %.not66.i325 = and i1 %205, %206
  br i1 %.not66.i325, label %207, label %305

207:                                              ; preds = %176
  %208 = load i64, ptr %204, align 4
  %.sroa_idx.i327 = getelementptr i8, ptr %202, i64 16
  %209 = load i64, ptr %.sroa_idx.i327, align 4
  %210 = inttoptr i64 %208 to ptr
  %211 = inttoptr i64 %209 to ptr
  %hash_coef_ptr.i.i11.i328 = getelementptr i8, ptr %203, i64 8
  %tbl_size_ptr.i.i12.i329 = getelementptr i8, ptr %203, i64 16
  %offset_tbl_ptr.i.i13.i330 = getelementptr i8, ptr %203, i64 40
  %hash_coef.i.i14.i331 = load i64, ptr %hash_coef_ptr.i.i11.i328, align 4, !noalias !17
  %tbl_size.i.i15.i332 = load i64, ptr %tbl_size_ptr.i.i12.i329, align 4, !noalias !17
  %offset_tbl.i.i16.i333 = load ptr, ptr %offset_tbl_ptr.i.i13.i330, align 8, !noalias !17
  %product.i.i.i17.i334 = mul i64 %hash_coef.i.i14.i331, 4015701072841558310
  %shifted.i.i.i18.i335 = lshr i64 %product.i.i.i17.i334, 32
  %xored.i.i.i19.i336 = xor i64 %shifted.i.i.i18.i335, %product.i.i.i17.i334
  %hash.i.i.i20.i337 = and i64 %xored.i.i.i19.i336, %tbl_size.i.i15.i332
  %offset_ptr.i.i21.i338 = getelementptr i32, ptr %offset_tbl.i.i16.i333, i64 %hash.i.i.i20.i337
  %offset.i.i22.i339 = load i32, ptr %offset_ptr.i.i21.i338, align 4, !noalias !17
  %212 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %203, 0
  %213 = insertvalue { ptr, ptr, ptr, i32 } %212, ptr %210, 1
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr %211, 2
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, i32 %offset.i.i22.i339, 3
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %217 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %203) #40
  %218 = sext i32 %offset.i.i22.i339 to i64
  %219 = getelementptr ptr, ptr %203, i64 %218
  %220 = getelementptr i8, ptr %219, i64 64
  %221 = load ptr, ptr %220, align 8
  %result.i8.i340 = call ptr %221({ ptr, ptr, ptr, i32 } %215, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %222 = call i32 %result.i8.i340({ ptr, ptr, ptr, i32 } %215, { ptr, ptr, ptr, i32 } %215, ptr nonnull align 8 %2) #53
  %223 = icmp eq i32 %222, %65
  br i1 %223, label %._crit_edge.i341, label %305

._crit_edge.i341:                                 ; preds = %207
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %203)
  %226 = getelementptr i8, ptr %219, i64 48
  %227 = load ptr, ptr %226, align 8
  %result.i7.i342 = call ptr %227({ ptr, ptr, ptr, i32 } %215, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %228 = call { ptr, i160 } %result.i7.i342({ ptr, ptr, ptr, i32 } %215, { ptr, ptr, ptr, i32 } %215, ptr nonnull align 8 %2) #53
  %229 = load ptr, ptr %49, align 8
  %230 = call i1 %229({ ptr, i160 } %228, { ptr, i160 } %62) #53
  br i1 %230, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit354, label %305

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit354: ; preds = %._crit_edge.i341
  %231 = load ptr, ptr %result.i31, align 8
  %232 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %233 = load ptr, ptr %43, align 8
  %234 = load ptr, ptr %231, align 8, !alias.scope !20
  %235 = getelementptr i8, ptr %234, i64 72
  %236 = load ptr, ptr %235, align 8, !alias.scope !20
  %result.i1.i.i346 = call { i64, i64 } %236(ptr nocapture nofree nonnull readonly align 8 %231) #44, !alias.scope !20
  %237 = extractvalue { i64, i64 } %result.i1.i.i346, 0
  %238 = extractvalue { i64, i64 } %result.i1.i.i346, 1
  %239 = urem i64 20, %238
  %240 = icmp eq i64 %239, 0
  %241 = sub i64 %238, %239
  %242 = select i1 %240, i64 0, i64 %241
  %243 = add i64 %237, 20
  %244 = add i64 %243, %242
  %245 = load ptr, ptr %233, align 8, !alias.scope !20
  %246 = getelementptr i8, ptr %245, i64 72
  %247 = load ptr, ptr %246, align 8, !alias.scope !20
  %result.i.i.i347 = call { i64, i64 } %247(ptr nocapture nofree nonnull readonly align 8 %233) #44, !alias.scope !20
  %248 = extractvalue { i64, i64 } %result.i.i.i347, 0
  %249 = extractvalue { i64, i64 } %result.i.i.i347, 1
  %250 = call i64 @llvm.umax.i64(i64 %238, i64 %249) #41
  %251 = call i64 @llvm.umax.i64(i64 %250, i64 noundef 8) #41, !range !16
  %252 = urem i64 %244, %249
  %253 = icmp eq i64 %252, 0
  %254 = sub i64 %249, %252
  %255 = select i1 %253, i64 0, i64 %254
  %256 = add i64 %248, %244
  %257 = add i64 %256, %255
  %258 = urem i64 %257, %251
  %259 = icmp eq i64 %258, 0
  %260 = sub i64 %251, %258
  %261 = select i1 %259, i64 0, i64 %260
  %262 = add i64 %261, %257
  %result.i9.i348 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %262) #48
  store ptr %231, ptr %result.i9.i348, align 8
  %263 = getelementptr inbounds i8, ptr %result.i9.i348, i64 8
  store ptr %233, ptr %263, align 8
  %264 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i348)
  %265 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %266 = load ptr, ptr %231, align 8
  %267 = getelementptr i8, ptr %266, i64 72
  %268 = load ptr, ptr %267, align 8
  %result.i.i38.i349 = call { i64, i64 } %268(ptr nocapture nofree nonnull readonly align 8 %231) #44
  %269 = extractvalue { i64, i64 } %result.i.i38.i349, 1
  %270 = urem i64 20, %269
  %271 = icmp eq i64 %270, 0
  %reass.sub1584 = sub i64 %269, %270
  %272 = add i64 %reass.sub1584, 20
  %273 = select i1 %271, i64 20, i64 %272
  %274 = getelementptr i8, ptr %result.i9.i348, i64 %273
  %275 = getelementptr i8, ptr %266, i64 64
  %276 = load ptr, ptr %275, align 8
  call void %276({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %231, ptr nocapture nofree writeonly %274) #45
  %277 = load ptr, ptr %result.i9.i348, align 8
  %278 = load ptr, ptr %277, align 8
  %279 = getelementptr i8, ptr %278, i64 72
  %280 = load ptr, ptr %279, align 8
  %result.i1.i39.i351 = call { i64, i64 } %280(ptr nocapture nofree nonnull readonly align 8 %277) #44
  %281 = extractvalue { i64, i64 } %result.i1.i39.i351, 0
  %282 = extractvalue { i64, i64 } %result.i1.i39.i351, 1
  %283 = urem i64 20, %282
  %284 = icmp eq i64 %283, 0
  %285 = sub i64 %282, %283
  %286 = select i1 %284, i64 0, i64 %285
  %287 = add i64 %281, 20
  %288 = add i64 %287, %286
  %289 = load ptr, ptr %263, align 8
  %290 = load ptr, ptr %289, align 8
  %291 = getelementptr i8, ptr %290, i64 72
  %292 = load ptr, ptr %291, align 8
  %result.i.i40.i352 = call { i64, i64 } %292(ptr nocapture nofree nonnull readonly align 8 %289) #44
  %293 = extractvalue { i64, i64 } %result.i.i40.i352, 1
  %294 = urem i64 %288, %293
  %295 = icmp eq i64 %294, 0
  %296 = sub i64 %293, %294
  %297 = select i1 %295, i64 0, i64 %296
  %298 = getelementptr i8, ptr %result.i9.i348, i64 %288
  %299 = getelementptr i8, ptr %298, i64 %297
  %300 = getelementptr i8, ptr %290, i64 64
  %301 = load ptr, ptr %300, align 8
  call void %301({ ptr, i160 } %63, ptr nocapture nofree nonnull readonly align 8 %289, ptr nocapture nofree writeonly %299) #45
  %302 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %303 = getelementptr inbounds i8, ptr %result.i9.i348, i64 16
  store i32 %65, ptr %303, align 8
  store ptr @Entry, ptr %202, align 8
  %304 = ptrtoint ptr %result.i9.i348 to i64
  store i64 %304, ptr %204, align 4
  %.sroa_idx30.i353 = getelementptr i8, ptr %202, i64 24
  store i32 10, ptr %.sroa_idx30.i353, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

305:                                              ; preds = %._crit_edge.i341, %207, %176
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %306 = load i32, ptr %54, align 4
  %307 = load i32, ptr %50, align 8
  %.not.i = icmp slt i32 %306, %307
  br i1 %.not.i, label %._crit_edge.i, label %308

308:                                              ; preds = %305
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %311 = load ptr, ptr %51, align 8
  %312 = load ptr, ptr %52, align 8
  %313 = shl i32 %307, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %313, i32 noundef 16) #40
  store i32 %spec.select.i, ptr %50, align 8
  %314 = zext nneg i32 %spec.select.i to i64
  %315 = shl nuw nsw i64 %314, 5
  %result.i5.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %315) #48
  store ptr %result.i5.i, ptr %51, align 8
  %result.i4.i370 = call noalias ptr @bump_malloc_wrapper(i64 noundef %315) #48
  store ptr %result.i4.i370, ptr %52, align 8
  store i32 0, ptr %54, align 4
  %316 = icmp sgt i32 %307, 0
  br i1 %316, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %308
  %wide.trip.count.i = zext nneg i32 %307 to i64
  br label %317

317:                                              ; preds = %._crit_edge.i757, %.lr.ph.i
  %indvars.iv.i756 = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i758, %._crit_edge.i757 ]
  %318 = shl nuw nsw i64 %indvars.iv.i756, 5
  %319 = getelementptr i8, ptr %311, i64 %318
  %320 = load ptr, ptr %319, align 8
  %321 = icmp ne ptr %320, @nil_typ
  %322 = icmp ne ptr %320, null
  %.not17.i = and i1 %321, %322
  br i1 %.not17.i, label %323, label %._crit_edge.i757

323:                                              ; preds = %317
  %324 = getelementptr i8, ptr %319, i64 8
  %325 = load i64, ptr %324, align 4
  %.sroa_idx.i760 = getelementptr i8, ptr %319, i64 16
  %326 = load i64, ptr %.sroa_idx.i760, align 4
  %hash_coef_ptr.i.i6.i = getelementptr i8, ptr %320, i64 8
  %tbl_size_ptr.i.i7.i = getelementptr i8, ptr %320, i64 16
  %offset_tbl_ptr.i.i8.i = getelementptr i8, ptr %320, i64 40
  %327 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i6.i, align 4, !noalias !23
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i7.i, align 4, !noalias !23
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i8.i, align 8, !noalias !23
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i29.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !23
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %330 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %331

331:                                              ; preds = %.cont.i1047, %323
  %.0290.i1029 = phi i32 [ 0, %323 ], [ %364, %.cont.i1047 ]
  %.074289.i1030 = phi i1 [ true, %323 ], [ %365, %.cont.i1047 ]
  %.sroa.0.0288.i1031 = phi ptr [ %320, %323 ], [ %354, %.cont.i1047 ]
  %.sroa.6.0287.i1032.in = phi i64 [ %325, %323 ], [ %356, %.cont.i1047 ]
  %.sroa.12.0286.i1033.in = phi i64 [ %326, %323 ], [ %357, %.cont.i1047 ]
  %.sroa.17.0285.i1034 = phi i32 [ %offset.i.i29.i, %323 ], [ %offset.i.i57.i1059, %.cont.i1047 ]
  %.sroa.12.0286.i1033 = inttoptr i64 %.sroa.12.0286.i1033.in to ptr
  %.sroa.6.0287.i1032 = inttoptr i64 %.sroa.6.0287.i1032.in to ptr
  %332 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1031, 0
  %333 = insertvalue { ptr, ptr, ptr, i32 } %332, ptr %.sroa.6.0287.i1032, 1
  %334 = insertvalue { ptr, ptr, ptr, i32 } %333, ptr %.sroa.12.0286.i1033, 2
  %335 = insertvalue { ptr, ptr, ptr, i32 } %334, i32 %.sroa.17.0285.i1034, 3
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1031)
  %337 = sext i32 %.sroa.17.0285.i1034 to i64
  %338 = getelementptr ptr, ptr %.sroa.0.0288.i1031, i64 %337
  %339 = getelementptr i8, ptr %338, i64 64
  %340 = load ptr, ptr %339, align 8
  %result.i15.i1035 = call ptr %340({ ptr, ptr, ptr, i32 } %335, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %341 = call i32 %result.i15.i1035({ ptr, ptr, ptr, i32 } %335, { ptr, ptr, ptr, i32 } %335, ptr nonnull align 8 %2) #53
  %..i1036 = select i1 %.074289.i1030, ptr %23, ptr %25
  %.188.i1037 = select i1 %.074289.i1030, i64 104, i64 112
  %.189.i1038 = select i1 %.074289.i1030, ptr %24, ptr %26
  %.190.i1039 = select i1 %.074289.i1030, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1036, align 8
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1036)
  %343 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1037
  %344 = load ptr, ptr %343, align 8
  store ptr @i32_typ, ptr %.189.i1038, align 8
  %result.i14.i1040 = call ptr %344({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1038) #46
  %345 = call i32 %result.i14.i1040({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1036, i32 %341) #53
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %347 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1039
  %348 = load ptr, ptr %347, align 8
  %349 = load ptr, ptr %348, align 8
  %350 = call { ptr } %349(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i1041 = extractvalue { ptr } %350, 0
  %351 = sext i32 %345 to i64
  %352 = shl nsw i64 %351, 5
  %353 = getelementptr i8, ptr %.fca.0.extract55.i1041, i64 %352
  %354 = load ptr, ptr %353, align 8
  %355 = getelementptr i8, ptr %353, i64 8
  %356 = load i64, ptr %355, align 4
  %.sroa_idx.i1042 = getelementptr i8, ptr %353, i64 16
  %357 = load i64, ptr %.sroa_idx.i1042, align 4
  %358 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %359 = call { ptr } %349(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i1043 = extractvalue { ptr } %359, 0
  %360 = getelementptr i8, ptr %.fca.0.extract52.i1043, i64 %352
  store ptr %.sroa.0.0288.i1031, ptr %360, align 8
  %361 = getelementptr i8, ptr %360, i64 8
  store i64 %.sroa.6.0287.i1032.in, ptr %361, align 4
  %.sroa_idx104.i1044 = getelementptr i8, ptr %360, i64 16
  store i64 %.sroa.12.0286.i1033.in, ptr %.sroa_idx104.i1044, align 4
  %.sroa_idx105.i1045 = getelementptr i8, ptr %360, i64 24
  store i32 %.sroa.17.0285.i1034, ptr %.sroa_idx105.i1045, align 4
  %362 = icmp ne ptr %354, @nil_typ
  %363 = icmp ne ptr %354, null
  %.not94.i1046 = and i1 %362, %363
  br i1 %.not94.i1046, label %.cont.i1047, label %368

.cont.i1047:                                      ; preds = %331
  %364 = add nuw nsw i32 %.0290.i1029, 1
  %365 = xor i1 %.074289.i1030, true
  %hash_coef_ptr.i.i46.i1048 = getelementptr i8, ptr %354, i64 8
  %tbl_size_ptr.i.i47.i1049 = getelementptr i8, ptr %354, i64 16
  %offset_tbl_ptr.i.i48.i1050 = getelementptr i8, ptr %354, i64 40
  %hash_coef.i.i49.i1051 = load i64, ptr %hash_coef_ptr.i.i46.i1048, align 4
  %tbl_size.i.i50.i1052 = load i64, ptr %tbl_size_ptr.i.i47.i1049, align 4
  %offset_tbl.i.i51.i1053 = load ptr, ptr %offset_tbl_ptr.i.i48.i1050, align 8
  %product.i.i.i52.i1054 = mul i64 %hash_coef.i.i49.i1051, 4015701072841558310
  %shifted.i.i.i53.i1055 = lshr i64 %product.i.i.i52.i1054, 32
  %xored.i.i.i54.i1056 = xor i64 %shifted.i.i.i53.i1055, %product.i.i.i52.i1054
  %hash.i.i.i55.i1057 = and i64 %xored.i.i.i54.i1056, %tbl_size.i.i50.i1052
  %offset_ptr.i.i56.i1058 = getelementptr i32, ptr %offset_tbl.i.i51.i1053, i64 %hash.i.i.i55.i1057
  %offset.i.i57.i1059 = load i32, ptr %offset_ptr.i.i56.i1058, align 4
  %366 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %367 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1060 = icmp eq i32 %364, 100
  br i1 %exitcond.not.i1060, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062, label %331

368:                                              ; preds = %331
  %369 = load i32, ptr %54, align 4
  %370 = add i32 %369, 1
  %371 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %370, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062: ; preds = %368, %.cont.i1047
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  br label %._crit_edge.i757

._crit_edge.i757:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062, %317
  %indvars.iv.next.i758 = add nuw nsw i64 %indvars.iv.i756, 1
  %exitcond.not.i759 = icmp eq i64 %indvars.iv.next.i758, %wide.trip.count.i
  br i1 %exitcond.not.i759, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit, label %317

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit: ; preds = %._crit_edge.i779, %._crit_edge.i757
  %indvars.iv.i777 = phi i64 [ %indvars.iv.next.i780, %._crit_edge.i779 ], [ 0, %._crit_edge.i757 ]
  %372 = shl nuw nsw i64 %indvars.iv.i777, 5
  %373 = getelementptr i8, ptr %312, i64 %372
  %374 = load ptr, ptr %373, align 8
  %375 = icmp ne ptr %374, @nil_typ
  %376 = icmp ne ptr %374, null
  %.not17.i778 = and i1 %375, %376
  br i1 %.not17.i778, label %377, label %._crit_edge.i779

377:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %378 = getelementptr i8, ptr %373, i64 8
  %379 = load i64, ptr %378, align 4
  %.sroa_idx.i782 = getelementptr i8, ptr %373, i64 16
  %380 = load i64, ptr %.sroa_idx.i782, align 4
  %hash_coef_ptr.i.i6.i783 = getelementptr i8, ptr %374, i64 8
  %tbl_size_ptr.i.i7.i784 = getelementptr i8, ptr %374, i64 16
  %offset_tbl_ptr.i.i8.i785 = getelementptr i8, ptr %374, i64 40
  %381 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  %hash_coef.i.i21.i1080 = load i64, ptr %hash_coef_ptr.i.i6.i783, align 4, !noalias !26
  %tbl_size.i.i22.i1081 = load i64, ptr %tbl_size_ptr.i.i7.i784, align 4, !noalias !26
  %offset_tbl.i.i23.i1082 = load ptr, ptr %offset_tbl_ptr.i.i8.i785, align 8, !noalias !26
  %product.i.i.i24.i1083 = mul i64 %hash_coef.i.i21.i1080, 4015701072841558310
  %shifted.i.i.i25.i1084 = lshr i64 %product.i.i.i24.i1083, 32
  %xored.i.i.i26.i1085 = xor i64 %shifted.i.i.i25.i1084, %product.i.i.i24.i1083
  %hash.i.i.i27.i1086 = and i64 %xored.i.i.i26.i1085, %tbl_size.i.i22.i1081
  %offset_ptr.i.i28.i1087 = getelementptr i32, ptr %offset_tbl.i.i23.i1082, i64 %hash.i.i.i27.i1086
  %offset.i.i29.i1088 = load i32, ptr %offset_ptr.i.i28.i1087, align 4, !noalias !26
  %382 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %383 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %384 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %385

385:                                              ; preds = %.cont.i1111, %377
  %.0290.i1089 = phi i32 [ 0, %377 ], [ %418, %.cont.i1111 ]
  %.074289.i1090 = phi i1 [ true, %377 ], [ %419, %.cont.i1111 ]
  %.sroa.0.0288.i1091 = phi ptr [ %374, %377 ], [ %408, %.cont.i1111 ]
  %.sroa.6.0287.i1092.in = phi i64 [ %379, %377 ], [ %410, %.cont.i1111 ]
  %.sroa.12.0286.i1093.in = phi i64 [ %380, %377 ], [ %411, %.cont.i1111 ]
  %.sroa.17.0285.i1094 = phi i32 [ %offset.i.i29.i1088, %377 ], [ %offset.i.i57.i1123, %.cont.i1111 ]
  %.sroa.12.0286.i1093 = inttoptr i64 %.sroa.12.0286.i1093.in to ptr
  %.sroa.6.0287.i1092 = inttoptr i64 %.sroa.6.0287.i1092.in to ptr
  %386 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1091, 0
  %387 = insertvalue { ptr, ptr, ptr, i32 } %386, ptr %.sroa.6.0287.i1092, 1
  %388 = insertvalue { ptr, ptr, ptr, i32 } %387, ptr %.sroa.12.0286.i1093, 2
  %389 = insertvalue { ptr, ptr, ptr, i32 } %388, i32 %.sroa.17.0285.i1094, 3
  %390 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1091)
  %391 = sext i32 %.sroa.17.0285.i1094 to i64
  %392 = getelementptr ptr, ptr %.sroa.0.0288.i1091, i64 %391
  %393 = getelementptr i8, ptr %392, i64 64
  %394 = load ptr, ptr %393, align 8
  %result.i15.i1095 = call ptr %394({ ptr, ptr, ptr, i32 } %389, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %395 = call i32 %result.i15.i1095({ ptr, ptr, ptr, i32 } %389, { ptr, ptr, ptr, i32 } %389, ptr nonnull align 8 %2) #53
  %..i1096 = select i1 %.074289.i1090, ptr %19, ptr %21
  %.188.i1097 = select i1 %.074289.i1090, i64 104, i64 112
  %.189.i1098 = select i1 %.074289.i1090, ptr %20, ptr %22
  %.190.i1099 = select i1 %.074289.i1090, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1096, align 8
  %396 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1096)
  %397 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1097
  %398 = load ptr, ptr %397, align 8
  store ptr @i32_typ, ptr %.189.i1098, align 8
  %result.i14.i1100 = call ptr %398({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1098) #46
  %399 = call i32 %result.i14.i1100({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1096, i32 %395) #53
  %400 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %401 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1099
  %402 = load ptr, ptr %401, align 8
  %403 = load ptr, ptr %402, align 8
  %404 = call { ptr } %403(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i1101 = extractvalue { ptr } %404, 0
  %405 = sext i32 %399 to i64
  %406 = shl nsw i64 %405, 5
  %407 = getelementptr i8, ptr %.fca.0.extract55.i1101, i64 %406
  %408 = load ptr, ptr %407, align 8
  %409 = getelementptr i8, ptr %407, i64 8
  %410 = load i64, ptr %409, align 4
  %.sroa_idx.i1102 = getelementptr i8, ptr %407, i64 16
  %411 = load i64, ptr %.sroa_idx.i1102, align 4
  %412 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %413 = call { ptr } %403(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i1103 = extractvalue { ptr } %413, 0
  %414 = getelementptr i8, ptr %.fca.0.extract52.i1103, i64 %406
  store ptr %.sroa.0.0288.i1091, ptr %414, align 8
  %415 = getelementptr i8, ptr %414, i64 8
  store i64 %.sroa.6.0287.i1092.in, ptr %415, align 4
  %.sroa_idx104.i1104 = getelementptr i8, ptr %414, i64 16
  store i64 %.sroa.12.0286.i1093.in, ptr %.sroa_idx104.i1104, align 4
  %.sroa_idx105.i1105 = getelementptr i8, ptr %414, i64 24
  store i32 %.sroa.17.0285.i1094, ptr %.sroa_idx105.i1105, align 4
  %416 = icmp ne ptr %408, @nil_typ
  %417 = icmp ne ptr %408, null
  %.not94.i1106 = and i1 %416, %417
  br i1 %.not94.i1106, label %.cont.i1111, label %422

.cont.i1111:                                      ; preds = %385
  %418 = add nuw nsw i32 %.0290.i1089, 1
  %419 = xor i1 %.074289.i1090, true
  %hash_coef_ptr.i.i46.i1112 = getelementptr i8, ptr %408, i64 8
  %tbl_size_ptr.i.i47.i1113 = getelementptr i8, ptr %408, i64 16
  %offset_tbl_ptr.i.i48.i1114 = getelementptr i8, ptr %408, i64 40
  %hash_coef.i.i49.i1115 = load i64, ptr %hash_coef_ptr.i.i46.i1112, align 4
  %tbl_size.i.i50.i1116 = load i64, ptr %tbl_size_ptr.i.i47.i1113, align 4
  %offset_tbl.i.i51.i1117 = load ptr, ptr %offset_tbl_ptr.i.i48.i1114, align 8
  %product.i.i.i52.i1118 = mul i64 %hash_coef.i.i49.i1115, 4015701072841558310
  %shifted.i.i.i53.i1119 = lshr i64 %product.i.i.i52.i1118, 32
  %xored.i.i.i54.i1120 = xor i64 %shifted.i.i.i53.i1119, %product.i.i.i52.i1118
  %hash.i.i.i55.i1121 = and i64 %xored.i.i.i54.i1120, %tbl_size.i.i50.i1116
  %offset_ptr.i.i56.i1122 = getelementptr i32, ptr %offset_tbl.i.i51.i1117, i64 %hash.i.i.i55.i1121
  %offset.i.i57.i1123 = load i32, ptr %offset_ptr.i.i56.i1122, align 4
  %420 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %421 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1124 = icmp eq i32 %418, 100
  br i1 %exitcond.not.i1124, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133, label %385

422:                                              ; preds = %385
  %423 = load i32, ptr %54, align 4
  %424 = add i32 %423, 1
  %425 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %424, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133: ; preds = %422, %.cont.i1111
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  br label %._crit_edge.i779

._crit_edge.i779:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %indvars.iv.next.i780 = add nuw nsw i64 %indvars.iv.i777, 1
  %exitcond.not.i781 = icmp eq i64 %indvars.iv.next.i780, %wide.trip.count.i
  br i1 %exitcond.not.i781, label %._crit_edge.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit

._crit_edge.i:                                    ; preds = %._crit_edge.i779, %308, %305
  %426 = load ptr, ptr %result.i31, align 8
  %427 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %428 = load ptr, ptr %43, align 8
  %429 = load ptr, ptr %426, align 8
  %430 = getelementptr i8, ptr %429, i64 72
  %431 = load ptr, ptr %430, align 8
  %result.i1.i.i90 = call { i64, i64 } %431(ptr nocapture nofree nonnull readonly align 8 %426) #44
  %432 = extractvalue { i64, i64 } %result.i1.i.i90, 0
  %433 = extractvalue { i64, i64 } %result.i1.i.i90, 1
  %434 = urem i64 20, %433
  %435 = icmp eq i64 %434, 0
  %436 = sub i64 %433, %434
  %437 = select i1 %435, i64 0, i64 %436
  %438 = add i64 %432, 20
  %439 = add i64 %438, %437
  %440 = load ptr, ptr %428, align 8
  %441 = getelementptr i8, ptr %440, i64 72
  %442 = load ptr, ptr %441, align 8
  %result.i.i.i91 = call { i64, i64 } %442(ptr nocapture nofree nonnull readonly align 8 %428) #44
  %443 = extractvalue { i64, i64 } %result.i.i.i91, 0
  %444 = extractvalue { i64, i64 } %result.i.i.i91, 1
  %445 = call i64 @llvm.umax.i64(i64 %433, i64 %444) #41
  %446 = call i64 @llvm.umax.i64(i64 %445, i64 noundef 8) #41, !range !16
  %447 = urem i64 %439, %444
  %448 = icmp eq i64 %447, 0
  %449 = sub i64 %444, %447
  %450 = select i1 %448, i64 0, i64 %449
  %451 = add i64 %443, %439
  %452 = add i64 %451, %450
  %453 = urem i64 %452, %446
  %454 = icmp eq i64 %453, 0
  %455 = sub i64 %446, %453
  %456 = select i1 %454, i64 0, i64 %455
  %457 = add i64 %456, %452
  %result.i22.i92 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %457) #48
  store ptr %426, ptr %result.i22.i92, align 8
  %458 = getelementptr inbounds i8, ptr %result.i22.i92, i64 8
  store ptr %428, ptr %458, align 8
  %459 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i92)
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %461 = load ptr, ptr %426, align 8
  %462 = getelementptr i8, ptr %461, i64 72
  %463 = load ptr, ptr %462, align 8
  %result.i.i127.i = call { i64, i64 } %463(ptr nocapture nofree nonnull readonly align 8 %426) #44
  %464 = extractvalue { i64, i64 } %result.i.i127.i, 1
  %465 = urem i64 20, %464
  %466 = icmp eq i64 %465, 0
  %reass.sub1583 = sub i64 %464, %465
  %467 = add i64 %reass.sub1583, 20
  %468 = select i1 %466, i64 20, i64 %467
  %469 = getelementptr i8, ptr %result.i22.i92, i64 %468
  %470 = getelementptr i8, ptr %461, i64 64
  %471 = load ptr, ptr %470, align 8
  call void %471({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %426, ptr nocapture nofree writeonly %469) #45
  %472 = load ptr, ptr %result.i22.i92, align 8
  %473 = load ptr, ptr %472, align 8
  %474 = getelementptr i8, ptr %473, i64 72
  %475 = load ptr, ptr %474, align 8
  %result.i1.i128.i = call { i64, i64 } %475(ptr nocapture nofree nonnull readonly align 8 %472) #44
  %476 = extractvalue { i64, i64 } %result.i1.i128.i, 0
  %477 = extractvalue { i64, i64 } %result.i1.i128.i, 1
  %478 = urem i64 20, %477
  %479 = icmp eq i64 %478, 0
  %480 = sub i64 %477, %478
  %481 = select i1 %479, i64 0, i64 %480
  %482 = add i64 %476, 20
  %483 = add i64 %482, %481
  %484 = load ptr, ptr %458, align 8
  %485 = load ptr, ptr %484, align 8
  %486 = getelementptr i8, ptr %485, i64 72
  %487 = load ptr, ptr %486, align 8
  %result.i.i129.i = call { i64, i64 } %487(ptr nocapture nofree nonnull readonly align 8 %484) #44
  %488 = extractvalue { i64, i64 } %result.i.i129.i, 1
  %489 = urem i64 %483, %488
  %490 = icmp eq i64 %489, 0
  %491 = sub i64 %488, %489
  %492 = select i1 %490, i64 0, i64 %491
  %493 = getelementptr i8, ptr %result.i22.i92, i64 %483
  %494 = getelementptr i8, ptr %493, i64 %492
  %495 = getelementptr i8, ptr %485, i64 64
  %496 = load ptr, ptr %495, align 8
  call void %496({ ptr, i160 } %63, ptr nocapture nofree nonnull readonly align 8 %484, ptr nocapture nofree writeonly %494) #45
  %497 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %498 = getelementptr inbounds i8, ptr %result.i22.i92, i64 16
  store i32 %65, ptr %498, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %499 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %500 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %502

502:                                              ; preds = %.cont.i, %._crit_edge.i
  %.0290.i = phi i32 [ 0, %._crit_edge.i ], [ %537, %.cont.i ]
  %.074289.i = phi i1 [ true, %._crit_edge.i ], [ %538, %.cont.i ]
  %.sroa.0.0288.i = phi ptr [ @Entry, %._crit_edge.i ], [ %525, %.cont.i ]
  %.sroa.6.0287.i = phi ptr [ %result.i22.i92, %._crit_edge.i ], [ %539, %.cont.i ]
  %.sroa.12.0286.i = phi ptr [ undef, %._crit_edge.i ], [ %540, %.cont.i ]
  %.sroa.17.0285.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i57.i, %.cont.i ]
  %503 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i, 0
  %504 = insertvalue { ptr, ptr, ptr, i32 } %503, ptr %.sroa.6.0287.i, 1
  %505 = insertvalue { ptr, ptr, ptr, i32 } %504, ptr %.sroa.12.0286.i, 2
  %506 = insertvalue { ptr, ptr, ptr, i32 } %505, i32 %.sroa.17.0285.i, 3
  %507 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i)
  %508 = sext i32 %.sroa.17.0285.i to i64
  %509 = getelementptr ptr, ptr %.sroa.0.0288.i, i64 %508
  %510 = getelementptr i8, ptr %509, i64 64
  %511 = load ptr, ptr %510, align 8
  %result.i15.i = call ptr %511({ ptr, ptr, ptr, i32 } %506, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %512 = call i32 %result.i15.i({ ptr, ptr, ptr, i32 } %506, { ptr, ptr, ptr, i32 } %506, ptr nonnull align 8 %2) #53
  %..i = select i1 %.074289.i, ptr %31, ptr %33
  %.188.i = select i1 %.074289.i, i64 104, i64 112
  %.189.i = select i1 %.074289.i, ptr %32, ptr %34
  %.190.i = select i1 %.074289.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i, align 8
  %513 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i)
  %514 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i
  %515 = load ptr, ptr %514, align 8
  store ptr @i32_typ, ptr %.189.i, align 8
  %result.i14.i = call ptr %515({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i) #46
  %516 = call i32 %result.i14.i({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 dereferenceable(8) %..i, i32 %512) #53
  %517 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %518 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i
  %519 = load ptr, ptr %518, align 8
  %520 = load ptr, ptr %519, align 8
  %521 = call { ptr } %520(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i = extractvalue { ptr } %521, 0
  %522 = sext i32 %516 to i64
  %523 = shl nsw i64 %522, 5
  %524 = getelementptr i8, ptr %.fca.0.extract55.i, i64 %523
  %525 = load ptr, ptr %524, align 8
  %526 = getelementptr i8, ptr %524, i64 8
  %527 = load i64, ptr %526, align 4
  %.sroa_idx.i389 = getelementptr i8, ptr %524, i64 16
  %528 = load i64, ptr %.sroa_idx.i389, align 4
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %530 = call { ptr } %520(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i = extractvalue { ptr } %530, 0
  %531 = getelementptr i8, ptr %.fca.0.extract52.i, i64 %523
  store ptr %.sroa.0.0288.i, ptr %531, align 8
  %532 = getelementptr i8, ptr %531, i64 8
  %533 = ptrtoint ptr %.sroa.6.0287.i to i64
  %534 = ptrtoint ptr %.sroa.12.0286.i to i64
  store i64 %533, ptr %532, align 4
  %.sroa_idx104.i = getelementptr i8, ptr %531, i64 16
  store i64 %534, ptr %.sroa_idx104.i, align 4
  %.sroa_idx105.i = getelementptr i8, ptr %531, i64 24
  store i32 %.sroa.17.0285.i, ptr %.sroa_idx105.i, align 4
  %535 = icmp ne ptr %525, @nil_typ
  %536 = icmp ne ptr %525, null
  %.not94.i = and i1 %535, %536
  br i1 %.not94.i, label %.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

.cont.i:                                          ; preds = %502
  %537 = add nuw nsw i32 %.0290.i, 1
  %538 = xor i1 %.074289.i, true
  %539 = inttoptr i64 %527 to ptr
  %540 = inttoptr i64 %528 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %525, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %525, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %525, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %542 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i = icmp eq i32 %537, 100
  br i1 %exitcond.not.i, label %546, label %502

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %502
  %543 = load i32, ptr %54, align 4
  %544 = add i32 %543, 1
  %545 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %544, ptr %54, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  br label %CuckooMap_insert_keyK_valueV.exit

546:                                              ; preds = %.cont.i
  %hash_coef_ptr.i.i46.i.le = getelementptr i8, ptr %525, i64 8
  %tbl_size_ptr.i.i47.i.le = getelementptr i8, ptr %525, i64 16
  %offset_tbl_ptr.i.i48.i.le = getelementptr i8, ptr %525, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %548 = load ptr, ptr %51, align 8
  %549 = load ptr, ptr %52, align 8
  %550 = load i32, ptr %50, align 8
  %551 = shl i32 %550, 1
  %spec.select.i407 = call i32 @llvm.smax.i32(i32 %551, i32 noundef 16) #40
  store i32 %spec.select.i407, ptr %50, align 8
  %552 = zext nneg i32 %spec.select.i407 to i64
  %553 = shl nuw nsw i64 %552, 5
  %result.i5.i408 = call noalias ptr @bump_malloc_wrapper(i64 noundef %553) #48
  store ptr %result.i5.i408, ptr %51, align 8
  %result.i4.i409 = call noalias ptr @bump_malloc_wrapper(i64 noundef %553) #48
  store ptr %result.i4.i409, ptr %52, align 8
  store i32 0, ptr %54, align 4
  %554 = icmp sgt i32 %550, 0
  br i1 %554, label %.lr.ph.i801, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875

.lr.ph.i801:                                      ; preds = %546
  %wide.trip.count.i814 = zext nneg i32 %550 to i64
  br label %555

555:                                              ; preds = %._crit_edge.i817, %.lr.ph.i801
  %indvars.iv.i815 = phi i64 [ 0, %.lr.ph.i801 ], [ %indvars.iv.next.i818, %._crit_edge.i817 ]
  %556 = shl nuw nsw i64 %indvars.iv.i815, 5
  %557 = getelementptr i8, ptr %548, i64 %556
  %558 = load ptr, ptr %557, align 8
  %559 = icmp ne ptr %558, @nil_typ
  %560 = icmp ne ptr %558, null
  %.not17.i816 = and i1 %559, %560
  br i1 %.not17.i816, label %561, label %._crit_edge.i817

561:                                              ; preds = %555
  %562 = getelementptr i8, ptr %557, i64 8
  %563 = load i64, ptr %562, align 4
  %.sroa_idx.i820 = getelementptr i8, ptr %557, i64 16
  %564 = load i64, ptr %.sroa_idx.i820, align 4
  %hash_coef_ptr.i.i6.i821 = getelementptr i8, ptr %558, i64 8
  %tbl_size_ptr.i.i7.i822 = getelementptr i8, ptr %558, i64 16
  %offset_tbl_ptr.i.i8.i823 = getelementptr i8, ptr %558, i64 40
  %565 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  %hash_coef.i.i21.i1151 = load i64, ptr %hash_coef_ptr.i.i6.i821, align 4, !noalias !29
  %tbl_size.i.i22.i1152 = load i64, ptr %tbl_size_ptr.i.i7.i822, align 4, !noalias !29
  %offset_tbl.i.i23.i1153 = load ptr, ptr %offset_tbl_ptr.i.i8.i823, align 8, !noalias !29
  %product.i.i.i24.i1154 = mul i64 %hash_coef.i.i21.i1151, 4015701072841558310
  %shifted.i.i.i25.i1155 = lshr i64 %product.i.i.i24.i1154, 32
  %xored.i.i.i26.i1156 = xor i64 %shifted.i.i.i25.i1155, %product.i.i.i24.i1154
  %hash.i.i.i27.i1157 = and i64 %xored.i.i.i26.i1156, %tbl_size.i.i22.i1152
  %offset_ptr.i.i28.i1158 = getelementptr i32, ptr %offset_tbl.i.i23.i1153, i64 %hash.i.i.i27.i1157
  %offset.i.i29.i1159 = load i32, ptr %offset_ptr.i.i28.i1158, align 4, !noalias !29
  %566 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %568 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %569

569:                                              ; preds = %.cont.i1182, %561
  %.0290.i1160 = phi i32 [ 0, %561 ], [ %602, %.cont.i1182 ]
  %.074289.i1161 = phi i1 [ true, %561 ], [ %603, %.cont.i1182 ]
  %.sroa.0.0288.i1162 = phi ptr [ %558, %561 ], [ %592, %.cont.i1182 ]
  %.sroa.6.0287.i1163.in = phi i64 [ %563, %561 ], [ %594, %.cont.i1182 ]
  %.sroa.12.0286.i1164.in = phi i64 [ %564, %561 ], [ %595, %.cont.i1182 ]
  %.sroa.17.0285.i1165 = phi i32 [ %offset.i.i29.i1159, %561 ], [ %offset.i.i57.i1194, %.cont.i1182 ]
  %.sroa.12.0286.i1164 = inttoptr i64 %.sroa.12.0286.i1164.in to ptr
  %.sroa.6.0287.i1163 = inttoptr i64 %.sroa.6.0287.i1163.in to ptr
  %570 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1162, 0
  %571 = insertvalue { ptr, ptr, ptr, i32 } %570, ptr %.sroa.6.0287.i1163, 1
  %572 = insertvalue { ptr, ptr, ptr, i32 } %571, ptr %.sroa.12.0286.i1164, 2
  %573 = insertvalue { ptr, ptr, ptr, i32 } %572, i32 %.sroa.17.0285.i1165, 3
  %574 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1162)
  %575 = sext i32 %.sroa.17.0285.i1165 to i64
  %576 = getelementptr ptr, ptr %.sroa.0.0288.i1162, i64 %575
  %577 = getelementptr i8, ptr %576, i64 64
  %578 = load ptr, ptr %577, align 8
  %result.i15.i1166 = call ptr %578({ ptr, ptr, ptr, i32 } %573, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %579 = call i32 %result.i15.i1166({ ptr, ptr, ptr, i32 } %573, { ptr, ptr, ptr, i32 } %573, ptr nonnull align 8 %2) #53
  %..i1167 = select i1 %.074289.i1161, ptr %15, ptr %17
  %.188.i1168 = select i1 %.074289.i1161, i64 104, i64 112
  %.189.i1169 = select i1 %.074289.i1161, ptr %16, ptr %18
  %.190.i1170 = select i1 %.074289.i1161, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1167, align 8
  %580 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1167)
  %581 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1168
  %582 = load ptr, ptr %581, align 8
  store ptr @i32_typ, ptr %.189.i1169, align 8
  %result.i14.i1171 = call ptr %582({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1169) #46
  %583 = call i32 %result.i14.i1171({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1167, i32 %579) #53
  %584 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %585 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1170
  %586 = load ptr, ptr %585, align 8
  %587 = load ptr, ptr %586, align 8
  %588 = call { ptr } %587(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i1172 = extractvalue { ptr } %588, 0
  %589 = sext i32 %583 to i64
  %590 = shl nsw i64 %589, 5
  %591 = getelementptr i8, ptr %.fca.0.extract55.i1172, i64 %590
  %592 = load ptr, ptr %591, align 8
  %593 = getelementptr i8, ptr %591, i64 8
  %594 = load i64, ptr %593, align 4
  %.sroa_idx.i1173 = getelementptr i8, ptr %591, i64 16
  %595 = load i64, ptr %.sroa_idx.i1173, align 4
  %596 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %597 = call { ptr } %587(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i1174 = extractvalue { ptr } %597, 0
  %598 = getelementptr i8, ptr %.fca.0.extract52.i1174, i64 %590
  store ptr %.sroa.0.0288.i1162, ptr %598, align 8
  %599 = getelementptr i8, ptr %598, i64 8
  store i64 %.sroa.6.0287.i1163.in, ptr %599, align 4
  %.sroa_idx104.i1175 = getelementptr i8, ptr %598, i64 16
  store i64 %.sroa.12.0286.i1164.in, ptr %.sroa_idx104.i1175, align 4
  %.sroa_idx105.i1176 = getelementptr i8, ptr %598, i64 24
  store i32 %.sroa.17.0285.i1165, ptr %.sroa_idx105.i1176, align 4
  %600 = icmp ne ptr %592, @nil_typ
  %601 = icmp ne ptr %592, null
  %.not94.i1177 = and i1 %600, %601
  br i1 %.not94.i1177, label %.cont.i1182, label %606

.cont.i1182:                                      ; preds = %569
  %602 = add nuw nsw i32 %.0290.i1160, 1
  %603 = xor i1 %.074289.i1161, true
  %hash_coef_ptr.i.i46.i1183 = getelementptr i8, ptr %592, i64 8
  %tbl_size_ptr.i.i47.i1184 = getelementptr i8, ptr %592, i64 16
  %offset_tbl_ptr.i.i48.i1185 = getelementptr i8, ptr %592, i64 40
  %hash_coef.i.i49.i1186 = load i64, ptr %hash_coef_ptr.i.i46.i1183, align 4
  %tbl_size.i.i50.i1187 = load i64, ptr %tbl_size_ptr.i.i47.i1184, align 4
  %offset_tbl.i.i51.i1188 = load ptr, ptr %offset_tbl_ptr.i.i48.i1185, align 8
  %product.i.i.i52.i1189 = mul i64 %hash_coef.i.i49.i1186, 4015701072841558310
  %shifted.i.i.i53.i1190 = lshr i64 %product.i.i.i52.i1189, 32
  %xored.i.i.i54.i1191 = xor i64 %shifted.i.i.i53.i1190, %product.i.i.i52.i1189
  %hash.i.i.i55.i1192 = and i64 %xored.i.i.i54.i1191, %tbl_size.i.i50.i1187
  %offset_ptr.i.i56.i1193 = getelementptr i32, ptr %offset_tbl.i.i51.i1188, i64 %hash.i.i.i55.i1192
  %offset.i.i57.i1194 = load i32, ptr %offset_ptr.i.i56.i1193, align 4
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %605 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1195 = icmp eq i32 %602, 100
  br i1 %exitcond.not.i1195, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204, label %569

606:                                              ; preds = %569
  %607 = load i32, ptr %54, align 4
  %608 = add i32 %607, 1
  %609 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %608, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204: ; preds = %606, %.cont.i1182
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  br label %._crit_edge.i817

._crit_edge.i817:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204, %555
  %indvars.iv.next.i818 = add nuw nsw i64 %indvars.iv.i815, 1
  %exitcond.not.i819 = icmp eq i64 %indvars.iv.next.i818, %wide.trip.count.i814
  br i1 %exitcond.not.i819, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837, label %555

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837: ; preds = %._crit_edge.i855, %._crit_edge.i817
  %indvars.iv.i853 = phi i64 [ %indvars.iv.next.i856, %._crit_edge.i855 ], [ 0, %._crit_edge.i817 ]
  %610 = shl nuw nsw i64 %indvars.iv.i853, 5
  %611 = getelementptr i8, ptr %549, i64 %610
  %612 = load ptr, ptr %611, align 8
  %613 = icmp ne ptr %612, @nil_typ
  %614 = icmp ne ptr %612, null
  %.not17.i854 = and i1 %613, %614
  br i1 %.not17.i854, label %615, label %._crit_edge.i855

615:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837
  %616 = getelementptr i8, ptr %611, i64 8
  %617 = load i64, ptr %616, align 4
  %.sroa_idx.i858 = getelementptr i8, ptr %611, i64 16
  %618 = load i64, ptr %.sroa_idx.i858, align 4
  %hash_coef_ptr.i.i6.i859 = getelementptr i8, ptr %612, i64 8
  %tbl_size_ptr.i.i7.i860 = getelementptr i8, ptr %612, i64 16
  %offset_tbl_ptr.i.i8.i861 = getelementptr i8, ptr %612, i64 40
  %619 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %hash_coef.i.i21.i1222 = load i64, ptr %hash_coef_ptr.i.i6.i859, align 4, !noalias !32
  %tbl_size.i.i22.i1223 = load i64, ptr %tbl_size_ptr.i.i7.i860, align 4, !noalias !32
  %offset_tbl.i.i23.i1224 = load ptr, ptr %offset_tbl_ptr.i.i8.i861, align 8, !noalias !32
  %product.i.i.i24.i1225 = mul i64 %hash_coef.i.i21.i1222, 4015701072841558310
  %shifted.i.i.i25.i1226 = lshr i64 %product.i.i.i24.i1225, 32
  %xored.i.i.i26.i1227 = xor i64 %shifted.i.i.i25.i1226, %product.i.i.i24.i1225
  %hash.i.i.i27.i1228 = and i64 %xored.i.i.i26.i1227, %tbl_size.i.i22.i1223
  %offset_ptr.i.i28.i1229 = getelementptr i32, ptr %offset_tbl.i.i23.i1224, i64 %hash.i.i.i27.i1228
  %offset.i.i29.i1230 = load i32, ptr %offset_ptr.i.i28.i1229, align 4, !noalias !32
  %620 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %621 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %622 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %623

623:                                              ; preds = %.cont.i1253, %615
  %.0290.i1231 = phi i32 [ 0, %615 ], [ %656, %.cont.i1253 ]
  %.074289.i1232 = phi i1 [ true, %615 ], [ %657, %.cont.i1253 ]
  %.sroa.0.0288.i1233 = phi ptr [ %612, %615 ], [ %646, %.cont.i1253 ]
  %.sroa.6.0287.i1234.in = phi i64 [ %617, %615 ], [ %648, %.cont.i1253 ]
  %.sroa.12.0286.i1235.in = phi i64 [ %618, %615 ], [ %649, %.cont.i1253 ]
  %.sroa.17.0285.i1236 = phi i32 [ %offset.i.i29.i1230, %615 ], [ %offset.i.i57.i1265, %.cont.i1253 ]
  %.sroa.12.0286.i1235 = inttoptr i64 %.sroa.12.0286.i1235.in to ptr
  %.sroa.6.0287.i1234 = inttoptr i64 %.sroa.6.0287.i1234.in to ptr
  %624 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1233, 0
  %625 = insertvalue { ptr, ptr, ptr, i32 } %624, ptr %.sroa.6.0287.i1234, 1
  %626 = insertvalue { ptr, ptr, ptr, i32 } %625, ptr %.sroa.12.0286.i1235, 2
  %627 = insertvalue { ptr, ptr, ptr, i32 } %626, i32 %.sroa.17.0285.i1236, 3
  %628 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1233)
  %629 = sext i32 %.sroa.17.0285.i1236 to i64
  %630 = getelementptr ptr, ptr %.sroa.0.0288.i1233, i64 %629
  %631 = getelementptr i8, ptr %630, i64 64
  %632 = load ptr, ptr %631, align 8
  %result.i15.i1237 = call ptr %632({ ptr, ptr, ptr, i32 } %627, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %633 = call i32 %result.i15.i1237({ ptr, ptr, ptr, i32 } %627, { ptr, ptr, ptr, i32 } %627, ptr nonnull align 8 %2) #53
  %..i1238 = select i1 %.074289.i1232, ptr %11, ptr %13
  %.188.i1239 = select i1 %.074289.i1232, i64 104, i64 112
  %.189.i1240 = select i1 %.074289.i1232, ptr %12, ptr %14
  %.190.i1241 = select i1 %.074289.i1232, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1238, align 8
  %634 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1238)
  %635 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1239
  %636 = load ptr, ptr %635, align 8
  store ptr @i32_typ, ptr %.189.i1240, align 8
  %result.i14.i1242 = call ptr %636({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1240) #46
  %637 = call i32 %result.i14.i1242({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1238, i32 %633) #53
  %638 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %639 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1241
  %640 = load ptr, ptr %639, align 8
  %641 = load ptr, ptr %640, align 8
  %642 = call { ptr } %641(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i1243 = extractvalue { ptr } %642, 0
  %643 = sext i32 %637 to i64
  %644 = shl nsw i64 %643, 5
  %645 = getelementptr i8, ptr %.fca.0.extract55.i1243, i64 %644
  %646 = load ptr, ptr %645, align 8
  %647 = getelementptr i8, ptr %645, i64 8
  %648 = load i64, ptr %647, align 4
  %.sroa_idx.i1244 = getelementptr i8, ptr %645, i64 16
  %649 = load i64, ptr %.sroa_idx.i1244, align 4
  %650 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %651 = call { ptr } %641(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i1245 = extractvalue { ptr } %651, 0
  %652 = getelementptr i8, ptr %.fca.0.extract52.i1245, i64 %644
  store ptr %.sroa.0.0288.i1233, ptr %652, align 8
  %653 = getelementptr i8, ptr %652, i64 8
  store i64 %.sroa.6.0287.i1234.in, ptr %653, align 4
  %.sroa_idx104.i1246 = getelementptr i8, ptr %652, i64 16
  store i64 %.sroa.12.0286.i1235.in, ptr %.sroa_idx104.i1246, align 4
  %.sroa_idx105.i1247 = getelementptr i8, ptr %652, i64 24
  store i32 %.sroa.17.0285.i1236, ptr %.sroa_idx105.i1247, align 4
  %654 = icmp ne ptr %646, @nil_typ
  %655 = icmp ne ptr %646, null
  %.not94.i1248 = and i1 %654, %655
  br i1 %.not94.i1248, label %.cont.i1253, label %660

.cont.i1253:                                      ; preds = %623
  %656 = add nuw nsw i32 %.0290.i1231, 1
  %657 = xor i1 %.074289.i1232, true
  %hash_coef_ptr.i.i46.i1254 = getelementptr i8, ptr %646, i64 8
  %tbl_size_ptr.i.i47.i1255 = getelementptr i8, ptr %646, i64 16
  %offset_tbl_ptr.i.i48.i1256 = getelementptr i8, ptr %646, i64 40
  %hash_coef.i.i49.i1257 = load i64, ptr %hash_coef_ptr.i.i46.i1254, align 4
  %tbl_size.i.i50.i1258 = load i64, ptr %tbl_size_ptr.i.i47.i1255, align 4
  %offset_tbl.i.i51.i1259 = load ptr, ptr %offset_tbl_ptr.i.i48.i1256, align 8
  %product.i.i.i52.i1260 = mul i64 %hash_coef.i.i49.i1257, 4015701072841558310
  %shifted.i.i.i53.i1261 = lshr i64 %product.i.i.i52.i1260, 32
  %xored.i.i.i54.i1262 = xor i64 %shifted.i.i.i53.i1261, %product.i.i.i52.i1260
  %hash.i.i.i55.i1263 = and i64 %xored.i.i.i54.i1262, %tbl_size.i.i50.i1258
  %offset_ptr.i.i56.i1264 = getelementptr i32, ptr %offset_tbl.i.i51.i1259, i64 %hash.i.i.i55.i1263
  %offset.i.i57.i1265 = load i32, ptr %offset_ptr.i.i56.i1264, align 4
  %658 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1266 = icmp eq i32 %656, 100
  br i1 %exitcond.not.i1266, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275, label %623

660:                                              ; preds = %623
  %661 = load i32, ptr %54, align 4
  %662 = add i32 %661, 1
  %663 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %662, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275: ; preds = %660, %.cont.i1253
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  br label %._crit_edge.i855

._crit_edge.i855:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837
  %indvars.iv.next.i856 = add nuw nsw i64 %indvars.iv.i853, 1
  %exitcond.not.i857 = icmp eq i64 %indvars.iv.next.i856, %wide.trip.count.i814
  br i1 %exitcond.not.i857, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875: ; preds = %._crit_edge.i855, %546
  %664 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %hash_coef.i.i21.i433 = load i64, ptr %hash_coef_ptr.i.i46.i.le, align 4, !noalias !35
  %tbl_size.i.i22.i434 = load i64, ptr %tbl_size_ptr.i.i47.i.le, align 4, !noalias !35
  %offset_tbl.i.i23.i435 = load ptr, ptr %offset_tbl_ptr.i.i48.i.le, align 8, !noalias !35
  %product.i.i.i24.i436 = mul i64 %hash_coef.i.i21.i433, 4015701072841558310
  %shifted.i.i.i25.i437 = lshr i64 %product.i.i.i24.i436, 32
  %xored.i.i.i26.i438 = xor i64 %shifted.i.i.i25.i437, %product.i.i.i24.i436
  %hash.i.i.i27.i439 = and i64 %xored.i.i.i26.i438, %tbl_size.i.i22.i434
  %offset_ptr.i.i28.i440 = getelementptr i32, ptr %offset_tbl.i.i23.i435, i64 %hash.i.i.i27.i439
  %offset.i.i29.i441 = load i32, ptr %offset_ptr.i.i28.i440, align 4, !noalias !35
  %665 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %667 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %668

668:                                              ; preds = %.cont.i465, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875
  %.0290.i443 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875 ], [ %701, %.cont.i465 ]
  %.074289.i444 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875 ], [ %702, %.cont.i465 ]
  %.sroa.0.0288.i445 = phi ptr [ %525, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875 ], [ %691, %.cont.i465 ]
  %.sroa.6.0287.i446.in = phi i64 [ %527, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875 ], [ %693, %.cont.i465 ]
  %.sroa.12.0286.i447.in = phi i64 [ %528, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875 ], [ %694, %.cont.i465 ]
  %.sroa.17.0285.i448 = phi i32 [ %offset.i.i29.i441, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875 ], [ %offset.i.i57.i477, %.cont.i465 ]
  %.sroa.12.0286.i447 = inttoptr i64 %.sroa.12.0286.i447.in to ptr
  %.sroa.6.0287.i446 = inttoptr i64 %.sroa.6.0287.i446.in to ptr
  %669 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i445, 0
  %670 = insertvalue { ptr, ptr, ptr, i32 } %669, ptr %.sroa.6.0287.i446, 1
  %671 = insertvalue { ptr, ptr, ptr, i32 } %670, ptr %.sroa.12.0286.i447, 2
  %672 = insertvalue { ptr, ptr, ptr, i32 } %671, i32 %.sroa.17.0285.i448, 3
  %673 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i445)
  %674 = sext i32 %.sroa.17.0285.i448 to i64
  %675 = getelementptr ptr, ptr %.sroa.0.0288.i445, i64 %674
  %676 = getelementptr i8, ptr %675, i64 64
  %677 = load ptr, ptr %676, align 8
  %result.i15.i449 = call ptr %677({ ptr, ptr, ptr, i32 } %672, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %678 = call i32 %result.i15.i449({ ptr, ptr, ptr, i32 } %672, { ptr, ptr, ptr, i32 } %672, ptr nonnull align 8 %2) #53
  %..i450 = select i1 %.074289.i444, ptr %27, ptr %29
  %.188.i451 = select i1 %.074289.i444, i64 104, i64 112
  %.189.i452 = select i1 %.074289.i444, ptr %28, ptr %30
  %.190.i453 = select i1 %.074289.i444, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i450, align 8
  %679 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i450)
  %680 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i451
  %681 = load ptr, ptr %680, align 8
  store ptr @i32_typ, ptr %.189.i452, align 8
  %result.i14.i454 = call ptr %681({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i452) #46
  %682 = call i32 %result.i14.i454({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 dereferenceable(8) %..i450, i32 %678) #53
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %684 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i453
  %685 = load ptr, ptr %684, align 8
  %686 = load ptr, ptr %685, align 8
  %687 = call { ptr } %686(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i455 = extractvalue { ptr } %687, 0
  %688 = sext i32 %682 to i64
  %689 = shl nsw i64 %688, 5
  %690 = getelementptr i8, ptr %.fca.0.extract55.i455, i64 %689
  %691 = load ptr, ptr %690, align 8
  %692 = getelementptr i8, ptr %690, i64 8
  %693 = load i64, ptr %692, align 4
  %.sroa_idx.i456 = getelementptr i8, ptr %690, i64 16
  %694 = load i64, ptr %.sroa_idx.i456, align 4
  %695 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %696 = call { ptr } %686(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i457 = extractvalue { ptr } %696, 0
  %697 = getelementptr i8, ptr %.fca.0.extract52.i457, i64 %689
  store ptr %.sroa.0.0288.i445, ptr %697, align 8
  %698 = getelementptr i8, ptr %697, i64 8
  store i64 %.sroa.6.0287.i446.in, ptr %698, align 4
  %.sroa_idx104.i458 = getelementptr i8, ptr %697, i64 16
  store i64 %.sroa.12.0286.i447.in, ptr %.sroa_idx104.i458, align 4
  %.sroa_idx105.i459 = getelementptr i8, ptr %697, i64 24
  store i32 %.sroa.17.0285.i448, ptr %.sroa_idx105.i459, align 4
  %699 = icmp ne ptr %691, @nil_typ
  %700 = icmp ne ptr %691, null
  %.not94.i460 = and i1 %699, %700
  br i1 %.not94.i460, label %.cont.i465, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit487

.cont.i465:                                       ; preds = %668
  %701 = add nuw nsw i32 %.0290.i443, 1
  %702 = xor i1 %.074289.i444, true
  %hash_coef_ptr.i.i46.i466 = getelementptr i8, ptr %691, i64 8
  %tbl_size_ptr.i.i47.i467 = getelementptr i8, ptr %691, i64 16
  %offset_tbl_ptr.i.i48.i468 = getelementptr i8, ptr %691, i64 40
  %hash_coef.i.i49.i469 = load i64, ptr %hash_coef_ptr.i.i46.i466, align 4
  %tbl_size.i.i50.i470 = load i64, ptr %tbl_size_ptr.i.i47.i467, align 4
  %offset_tbl.i.i51.i471 = load ptr, ptr %offset_tbl_ptr.i.i48.i468, align 8
  %product.i.i.i52.i472 = mul i64 %hash_coef.i.i49.i469, 4015701072841558310
  %shifted.i.i.i53.i473 = lshr i64 %product.i.i.i52.i472, 32
  %xored.i.i.i54.i474 = xor i64 %shifted.i.i.i53.i473, %product.i.i.i52.i472
  %hash.i.i.i55.i475 = and i64 %xored.i.i.i54.i474, %tbl_size.i.i50.i470
  %offset_ptr.i.i56.i476 = getelementptr i32, ptr %offset_tbl.i.i51.i471, i64 %hash.i.i.i55.i475
  %offset.i.i57.i477 = load i32, ptr %offset_ptr.i.i56.i476, align 4
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %704 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i478 = icmp eq i32 %701, 100
  br i1 %exitcond.not.i478, label %708, label %668

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit487: ; preds = %668
  %705 = load i32, ptr %54, align 4
  %706 = add i32 %705, 1
  %707 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %706, ptr %54, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  br label %CuckooMap_insert_keyK_valueV.exit

708:                                              ; preds = %.cont.i465
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %709 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %710 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %711 = load ptr, ptr %51, align 8
  %712 = load ptr, ptr %52, align 8
  %713 = load i32, ptr %50, align 8
  %714 = shl i32 %713, 1
  %spec.select.i504 = call i32 @llvm.smax.i32(i32 %714, i32 noundef 16) #40
  store i32 %spec.select.i504, ptr %50, align 8
  %715 = zext nneg i32 %spec.select.i504 to i64
  %716 = shl nuw nsw i64 %715, 5
  %result.i5.i505 = call noalias ptr @bump_malloc_wrapper(i64 noundef %716) #48
  store ptr %result.i5.i505, ptr %51, align 8
  %result.i4.i506 = call noalias ptr @bump_malloc_wrapper(i64 noundef %716) #48
  store ptr %result.i4.i506, ptr %52, align 8
  store i32 0, ptr %54, align 4
  %717 = icmp sgt i32 %713, 0
  br i1 %717, label %.lr.ph.i877, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.thread: ; preds = %708
  %718 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i877:                                      ; preds = %708
  %wide.trip.count.i890 = zext nneg i32 %713 to i64
  br label %719

719:                                              ; preds = %._crit_edge.i893, %.lr.ph.i877
  %indvars.iv.i891 = phi i64 [ 0, %.lr.ph.i877 ], [ %indvars.iv.next.i894, %._crit_edge.i893 ]
  %720 = shl nuw nsw i64 %indvars.iv.i891, 5
  %721 = getelementptr i8, ptr %711, i64 %720
  %722 = load ptr, ptr %721, align 8
  %723 = icmp ne ptr %722, @nil_typ
  %724 = icmp ne ptr %722, null
  %.not17.i892 = and i1 %723, %724
  br i1 %.not17.i892, label %725, label %._crit_edge.i893

725:                                              ; preds = %719
  %726 = getelementptr i8, ptr %721, i64 8
  %727 = load i64, ptr %726, align 4
  %.sroa_idx.i896 = getelementptr i8, ptr %721, i64 16
  %728 = load i64, ptr %.sroa_idx.i896, align 4
  %hash_coef_ptr.i.i6.i897 = getelementptr i8, ptr %722, i64 8
  %tbl_size_ptr.i.i7.i898 = getelementptr i8, ptr %722, i64 16
  %offset_tbl_ptr.i.i8.i899 = getelementptr i8, ptr %722, i64 40
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  %hash_coef.i.i21.i1293 = load i64, ptr %hash_coef_ptr.i.i6.i897, align 4, !noalias !38
  %tbl_size.i.i22.i1294 = load i64, ptr %tbl_size_ptr.i.i7.i898, align 4, !noalias !38
  %offset_tbl.i.i23.i1295 = load ptr, ptr %offset_tbl_ptr.i.i8.i899, align 8, !noalias !38
  %product.i.i.i24.i1296 = mul i64 %hash_coef.i.i21.i1293, 4015701072841558310
  %shifted.i.i.i25.i1297 = lshr i64 %product.i.i.i24.i1296, 32
  %xored.i.i.i26.i1298 = xor i64 %shifted.i.i.i25.i1297, %product.i.i.i24.i1296
  %hash.i.i.i27.i1299 = and i64 %xored.i.i.i26.i1298, %tbl_size.i.i22.i1294
  %offset_ptr.i.i28.i1300 = getelementptr i32, ptr %offset_tbl.i.i23.i1295, i64 %hash.i.i.i27.i1299
  %offset.i.i29.i1301 = load i32, ptr %offset_ptr.i.i28.i1300, align 4, !noalias !38
  %730 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %731 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %732 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %733

733:                                              ; preds = %.cont.i1324, %725
  %.0290.i1302 = phi i32 [ 0, %725 ], [ %766, %.cont.i1324 ]
  %.074289.i1303 = phi i1 [ true, %725 ], [ %767, %.cont.i1324 ]
  %.sroa.0.0288.i1304 = phi ptr [ %722, %725 ], [ %756, %.cont.i1324 ]
  %.sroa.6.0287.i1305.in = phi i64 [ %727, %725 ], [ %758, %.cont.i1324 ]
  %.sroa.12.0286.i1306.in = phi i64 [ %728, %725 ], [ %759, %.cont.i1324 ]
  %.sroa.17.0285.i1307 = phi i32 [ %offset.i.i29.i1301, %725 ], [ %offset.i.i57.i1336, %.cont.i1324 ]
  %.sroa.12.0286.i1306 = inttoptr i64 %.sroa.12.0286.i1306.in to ptr
  %.sroa.6.0287.i1305 = inttoptr i64 %.sroa.6.0287.i1305.in to ptr
  %734 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1304, 0
  %735 = insertvalue { ptr, ptr, ptr, i32 } %734, ptr %.sroa.6.0287.i1305, 1
  %736 = insertvalue { ptr, ptr, ptr, i32 } %735, ptr %.sroa.12.0286.i1306, 2
  %737 = insertvalue { ptr, ptr, ptr, i32 } %736, i32 %.sroa.17.0285.i1307, 3
  %738 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1304)
  %739 = sext i32 %.sroa.17.0285.i1307 to i64
  %740 = getelementptr ptr, ptr %.sroa.0.0288.i1304, i64 %739
  %741 = getelementptr i8, ptr %740, i64 64
  %742 = load ptr, ptr %741, align 8
  %result.i15.i1308 = call ptr %742({ ptr, ptr, ptr, i32 } %737, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %743 = call i32 %result.i15.i1308({ ptr, ptr, ptr, i32 } %737, { ptr, ptr, ptr, i32 } %737, ptr nonnull align 8 %2) #53
  %..i1309 = select i1 %.074289.i1303, ptr %7, ptr %9
  %.188.i1310 = select i1 %.074289.i1303, i64 104, i64 112
  %.189.i1311 = select i1 %.074289.i1303, ptr %8, ptr %10
  %.190.i1312 = select i1 %.074289.i1303, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1309, align 8
  %744 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1309)
  %745 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1310
  %746 = load ptr, ptr %745, align 8
  store ptr @i32_typ, ptr %.189.i1311, align 8
  %result.i14.i1313 = call ptr %746({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1311) #46
  %747 = call i32 %result.i14.i1313({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1309, i32 %743) #53
  %748 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %749 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1312
  %750 = load ptr, ptr %749, align 8
  %751 = load ptr, ptr %750, align 8
  %752 = call { ptr } %751(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i1314 = extractvalue { ptr } %752, 0
  %753 = sext i32 %747 to i64
  %754 = shl nsw i64 %753, 5
  %755 = getelementptr i8, ptr %.fca.0.extract55.i1314, i64 %754
  %756 = load ptr, ptr %755, align 8
  %757 = getelementptr i8, ptr %755, i64 8
  %758 = load i64, ptr %757, align 4
  %.sroa_idx.i1315 = getelementptr i8, ptr %755, i64 16
  %759 = load i64, ptr %.sroa_idx.i1315, align 4
  %760 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %761 = call { ptr } %751(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i1316 = extractvalue { ptr } %761, 0
  %762 = getelementptr i8, ptr %.fca.0.extract52.i1316, i64 %754
  store ptr %.sroa.0.0288.i1304, ptr %762, align 8
  %763 = getelementptr i8, ptr %762, i64 8
  store i64 %.sroa.6.0287.i1305.in, ptr %763, align 4
  %.sroa_idx104.i1317 = getelementptr i8, ptr %762, i64 16
  store i64 %.sroa.12.0286.i1306.in, ptr %.sroa_idx104.i1317, align 4
  %.sroa_idx105.i1318 = getelementptr i8, ptr %762, i64 24
  store i32 %.sroa.17.0285.i1307, ptr %.sroa_idx105.i1318, align 4
  %764 = icmp ne ptr %756, @nil_typ
  %765 = icmp ne ptr %756, null
  %.not94.i1319 = and i1 %764, %765
  br i1 %.not94.i1319, label %.cont.i1324, label %770

.cont.i1324:                                      ; preds = %733
  %766 = add nuw nsw i32 %.0290.i1302, 1
  %767 = xor i1 %.074289.i1303, true
  %hash_coef_ptr.i.i46.i1325 = getelementptr i8, ptr %756, i64 8
  %tbl_size_ptr.i.i47.i1326 = getelementptr i8, ptr %756, i64 16
  %offset_tbl_ptr.i.i48.i1327 = getelementptr i8, ptr %756, i64 40
  %hash_coef.i.i49.i1328 = load i64, ptr %hash_coef_ptr.i.i46.i1325, align 4
  %tbl_size.i.i50.i1329 = load i64, ptr %tbl_size_ptr.i.i47.i1326, align 4
  %offset_tbl.i.i51.i1330 = load ptr, ptr %offset_tbl_ptr.i.i48.i1327, align 8
  %product.i.i.i52.i1331 = mul i64 %hash_coef.i.i49.i1328, 4015701072841558310
  %shifted.i.i.i53.i1332 = lshr i64 %product.i.i.i52.i1331, 32
  %xored.i.i.i54.i1333 = xor i64 %shifted.i.i.i53.i1332, %product.i.i.i52.i1331
  %hash.i.i.i55.i1334 = and i64 %xored.i.i.i54.i1333, %tbl_size.i.i50.i1329
  %offset_ptr.i.i56.i1335 = getelementptr i32, ptr %offset_tbl.i.i51.i1330, i64 %hash.i.i.i55.i1334
  %offset.i.i57.i1336 = load i32, ptr %offset_ptr.i.i56.i1335, align 4
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1337 = icmp eq i32 %766, 100
  br i1 %exitcond.not.i1337, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346, label %733

770:                                              ; preds = %733
  %771 = load i32, ptr %54, align 4
  %772 = add i32 %771, 1
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %772, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346: ; preds = %770, %.cont.i1324
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  br label %._crit_edge.i893

._crit_edge.i893:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346, %719
  %indvars.iv.next.i894 = add nuw nsw i64 %indvars.iv.i891, 1
  %exitcond.not.i895 = icmp eq i64 %indvars.iv.next.i894, %wide.trip.count.i890
  br i1 %exitcond.not.i895, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913, label %719

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913: ; preds = %._crit_edge.i893
  %774 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %775

775:                                              ; preds = %._crit_edge.i931, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913
  %indvars.iv.i929 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913 ], [ %indvars.iv.next.i932, %._crit_edge.i931 ]
  %776 = shl nuw nsw i64 %indvars.iv.i929, 5
  %777 = getelementptr i8, ptr %712, i64 %776
  %778 = load ptr, ptr %777, align 8
  %779 = icmp ne ptr %778, @nil_typ
  %780 = icmp ne ptr %778, null
  %.not17.i930 = and i1 %779, %780
  br i1 %.not17.i930, label %781, label %._crit_edge.i931

781:                                              ; preds = %775
  %782 = getelementptr i8, ptr %777, i64 8
  %783 = load i64, ptr %782, align 4
  %.sroa_idx.i934 = getelementptr i8, ptr %777, i64 16
  %784 = load i64, ptr %.sroa_idx.i934, align 4
  %hash_coef_ptr.i.i6.i935 = getelementptr i8, ptr %778, i64 8
  %tbl_size_ptr.i.i7.i936 = getelementptr i8, ptr %778, i64 16
  %offset_tbl_ptr.i.i8.i937 = getelementptr i8, ptr %778, i64 40
  %785 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %hash_coef.i.i21.i1364 = load i64, ptr %hash_coef_ptr.i.i6.i935, align 4, !noalias !41
  %tbl_size.i.i22.i1365 = load i64, ptr %tbl_size_ptr.i.i7.i936, align 4, !noalias !41
  %offset_tbl.i.i23.i1366 = load ptr, ptr %offset_tbl_ptr.i.i8.i937, align 8, !noalias !41
  %product.i.i.i24.i1367 = mul i64 %hash_coef.i.i21.i1364, 4015701072841558310
  %shifted.i.i.i25.i1368 = lshr i64 %product.i.i.i24.i1367, 32
  %xored.i.i.i26.i1369 = xor i64 %shifted.i.i.i25.i1368, %product.i.i.i24.i1367
  %hash.i.i.i27.i1370 = and i64 %xored.i.i.i26.i1369, %tbl_size.i.i22.i1365
  %offset_ptr.i.i28.i1371 = getelementptr i32, ptr %offset_tbl.i.i23.i1366, i64 %hash.i.i.i27.i1370
  %offset.i.i29.i1372 = load i32, ptr %offset_ptr.i.i28.i1371, align 4, !noalias !41
  %786 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %787 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %788 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %789

789:                                              ; preds = %.cont.i1395, %781
  %.0290.i1373 = phi i32 [ 0, %781 ], [ %822, %.cont.i1395 ]
  %.074289.i1374 = phi i1 [ true, %781 ], [ %823, %.cont.i1395 ]
  %.sroa.0.0288.i1375 = phi ptr [ %778, %781 ], [ %812, %.cont.i1395 ]
  %.sroa.6.0287.i1376.in = phi i64 [ %783, %781 ], [ %814, %.cont.i1395 ]
  %.sroa.12.0286.i1377.in = phi i64 [ %784, %781 ], [ %815, %.cont.i1395 ]
  %.sroa.17.0285.i1378 = phi i32 [ %offset.i.i29.i1372, %781 ], [ %offset.i.i57.i1407, %.cont.i1395 ]
  %.sroa.12.0286.i1377 = inttoptr i64 %.sroa.12.0286.i1377.in to ptr
  %.sroa.6.0287.i1376 = inttoptr i64 %.sroa.6.0287.i1376.in to ptr
  %790 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1375, 0
  %791 = insertvalue { ptr, ptr, ptr, i32 } %790, ptr %.sroa.6.0287.i1376, 1
  %792 = insertvalue { ptr, ptr, ptr, i32 } %791, ptr %.sroa.12.0286.i1377, 2
  %793 = insertvalue { ptr, ptr, ptr, i32 } %792, i32 %.sroa.17.0285.i1378, 3
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1375)
  %795 = sext i32 %.sroa.17.0285.i1378 to i64
  %796 = getelementptr ptr, ptr %.sroa.0.0288.i1375, i64 %795
  %797 = getelementptr i8, ptr %796, i64 64
  %798 = load ptr, ptr %797, align 8
  %result.i15.i1379 = call ptr %798({ ptr, ptr, ptr, i32 } %793, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %799 = call i32 %result.i15.i1379({ ptr, ptr, ptr, i32 } %793, { ptr, ptr, ptr, i32 } %793, ptr nonnull align 8 %2) #53
  %..i1380 = select i1 %.074289.i1374, ptr %3, ptr %5
  %.188.i1381 = select i1 %.074289.i1374, i64 104, i64 112
  %.189.i1382 = select i1 %.074289.i1374, ptr %4, ptr %6
  %.190.i1383 = select i1 %.074289.i1374, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1380, align 8
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1380)
  %801 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1381
  %802 = load ptr, ptr %801, align 8
  store ptr @i32_typ, ptr %.189.i1382, align 8
  %result.i14.i1384 = call ptr %802({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1382) #46
  %803 = call i32 %result.i14.i1384({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1380, i32 %799) #53
  %804 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %805 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1383
  %806 = load ptr, ptr %805, align 8
  %807 = load ptr, ptr %806, align 8
  %808 = call { ptr } %807(ptr nonnull %result.i31) #43
  %.fca.0.extract55.i1385 = extractvalue { ptr } %808, 0
  %809 = sext i32 %803 to i64
  %810 = shl nsw i64 %809, 5
  %811 = getelementptr i8, ptr %.fca.0.extract55.i1385, i64 %810
  %812 = load ptr, ptr %811, align 8
  %813 = getelementptr i8, ptr %811, i64 8
  %814 = load i64, ptr %813, align 4
  %.sroa_idx.i1386 = getelementptr i8, ptr %811, i64 16
  %815 = load i64, ptr %.sroa_idx.i1386, align 4
  %816 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %817 = call { ptr } %807(ptr nonnull %result.i31) #43
  %.fca.0.extract52.i1387 = extractvalue { ptr } %817, 0
  %818 = getelementptr i8, ptr %.fca.0.extract52.i1387, i64 %810
  store ptr %.sroa.0.0288.i1375, ptr %818, align 8
  %819 = getelementptr i8, ptr %818, i64 8
  store i64 %.sroa.6.0287.i1376.in, ptr %819, align 4
  %.sroa_idx104.i1388 = getelementptr i8, ptr %818, i64 16
  store i64 %.sroa.12.0286.i1377.in, ptr %.sroa_idx104.i1388, align 4
  %.sroa_idx105.i1389 = getelementptr i8, ptr %818, i64 24
  store i32 %.sroa.17.0285.i1378, ptr %.sroa_idx105.i1389, align 4
  %820 = icmp ne ptr %812, @nil_typ
  %821 = icmp ne ptr %812, null
  %.not94.i1390 = and i1 %820, %821
  br i1 %.not94.i1390, label %.cont.i1395, label %826

.cont.i1395:                                      ; preds = %789
  %822 = add nuw nsw i32 %.0290.i1373, 1
  %823 = xor i1 %.074289.i1374, true
  %hash_coef_ptr.i.i46.i1396 = getelementptr i8, ptr %812, i64 8
  %tbl_size_ptr.i.i47.i1397 = getelementptr i8, ptr %812, i64 16
  %offset_tbl_ptr.i.i48.i1398 = getelementptr i8, ptr %812, i64 40
  %hash_coef.i.i49.i1399 = load i64, ptr %hash_coef_ptr.i.i46.i1396, align 4
  %tbl_size.i.i50.i1400 = load i64, ptr %tbl_size_ptr.i.i47.i1397, align 4
  %offset_tbl.i.i51.i1401 = load ptr, ptr %offset_tbl_ptr.i.i48.i1398, align 8
  %product.i.i.i52.i1402 = mul i64 %hash_coef.i.i49.i1399, 4015701072841558310
  %shifted.i.i.i53.i1403 = lshr i64 %product.i.i.i52.i1402, 32
  %xored.i.i.i54.i1404 = xor i64 %shifted.i.i.i53.i1403, %product.i.i.i52.i1402
  %hash.i.i.i55.i1405 = and i64 %xored.i.i.i54.i1404, %tbl_size.i.i50.i1400
  %offset_ptr.i.i56.i1406 = getelementptr i32, ptr %offset_tbl.i.i51.i1401, i64 %hash.i.i.i55.i1405
  %offset.i.i57.i1407 = load i32, ptr %offset_ptr.i.i56.i1406, align 4
  %824 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %825 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1408 = icmp eq i32 %822, 100
  br i1 %exitcond.not.i1408, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417, label %789

826:                                              ; preds = %789
  %827 = load i32, ptr %54, align 4
  %828 = add i32 %827, 1
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %828, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417: ; preds = %826, %.cont.i1395
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  br label %._crit_edge.i931

._crit_edge.i931:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417, %775
  %indvars.iv.next.i932 = add nuw nsw i64 %indvars.iv.i929, 1
  %exitcond.not.i933 = icmp eq i64 %indvars.iv.next.i932, %wide.trip.count.i890
  br i1 %exitcond.not.i933, label %CuckooMap_insert_keyK_valueV.exit, label %775

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i931, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit487, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit354, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %exitcond.not = icmp eq i32 %61, %0
  br i1 %exitcond.not, label %._crit_edge2, label %._crit_edge

._crit_edge2:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit
  %830 = call i64 @clock()
  %831 = add nsw i32 %0, -1
  %.sroa.0124.0.insert.ext = zext nneg i32 %831 to i160
  %832 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0124.0.insert.ext, 1
  %833 = load ptr, ptr %48, align 8
  %834 = call i32 %833({ ptr, i160 } %832) #53
  %835 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %836 = load i32, ptr %50, align 8
  %837 = add i32 %836, -1
  %838 = and i32 %837, %834
  %839 = load ptr, ptr %51, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %840 = sext i32 %838 to i64
  %841 = shl nsw i64 %840, 5
  %842 = getelementptr i8, ptr %839, i64 %841
  %843 = load ptr, ptr %842, align 8
  %844 = icmp ne ptr %843, @nil_typ
  %845 = icmp ne ptr %843, null
  %.not45.i = and i1 %844, %845
  br i1 %.not45.i, label %846, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

846:                                              ; preds = %._crit_edge2
  %847 = getelementptr i8, ptr %842, i64 8
  %848 = load i64, ptr %847, align 4
  %.sroa_idx.i552 = getelementptr i8, ptr %842, i64 16
  %849 = load i64, ptr %.sroa_idx.i552, align 4
  %850 = inttoptr i64 %848 to ptr
  %851 = inttoptr i64 %849 to ptr
  %hash_coef_ptr.i.i4.i = getelementptr i8, ptr %843, i64 8
  %tbl_size_ptr.i.i5.i = getelementptr i8, ptr %843, i64 16
  %offset_tbl_ptr.i.i6.i = getelementptr i8, ptr %843, i64 40
  %hash_coef.i.i7.i = load i64, ptr %hash_coef_ptr.i.i4.i, align 4, !noalias !44
  %tbl_size.i.i8.i = load i64, ptr %tbl_size_ptr.i.i5.i, align 4, !noalias !44
  %offset_tbl.i.i9.i = load ptr, ptr %offset_tbl_ptr.i.i6.i, align 8, !noalias !44
  %product.i.i.i10.i = mul i64 %hash_coef.i.i7.i, 4015701072841558310
  %shifted.i.i.i11.i = lshr i64 %product.i.i.i10.i, 32
  %xored.i.i.i12.i = xor i64 %shifted.i.i.i11.i, %product.i.i.i10.i
  %hash.i.i.i13.i = and i64 %xored.i.i.i12.i, %tbl_size.i.i8.i
  %offset_ptr.i.i14.i = getelementptr i32, ptr %offset_tbl.i.i9.i, i64 %hash.i.i.i13.i
  %offset.i.i15.i = load i32, ptr %offset_ptr.i.i14.i, align 4, !noalias !44
  %852 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %843, 0
  %853 = insertvalue { ptr, ptr, ptr, i32 } %852, ptr %850, 1
  %854 = insertvalue { ptr, ptr, ptr, i32 } %853, ptr %851, 2
  %855 = insertvalue { ptr, ptr, ptr, i32 } %854, i32 %offset.i.i15.i, 3
  %856 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %857 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %843) #40
  %858 = sext i32 %offset.i.i15.i to i64
  %859 = getelementptr ptr, ptr %843, i64 %858
  %860 = getelementptr i8, ptr %859, i64 64
  %861 = load ptr, ptr %860, align 8
  %result.i2.i553 = call ptr %861({ ptr, ptr, ptr, i32 } %855, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %862 = call i32 %result.i2.i553({ ptr, ptr, ptr, i32 } %855, { ptr, ptr, ptr, i32 } %855, ptr nonnull align 8 %2) #53
  %863 = icmp eq i32 %862, %834
  br i1 %863, label %._crit_edge.i554, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i554:                                 ; preds = %846
  %864 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %865 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %843)
  %866 = getelementptr i8, ptr %859, i64 48
  %867 = load ptr, ptr %866, align 8
  %result.i1.i555 = call ptr %867({ ptr, ptr, ptr, i32 } %855, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %868 = call { ptr, i160 } %result.i1.i555({ ptr, ptr, ptr, i32 } %855, { ptr, ptr, ptr, i32 } %855, ptr nonnull align 8 %2) #53
  %869 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %870 = load ptr, ptr %49, align 8
  %871 = call i1 %870({ ptr, i160 } %868, { ptr, i160 } %832) #53
  br i1 %871, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i554, %846, %._crit_edge2
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %879

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i554
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %873 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %843)
  %874 = getelementptr i8, ptr %859, i64 56
  %875 = load ptr, ptr %874, align 8
  %result.i.i556 = call ptr %875({ ptr, ptr, ptr, i32 } %855, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %876 = call { ptr, i160 } %result.i.i556({ ptr, ptr, ptr, i32 } %855, { ptr, ptr, ptr, i32 } %855, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i = extractvalue { ptr, i160 } %876, 0
  %.fca.1.extract23.i = extractvalue { ptr, i160 } %876, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %877 = icmp ne ptr %.fca.0.extract22.i, @nil_typ
  %878 = icmp ne ptr %.fca.0.extract22.i, null
  %.not63.i = and i1 %877, %878
  %extract.t643 = trunc i160 %.fca.1.extract23.i to i32
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %879

879:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %880 = add i32 %834, 2127912214
  %881 = shl i32 %834, 12
  %882 = add i32 %880, %881
  %883 = ashr i32 %882, 19
  %884 = xor i32 %882, %883
  %885 = xor i32 %884, -949894596
  %886 = add i32 %885, 374761393
  %887 = shl i32 %885, 5
  %888 = add i32 %886, %887
  %889 = add i32 %888, -744332180
  %890 = shl i32 %888, 9
  %891 = xor i32 %889, %890
  %892 = add i32 %891, -42973499
  %893 = shl i32 %891, 3
  %894 = add i32 %892, %893
  %895 = ashr i32 %894, 16
  %896 = xor i32 %894, %895
  %897 = xor i32 %896, -1252372727
  %898 = load i32, ptr %50, align 8
  %899 = add i32 %898, -1
  %900 = and i32 %899, %897
  %901 = load ptr, ptr %52, align 8
  %902 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %903 = sext i32 %900 to i64
  %904 = shl nsw i64 %903, 5
  %905 = getelementptr i8, ptr %901, i64 %904
  %906 = load ptr, ptr %905, align 8
  %907 = icmp ne ptr %906, @nil_typ
  %908 = icmp ne ptr %906, null
  %.not45.i587 = and i1 %907, %908
  br i1 %.not45.i587, label %909, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612

909:                                              ; preds = %879
  %910 = getelementptr i8, ptr %905, i64 8
  %911 = load i64, ptr %910, align 4
  %.sroa_idx.i592 = getelementptr i8, ptr %905, i64 16
  %912 = load i64, ptr %.sroa_idx.i592, align 4
  %913 = inttoptr i64 %911 to ptr
  %914 = inttoptr i64 %912 to ptr
  %hash_coef_ptr.i.i4.i593 = getelementptr i8, ptr %906, i64 8
  %tbl_size_ptr.i.i5.i594 = getelementptr i8, ptr %906, i64 16
  %offset_tbl_ptr.i.i6.i595 = getelementptr i8, ptr %906, i64 40
  %hash_coef.i.i7.i596 = load i64, ptr %hash_coef_ptr.i.i4.i593, align 4, !noalias !47
  %tbl_size.i.i8.i597 = load i64, ptr %tbl_size_ptr.i.i5.i594, align 4, !noalias !47
  %offset_tbl.i.i9.i598 = load ptr, ptr %offset_tbl_ptr.i.i6.i595, align 8, !noalias !47
  %product.i.i.i10.i599 = mul i64 %hash_coef.i.i7.i596, 4015701072841558310
  %shifted.i.i.i11.i600 = lshr i64 %product.i.i.i10.i599, 32
  %xored.i.i.i12.i601 = xor i64 %shifted.i.i.i11.i600, %product.i.i.i10.i599
  %hash.i.i.i13.i602 = and i64 %xored.i.i.i12.i601, %tbl_size.i.i8.i597
  %offset_ptr.i.i14.i603 = getelementptr i32, ptr %offset_tbl.i.i9.i598, i64 %hash.i.i.i13.i602
  %offset.i.i15.i604 = load i32, ptr %offset_ptr.i.i14.i603, align 4, !noalias !47
  %915 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %906, 0
  %916 = insertvalue { ptr, ptr, ptr, i32 } %915, ptr %913, 1
  %917 = insertvalue { ptr, ptr, ptr, i32 } %916, ptr %914, 2
  %918 = insertvalue { ptr, ptr, ptr, i32 } %917, i32 %offset.i.i15.i604, 3
  %919 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %920 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %906) #40
  %921 = sext i32 %offset.i.i15.i604 to i64
  %922 = getelementptr ptr, ptr %906, i64 %921
  %923 = getelementptr i8, ptr %922, i64 64
  %924 = load ptr, ptr %923, align 8
  %result.i2.i605 = call ptr %924({ ptr, ptr, ptr, i32 } %918, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %925 = call i32 %result.i2.i605({ ptr, ptr, ptr, i32 } %918, { ptr, ptr, ptr, i32 } %918, ptr nonnull align 8 %2) #53
  %926 = icmp eq i32 %925, %834
  br i1 %926, label %._crit_edge.i606, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612

._crit_edge.i606:                                 ; preds = %909
  %927 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %928 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %906)
  %929 = getelementptr i8, ptr %922, i64 48
  %930 = load ptr, ptr %929, align 8
  %result.i1.i607 = call ptr %930({ ptr, ptr, ptr, i32 } %918, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %931 = call { ptr, i160 } %result.i1.i607({ ptr, ptr, ptr, i32 } %918, { ptr, ptr, ptr, i32 } %918, ptr nonnull align 8 %2) #53
  %932 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %933 = load ptr, ptr %49, align 8
  %934 = call i1 %933({ ptr, i160 } %931, { ptr, i160 } %832) #53
  br i1 %934, label %935, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612

935:                                              ; preds = %._crit_edge.i606
  %936 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %937 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %906)
  %938 = getelementptr i8, ptr %922, i64 56
  %939 = load ptr, ptr %938, align 8
  %result.i.i609 = call ptr %939({ ptr, ptr, ptr, i32 } %918, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %940 = call { ptr, i160 } %result.i.i609({ ptr, ptr, ptr, i32 } %918, { ptr, ptr, ptr, i32 } %918, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i610 = extractvalue { ptr, i160 } %940, 0
  %.fca.1.extract23.i611 = extractvalue { ptr, i160 } %940, 1
  %941 = trunc i160 %.fca.1.extract23.i611 to i32
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612: ; preds = %935, %._crit_edge.i606, %909, %879
  %.reg2mem43.sroa.3.0.i588 = phi i32 [ %941, %935 ], [ poison, %._crit_edge.i606 ], [ poison, %879 ], [ poison, %909 ]
  %.reg2mem41.0.i589 = phi ptr [ %.fca.0.extract22.i610, %935 ], [ @nil_typ, %._crit_edge.i606 ], [ @nil_typ, %879 ], [ @nil_typ, %909 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.not.i117 = icmp eq ptr %.reg2mem41.0.i589, null
  %942 = select i1 %.not.i117, ptr @nil_typ, ptr %.reg2mem41.0.i589
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not63.i642.off0 = phi i32 [ %.reg2mem43.sroa.3.0.i588, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612 ], [ %extract.t643, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem56.0.i = phi ptr [ %942, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612 ], [ %.fca.0.extract22.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %943 = icmp ne ptr %.reg2mem56.0.i, @nil_typ
  %944 = icmp ne ptr %.reg2mem56.0.i, null
  %.not150 = and i1 %943, %944
  br i1 %.not150, label %._crit_edge3, label %._crit_edge4

._crit_edge3:                                     ; preds = %CuckooMap_get_keyK.exit
  %.not154 = icmp eq i32 %0, %.not63.i642.off0
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3, %CuckooMap_get_keyK.exit
  %.3 = phi i1 [ %.not154, %._crit_edge3 ], [ false, %CuckooMap_get_keyK.exit ]
  %945 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %946 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %947 = load i32, ptr %54, align 4
  %.not155 = icmp eq i32 %947, %0
  %948 = select i1 %.not155, i1 %.3, i1 false
  br label %._crit_edge.lr.ph.i

949:                                              ; preds = %1
  %950 = call i64 @clock()
  %951 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %952 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %949, %._crit_edge4
  %953 = phi i64 [ %830, %._crit_edge4 ], [ %950, %949 ]
  %.reg2mem15.0.in = phi i1 [ %948, %._crit_edge4 ], [ true, %949 ]
  %954 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %955 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %956 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i.i672.h2s1565, align 1
  %957 = sub i64 %953, %55
  %958 = getelementptr inbounds i8, ptr %result.i.i672.h2s1565, i64 17
  store i8 0, ptr %958, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(18) %result.i.i672.h2s1565) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i.i.i.h2s1563, align 16
  %959 = getelementptr inbounds i8, ptr %result.i.i.i.h2s1563, i64 14
  store i8 0, ptr %959, align 2
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.h2s1563) #53
  %960 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #55
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i.i304.i.h2s1561, align 16
  %961 = getelementptr inbounds i8, ptr %result.i.i304.i.h2s1561, i64 14
  store i8 0, ptr %961, align 2
  %puts.i229.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.h2s1561) #53
  %962 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %957) #55
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i.i324.i.h2s1559, align 4
  %963 = getelementptr inbounds i8, ptr %result.i.i324.i.h2s1559, i64 3
  store i8 0, ptr %963, align 1
  %puts.i249.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.h2s1559) #53
  br i1 %56, label %._crit_edge.lr.ph.i345.i, label %._crit_edge.lr.ph.i688

._crit_edge.lr.ph.i345.i:                         ; preds = %._crit_edge.lr.ph.i
  %964 = zext nneg i32 %0 to i64
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i.i344.i.h2s1557, align 16
  %965 = mul i64 %957, 1000000
  %966 = sdiv i64 %965, %964
  %967 = getelementptr inbounds i8, ptr %result.i.i344.i.h2s1557, i64 15
  store i8 0, ptr %967, align 1
  %puts.i269.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.h2s1557) #53
  %968 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %966) #55
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i.i364.i.h2s1555, align 4
  %970 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %971 = getelementptr inbounds i8, ptr %result.i.i364.i.h2s1555, i64 3
  store i8 0, ptr %971, align 1
  %puts.i289.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.h2s1555) #53
  br label %._crit_edge.lr.ph.i688

._crit_edge.lr.ph.i688:                           ; preds = %._crit_edge.lr.ph.i345.i, %._crit_edge.lr.ph.i
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %973 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i.i687.h2s1553, align 1
  %974 = getelementptr inbounds i8, ptr %result.i.i687.h2s1553, i64 18
  store i8 0, ptr %974, align 1
  %puts.i229 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i687.h2s1553) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %. = select i1 %.reg2mem15.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.191 = select i1 %.reg2mem15.0.in, ptr %35, ptr %39
  %.192 = select i1 %.reg2mem15.0.in, ptr %36, ptr %40
  %.193 = select i1 %.reg2mem15.0.in, ptr %37, ptr %41
  %.194 = select i1 %.reg2mem15.0.in, ptr %38, ptr %42
  store ptr @_parameterization_Bufferi8, ptr %.191, align 8
  %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem15.0.in, ptr %35, ptr %39
  %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem15.0.in, ptr %35, ptr %39
  %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %975 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.191)
  store ptr @buffer_typ, ptr %.192, align 8
  %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem15.0.in, ptr %36, ptr %40
  %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem15.0.in, ptr %36, ptr %40
  %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %976 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.192) #40
  store ptr @_parameterization_String, ptr %.193, align 8
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.193)
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %.194, align 8
  %979 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.194) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %980 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %981 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <4 x i8> %., ptr %result.i.i707.h2s1552, align 4
  %982 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %983 = getelementptr inbounds i8, ptr %result.i.i707.h2s1552, i64 4
  store i8 0, ptr %983, align 4
  %puts.i250 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i707.h2s1552) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #7

declare i64 @clock() local_unnamed_addr #18

define void @benchmark_insert_random(i32 %0) local_unnamed_addr #18 {
  %2 = alloca {}, align 8
  %result.i.i1493.h2s3177 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i.i1493.h2s3177, align 2
  %result.i.i1473.h2s3178 = alloca [28 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(28) %result.i.i1473.h2s3178, i8 0, i64 28, i1 false)
  %result.i.i1453.h2s3180 = alloca [5 x i8], align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(5) %result.i.i1453.h2s3180, i8 0, i64 5, i1 false)
  %result.i.i1433.h2s3181 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i.i1433.h2s3181, i8 0, i64 19, i1 false)
  %result.i.i364.i.h2s3183 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i364.i.h2s3183, align 4
  %result.i.i344.i.h2s3185 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i344.i.h2s3185, i8 0, i64 16, i1 false)
  %result.i.i324.i.h2s3187 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i324.i.h2s3187, align 4
  %result.i.i304.i.h2s3189 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i304.i.h2s3189, i8 0, i64 15, i1 false)
  %result.i.i.i.h2s3191 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i.i.h2s3191, i8 0, i64 15, i1 false)
  %result.i.i1418.h2s3193 = alloca [14 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(14) %result.i.i1418.h2s3193, i8 0, i64 14, i1 false)
  %result.i56.h2s3195 = alloca [24 x i8], align 8
  %3 = getelementptr inbounds i8, ptr %result.i56.h2s3195, i64 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %3, i8 0, i64 16, i1 false)
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca { ptr }, align 8
  %20 = alloca [1 x ptr], align 8
  %21 = alloca { ptr }, align 8
  %22 = alloca [1 x ptr], align 8
  %23 = alloca { ptr }, align 8
  %24 = alloca [1 x ptr], align 8
  %25 = alloca { ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca { ptr }, align 8
  %28 = alloca [1 x ptr], align 8
  %29 = alloca { ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca { ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca { ptr }, align 8
  %36 = alloca [1 x ptr], align 8
  %37 = alloca { ptr }, align 8
  %38 = alloca [1 x ptr], align 8
  %39 = alloca { ptr }, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca { ptr }, align 8
  %42 = alloca [1 x ptr], align 8
  %43 = alloca { ptr }, align 8
  %44 = alloca [1 x ptr], align 8
  %45 = alloca { ptr }, align 8
  %46 = alloca [1 x ptr], align 8
  %47 = alloca { ptr }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca [1 x ptr], align 8
  %53 = alloca { ptr }, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca [1 x ptr], align 8
  %59 = alloca { ptr }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [1 x ptr], align 8
  %63 = alloca { ptr }, align 8
  %64 = alloca [1 x ptr], align 8
  %65 = alloca { ptr }, align 8
  %66 = alloca [1 x ptr], align 8
  %67 = alloca { ptr }, align 8
  %oldProtect.i66 = alloca i32, align 4
  %oldProtect.i64 = alloca i32, align 4
  %oldProtect.i62 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0242.sroa.0 = alloca i8, align 8
  %68 = alloca [3 x ptr], align 8
  %69 = alloca { ptr, ptr, ptr }, align 8
  %70 = alloca [1 x ptr], align 8
  %71 = alloca { ptr }, align 8
  %72 = alloca [3 x ptr], align 8
  %73 = alloca { ptr, ptr, ptr }, align 8
  %74 = alloca [1 x ptr], align 8
  %75 = alloca { ptr }, align 8
  %result.i60 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i60, align 8
  %76 = getelementptr inbounds i8, ptr %result.i60, i64 8
  store ptr @_parameterization_i32, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %result.i60, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %77, align 8
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i60) #40
  %result.i59 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  %result.i61 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i59, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i59, ptr noalias nofree noundef nonnull readnone @vimoiwpapu, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i42 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i59) #47
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i59) #40
  %result.i58 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #40
  %result.i63 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i58, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i62) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i58, ptr noalias nofree noundef nonnull readnone @genyhirpvr, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i41 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i58) #47
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i58) #40
  %81 = getelementptr inbounds i8, ptr %result.i60, i64 48
  store ptr %ret.i42, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i60, i64 56
  store ptr %ret.i41, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i60, i64 40
  store i32 8, ptr %83, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %84 = getelementptr inbounds i8, ptr %result.i60, i64 24
  store ptr %result.i1.i, ptr %84, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %85 = getelementptr inbounds i8, ptr %result.i60, i64 32
  store ptr %result.i.i, ptr %85, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %87 = getelementptr inbounds i8, ptr %result.i60, i64 44
  store i32 0, ptr %87, align 4
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  store ptr @_parameterization_i32, ptr %result.i56.h2s3195, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i56.h2s3195) #40
  %90 = getelementptr inbounds i8, ptr %result.i56.h2s3195, i64 20
  store i32 %0, ptr %90, align 4
  %91 = sext i32 %0 to i64
  %92 = shl nsw i64 %91, 2
  %result.i2.i202 = call noalias ptr @bump_malloc_wrapper(i64 noundef %92) #48
  %93 = getelementptr inbounds i8, ptr %result.i56.h2s3195, i64 8
  store ptr %result.i2.i202, ptr %93, align 8
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #40
  %95 = getelementptr inbounds i8, ptr %result.i56.h2s3195, i64 16
  store i32 0, ptr %95, align 8
  %result.i55 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i55, align 8
  %96 = getelementptr inbounds i8, ptr %result.i55, i64 8
  store ptr @_parameterization_Bool, ptr %96, align 8
  %97 = getelementptr inbounds i8, ptr %result.i55, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i55) #40
  %result.i54 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i64) #40
  %result.i65 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i54, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i64) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i64) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i54, ptr noalias nofree noundef nonnull readnone @nyfuylfwaq, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i40 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i54) #47
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i54) #40
  %result.i53 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i66) #40
  %result.i67 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i53, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i66) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i66) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i53, ptr noalias nofree noundef nonnull readnone @weyllhhkpb, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i53) #47
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i53) #40
  %101 = getelementptr inbounds i8, ptr %result.i55, i64 48
  store ptr %ret.i40, ptr %101, align 8
  %102 = getelementptr inbounds i8, ptr %result.i55, i64 56
  store ptr %ret.i, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %result.i55, i64 40
  store i32 8, ptr %103, align 8
  %result.i1.i216 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %104 = getelementptr inbounds i8, ptr %result.i55, i64 24
  store ptr %result.i1.i216, ptr %104, align 8
  %result.i.i217 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %105 = getelementptr inbounds i8, ptr %result.i55, i64 32
  store ptr %result.i.i217, ptr %105, align 8
  %106 = getelementptr inbounds i8, ptr %result.i55, i64 44
  store i32 0, ptr %106, align 4
  %107 = icmp sgt i32 %0, 0
  br i1 %107, label %._crit_edge.lr.ph, label %1794

._crit_edge.lr.ph:                                ; preds = %1
  %108 = add nsw i32 %0, -1
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %110 = zext nneg i32 %108 to i64
  %111 = zext nneg i32 %0 to i64
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #40
  %114 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i55, 1
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr undef, 2
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 10, 3
  %117 = insertvalue { ptr, ptr, ptr, i32 } %114, i32 10, 3
  br label %._crit_edge

._crit_edge:                                      ; preds = %CuckooMap_insert_keyK_valueV.exit, %._crit_edge.lr.ph
  %118 = phi i32 [ 123, %._crit_edge.lr.ph ], [ %121, %CuckooMap_insert_keyK_valueV.exit ]
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %CuckooMap_insert_keyK_valueV.exit ]
  %.0159 = phi i32 [ -1, %._crit_edge.lr.ph ], [ %spec.select, %CuckooMap_insert_keyK_valueV.exit ]
  %119 = mul i32 %118, 1103515245
  %120 = add i32 %119, 12345
  %121 = and i32 %120, 2147483647
  %.sroa.0252.0.insert.ext = zext nneg i32 %121 to i160
  %122 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0252.0.insert.ext, 1
  %123 = load ptr, ptr %93, align 8
  %124 = shl i64 %indvars.iv, 2
  %125 = getelementptr i8, ptr %123, i64 %124
  store i32 %121, ptr %125, align 1
  %126 = icmp eq i64 %indvars.iv, %110
  %spec.select = select i1 %126, i32 %121, i32 %.0159
  store i1 true, ptr %.sroa.0242.sroa.0, align 8
  %.sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.0. = load i8, ptr %.sroa.0242.sroa.0, align 8
  %.sroa.0242.0.insert.ext = zext i8 %.sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.0. to i160
  %127 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0242.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %128 = load ptr, ptr %101, align 8
  %129 = call i32 %128({ ptr, i160 } %122) #53
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %131 = load i32, ptr %103, align 8
  %132 = add i32 %131, -1
  %133 = and i32 %132, %129
  %134 = load ptr, ptr %104, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %135 = sext i32 %133 to i64
  %136 = shl nsw i64 %135, 5
  %137 = getelementptr i8, ptr %134, i64 %136
  %138 = load ptr, ptr %137, align 8
  %139 = getelementptr i8, ptr %137, i64 8
  %140 = icmp ne ptr %138, @nil_typ
  %141 = icmp ne ptr %138, null
  %.not66.i = and i1 %140, %141
  br i1 %.not66.i, label %142, label %240

142:                                              ; preds = %._crit_edge
  %143 = load i64, ptr %139, align 4
  %.sroa_idx.i = getelementptr i8, ptr %137, i64 16
  %144 = load i64, ptr %.sroa_idx.i, align 4
  %145 = inttoptr i64 %143 to ptr
  %146 = inttoptr i64 %144 to ptr
  %hash_coef_ptr.i.i11.i = getelementptr i8, ptr %138, i64 8
  %tbl_size_ptr.i.i12.i = getelementptr i8, ptr %138, i64 16
  %offset_tbl_ptr.i.i13.i = getelementptr i8, ptr %138, i64 40
  %hash_coef.i.i14.i = load i64, ptr %hash_coef_ptr.i.i11.i, align 4, !noalias !50
  %tbl_size.i.i15.i = load i64, ptr %tbl_size_ptr.i.i12.i, align 4, !noalias !50
  %offset_tbl.i.i16.i = load ptr, ptr %offset_tbl_ptr.i.i13.i, align 8, !noalias !50
  %product.i.i.i17.i = mul i64 %hash_coef.i.i14.i, 4015701072841558310
  %shifted.i.i.i18.i = lshr i64 %product.i.i.i17.i, 32
  %xored.i.i.i19.i = xor i64 %shifted.i.i.i18.i, %product.i.i.i17.i
  %hash.i.i.i20.i = and i64 %xored.i.i.i19.i, %tbl_size.i.i15.i
  %offset_ptr.i.i21.i = getelementptr i32, ptr %offset_tbl.i.i16.i, i64 %hash.i.i.i20.i
  %offset.i.i22.i = load i32, ptr %offset_ptr.i.i21.i, align 4, !noalias !50
  %147 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %138, 0
  %148 = insertvalue { ptr, ptr, ptr, i32 } %147, ptr %145, 1
  %149 = insertvalue { ptr, ptr, ptr, i32 } %148, ptr %146, 2
  %150 = insertvalue { ptr, ptr, ptr, i32 } %149, i32 %offset.i.i22.i, 3
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %138) #40
  %153 = sext i32 %offset.i.i22.i to i64
  %154 = getelementptr ptr, ptr %138, i64 %153
  %155 = getelementptr i8, ptr %154, i64 64
  %156 = load ptr, ptr %155, align 8
  %result.i8.i = call ptr %156({ ptr, ptr, ptr, i32 } %150, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %157 = call i32 %result.i8.i({ ptr, ptr, ptr, i32 } %150, { ptr, ptr, ptr, i32 } %150, ptr nonnull align 8 %2) #53
  %158 = icmp eq i32 %157, %129
  br i1 %158, label %._crit_edge.i642, label %240

._crit_edge.i642:                                 ; preds = %142
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %138)
  %161 = getelementptr i8, ptr %154, i64 48
  %162 = load ptr, ptr %161, align 8
  %result.i7.i = call ptr %162({ ptr, ptr, ptr, i32 } %150, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %163 = call { ptr, i160 } %result.i7.i({ ptr, ptr, ptr, i32 } %150, { ptr, ptr, ptr, i32 } %150, ptr nonnull align 8 %2) #53
  %164 = load ptr, ptr %102, align 8
  %165 = call i1 %164({ ptr, i160 } %163, { ptr, i160 } %122) #53
  br i1 %165, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %240

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i642
  %166 = load ptr, ptr %result.i55, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %168 = load ptr, ptr %96, align 8
  %169 = load ptr, ptr %166, align 8, !alias.scope !53
  %170 = getelementptr i8, ptr %169, i64 72
  %171 = load ptr, ptr %170, align 8, !alias.scope !53
  %result.i1.i.i = call { i64, i64 } %171(ptr nocapture nofree nonnull readonly align 8 %166) #44, !alias.scope !53
  %172 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %173 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %174 = urem i64 20, %173
  %175 = icmp eq i64 %174, 0
  %176 = sub i64 %173, %174
  %177 = select i1 %175, i64 0, i64 %176
  %178 = add i64 %172, 20
  %179 = add i64 %178, %177
  %180 = load ptr, ptr %168, align 8, !alias.scope !53
  %181 = getelementptr i8, ptr %180, i64 72
  %182 = load ptr, ptr %181, align 8, !alias.scope !53
  %result.i.i.i643 = call { i64, i64 } %182(ptr nocapture nofree nonnull readonly align 8 %168) #44, !alias.scope !53
  %183 = extractvalue { i64, i64 } %result.i.i.i643, 0
  %184 = extractvalue { i64, i64 } %result.i.i.i643, 1
  %185 = call i64 @llvm.umax.i64(i64 %173, i64 %184) #41
  %186 = call i64 @llvm.umax.i64(i64 %185, i64 noundef 8) #41, !range !16
  %187 = urem i64 %179, %184
  %188 = icmp eq i64 %187, 0
  %189 = sub i64 %184, %187
  %190 = select i1 %188, i64 0, i64 %189
  %191 = add i64 %183, %179
  %192 = add i64 %191, %190
  %193 = urem i64 %192, %186
  %194 = icmp eq i64 %193, 0
  %195 = sub i64 %186, %193
  %196 = select i1 %194, i64 0, i64 %195
  %197 = add i64 %196, %192
  %result.i9.i = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %197) #48
  store ptr %166, ptr %result.i9.i, align 8
  %198 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr %168, ptr %198, align 8
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i)
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %201 = load ptr, ptr %166, align 8
  %202 = getelementptr i8, ptr %201, i64 72
  %203 = load ptr, ptr %202, align 8
  %result.i.i38.i = call { i64, i64 } %203(ptr nocapture nofree nonnull readonly align 8 %166) #44
  %204 = extractvalue { i64, i64 } %result.i.i38.i, 1
  %205 = urem i64 20, %204
  %206 = icmp eq i64 %205, 0
  %reass.sub3225 = sub i64 %204, %205
  %207 = add i64 %reass.sub3225, 20
  %208 = select i1 %206, i64 20, i64 %207
  %209 = getelementptr i8, ptr %result.i9.i, i64 %208
  %210 = getelementptr i8, ptr %201, i64 64
  %211 = load ptr, ptr %210, align 8
  call void %211({ ptr, i160 } %122, ptr nocapture nofree nonnull readonly align 8 %166, ptr nocapture nofree writeonly %209) #45
  %212 = load ptr, ptr %result.i9.i, align 8
  %213 = load ptr, ptr %212, align 8
  %214 = getelementptr i8, ptr %213, i64 72
  %215 = load ptr, ptr %214, align 8
  %result.i1.i39.i = call { i64, i64 } %215(ptr nocapture nofree nonnull readonly align 8 %212) #44
  %216 = extractvalue { i64, i64 } %result.i1.i39.i, 0
  %217 = extractvalue { i64, i64 } %result.i1.i39.i, 1
  %218 = urem i64 20, %217
  %219 = icmp eq i64 %218, 0
  %220 = sub i64 %217, %218
  %221 = select i1 %219, i64 0, i64 %220
  %222 = add i64 %216, 20
  %223 = add i64 %222, %221
  %224 = load ptr, ptr %198, align 8
  %225 = load ptr, ptr %224, align 8
  %226 = getelementptr i8, ptr %225, i64 72
  %227 = load ptr, ptr %226, align 8
  %result.i.i40.i = call { i64, i64 } %227(ptr nocapture nofree nonnull readonly align 8 %224) #44
  %228 = extractvalue { i64, i64 } %result.i.i40.i, 1
  %229 = urem i64 %223, %228
  %230 = icmp eq i64 %229, 0
  %231 = sub i64 %228, %229
  %232 = select i1 %230, i64 0, i64 %231
  %233 = getelementptr i8, ptr %result.i9.i, i64 %223
  %234 = getelementptr i8, ptr %233, i64 %232
  %235 = getelementptr i8, ptr %225, i64 64
  %236 = load ptr, ptr %235, align 8
  call void %236({ ptr, i160 } %127, ptr nocapture nofree nonnull readonly align 8 %224, ptr nocapture nofree writeonly %234) #45
  %237 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %238 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %129, ptr %238, align 8
  store ptr @Entry, ptr %137, align 8
  %239 = ptrtoint ptr %result.i9.i to i64
  store i64 %239, ptr %139, align 4
  %.sroa_idx30.i = getelementptr i8, ptr %137, i64 24
  store i32 10, ptr %.sroa_idx30.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

240:                                              ; preds = %._crit_edge.i642, %142, %._crit_edge
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %241 = add i32 %129, 2127912214
  %242 = shl i32 %129, 12
  %243 = add i32 %241, %242
  %244 = ashr i32 %243, 19
  %245 = xor i32 %243, %244
  %246 = xor i32 %245, -949894596
  %247 = add i32 %246, 374761393
  %248 = shl i32 %246, 5
  %249 = add i32 %247, %248
  %250 = add i32 %249, -744332180
  %251 = shl i32 %249, 9
  %252 = xor i32 %250, %251
  %253 = add i32 %252, -42973499
  %254 = shl i32 %252, 3
  %255 = add i32 %253, %254
  %256 = ashr i32 %255, 16
  %257 = xor i32 %255, %256
  %258 = xor i32 %257, -1252372727
  %259 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %260 = load i32, ptr %103, align 8
  %261 = add i32 %260, -1
  %262 = and i32 %261, %258
  %263 = load ptr, ptr %105, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %264 = sext i32 %262 to i64
  %265 = shl nsw i64 %264, 5
  %266 = getelementptr i8, ptr %263, i64 %265
  %267 = load ptr, ptr %266, align 8
  %268 = getelementptr i8, ptr %266, i64 8
  %269 = icmp ne ptr %267, @nil_typ
  %270 = icmp ne ptr %267, null
  %.not66.i673 = and i1 %269, %270
  br i1 %.not66.i673, label %271, label %369

271:                                              ; preds = %240
  %272 = load i64, ptr %268, align 4
  %.sroa_idx.i675 = getelementptr i8, ptr %266, i64 16
  %273 = load i64, ptr %.sroa_idx.i675, align 4
  %274 = inttoptr i64 %272 to ptr
  %275 = inttoptr i64 %273 to ptr
  %hash_coef_ptr.i.i11.i676 = getelementptr i8, ptr %267, i64 8
  %tbl_size_ptr.i.i12.i677 = getelementptr i8, ptr %267, i64 16
  %offset_tbl_ptr.i.i13.i678 = getelementptr i8, ptr %267, i64 40
  %hash_coef.i.i14.i679 = load i64, ptr %hash_coef_ptr.i.i11.i676, align 4, !noalias !56
  %tbl_size.i.i15.i680 = load i64, ptr %tbl_size_ptr.i.i12.i677, align 4, !noalias !56
  %offset_tbl.i.i16.i681 = load ptr, ptr %offset_tbl_ptr.i.i13.i678, align 8, !noalias !56
  %product.i.i.i17.i682 = mul i64 %hash_coef.i.i14.i679, 4015701072841558310
  %shifted.i.i.i18.i683 = lshr i64 %product.i.i.i17.i682, 32
  %xored.i.i.i19.i684 = xor i64 %shifted.i.i.i18.i683, %product.i.i.i17.i682
  %hash.i.i.i20.i685 = and i64 %xored.i.i.i19.i684, %tbl_size.i.i15.i680
  %offset_ptr.i.i21.i686 = getelementptr i32, ptr %offset_tbl.i.i16.i681, i64 %hash.i.i.i20.i685
  %offset.i.i22.i687 = load i32, ptr %offset_ptr.i.i21.i686, align 4, !noalias !56
  %276 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %267, 0
  %277 = insertvalue { ptr, ptr, ptr, i32 } %276, ptr %274, 1
  %278 = insertvalue { ptr, ptr, ptr, i32 } %277, ptr %275, 2
  %279 = insertvalue { ptr, ptr, ptr, i32 } %278, i32 %offset.i.i22.i687, 3
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %281 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %267) #40
  %282 = sext i32 %offset.i.i22.i687 to i64
  %283 = getelementptr ptr, ptr %267, i64 %282
  %284 = getelementptr i8, ptr %283, i64 64
  %285 = load ptr, ptr %284, align 8
  %result.i8.i688 = call ptr %285({ ptr, ptr, ptr, i32 } %279, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %286 = call i32 %result.i8.i688({ ptr, ptr, ptr, i32 } %279, { ptr, ptr, ptr, i32 } %279, ptr nonnull align 8 %2) #53
  %287 = icmp eq i32 %286, %129
  br i1 %287, label %._crit_edge.i689, label %369

._crit_edge.i689:                                 ; preds = %271
  %288 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %289 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %267)
  %290 = getelementptr i8, ptr %283, i64 48
  %291 = load ptr, ptr %290, align 8
  %result.i7.i690 = call ptr %291({ ptr, ptr, ptr, i32 } %279, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %292 = call { ptr, i160 } %result.i7.i690({ ptr, ptr, ptr, i32 } %279, { ptr, ptr, ptr, i32 } %279, ptr nonnull align 8 %2) #53
  %293 = load ptr, ptr %102, align 8
  %294 = call i1 %293({ ptr, i160 } %292, { ptr, i160 } %122) #53
  br i1 %294, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit702, label %369

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit702: ; preds = %._crit_edge.i689
  %295 = load ptr, ptr %result.i55, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %297 = load ptr, ptr %96, align 8
  %298 = load ptr, ptr %295, align 8, !alias.scope !59
  %299 = getelementptr i8, ptr %298, i64 72
  %300 = load ptr, ptr %299, align 8, !alias.scope !59
  %result.i1.i.i694 = call { i64, i64 } %300(ptr nocapture nofree nonnull readonly align 8 %295) #44, !alias.scope !59
  %301 = extractvalue { i64, i64 } %result.i1.i.i694, 0
  %302 = extractvalue { i64, i64 } %result.i1.i.i694, 1
  %303 = urem i64 20, %302
  %304 = icmp eq i64 %303, 0
  %305 = sub i64 %302, %303
  %306 = select i1 %304, i64 0, i64 %305
  %307 = add i64 %301, 20
  %308 = add i64 %307, %306
  %309 = load ptr, ptr %297, align 8, !alias.scope !59
  %310 = getelementptr i8, ptr %309, i64 72
  %311 = load ptr, ptr %310, align 8, !alias.scope !59
  %result.i.i.i695 = call { i64, i64 } %311(ptr nocapture nofree nonnull readonly align 8 %297) #44, !alias.scope !59
  %312 = extractvalue { i64, i64 } %result.i.i.i695, 0
  %313 = extractvalue { i64, i64 } %result.i.i.i695, 1
  %314 = call i64 @llvm.umax.i64(i64 %302, i64 %313) #41
  %315 = call i64 @llvm.umax.i64(i64 %314, i64 noundef 8) #41, !range !16
  %316 = urem i64 %308, %313
  %317 = icmp eq i64 %316, 0
  %318 = sub i64 %313, %316
  %319 = select i1 %317, i64 0, i64 %318
  %320 = add i64 %312, %308
  %321 = add i64 %320, %319
  %322 = urem i64 %321, %315
  %323 = icmp eq i64 %322, 0
  %324 = sub i64 %315, %322
  %325 = select i1 %323, i64 0, i64 %324
  %326 = add i64 %325, %321
  %result.i9.i696 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %326) #48
  store ptr %295, ptr %result.i9.i696, align 8
  %327 = getelementptr inbounds i8, ptr %result.i9.i696, i64 8
  store ptr %297, ptr %327, align 8
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i696)
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %330 = load ptr, ptr %295, align 8
  %331 = getelementptr i8, ptr %330, i64 72
  %332 = load ptr, ptr %331, align 8
  %result.i.i38.i697 = call { i64, i64 } %332(ptr nocapture nofree nonnull readonly align 8 %295) #44
  %333 = extractvalue { i64, i64 } %result.i.i38.i697, 1
  %334 = urem i64 20, %333
  %335 = icmp eq i64 %334, 0
  %reass.sub3224 = sub i64 %333, %334
  %336 = add i64 %reass.sub3224, 20
  %337 = select i1 %335, i64 20, i64 %336
  %338 = getelementptr i8, ptr %result.i9.i696, i64 %337
  %339 = getelementptr i8, ptr %330, i64 64
  %340 = load ptr, ptr %339, align 8
  call void %340({ ptr, i160 } %122, ptr nocapture nofree nonnull readonly align 8 %295, ptr nocapture nofree writeonly %338) #45
  %341 = load ptr, ptr %result.i9.i696, align 8
  %342 = load ptr, ptr %341, align 8
  %343 = getelementptr i8, ptr %342, i64 72
  %344 = load ptr, ptr %343, align 8
  %result.i1.i39.i699 = call { i64, i64 } %344(ptr nocapture nofree nonnull readonly align 8 %341) #44
  %345 = extractvalue { i64, i64 } %result.i1.i39.i699, 0
  %346 = extractvalue { i64, i64 } %result.i1.i39.i699, 1
  %347 = urem i64 20, %346
  %348 = icmp eq i64 %347, 0
  %349 = sub i64 %346, %347
  %350 = select i1 %348, i64 0, i64 %349
  %351 = add i64 %345, 20
  %352 = add i64 %351, %350
  %353 = load ptr, ptr %327, align 8
  %354 = load ptr, ptr %353, align 8
  %355 = getelementptr i8, ptr %354, i64 72
  %356 = load ptr, ptr %355, align 8
  %result.i.i40.i700 = call { i64, i64 } %356(ptr nocapture nofree nonnull readonly align 8 %353) #44
  %357 = extractvalue { i64, i64 } %result.i.i40.i700, 1
  %358 = urem i64 %352, %357
  %359 = icmp eq i64 %358, 0
  %360 = sub i64 %357, %358
  %361 = select i1 %359, i64 0, i64 %360
  %362 = getelementptr i8, ptr %result.i9.i696, i64 %352
  %363 = getelementptr i8, ptr %362, i64 %361
  %364 = getelementptr i8, ptr %354, i64 64
  %365 = load ptr, ptr %364, align 8
  call void %365({ ptr, i160 } %127, ptr nocapture nofree nonnull readonly align 8 %353, ptr nocapture nofree writeonly %363) #45
  %366 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %367 = getelementptr inbounds i8, ptr %result.i9.i696, i64 16
  store i32 %129, ptr %367, align 8
  store ptr @Entry, ptr %266, align 8
  %368 = ptrtoint ptr %result.i9.i696 to i64
  store i64 %368, ptr %268, align 4
  %.sroa_idx30.i701 = getelementptr i8, ptr %266, i64 24
  store i32 10, ptr %.sroa_idx30.i701, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

369:                                              ; preds = %._crit_edge.i689, %271, %240
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %370 = load i32, ptr %106, align 4
  %371 = load i32, ptr %103, align 8
  %.not.i = icmp slt i32 %370, %371
  br i1 %.not.i, label %._crit_edge.i, label %372

372:                                              ; preds = %369
  %373 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %374 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %375 = load ptr, ptr %104, align 8
  %376 = load ptr, ptr %105, align 8
  %377 = shl i32 %371, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %377, i32 noundef 16) #40
  store i32 %spec.select.i, ptr %103, align 8
  %378 = zext nneg i32 %spec.select.i to i64
  %379 = shl nuw nsw i64 %378, 5
  %result.i5.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %379) #48
  store ptr %result.i5.i, ptr %104, align 8
  %result.i4.i718 = call noalias ptr @bump_malloc_wrapper(i64 noundef %379) #48
  store ptr %result.i4.i718, ptr %105, align 8
  store i32 0, ptr %106, align 4
  %380 = icmp sgt i32 %371, 0
  br i1 %380, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %372
  %wide.trip.count.i = zext nneg i32 %371 to i64
  br label %381

381:                                              ; preds = %._crit_edge.i1574, %.lr.ph.i
  %indvars.iv.i1573 = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i1575, %._crit_edge.i1574 ]
  %382 = shl nuw nsw i64 %indvars.iv.i1573, 5
  %383 = getelementptr i8, ptr %375, i64 %382
  %384 = load ptr, ptr %383, align 8
  %385 = icmp ne ptr %384, @nil_typ
  %386 = icmp ne ptr %384, null
  %.not17.i = and i1 %385, %386
  br i1 %.not17.i, label %387, label %._crit_edge.i1574

387:                                              ; preds = %381
  %388 = getelementptr i8, ptr %383, i64 8
  %389 = load i64, ptr %388, align 4
  %.sroa_idx.i1577 = getelementptr i8, ptr %383, i64 16
  %390 = load i64, ptr %.sroa_idx.i1577, align 4
  %hash_coef_ptr.i.i6.i = getelementptr i8, ptr %384, i64 8
  %tbl_size_ptr.i.i7.i = getelementptr i8, ptr %384, i64 16
  %offset_tbl_ptr.i.i8.i = getelementptr i8, ptr %384, i64 40
  %391 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i6.i, align 4, !noalias !62
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i7.i, align 4, !noalias !62
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i8.i, align 8, !noalias !62
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i29.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !62
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %393 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %394 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %395

395:                                              ; preds = %.cont.i2147, %387
  %.0290.i2129 = phi i32 [ 0, %387 ], [ %428, %.cont.i2147 ]
  %.074289.i2130 = phi i1 [ true, %387 ], [ %429, %.cont.i2147 ]
  %.sroa.0.0288.i2131 = phi ptr [ %384, %387 ], [ %418, %.cont.i2147 ]
  %.sroa.6.0287.i2132.in = phi i64 [ %389, %387 ], [ %420, %.cont.i2147 ]
  %.sroa.12.0286.i2133.in = phi i64 [ %390, %387 ], [ %421, %.cont.i2147 ]
  %.sroa.17.0285.i2134 = phi i32 [ %offset.i.i29.i, %387 ], [ %offset.i.i57.i2159, %.cont.i2147 ]
  %.sroa.12.0286.i2133 = inttoptr i64 %.sroa.12.0286.i2133.in to ptr
  %.sroa.6.0287.i2132 = inttoptr i64 %.sroa.6.0287.i2132.in to ptr
  %396 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2131, 0
  %397 = insertvalue { ptr, ptr, ptr, i32 } %396, ptr %.sroa.6.0287.i2132, 1
  %398 = insertvalue { ptr, ptr, ptr, i32 } %397, ptr %.sroa.12.0286.i2133, 2
  %399 = insertvalue { ptr, ptr, ptr, i32 } %398, i32 %.sroa.17.0285.i2134, 3
  %400 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2131)
  %401 = sext i32 %.sroa.17.0285.i2134 to i64
  %402 = getelementptr ptr, ptr %.sroa.0.0288.i2131, i64 %401
  %403 = getelementptr i8, ptr %402, i64 64
  %404 = load ptr, ptr %403, align 8
  %result.i15.i2135 = call ptr %404({ ptr, ptr, ptr, i32 } %399, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %405 = call i32 %result.i15.i2135({ ptr, ptr, ptr, i32 } %399, { ptr, ptr, ptr, i32 } %399, ptr nonnull align 8 %2) #53
  %..i2136 = select i1 %.074289.i2130, ptr %48, ptr %50
  %.188.i2137 = select i1 %.074289.i2130, i64 104, i64 112
  %.189.i2138 = select i1 %.074289.i2130, ptr %49, ptr %51
  %.190.i2139 = select i1 %.074289.i2130, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2136, align 8
  %406 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2136)
  %407 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2137
  %408 = load ptr, ptr %407, align 8
  store ptr @i32_typ, ptr %.189.i2138, align 8
  %result.i14.i2140 = call ptr %408({ ptr, ptr, ptr, i32 } %117, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2138) #46
  %409 = call i32 %result.i14.i2140({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull align 8 dereferenceable(8) %..i2136, i32 %405) #53
  %410 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %411 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2139
  %412 = load ptr, ptr %411, align 8
  %413 = load ptr, ptr %412, align 8
  %414 = call { ptr } %413(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i2141 = extractvalue { ptr } %414, 0
  %415 = sext i32 %409 to i64
  %416 = shl nsw i64 %415, 5
  %417 = getelementptr i8, ptr %.fca.0.extract55.i2141, i64 %416
  %418 = load ptr, ptr %417, align 8
  %419 = getelementptr i8, ptr %417, i64 8
  %420 = load i64, ptr %419, align 4
  %.sroa_idx.i2142 = getelementptr i8, ptr %417, i64 16
  %421 = load i64, ptr %.sroa_idx.i2142, align 4
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %423 = call { ptr } %413(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i2143 = extractvalue { ptr } %423, 0
  %424 = getelementptr i8, ptr %.fca.0.extract52.i2143, i64 %416
  store ptr %.sroa.0.0288.i2131, ptr %424, align 8
  %425 = getelementptr i8, ptr %424, i64 8
  store i64 %.sroa.6.0287.i2132.in, ptr %425, align 4
  %.sroa_idx104.i2144 = getelementptr i8, ptr %424, i64 16
  store i64 %.sroa.12.0286.i2133.in, ptr %.sroa_idx104.i2144, align 4
  %.sroa_idx105.i2145 = getelementptr i8, ptr %424, i64 24
  store i32 %.sroa.17.0285.i2134, ptr %.sroa_idx105.i2145, align 4
  %426 = icmp ne ptr %418, @nil_typ
  %427 = icmp ne ptr %418, null
  %.not94.i2146 = and i1 %426, %427
  br i1 %.not94.i2146, label %.cont.i2147, label %432

.cont.i2147:                                      ; preds = %395
  %428 = add nuw nsw i32 %.0290.i2129, 1
  %429 = xor i1 %.074289.i2130, true
  %hash_coef_ptr.i.i46.i2148 = getelementptr i8, ptr %418, i64 8
  %tbl_size_ptr.i.i47.i2149 = getelementptr i8, ptr %418, i64 16
  %offset_tbl_ptr.i.i48.i2150 = getelementptr i8, ptr %418, i64 40
  %hash_coef.i.i49.i2151 = load i64, ptr %hash_coef_ptr.i.i46.i2148, align 4
  %tbl_size.i.i50.i2152 = load i64, ptr %tbl_size_ptr.i.i47.i2149, align 4
  %offset_tbl.i.i51.i2153 = load ptr, ptr %offset_tbl_ptr.i.i48.i2150, align 8
  %product.i.i.i52.i2154 = mul i64 %hash_coef.i.i49.i2151, 4015701072841558310
  %shifted.i.i.i53.i2155 = lshr i64 %product.i.i.i52.i2154, 32
  %xored.i.i.i54.i2156 = xor i64 %shifted.i.i.i53.i2155, %product.i.i.i52.i2154
  %hash.i.i.i55.i2157 = and i64 %xored.i.i.i54.i2156, %tbl_size.i.i50.i2152
  %offset_ptr.i.i56.i2158 = getelementptr i32, ptr %offset_tbl.i.i51.i2153, i64 %hash.i.i.i55.i2157
  %offset.i.i57.i2159 = load i32, ptr %offset_ptr.i.i56.i2158, align 4
  %430 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %431 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2160 = icmp eq i32 %428, 100
  br i1 %exitcond.not.i2160, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2162, label %395

432:                                              ; preds = %395
  %433 = load i32, ptr %106, align 4
  %434 = add i32 %433, 1
  %435 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %434, ptr %106, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2162

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2162: ; preds = %432, %.cont.i2147
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  br label %._crit_edge.i1574

._crit_edge.i1574:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2162, %381
  %indvars.iv.next.i1575 = add nuw nsw i64 %indvars.iv.i1573, 1
  %exitcond.not.i1576 = icmp eq i64 %indvars.iv.next.i1575, %wide.trip.count.i
  br i1 %exitcond.not.i1576, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit, label %381

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit: ; preds = %._crit_edge.i1596, %._crit_edge.i1574
  %indvars.iv.i1594 = phi i64 [ %indvars.iv.next.i1597, %._crit_edge.i1596 ], [ 0, %._crit_edge.i1574 ]
  %436 = shl nuw nsw i64 %indvars.iv.i1594, 5
  %437 = getelementptr i8, ptr %376, i64 %436
  %438 = load ptr, ptr %437, align 8
  %439 = icmp ne ptr %438, @nil_typ
  %440 = icmp ne ptr %438, null
  %.not17.i1595 = and i1 %439, %440
  br i1 %.not17.i1595, label %441, label %._crit_edge.i1596

441:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %442 = getelementptr i8, ptr %437, i64 8
  %443 = load i64, ptr %442, align 4
  %.sroa_idx.i1599 = getelementptr i8, ptr %437, i64 16
  %444 = load i64, ptr %.sroa_idx.i1599, align 4
  %hash_coef_ptr.i.i6.i1600 = getelementptr i8, ptr %438, i64 8
  %tbl_size_ptr.i.i7.i1601 = getelementptr i8, ptr %438, i64 16
  %offset_tbl_ptr.i.i8.i1602 = getelementptr i8, ptr %438, i64 40
  %445 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  %hash_coef.i.i21.i2180 = load i64, ptr %hash_coef_ptr.i.i6.i1600, align 4, !noalias !65
  %tbl_size.i.i22.i2181 = load i64, ptr %tbl_size_ptr.i.i7.i1601, align 4, !noalias !65
  %offset_tbl.i.i23.i2182 = load ptr, ptr %offset_tbl_ptr.i.i8.i1602, align 8, !noalias !65
  %product.i.i.i24.i2183 = mul i64 %hash_coef.i.i21.i2180, 4015701072841558310
  %shifted.i.i.i25.i2184 = lshr i64 %product.i.i.i24.i2183, 32
  %xored.i.i.i26.i2185 = xor i64 %shifted.i.i.i25.i2184, %product.i.i.i24.i2183
  %hash.i.i.i27.i2186 = and i64 %xored.i.i.i26.i2185, %tbl_size.i.i22.i2181
  %offset_ptr.i.i28.i2187 = getelementptr i32, ptr %offset_tbl.i.i23.i2182, i64 %hash.i.i.i27.i2186
  %offset.i.i29.i2188 = load i32, ptr %offset_ptr.i.i28.i2187, align 4, !noalias !65
  %446 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %447 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %448 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %449

449:                                              ; preds = %.cont.i2211, %441
  %.0290.i2189 = phi i32 [ 0, %441 ], [ %482, %.cont.i2211 ]
  %.074289.i2190 = phi i1 [ true, %441 ], [ %483, %.cont.i2211 ]
  %.sroa.0.0288.i2191 = phi ptr [ %438, %441 ], [ %472, %.cont.i2211 ]
  %.sroa.6.0287.i2192.in = phi i64 [ %443, %441 ], [ %474, %.cont.i2211 ]
  %.sroa.12.0286.i2193.in = phi i64 [ %444, %441 ], [ %475, %.cont.i2211 ]
  %.sroa.17.0285.i2194 = phi i32 [ %offset.i.i29.i2188, %441 ], [ %offset.i.i57.i2223, %.cont.i2211 ]
  %.sroa.12.0286.i2193 = inttoptr i64 %.sroa.12.0286.i2193.in to ptr
  %.sroa.6.0287.i2192 = inttoptr i64 %.sroa.6.0287.i2192.in to ptr
  %450 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2191, 0
  %451 = insertvalue { ptr, ptr, ptr, i32 } %450, ptr %.sroa.6.0287.i2192, 1
  %452 = insertvalue { ptr, ptr, ptr, i32 } %451, ptr %.sroa.12.0286.i2193, 2
  %453 = insertvalue { ptr, ptr, ptr, i32 } %452, i32 %.sroa.17.0285.i2194, 3
  %454 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2191)
  %455 = sext i32 %.sroa.17.0285.i2194 to i64
  %456 = getelementptr ptr, ptr %.sroa.0.0288.i2191, i64 %455
  %457 = getelementptr i8, ptr %456, i64 64
  %458 = load ptr, ptr %457, align 8
  %result.i15.i2195 = call ptr %458({ ptr, ptr, ptr, i32 } %453, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %459 = call i32 %result.i15.i2195({ ptr, ptr, ptr, i32 } %453, { ptr, ptr, ptr, i32 } %453, ptr nonnull align 8 %2) #53
  %..i2196 = select i1 %.074289.i2190, ptr %44, ptr %46
  %.188.i2197 = select i1 %.074289.i2190, i64 104, i64 112
  %.189.i2198 = select i1 %.074289.i2190, ptr %45, ptr %47
  %.190.i2199 = select i1 %.074289.i2190, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2196, align 8
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2196)
  %461 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2197
  %462 = load ptr, ptr %461, align 8
  store ptr @i32_typ, ptr %.189.i2198, align 8
  %result.i14.i2200 = call ptr %462({ ptr, ptr, ptr, i32 } %117, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2198) #46
  %463 = call i32 %result.i14.i2200({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull align 8 dereferenceable(8) %..i2196, i32 %459) #53
  %464 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %465 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2199
  %466 = load ptr, ptr %465, align 8
  %467 = load ptr, ptr %466, align 8
  %468 = call { ptr } %467(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i2201 = extractvalue { ptr } %468, 0
  %469 = sext i32 %463 to i64
  %470 = shl nsw i64 %469, 5
  %471 = getelementptr i8, ptr %.fca.0.extract55.i2201, i64 %470
  %472 = load ptr, ptr %471, align 8
  %473 = getelementptr i8, ptr %471, i64 8
  %474 = load i64, ptr %473, align 4
  %.sroa_idx.i2202 = getelementptr i8, ptr %471, i64 16
  %475 = load i64, ptr %.sroa_idx.i2202, align 4
  %476 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %477 = call { ptr } %467(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i2203 = extractvalue { ptr } %477, 0
  %478 = getelementptr i8, ptr %.fca.0.extract52.i2203, i64 %470
  store ptr %.sroa.0.0288.i2191, ptr %478, align 8
  %479 = getelementptr i8, ptr %478, i64 8
  store i64 %.sroa.6.0287.i2192.in, ptr %479, align 4
  %.sroa_idx104.i2204 = getelementptr i8, ptr %478, i64 16
  store i64 %.sroa.12.0286.i2193.in, ptr %.sroa_idx104.i2204, align 4
  %.sroa_idx105.i2205 = getelementptr i8, ptr %478, i64 24
  store i32 %.sroa.17.0285.i2194, ptr %.sroa_idx105.i2205, align 4
  %480 = icmp ne ptr %472, @nil_typ
  %481 = icmp ne ptr %472, null
  %.not94.i2206 = and i1 %480, %481
  br i1 %.not94.i2206, label %.cont.i2211, label %486

.cont.i2211:                                      ; preds = %449
  %482 = add nuw nsw i32 %.0290.i2189, 1
  %483 = xor i1 %.074289.i2190, true
  %hash_coef_ptr.i.i46.i2212 = getelementptr i8, ptr %472, i64 8
  %tbl_size_ptr.i.i47.i2213 = getelementptr i8, ptr %472, i64 16
  %offset_tbl_ptr.i.i48.i2214 = getelementptr i8, ptr %472, i64 40
  %hash_coef.i.i49.i2215 = load i64, ptr %hash_coef_ptr.i.i46.i2212, align 4
  %tbl_size.i.i50.i2216 = load i64, ptr %tbl_size_ptr.i.i47.i2213, align 4
  %offset_tbl.i.i51.i2217 = load ptr, ptr %offset_tbl_ptr.i.i48.i2214, align 8
  %product.i.i.i52.i2218 = mul i64 %hash_coef.i.i49.i2215, 4015701072841558310
  %shifted.i.i.i53.i2219 = lshr i64 %product.i.i.i52.i2218, 32
  %xored.i.i.i54.i2220 = xor i64 %shifted.i.i.i53.i2219, %product.i.i.i52.i2218
  %hash.i.i.i55.i2221 = and i64 %xored.i.i.i54.i2220, %tbl_size.i.i50.i2216
  %offset_ptr.i.i56.i2222 = getelementptr i32, ptr %offset_tbl.i.i51.i2217, i64 %hash.i.i.i55.i2221
  %offset.i.i57.i2223 = load i32, ptr %offset_ptr.i.i56.i2222, align 4
  %484 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %485 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2224 = icmp eq i32 %482, 100
  br i1 %exitcond.not.i2224, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2233, label %449

486:                                              ; preds = %449
  %487 = load i32, ptr %106, align 4
  %488 = add i32 %487, 1
  %489 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %488, ptr %106, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2233

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2233: ; preds = %486, %.cont.i2211
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  br label %._crit_edge.i1596

._crit_edge.i1596:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2233, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %indvars.iv.next.i1597 = add nuw nsw i64 %indvars.iv.i1594, 1
  %exitcond.not.i1598 = icmp eq i64 %indvars.iv.next.i1597, %wide.trip.count.i
  br i1 %exitcond.not.i1598, label %._crit_edge.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit

._crit_edge.i:                                    ; preds = %._crit_edge.i1596, %372, %369
  %490 = load ptr, ptr %result.i55, align 8
  %491 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %492 = load ptr, ptr %96, align 8
  %493 = load ptr, ptr %490, align 8
  %494 = getelementptr i8, ptr %493, i64 72
  %495 = load ptr, ptr %494, align 8
  %result.i1.i.i262 = call { i64, i64 } %495(ptr nocapture nofree nonnull readonly align 8 %490) #44
  %496 = extractvalue { i64, i64 } %result.i1.i.i262, 0
  %497 = extractvalue { i64, i64 } %result.i1.i.i262, 1
  %498 = urem i64 20, %497
  %499 = icmp eq i64 %498, 0
  %500 = sub i64 %497, %498
  %501 = select i1 %499, i64 0, i64 %500
  %502 = add i64 %496, 20
  %503 = add i64 %502, %501
  %504 = load ptr, ptr %492, align 8
  %505 = getelementptr i8, ptr %504, i64 72
  %506 = load ptr, ptr %505, align 8
  %result.i.i.i263 = call { i64, i64 } %506(ptr nocapture nofree nonnull readonly align 8 %492) #44
  %507 = extractvalue { i64, i64 } %result.i.i.i263, 0
  %508 = extractvalue { i64, i64 } %result.i.i.i263, 1
  %509 = call i64 @llvm.umax.i64(i64 %497, i64 %508) #41
  %510 = call i64 @llvm.umax.i64(i64 %509, i64 noundef 8) #41, !range !16
  %511 = urem i64 %503, %508
  %512 = icmp eq i64 %511, 0
  %513 = sub i64 %508, %511
  %514 = select i1 %512, i64 0, i64 %513
  %515 = add i64 %507, %503
  %516 = add i64 %515, %514
  %517 = urem i64 %516, %510
  %518 = icmp eq i64 %517, 0
  %519 = sub i64 %510, %517
  %520 = select i1 %518, i64 0, i64 %519
  %521 = add i64 %520, %516
  %result.i22.i264 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %521) #48
  store ptr %490, ptr %result.i22.i264, align 8
  %522 = getelementptr inbounds i8, ptr %result.i22.i264, i64 8
  store ptr %492, ptr %522, align 8
  %523 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i264)
  %524 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %525 = load ptr, ptr %490, align 8
  %526 = getelementptr i8, ptr %525, i64 72
  %527 = load ptr, ptr %526, align 8
  %result.i.i127.i = call { i64, i64 } %527(ptr nocapture nofree nonnull readonly align 8 %490) #44
  %528 = extractvalue { i64, i64 } %result.i.i127.i, 1
  %529 = urem i64 20, %528
  %530 = icmp eq i64 %529, 0
  %reass.sub3223 = sub i64 %528, %529
  %531 = add i64 %reass.sub3223, 20
  %532 = select i1 %530, i64 20, i64 %531
  %533 = getelementptr i8, ptr %result.i22.i264, i64 %532
  %534 = getelementptr i8, ptr %525, i64 64
  %535 = load ptr, ptr %534, align 8
  call void %535({ ptr, i160 } %122, ptr nocapture nofree nonnull readonly align 8 %490, ptr nocapture nofree writeonly %533) #45
  %536 = load ptr, ptr %result.i22.i264, align 8
  %537 = load ptr, ptr %536, align 8
  %538 = getelementptr i8, ptr %537, i64 72
  %539 = load ptr, ptr %538, align 8
  %result.i1.i128.i = call { i64, i64 } %539(ptr nocapture nofree nonnull readonly align 8 %536) #44
  %540 = extractvalue { i64, i64 } %result.i1.i128.i, 0
  %541 = extractvalue { i64, i64 } %result.i1.i128.i, 1
  %542 = urem i64 20, %541
  %543 = icmp eq i64 %542, 0
  %544 = sub i64 %541, %542
  %545 = select i1 %543, i64 0, i64 %544
  %546 = add i64 %540, 20
  %547 = add i64 %546, %545
  %548 = load ptr, ptr %522, align 8
  %549 = load ptr, ptr %548, align 8
  %550 = getelementptr i8, ptr %549, i64 72
  %551 = load ptr, ptr %550, align 8
  %result.i.i129.i = call { i64, i64 } %551(ptr nocapture nofree nonnull readonly align 8 %548) #44
  %552 = extractvalue { i64, i64 } %result.i.i129.i, 1
  %553 = urem i64 %547, %552
  %554 = icmp eq i64 %553, 0
  %555 = sub i64 %552, %553
  %556 = select i1 %554, i64 0, i64 %555
  %557 = getelementptr i8, ptr %result.i22.i264, i64 %547
  %558 = getelementptr i8, ptr %557, i64 %556
  %559 = getelementptr i8, ptr %549, i64 64
  %560 = load ptr, ptr %559, align 8
  call void %560({ ptr, i160 } %127, ptr nocapture nofree nonnull readonly align 8 %548, ptr nocapture nofree writeonly %558) #45
  %561 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %562 = getelementptr inbounds i8, ptr %result.i22.i264, i64 16
  store i32 %129, ptr %562, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %563 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %564 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %565 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %566

566:                                              ; preds = %.cont.i, %._crit_edge.i
  %.0290.i = phi i32 [ 0, %._crit_edge.i ], [ %601, %.cont.i ]
  %.074289.i = phi i1 [ true, %._crit_edge.i ], [ %602, %.cont.i ]
  %.sroa.0.0288.i = phi ptr [ @Entry, %._crit_edge.i ], [ %589, %.cont.i ]
  %.sroa.6.0287.i = phi ptr [ %result.i22.i264, %._crit_edge.i ], [ %603, %.cont.i ]
  %.sroa.12.0286.i = phi ptr [ undef, %._crit_edge.i ], [ %604, %.cont.i ]
  %.sroa.17.0285.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i57.i, %.cont.i ]
  %567 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i, 0
  %568 = insertvalue { ptr, ptr, ptr, i32 } %567, ptr %.sroa.6.0287.i, 1
  %569 = insertvalue { ptr, ptr, ptr, i32 } %568, ptr %.sroa.12.0286.i, 2
  %570 = insertvalue { ptr, ptr, ptr, i32 } %569, i32 %.sroa.17.0285.i, 3
  %571 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i)
  %572 = sext i32 %.sroa.17.0285.i to i64
  %573 = getelementptr ptr, ptr %.sroa.0.0288.i, i64 %572
  %574 = getelementptr i8, ptr %573, i64 64
  %575 = load ptr, ptr %574, align 8
  %result.i15.i = call ptr %575({ ptr, ptr, ptr, i32 } %570, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %576 = call i32 %result.i15.i({ ptr, ptr, ptr, i32 } %570, { ptr, ptr, ptr, i32 } %570, ptr nonnull align 8 %2) #53
  %..i = select i1 %.074289.i, ptr %64, ptr %66
  %.188.i = select i1 %.074289.i, i64 104, i64 112
  %.189.i = select i1 %.074289.i, ptr %65, ptr %67
  %.190.i = select i1 %.074289.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i, align 8
  %577 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i)
  %578 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i
  %579 = load ptr, ptr %578, align 8
  store ptr @i32_typ, ptr %.189.i, align 8
  %result.i14.i = call ptr %579({ ptr, ptr, ptr, i32 } %116, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i) #46
  %580 = call i32 %result.i14.i({ ptr, ptr, ptr, i32 } %116, { ptr, ptr, ptr, i32 } %116, ptr nonnull align 8 dereferenceable(8) %..i, i32 %576) #53
  %581 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %582 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i
  %583 = load ptr, ptr %582, align 8
  %584 = load ptr, ptr %583, align 8
  %585 = call { ptr } %584(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i = extractvalue { ptr } %585, 0
  %586 = sext i32 %580 to i64
  %587 = shl nsw i64 %586, 5
  %588 = getelementptr i8, ptr %.fca.0.extract55.i, i64 %587
  %589 = load ptr, ptr %588, align 8
  %590 = getelementptr i8, ptr %588, i64 8
  %591 = load i64, ptr %590, align 4
  %.sroa_idx.i737 = getelementptr i8, ptr %588, i64 16
  %592 = load i64, ptr %.sroa_idx.i737, align 4
  %593 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %594 = call { ptr } %584(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i = extractvalue { ptr } %594, 0
  %595 = getelementptr i8, ptr %.fca.0.extract52.i, i64 %587
  store ptr %.sroa.0.0288.i, ptr %595, align 8
  %596 = getelementptr i8, ptr %595, i64 8
  %597 = ptrtoint ptr %.sroa.6.0287.i to i64
  %598 = ptrtoint ptr %.sroa.12.0286.i to i64
  store i64 %597, ptr %596, align 4
  %.sroa_idx104.i = getelementptr i8, ptr %595, i64 16
  store i64 %598, ptr %.sroa_idx104.i, align 4
  %.sroa_idx105.i = getelementptr i8, ptr %595, i64 24
  store i32 %.sroa.17.0285.i, ptr %.sroa_idx105.i, align 4
  %599 = icmp ne ptr %589, @nil_typ
  %600 = icmp ne ptr %589, null
  %.not94.i = and i1 %599, %600
  br i1 %.not94.i, label %.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

.cont.i:                                          ; preds = %566
  %601 = add nuw nsw i32 %.0290.i, 1
  %602 = xor i1 %.074289.i, true
  %603 = inttoptr i64 %591 to ptr
  %604 = inttoptr i64 %592 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %589, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %589, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %589, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4
  %605 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %606 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i = icmp eq i32 %601, 100
  br i1 %exitcond.not.i, label %610, label %566

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %566
  %607 = load i32, ptr %106, align 4
  %608 = add i32 %607, 1
  %609 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %608, ptr %106, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  br label %CuckooMap_insert_keyK_valueV.exit

610:                                              ; preds = %.cont.i
  %hash_coef_ptr.i.i46.i.le = getelementptr i8, ptr %589, i64 8
  %tbl_size_ptr.i.i47.i.le = getelementptr i8, ptr %589, i64 16
  %offset_tbl_ptr.i.i48.i.le = getelementptr i8, ptr %589, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %612 = load ptr, ptr %104, align 8
  %613 = load ptr, ptr %105, align 8
  %614 = load i32, ptr %103, align 8
  %615 = shl i32 %614, 1
  %spec.select.i755 = call i32 @llvm.smax.i32(i32 %615, i32 noundef 16) #40
  store i32 %spec.select.i755, ptr %103, align 8
  %616 = zext nneg i32 %spec.select.i755 to i64
  %617 = shl nuw nsw i64 %616, 5
  %result.i5.i756 = call noalias ptr @bump_malloc_wrapper(i64 noundef %617) #48
  store ptr %result.i5.i756, ptr %104, align 8
  %result.i4.i757 = call noalias ptr @bump_malloc_wrapper(i64 noundef %617) #48
  store ptr %result.i4.i757, ptr %105, align 8
  store i32 0, ptr %106, align 4
  %618 = icmp sgt i32 %614, 0
  br i1 %618, label %.lr.ph.i1618, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692

.lr.ph.i1618:                                     ; preds = %610
  %wide.trip.count.i1631 = zext nneg i32 %614 to i64
  br label %619

619:                                              ; preds = %._crit_edge.i1634, %.lr.ph.i1618
  %indvars.iv.i1632 = phi i64 [ 0, %.lr.ph.i1618 ], [ %indvars.iv.next.i1635, %._crit_edge.i1634 ]
  %620 = shl nuw nsw i64 %indvars.iv.i1632, 5
  %621 = getelementptr i8, ptr %612, i64 %620
  %622 = load ptr, ptr %621, align 8
  %623 = icmp ne ptr %622, @nil_typ
  %624 = icmp ne ptr %622, null
  %.not17.i1633 = and i1 %623, %624
  br i1 %.not17.i1633, label %625, label %._crit_edge.i1634

625:                                              ; preds = %619
  %626 = getelementptr i8, ptr %621, i64 8
  %627 = load i64, ptr %626, align 4
  %.sroa_idx.i1637 = getelementptr i8, ptr %621, i64 16
  %628 = load i64, ptr %.sroa_idx.i1637, align 4
  %hash_coef_ptr.i.i6.i1638 = getelementptr i8, ptr %622, i64 8
  %tbl_size_ptr.i.i7.i1639 = getelementptr i8, ptr %622, i64 16
  %offset_tbl_ptr.i.i8.i1640 = getelementptr i8, ptr %622, i64 40
  %629 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  %hash_coef.i.i21.i2251 = load i64, ptr %hash_coef_ptr.i.i6.i1638, align 4, !noalias !68
  %tbl_size.i.i22.i2252 = load i64, ptr %tbl_size_ptr.i.i7.i1639, align 4, !noalias !68
  %offset_tbl.i.i23.i2253 = load ptr, ptr %offset_tbl_ptr.i.i8.i1640, align 8, !noalias !68
  %product.i.i.i24.i2254 = mul i64 %hash_coef.i.i21.i2251, 4015701072841558310
  %shifted.i.i.i25.i2255 = lshr i64 %product.i.i.i24.i2254, 32
  %xored.i.i.i26.i2256 = xor i64 %shifted.i.i.i25.i2255, %product.i.i.i24.i2254
  %hash.i.i.i27.i2257 = and i64 %xored.i.i.i26.i2256, %tbl_size.i.i22.i2252
  %offset_ptr.i.i28.i2258 = getelementptr i32, ptr %offset_tbl.i.i23.i2253, i64 %hash.i.i.i27.i2257
  %offset.i.i29.i2259 = load i32, ptr %offset_ptr.i.i28.i2258, align 4, !noalias !68
  %630 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %631 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %632 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %633

633:                                              ; preds = %.cont.i2282, %625
  %.0290.i2260 = phi i32 [ 0, %625 ], [ %666, %.cont.i2282 ]
  %.074289.i2261 = phi i1 [ true, %625 ], [ %667, %.cont.i2282 ]
  %.sroa.0.0288.i2262 = phi ptr [ %622, %625 ], [ %656, %.cont.i2282 ]
  %.sroa.6.0287.i2263.in = phi i64 [ %627, %625 ], [ %658, %.cont.i2282 ]
  %.sroa.12.0286.i2264.in = phi i64 [ %628, %625 ], [ %659, %.cont.i2282 ]
  %.sroa.17.0285.i2265 = phi i32 [ %offset.i.i29.i2259, %625 ], [ %offset.i.i57.i2294, %.cont.i2282 ]
  %.sroa.12.0286.i2264 = inttoptr i64 %.sroa.12.0286.i2264.in to ptr
  %.sroa.6.0287.i2263 = inttoptr i64 %.sroa.6.0287.i2263.in to ptr
  %634 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2262, 0
  %635 = insertvalue { ptr, ptr, ptr, i32 } %634, ptr %.sroa.6.0287.i2263, 1
  %636 = insertvalue { ptr, ptr, ptr, i32 } %635, ptr %.sroa.12.0286.i2264, 2
  %637 = insertvalue { ptr, ptr, ptr, i32 } %636, i32 %.sroa.17.0285.i2265, 3
  %638 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2262)
  %639 = sext i32 %.sroa.17.0285.i2265 to i64
  %640 = getelementptr ptr, ptr %.sroa.0.0288.i2262, i64 %639
  %641 = getelementptr i8, ptr %640, i64 64
  %642 = load ptr, ptr %641, align 8
  %result.i15.i2266 = call ptr %642({ ptr, ptr, ptr, i32 } %637, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %643 = call i32 %result.i15.i2266({ ptr, ptr, ptr, i32 } %637, { ptr, ptr, ptr, i32 } %637, ptr nonnull align 8 %2) #53
  %..i2267 = select i1 %.074289.i2261, ptr %40, ptr %42
  %.188.i2268 = select i1 %.074289.i2261, i64 104, i64 112
  %.189.i2269 = select i1 %.074289.i2261, ptr %41, ptr %43
  %.190.i2270 = select i1 %.074289.i2261, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2267, align 8
  %644 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2267)
  %645 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2268
  %646 = load ptr, ptr %645, align 8
  store ptr @i32_typ, ptr %.189.i2269, align 8
  %result.i14.i2271 = call ptr %646({ ptr, ptr, ptr, i32 } %117, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2269) #46
  %647 = call i32 %result.i14.i2271({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull align 8 dereferenceable(8) %..i2267, i32 %643) #53
  %648 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %649 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2270
  %650 = load ptr, ptr %649, align 8
  %651 = load ptr, ptr %650, align 8
  %652 = call { ptr } %651(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i2272 = extractvalue { ptr } %652, 0
  %653 = sext i32 %647 to i64
  %654 = shl nsw i64 %653, 5
  %655 = getelementptr i8, ptr %.fca.0.extract55.i2272, i64 %654
  %656 = load ptr, ptr %655, align 8
  %657 = getelementptr i8, ptr %655, i64 8
  %658 = load i64, ptr %657, align 4
  %.sroa_idx.i2273 = getelementptr i8, ptr %655, i64 16
  %659 = load i64, ptr %.sroa_idx.i2273, align 4
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %661 = call { ptr } %651(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i2274 = extractvalue { ptr } %661, 0
  %662 = getelementptr i8, ptr %.fca.0.extract52.i2274, i64 %654
  store ptr %.sroa.0.0288.i2262, ptr %662, align 8
  %663 = getelementptr i8, ptr %662, i64 8
  store i64 %.sroa.6.0287.i2263.in, ptr %663, align 4
  %.sroa_idx104.i2275 = getelementptr i8, ptr %662, i64 16
  store i64 %.sroa.12.0286.i2264.in, ptr %.sroa_idx104.i2275, align 4
  %.sroa_idx105.i2276 = getelementptr i8, ptr %662, i64 24
  store i32 %.sroa.17.0285.i2265, ptr %.sroa_idx105.i2276, align 4
  %664 = icmp ne ptr %656, @nil_typ
  %665 = icmp ne ptr %656, null
  %.not94.i2277 = and i1 %664, %665
  br i1 %.not94.i2277, label %.cont.i2282, label %670

.cont.i2282:                                      ; preds = %633
  %666 = add nuw nsw i32 %.0290.i2260, 1
  %667 = xor i1 %.074289.i2261, true
  %hash_coef_ptr.i.i46.i2283 = getelementptr i8, ptr %656, i64 8
  %tbl_size_ptr.i.i47.i2284 = getelementptr i8, ptr %656, i64 16
  %offset_tbl_ptr.i.i48.i2285 = getelementptr i8, ptr %656, i64 40
  %hash_coef.i.i49.i2286 = load i64, ptr %hash_coef_ptr.i.i46.i2283, align 4
  %tbl_size.i.i50.i2287 = load i64, ptr %tbl_size_ptr.i.i47.i2284, align 4
  %offset_tbl.i.i51.i2288 = load ptr, ptr %offset_tbl_ptr.i.i48.i2285, align 8
  %product.i.i.i52.i2289 = mul i64 %hash_coef.i.i49.i2286, 4015701072841558310
  %shifted.i.i.i53.i2290 = lshr i64 %product.i.i.i52.i2289, 32
  %xored.i.i.i54.i2291 = xor i64 %shifted.i.i.i53.i2290, %product.i.i.i52.i2289
  %hash.i.i.i55.i2292 = and i64 %xored.i.i.i54.i2291, %tbl_size.i.i50.i2287
  %offset_ptr.i.i56.i2293 = getelementptr i32, ptr %offset_tbl.i.i51.i2288, i64 %hash.i.i.i55.i2292
  %offset.i.i57.i2294 = load i32, ptr %offset_ptr.i.i56.i2293, align 4
  %668 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %669 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2295 = icmp eq i32 %666, 100
  br i1 %exitcond.not.i2295, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2304, label %633

670:                                              ; preds = %633
  %671 = load i32, ptr %106, align 4
  %672 = add i32 %671, 1
  %673 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %672, ptr %106, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2304

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2304: ; preds = %670, %.cont.i2282
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  br label %._crit_edge.i1634

._crit_edge.i1634:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2304, %619
  %indvars.iv.next.i1635 = add nuw nsw i64 %indvars.iv.i1632, 1
  %exitcond.not.i1636 = icmp eq i64 %indvars.iv.next.i1635, %wide.trip.count.i1631
  br i1 %exitcond.not.i1636, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1654, label %619

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1654: ; preds = %._crit_edge.i1672, %._crit_edge.i1634
  %indvars.iv.i1670 = phi i64 [ %indvars.iv.next.i1673, %._crit_edge.i1672 ], [ 0, %._crit_edge.i1634 ]
  %674 = shl nuw nsw i64 %indvars.iv.i1670, 5
  %675 = getelementptr i8, ptr %613, i64 %674
  %676 = load ptr, ptr %675, align 8
  %677 = icmp ne ptr %676, @nil_typ
  %678 = icmp ne ptr %676, null
  %.not17.i1671 = and i1 %677, %678
  br i1 %.not17.i1671, label %679, label %._crit_edge.i1672

679:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1654
  %680 = getelementptr i8, ptr %675, i64 8
  %681 = load i64, ptr %680, align 4
  %.sroa_idx.i1675 = getelementptr i8, ptr %675, i64 16
  %682 = load i64, ptr %.sroa_idx.i1675, align 4
  %hash_coef_ptr.i.i6.i1676 = getelementptr i8, ptr %676, i64 8
  %tbl_size_ptr.i.i7.i1677 = getelementptr i8, ptr %676, i64 16
  %offset_tbl_ptr.i.i8.i1678 = getelementptr i8, ptr %676, i64 40
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  %hash_coef.i.i21.i2322 = load i64, ptr %hash_coef_ptr.i.i6.i1676, align 4, !noalias !71
  %tbl_size.i.i22.i2323 = load i64, ptr %tbl_size_ptr.i.i7.i1677, align 4, !noalias !71
  %offset_tbl.i.i23.i2324 = load ptr, ptr %offset_tbl_ptr.i.i8.i1678, align 8, !noalias !71
  %product.i.i.i24.i2325 = mul i64 %hash_coef.i.i21.i2322, 4015701072841558310
  %shifted.i.i.i25.i2326 = lshr i64 %product.i.i.i24.i2325, 32
  %xored.i.i.i26.i2327 = xor i64 %shifted.i.i.i25.i2326, %product.i.i.i24.i2325
  %hash.i.i.i27.i2328 = and i64 %xored.i.i.i26.i2327, %tbl_size.i.i22.i2323
  %offset_ptr.i.i28.i2329 = getelementptr i32, ptr %offset_tbl.i.i23.i2324, i64 %hash.i.i.i27.i2328
  %offset.i.i29.i2330 = load i32, ptr %offset_ptr.i.i28.i2329, align 4, !noalias !71
  %684 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %685 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %686 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %687

687:                                              ; preds = %.cont.i2353, %679
  %.0290.i2331 = phi i32 [ 0, %679 ], [ %720, %.cont.i2353 ]
  %.074289.i2332 = phi i1 [ true, %679 ], [ %721, %.cont.i2353 ]
  %.sroa.0.0288.i2333 = phi ptr [ %676, %679 ], [ %710, %.cont.i2353 ]
  %.sroa.6.0287.i2334.in = phi i64 [ %681, %679 ], [ %712, %.cont.i2353 ]
  %.sroa.12.0286.i2335.in = phi i64 [ %682, %679 ], [ %713, %.cont.i2353 ]
  %.sroa.17.0285.i2336 = phi i32 [ %offset.i.i29.i2330, %679 ], [ %offset.i.i57.i2365, %.cont.i2353 ]
  %.sroa.12.0286.i2335 = inttoptr i64 %.sroa.12.0286.i2335.in to ptr
  %.sroa.6.0287.i2334 = inttoptr i64 %.sroa.6.0287.i2334.in to ptr
  %688 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2333, 0
  %689 = insertvalue { ptr, ptr, ptr, i32 } %688, ptr %.sroa.6.0287.i2334, 1
  %690 = insertvalue { ptr, ptr, ptr, i32 } %689, ptr %.sroa.12.0286.i2335, 2
  %691 = insertvalue { ptr, ptr, ptr, i32 } %690, i32 %.sroa.17.0285.i2336, 3
  %692 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2333)
  %693 = sext i32 %.sroa.17.0285.i2336 to i64
  %694 = getelementptr ptr, ptr %.sroa.0.0288.i2333, i64 %693
  %695 = getelementptr i8, ptr %694, i64 64
  %696 = load ptr, ptr %695, align 8
  %result.i15.i2337 = call ptr %696({ ptr, ptr, ptr, i32 } %691, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %697 = call i32 %result.i15.i2337({ ptr, ptr, ptr, i32 } %691, { ptr, ptr, ptr, i32 } %691, ptr nonnull align 8 %2) #53
  %..i2338 = select i1 %.074289.i2332, ptr %36, ptr %38
  %.188.i2339 = select i1 %.074289.i2332, i64 104, i64 112
  %.189.i2340 = select i1 %.074289.i2332, ptr %37, ptr %39
  %.190.i2341 = select i1 %.074289.i2332, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2338, align 8
  %698 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2338)
  %699 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2339
  %700 = load ptr, ptr %699, align 8
  store ptr @i32_typ, ptr %.189.i2340, align 8
  %result.i14.i2342 = call ptr %700({ ptr, ptr, ptr, i32 } %117, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2340) #46
  %701 = call i32 %result.i14.i2342({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull align 8 dereferenceable(8) %..i2338, i32 %697) #53
  %702 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %703 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2341
  %704 = load ptr, ptr %703, align 8
  %705 = load ptr, ptr %704, align 8
  %706 = call { ptr } %705(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i2343 = extractvalue { ptr } %706, 0
  %707 = sext i32 %701 to i64
  %708 = shl nsw i64 %707, 5
  %709 = getelementptr i8, ptr %.fca.0.extract55.i2343, i64 %708
  %710 = load ptr, ptr %709, align 8
  %711 = getelementptr i8, ptr %709, i64 8
  %712 = load i64, ptr %711, align 4
  %.sroa_idx.i2344 = getelementptr i8, ptr %709, i64 16
  %713 = load i64, ptr %.sroa_idx.i2344, align 4
  %714 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %715 = call { ptr } %705(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i2345 = extractvalue { ptr } %715, 0
  %716 = getelementptr i8, ptr %.fca.0.extract52.i2345, i64 %708
  store ptr %.sroa.0.0288.i2333, ptr %716, align 8
  %717 = getelementptr i8, ptr %716, i64 8
  store i64 %.sroa.6.0287.i2334.in, ptr %717, align 4
  %.sroa_idx104.i2346 = getelementptr i8, ptr %716, i64 16
  store i64 %.sroa.12.0286.i2335.in, ptr %.sroa_idx104.i2346, align 4
  %.sroa_idx105.i2347 = getelementptr i8, ptr %716, i64 24
  store i32 %.sroa.17.0285.i2336, ptr %.sroa_idx105.i2347, align 4
  %718 = icmp ne ptr %710, @nil_typ
  %719 = icmp ne ptr %710, null
  %.not94.i2348 = and i1 %718, %719
  br i1 %.not94.i2348, label %.cont.i2353, label %724

.cont.i2353:                                      ; preds = %687
  %720 = add nuw nsw i32 %.0290.i2331, 1
  %721 = xor i1 %.074289.i2332, true
  %hash_coef_ptr.i.i46.i2354 = getelementptr i8, ptr %710, i64 8
  %tbl_size_ptr.i.i47.i2355 = getelementptr i8, ptr %710, i64 16
  %offset_tbl_ptr.i.i48.i2356 = getelementptr i8, ptr %710, i64 40
  %hash_coef.i.i49.i2357 = load i64, ptr %hash_coef_ptr.i.i46.i2354, align 4
  %tbl_size.i.i50.i2358 = load i64, ptr %tbl_size_ptr.i.i47.i2355, align 4
  %offset_tbl.i.i51.i2359 = load ptr, ptr %offset_tbl_ptr.i.i48.i2356, align 8
  %product.i.i.i52.i2360 = mul i64 %hash_coef.i.i49.i2357, 4015701072841558310
  %shifted.i.i.i53.i2361 = lshr i64 %product.i.i.i52.i2360, 32
  %xored.i.i.i54.i2362 = xor i64 %shifted.i.i.i53.i2361, %product.i.i.i52.i2360
  %hash.i.i.i55.i2363 = and i64 %xored.i.i.i54.i2362, %tbl_size.i.i50.i2358
  %offset_ptr.i.i56.i2364 = getelementptr i32, ptr %offset_tbl.i.i51.i2359, i64 %hash.i.i.i55.i2363
  %offset.i.i57.i2365 = load i32, ptr %offset_ptr.i.i56.i2364, align 4
  %722 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %723 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2366 = icmp eq i32 %720, 100
  br i1 %exitcond.not.i2366, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2375, label %687

724:                                              ; preds = %687
  %725 = load i32, ptr %106, align 4
  %726 = add i32 %725, 1
  %727 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %726, ptr %106, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2375

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2375: ; preds = %724, %.cont.i2353
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  br label %._crit_edge.i1672

._crit_edge.i1672:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2375, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1654
  %indvars.iv.next.i1673 = add nuw nsw i64 %indvars.iv.i1670, 1
  %exitcond.not.i1674 = icmp eq i64 %indvars.iv.next.i1673, %wide.trip.count.i1631
  br i1 %exitcond.not.i1674, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1654

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692: ; preds = %._crit_edge.i1672, %610
  %728 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  %hash_coef.i.i21.i781 = load i64, ptr %hash_coef_ptr.i.i46.i.le, align 4, !noalias !74
  %tbl_size.i.i22.i782 = load i64, ptr %tbl_size_ptr.i.i47.i.le, align 4, !noalias !74
  %offset_tbl.i.i23.i783 = load ptr, ptr %offset_tbl_ptr.i.i48.i.le, align 8, !noalias !74
  %product.i.i.i24.i784 = mul i64 %hash_coef.i.i21.i781, 4015701072841558310
  %shifted.i.i.i25.i785 = lshr i64 %product.i.i.i24.i784, 32
  %xored.i.i.i26.i786 = xor i64 %shifted.i.i.i25.i785, %product.i.i.i24.i784
  %hash.i.i.i27.i787 = and i64 %xored.i.i.i26.i786, %tbl_size.i.i22.i782
  %offset_ptr.i.i28.i788 = getelementptr i32, ptr %offset_tbl.i.i23.i783, i64 %hash.i.i.i27.i787
  %offset.i.i29.i789 = load i32, ptr %offset_ptr.i.i28.i788, align 4, !noalias !74
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %730 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %731 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %732

732:                                              ; preds = %.cont.i813, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692
  %.0290.i791 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692 ], [ %765, %.cont.i813 ]
  %.074289.i792 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692 ], [ %766, %.cont.i813 ]
  %.sroa.0.0288.i793 = phi ptr [ %589, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692 ], [ %755, %.cont.i813 ]
  %.sroa.6.0287.i794.in = phi i64 [ %591, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692 ], [ %757, %.cont.i813 ]
  %.sroa.12.0286.i795.in = phi i64 [ %592, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692 ], [ %758, %.cont.i813 ]
  %.sroa.17.0285.i796 = phi i32 [ %offset.i.i29.i789, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1692 ], [ %offset.i.i57.i825, %.cont.i813 ]
  %.sroa.12.0286.i795 = inttoptr i64 %.sroa.12.0286.i795.in to ptr
  %.sroa.6.0287.i794 = inttoptr i64 %.sroa.6.0287.i794.in to ptr
  %733 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i793, 0
  %734 = insertvalue { ptr, ptr, ptr, i32 } %733, ptr %.sroa.6.0287.i794, 1
  %735 = insertvalue { ptr, ptr, ptr, i32 } %734, ptr %.sroa.12.0286.i795, 2
  %736 = insertvalue { ptr, ptr, ptr, i32 } %735, i32 %.sroa.17.0285.i796, 3
  %737 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i793)
  %738 = sext i32 %.sroa.17.0285.i796 to i64
  %739 = getelementptr ptr, ptr %.sroa.0.0288.i793, i64 %738
  %740 = getelementptr i8, ptr %739, i64 64
  %741 = load ptr, ptr %740, align 8
  %result.i15.i797 = call ptr %741({ ptr, ptr, ptr, i32 } %736, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %742 = call i32 %result.i15.i797({ ptr, ptr, ptr, i32 } %736, { ptr, ptr, ptr, i32 } %736, ptr nonnull align 8 %2) #53
  %..i798 = select i1 %.074289.i792, ptr %60, ptr %62
  %.188.i799 = select i1 %.074289.i792, i64 104, i64 112
  %.189.i800 = select i1 %.074289.i792, ptr %61, ptr %63
  %.190.i801 = select i1 %.074289.i792, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i798, align 8
  %743 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i798)
  %744 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i799
  %745 = load ptr, ptr %744, align 8
  store ptr @i32_typ, ptr %.189.i800, align 8
  %result.i14.i802 = call ptr %745({ ptr, ptr, ptr, i32 } %116, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i800) #46
  %746 = call i32 %result.i14.i802({ ptr, ptr, ptr, i32 } %116, { ptr, ptr, ptr, i32 } %116, ptr nonnull align 8 dereferenceable(8) %..i798, i32 %742) #53
  %747 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %748 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i801
  %749 = load ptr, ptr %748, align 8
  %750 = load ptr, ptr %749, align 8
  %751 = call { ptr } %750(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i803 = extractvalue { ptr } %751, 0
  %752 = sext i32 %746 to i64
  %753 = shl nsw i64 %752, 5
  %754 = getelementptr i8, ptr %.fca.0.extract55.i803, i64 %753
  %755 = load ptr, ptr %754, align 8
  %756 = getelementptr i8, ptr %754, i64 8
  %757 = load i64, ptr %756, align 4
  %.sroa_idx.i804 = getelementptr i8, ptr %754, i64 16
  %758 = load i64, ptr %.sroa_idx.i804, align 4
  %759 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %760 = call { ptr } %750(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i805 = extractvalue { ptr } %760, 0
  %761 = getelementptr i8, ptr %.fca.0.extract52.i805, i64 %753
  store ptr %.sroa.0.0288.i793, ptr %761, align 8
  %762 = getelementptr i8, ptr %761, i64 8
  store i64 %.sroa.6.0287.i794.in, ptr %762, align 4
  %.sroa_idx104.i806 = getelementptr i8, ptr %761, i64 16
  store i64 %.sroa.12.0286.i795.in, ptr %.sroa_idx104.i806, align 4
  %.sroa_idx105.i807 = getelementptr i8, ptr %761, i64 24
  store i32 %.sroa.17.0285.i796, ptr %.sroa_idx105.i807, align 4
  %763 = icmp ne ptr %755, @nil_typ
  %764 = icmp ne ptr %755, null
  %.not94.i808 = and i1 %763, %764
  br i1 %.not94.i808, label %.cont.i813, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit835

.cont.i813:                                       ; preds = %732
  %765 = add nuw nsw i32 %.0290.i791, 1
  %766 = xor i1 %.074289.i792, true
  %hash_coef_ptr.i.i46.i814 = getelementptr i8, ptr %755, i64 8
  %tbl_size_ptr.i.i47.i815 = getelementptr i8, ptr %755, i64 16
  %offset_tbl_ptr.i.i48.i816 = getelementptr i8, ptr %755, i64 40
  %hash_coef.i.i49.i817 = load i64, ptr %hash_coef_ptr.i.i46.i814, align 4
  %tbl_size.i.i50.i818 = load i64, ptr %tbl_size_ptr.i.i47.i815, align 4
  %offset_tbl.i.i51.i819 = load ptr, ptr %offset_tbl_ptr.i.i48.i816, align 8
  %product.i.i.i52.i820 = mul i64 %hash_coef.i.i49.i817, 4015701072841558310
  %shifted.i.i.i53.i821 = lshr i64 %product.i.i.i52.i820, 32
  %xored.i.i.i54.i822 = xor i64 %shifted.i.i.i53.i821, %product.i.i.i52.i820
  %hash.i.i.i55.i823 = and i64 %xored.i.i.i54.i822, %tbl_size.i.i50.i818
  %offset_ptr.i.i56.i824 = getelementptr i32, ptr %offset_tbl.i.i51.i819, i64 %hash.i.i.i55.i823
  %offset.i.i57.i825 = load i32, ptr %offset_ptr.i.i56.i824, align 4
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i826 = icmp eq i32 %765, 100
  br i1 %exitcond.not.i826, label %772, label %732

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit835: ; preds = %732
  %769 = load i32, ptr %106, align 4
  %770 = add i32 %769, 1
  %771 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %770, ptr %106, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  br label %CuckooMap_insert_keyK_valueV.exit

772:                                              ; preds = %.cont.i813
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %774 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %775 = load ptr, ptr %104, align 8
  %776 = load ptr, ptr %105, align 8
  %777 = load i32, ptr %103, align 8
  %778 = shl i32 %777, 1
  %spec.select.i852 = call i32 @llvm.smax.i32(i32 %778, i32 noundef 16) #40
  store i32 %spec.select.i852, ptr %103, align 8
  %779 = zext nneg i32 %spec.select.i852 to i64
  %780 = shl nuw nsw i64 %779, 5
  %result.i5.i853 = call noalias ptr @bump_malloc_wrapper(i64 noundef %780) #48
  store ptr %result.i5.i853, ptr %104, align 8
  %result.i4.i854 = call noalias ptr @bump_malloc_wrapper(i64 noundef %780) #48
  store ptr %result.i4.i854, ptr %105, align 8
  store i32 0, ptr %106, align 4
  %781 = icmp sgt i32 %777, 0
  br i1 %781, label %.lr.ph.i1694, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1730.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1730.thread: ; preds = %772
  %782 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i1694:                                     ; preds = %772
  %wide.trip.count.i1707 = zext nneg i32 %777 to i64
  br label %783

783:                                              ; preds = %._crit_edge.i1710, %.lr.ph.i1694
  %indvars.iv.i1708 = phi i64 [ 0, %.lr.ph.i1694 ], [ %indvars.iv.next.i1711, %._crit_edge.i1710 ]
  %784 = shl nuw nsw i64 %indvars.iv.i1708, 5
  %785 = getelementptr i8, ptr %775, i64 %784
  %786 = load ptr, ptr %785, align 8
  %787 = icmp ne ptr %786, @nil_typ
  %788 = icmp ne ptr %786, null
  %.not17.i1709 = and i1 %787, %788
  br i1 %.not17.i1709, label %789, label %._crit_edge.i1710

789:                                              ; preds = %783
  %790 = getelementptr i8, ptr %785, i64 8
  %791 = load i64, ptr %790, align 4
  %.sroa_idx.i1713 = getelementptr i8, ptr %785, i64 16
  %792 = load i64, ptr %.sroa_idx.i1713, align 4
  %hash_coef_ptr.i.i6.i1714 = getelementptr i8, ptr %786, i64 8
  %tbl_size_ptr.i.i7.i1715 = getelementptr i8, ptr %786, i64 16
  %offset_tbl_ptr.i.i8.i1716 = getelementptr i8, ptr %786, i64 40
  %793 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  %hash_coef.i.i21.i2393 = load i64, ptr %hash_coef_ptr.i.i6.i1714, align 4, !noalias !77
  %tbl_size.i.i22.i2394 = load i64, ptr %tbl_size_ptr.i.i7.i1715, align 4, !noalias !77
  %offset_tbl.i.i23.i2395 = load ptr, ptr %offset_tbl_ptr.i.i8.i1716, align 8, !noalias !77
  %product.i.i.i24.i2396 = mul i64 %hash_coef.i.i21.i2393, 4015701072841558310
  %shifted.i.i.i25.i2397 = lshr i64 %product.i.i.i24.i2396, 32
  %xored.i.i.i26.i2398 = xor i64 %shifted.i.i.i25.i2397, %product.i.i.i24.i2396
  %hash.i.i.i27.i2399 = and i64 %xored.i.i.i26.i2398, %tbl_size.i.i22.i2394
  %offset_ptr.i.i28.i2400 = getelementptr i32, ptr %offset_tbl.i.i23.i2395, i64 %hash.i.i.i27.i2399
  %offset.i.i29.i2401 = load i32, ptr %offset_ptr.i.i28.i2400, align 4, !noalias !77
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %795 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %796 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %797

797:                                              ; preds = %.cont.i2424, %789
  %.0290.i2402 = phi i32 [ 0, %789 ], [ %830, %.cont.i2424 ]
  %.074289.i2403 = phi i1 [ true, %789 ], [ %831, %.cont.i2424 ]
  %.sroa.0.0288.i2404 = phi ptr [ %786, %789 ], [ %820, %.cont.i2424 ]
  %.sroa.6.0287.i2405.in = phi i64 [ %791, %789 ], [ %822, %.cont.i2424 ]
  %.sroa.12.0286.i2406.in = phi i64 [ %792, %789 ], [ %823, %.cont.i2424 ]
  %.sroa.17.0285.i2407 = phi i32 [ %offset.i.i29.i2401, %789 ], [ %offset.i.i57.i2436, %.cont.i2424 ]
  %.sroa.12.0286.i2406 = inttoptr i64 %.sroa.12.0286.i2406.in to ptr
  %.sroa.6.0287.i2405 = inttoptr i64 %.sroa.6.0287.i2405.in to ptr
  %798 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2404, 0
  %799 = insertvalue { ptr, ptr, ptr, i32 } %798, ptr %.sroa.6.0287.i2405, 1
  %800 = insertvalue { ptr, ptr, ptr, i32 } %799, ptr %.sroa.12.0286.i2406, 2
  %801 = insertvalue { ptr, ptr, ptr, i32 } %800, i32 %.sroa.17.0285.i2407, 3
  %802 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2404)
  %803 = sext i32 %.sroa.17.0285.i2407 to i64
  %804 = getelementptr ptr, ptr %.sroa.0.0288.i2404, i64 %803
  %805 = getelementptr i8, ptr %804, i64 64
  %806 = load ptr, ptr %805, align 8
  %result.i15.i2408 = call ptr %806({ ptr, ptr, ptr, i32 } %801, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %807 = call i32 %result.i15.i2408({ ptr, ptr, ptr, i32 } %801, { ptr, ptr, ptr, i32 } %801, ptr nonnull align 8 %2) #53
  %..i2409 = select i1 %.074289.i2403, ptr %32, ptr %34
  %.188.i2410 = select i1 %.074289.i2403, i64 104, i64 112
  %.189.i2411 = select i1 %.074289.i2403, ptr %33, ptr %35
  %.190.i2412 = select i1 %.074289.i2403, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2409, align 8
  %808 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2409)
  %809 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2410
  %810 = load ptr, ptr %809, align 8
  store ptr @i32_typ, ptr %.189.i2411, align 8
  %result.i14.i2413 = call ptr %810({ ptr, ptr, ptr, i32 } %117, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2411) #46
  %811 = call i32 %result.i14.i2413({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull align 8 dereferenceable(8) %..i2409, i32 %807) #53
  %812 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %813 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2412
  %814 = load ptr, ptr %813, align 8
  %815 = load ptr, ptr %814, align 8
  %816 = call { ptr } %815(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i2414 = extractvalue { ptr } %816, 0
  %817 = sext i32 %811 to i64
  %818 = shl nsw i64 %817, 5
  %819 = getelementptr i8, ptr %.fca.0.extract55.i2414, i64 %818
  %820 = load ptr, ptr %819, align 8
  %821 = getelementptr i8, ptr %819, i64 8
  %822 = load i64, ptr %821, align 4
  %.sroa_idx.i2415 = getelementptr i8, ptr %819, i64 16
  %823 = load i64, ptr %.sroa_idx.i2415, align 4
  %824 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %825 = call { ptr } %815(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i2416 = extractvalue { ptr } %825, 0
  %826 = getelementptr i8, ptr %.fca.0.extract52.i2416, i64 %818
  store ptr %.sroa.0.0288.i2404, ptr %826, align 8
  %827 = getelementptr i8, ptr %826, i64 8
  store i64 %.sroa.6.0287.i2405.in, ptr %827, align 4
  %.sroa_idx104.i2417 = getelementptr i8, ptr %826, i64 16
  store i64 %.sroa.12.0286.i2406.in, ptr %.sroa_idx104.i2417, align 4
  %.sroa_idx105.i2418 = getelementptr i8, ptr %826, i64 24
  store i32 %.sroa.17.0285.i2407, ptr %.sroa_idx105.i2418, align 4
  %828 = icmp ne ptr %820, @nil_typ
  %829 = icmp ne ptr %820, null
  %.not94.i2419 = and i1 %828, %829
  br i1 %.not94.i2419, label %.cont.i2424, label %834

.cont.i2424:                                      ; preds = %797
  %830 = add nuw nsw i32 %.0290.i2402, 1
  %831 = xor i1 %.074289.i2403, true
  %hash_coef_ptr.i.i46.i2425 = getelementptr i8, ptr %820, i64 8
  %tbl_size_ptr.i.i47.i2426 = getelementptr i8, ptr %820, i64 16
  %offset_tbl_ptr.i.i48.i2427 = getelementptr i8, ptr %820, i64 40
  %hash_coef.i.i49.i2428 = load i64, ptr %hash_coef_ptr.i.i46.i2425, align 4
  %tbl_size.i.i50.i2429 = load i64, ptr %tbl_size_ptr.i.i47.i2426, align 4
  %offset_tbl.i.i51.i2430 = load ptr, ptr %offset_tbl_ptr.i.i48.i2427, align 8
  %product.i.i.i52.i2431 = mul i64 %hash_coef.i.i49.i2428, 4015701072841558310
  %shifted.i.i.i53.i2432 = lshr i64 %product.i.i.i52.i2431, 32
  %xored.i.i.i54.i2433 = xor i64 %shifted.i.i.i53.i2432, %product.i.i.i52.i2431
  %hash.i.i.i55.i2434 = and i64 %xored.i.i.i54.i2433, %tbl_size.i.i50.i2429
  %offset_ptr.i.i56.i2435 = getelementptr i32, ptr %offset_tbl.i.i51.i2430, i64 %hash.i.i.i55.i2434
  %offset.i.i57.i2436 = load i32, ptr %offset_ptr.i.i56.i2435, align 4
  %832 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %833 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2437 = icmp eq i32 %830, 100
  br i1 %exitcond.not.i2437, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2446, label %797

834:                                              ; preds = %797
  %835 = load i32, ptr %106, align 4
  %836 = add i32 %835, 1
  %837 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %836, ptr %106, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2446

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2446: ; preds = %834, %.cont.i2424
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  br label %._crit_edge.i1710

._crit_edge.i1710:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2446, %783
  %indvars.iv.next.i1711 = add nuw nsw i64 %indvars.iv.i1708, 1
  %exitcond.not.i1712 = icmp eq i64 %indvars.iv.next.i1711, %wide.trip.count.i1707
  br i1 %exitcond.not.i1712, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1730, label %783

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1730: ; preds = %._crit_edge.i1710
  %838 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %839

839:                                              ; preds = %._crit_edge.i1748, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1730
  %indvars.iv.i1746 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1730 ], [ %indvars.iv.next.i1749, %._crit_edge.i1748 ]
  %840 = shl nuw nsw i64 %indvars.iv.i1746, 5
  %841 = getelementptr i8, ptr %776, i64 %840
  %842 = load ptr, ptr %841, align 8
  %843 = icmp ne ptr %842, @nil_typ
  %844 = icmp ne ptr %842, null
  %.not17.i1747 = and i1 %843, %844
  br i1 %.not17.i1747, label %845, label %._crit_edge.i1748

845:                                              ; preds = %839
  %846 = getelementptr i8, ptr %841, i64 8
  %847 = load i64, ptr %846, align 4
  %.sroa_idx.i1751 = getelementptr i8, ptr %841, i64 16
  %848 = load i64, ptr %.sroa_idx.i1751, align 4
  %hash_coef_ptr.i.i6.i1752 = getelementptr i8, ptr %842, i64 8
  %tbl_size_ptr.i.i7.i1753 = getelementptr i8, ptr %842, i64 16
  %offset_tbl_ptr.i.i8.i1754 = getelementptr i8, ptr %842, i64 40
  %849 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %hash_coef.i.i21.i2464 = load i64, ptr %hash_coef_ptr.i.i6.i1752, align 4, !noalias !80
  %tbl_size.i.i22.i2465 = load i64, ptr %tbl_size_ptr.i.i7.i1753, align 4, !noalias !80
  %offset_tbl.i.i23.i2466 = load ptr, ptr %offset_tbl_ptr.i.i8.i1754, align 8, !noalias !80
  %product.i.i.i24.i2467 = mul i64 %hash_coef.i.i21.i2464, 4015701072841558310
  %shifted.i.i.i25.i2468 = lshr i64 %product.i.i.i24.i2467, 32
  %xored.i.i.i26.i2469 = xor i64 %shifted.i.i.i25.i2468, %product.i.i.i24.i2467
  %hash.i.i.i27.i2470 = and i64 %xored.i.i.i26.i2469, %tbl_size.i.i22.i2465
  %offset_ptr.i.i28.i2471 = getelementptr i32, ptr %offset_tbl.i.i23.i2466, i64 %hash.i.i.i27.i2470
  %offset.i.i29.i2472 = load i32, ptr %offset_ptr.i.i28.i2471, align 4, !noalias !80
  %850 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %851 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %852 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %853

853:                                              ; preds = %.cont.i2495, %845
  %.0290.i2473 = phi i32 [ 0, %845 ], [ %886, %.cont.i2495 ]
  %.074289.i2474 = phi i1 [ true, %845 ], [ %887, %.cont.i2495 ]
  %.sroa.0.0288.i2475 = phi ptr [ %842, %845 ], [ %876, %.cont.i2495 ]
  %.sroa.6.0287.i2476.in = phi i64 [ %847, %845 ], [ %878, %.cont.i2495 ]
  %.sroa.12.0286.i2477.in = phi i64 [ %848, %845 ], [ %879, %.cont.i2495 ]
  %.sroa.17.0285.i2478 = phi i32 [ %offset.i.i29.i2472, %845 ], [ %offset.i.i57.i2507, %.cont.i2495 ]
  %.sroa.12.0286.i2477 = inttoptr i64 %.sroa.12.0286.i2477.in to ptr
  %.sroa.6.0287.i2476 = inttoptr i64 %.sroa.6.0287.i2476.in to ptr
  %854 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2475, 0
  %855 = insertvalue { ptr, ptr, ptr, i32 } %854, ptr %.sroa.6.0287.i2476, 1
  %856 = insertvalue { ptr, ptr, ptr, i32 } %855, ptr %.sroa.12.0286.i2477, 2
  %857 = insertvalue { ptr, ptr, ptr, i32 } %856, i32 %.sroa.17.0285.i2478, 3
  %858 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2475)
  %859 = sext i32 %.sroa.17.0285.i2478 to i64
  %860 = getelementptr ptr, ptr %.sroa.0.0288.i2475, i64 %859
  %861 = getelementptr i8, ptr %860, i64 64
  %862 = load ptr, ptr %861, align 8
  %result.i15.i2479 = call ptr %862({ ptr, ptr, ptr, i32 } %857, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %863 = call i32 %result.i15.i2479({ ptr, ptr, ptr, i32 } %857, { ptr, ptr, ptr, i32 } %857, ptr nonnull align 8 %2) #53
  %..i2480 = select i1 %.074289.i2474, ptr %28, ptr %30
  %.188.i2481 = select i1 %.074289.i2474, i64 104, i64 112
  %.189.i2482 = select i1 %.074289.i2474, ptr %29, ptr %31
  %.190.i2483 = select i1 %.074289.i2474, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2480, align 8
  %864 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2480)
  %865 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2481
  %866 = load ptr, ptr %865, align 8
  store ptr @i32_typ, ptr %.189.i2482, align 8
  %result.i14.i2484 = call ptr %866({ ptr, ptr, ptr, i32 } %117, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2482) #46
  %867 = call i32 %result.i14.i2484({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull align 8 dereferenceable(8) %..i2480, i32 %863) #53
  %868 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %869 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2483
  %870 = load ptr, ptr %869, align 8
  %871 = load ptr, ptr %870, align 8
  %872 = call { ptr } %871(ptr nonnull %result.i55) #43
  %.fca.0.extract55.i2485 = extractvalue { ptr } %872, 0
  %873 = sext i32 %867 to i64
  %874 = shl nsw i64 %873, 5
  %875 = getelementptr i8, ptr %.fca.0.extract55.i2485, i64 %874
  %876 = load ptr, ptr %875, align 8
  %877 = getelementptr i8, ptr %875, i64 8
  %878 = load i64, ptr %877, align 4
  %.sroa_idx.i2486 = getelementptr i8, ptr %875, i64 16
  %879 = load i64, ptr %.sroa_idx.i2486, align 4
  %880 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %881 = call { ptr } %871(ptr nonnull %result.i55) #43
  %.fca.0.extract52.i2487 = extractvalue { ptr } %881, 0
  %882 = getelementptr i8, ptr %.fca.0.extract52.i2487, i64 %874
  store ptr %.sroa.0.0288.i2475, ptr %882, align 8
  %883 = getelementptr i8, ptr %882, i64 8
  store i64 %.sroa.6.0287.i2476.in, ptr %883, align 4
  %.sroa_idx104.i2488 = getelementptr i8, ptr %882, i64 16
  store i64 %.sroa.12.0286.i2477.in, ptr %.sroa_idx104.i2488, align 4
  %.sroa_idx105.i2489 = getelementptr i8, ptr %882, i64 24
  store i32 %.sroa.17.0285.i2478, ptr %.sroa_idx105.i2489, align 4
  %884 = icmp ne ptr %876, @nil_typ
  %885 = icmp ne ptr %876, null
  %.not94.i2490 = and i1 %884, %885
  br i1 %.not94.i2490, label %.cont.i2495, label %890

.cont.i2495:                                      ; preds = %853
  %886 = add nuw nsw i32 %.0290.i2473, 1
  %887 = xor i1 %.074289.i2474, true
  %hash_coef_ptr.i.i46.i2496 = getelementptr i8, ptr %876, i64 8
  %tbl_size_ptr.i.i47.i2497 = getelementptr i8, ptr %876, i64 16
  %offset_tbl_ptr.i.i48.i2498 = getelementptr i8, ptr %876, i64 40
  %hash_coef.i.i49.i2499 = load i64, ptr %hash_coef_ptr.i.i46.i2496, align 4
  %tbl_size.i.i50.i2500 = load i64, ptr %tbl_size_ptr.i.i47.i2497, align 4
  %offset_tbl.i.i51.i2501 = load ptr, ptr %offset_tbl_ptr.i.i48.i2498, align 8
  %product.i.i.i52.i2502 = mul i64 %hash_coef.i.i49.i2499, 4015701072841558310
  %shifted.i.i.i53.i2503 = lshr i64 %product.i.i.i52.i2502, 32
  %xored.i.i.i54.i2504 = xor i64 %shifted.i.i.i53.i2503, %product.i.i.i52.i2502
  %hash.i.i.i55.i2505 = and i64 %xored.i.i.i54.i2504, %tbl_size.i.i50.i2500
  %offset_ptr.i.i56.i2506 = getelementptr i32, ptr %offset_tbl.i.i51.i2501, i64 %hash.i.i.i55.i2505
  %offset.i.i57.i2507 = load i32, ptr %offset_ptr.i.i56.i2506, align 4
  %888 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2508 = icmp eq i32 %886, 100
  br i1 %exitcond.not.i2508, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2517, label %853

890:                                              ; preds = %853
  %891 = load i32, ptr %106, align 4
  %892 = add i32 %891, 1
  %893 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %892, ptr %106, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2517

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2517: ; preds = %890, %.cont.i2495
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  br label %._crit_edge.i1748

._crit_edge.i1748:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2517, %839
  %indvars.iv.next.i1749 = add nuw nsw i64 %indvars.iv.i1746, 1
  %exitcond.not.i1750 = icmp eq i64 %indvars.iv.next.i1749, %wide.trip.count.i1707
  br i1 %exitcond.not.i1750, label %CuckooMap_insert_keyK_valueV.exit, label %839

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i1748, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1730.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit835, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit702, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %111
  br i1 %exitcond.not, label %._crit_edge3.preheader, label %._crit_edge

._crit_edge3.preheader:                           ; preds = %CuckooMap_insert_keyK_valueV.exit
  %.pre = load i32, ptr %106, align 4
  %894 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %895 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %896 = call i64 @clock()
  %897 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %898 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i60, 1
  %899 = insertvalue { ptr, ptr, ptr, i32 } %898, ptr undef, 2
  %900 = insertvalue { ptr, ptr, ptr, i32 } %899, i32 10, 3
  %901 = insertvalue { ptr, ptr, ptr, i32 } %898, i32 10, 3
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit364, %._crit_edge3.preheader
  %indvars.iv497 = phi i64 [ 0, %._crit_edge3.preheader ], [ %indvars.iv.next498, %CuckooMap_insert_keyK_valueV.exit364 ]
  %902 = load ptr, ptr %93, align 8
  %903 = shl i64 %indvars.iv497, 2
  %904 = getelementptr i8, ptr %902, i64 %903
  %905 = load i32, ptr %904, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %905 to i160
  %906 = add i32 %905, 1
  %907 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %.sroa.0222.0.insert.ext = zext i32 %906 to i160
  %908 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0222.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %909 = load ptr, ptr %81, align 8
  %910 = call i32 %909({ ptr, i160 } %907) #53
  %911 = load i32, ptr %83, align 8
  %912 = add i32 %911, -1
  %913 = and i32 %912, %910
  %914 = load ptr, ptr %84, align 8
  %915 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %916 = sext i32 %913 to i64
  %917 = shl nsw i64 %916, 5
  %918 = getelementptr i8, ptr %914, i64 %917
  %919 = load ptr, ptr %918, align 8
  %920 = getelementptr i8, ptr %918, i64 8
  %921 = icmp ne ptr %919, @nil_typ
  %922 = icmp ne ptr %919, null
  %.not66.i901 = and i1 %921, %922
  br i1 %.not66.i901, label %923, label %1021

923:                                              ; preds = %._crit_edge3
  %924 = load i64, ptr %920, align 4
  %.sroa_idx.i903 = getelementptr i8, ptr %918, i64 16
  %925 = load i64, ptr %.sroa_idx.i903, align 4
  %926 = inttoptr i64 %924 to ptr
  %927 = inttoptr i64 %925 to ptr
  %hash_coef_ptr.i.i11.i904 = getelementptr i8, ptr %919, i64 8
  %tbl_size_ptr.i.i12.i905 = getelementptr i8, ptr %919, i64 16
  %offset_tbl_ptr.i.i13.i906 = getelementptr i8, ptr %919, i64 40
  %hash_coef.i.i14.i907 = load i64, ptr %hash_coef_ptr.i.i11.i904, align 4, !noalias !83
  %tbl_size.i.i15.i908 = load i64, ptr %tbl_size_ptr.i.i12.i905, align 4, !noalias !83
  %offset_tbl.i.i16.i909 = load ptr, ptr %offset_tbl_ptr.i.i13.i906, align 8, !noalias !83
  %product.i.i.i17.i910 = mul i64 %hash_coef.i.i14.i907, 4015701072841558310
  %shifted.i.i.i18.i911 = lshr i64 %product.i.i.i17.i910, 32
  %xored.i.i.i19.i912 = xor i64 %shifted.i.i.i18.i911, %product.i.i.i17.i910
  %hash.i.i.i20.i913 = and i64 %xored.i.i.i19.i912, %tbl_size.i.i15.i908
  %offset_ptr.i.i21.i914 = getelementptr i32, ptr %offset_tbl.i.i16.i909, i64 %hash.i.i.i20.i913
  %offset.i.i22.i915 = load i32, ptr %offset_ptr.i.i21.i914, align 4, !noalias !83
  %928 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %919, 0
  %929 = insertvalue { ptr, ptr, ptr, i32 } %928, ptr %926, 1
  %930 = insertvalue { ptr, ptr, ptr, i32 } %929, ptr %927, 2
  %931 = insertvalue { ptr, ptr, ptr, i32 } %930, i32 %offset.i.i22.i915, 3
  %932 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %933 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %919) #40
  %934 = sext i32 %offset.i.i22.i915 to i64
  %935 = getelementptr ptr, ptr %919, i64 %934
  %936 = getelementptr i8, ptr %935, i64 64
  %937 = load ptr, ptr %936, align 8
  %result.i8.i916 = call ptr %937({ ptr, ptr, ptr, i32 } %931, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %938 = call i32 %result.i8.i916({ ptr, ptr, ptr, i32 } %931, { ptr, ptr, ptr, i32 } %931, ptr nonnull align 8 %2) #53
  %939 = icmp eq i32 %938, %910
  br i1 %939, label %._crit_edge.i917, label %1021

._crit_edge.i917:                                 ; preds = %923
  %940 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %941 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %919)
  %942 = getelementptr i8, ptr %935, i64 48
  %943 = load ptr, ptr %942, align 8
  %result.i7.i918 = call ptr %943({ ptr, ptr, ptr, i32 } %931, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %944 = call { ptr, i160 } %result.i7.i918({ ptr, ptr, ptr, i32 } %931, { ptr, ptr, ptr, i32 } %931, ptr nonnull align 8 %2) #53
  %945 = load ptr, ptr %82, align 8
  %946 = call i1 %945({ ptr, i160 } %944, { ptr, i160 } %907) #53
  br i1 %946, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit930, label %1021

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit930: ; preds = %._crit_edge.i917
  %947 = load ptr, ptr %result.i60, align 8
  %948 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %949 = load ptr, ptr %76, align 8
  %950 = load ptr, ptr %947, align 8, !alias.scope !86
  %951 = getelementptr i8, ptr %950, i64 72
  %952 = load ptr, ptr %951, align 8, !alias.scope !86
  %result.i1.i.i922 = call { i64, i64 } %952(ptr nocapture nofree nonnull readonly align 8 %947) #44, !alias.scope !86
  %953 = extractvalue { i64, i64 } %result.i1.i.i922, 0
  %954 = extractvalue { i64, i64 } %result.i1.i.i922, 1
  %955 = urem i64 20, %954
  %956 = icmp eq i64 %955, 0
  %957 = sub i64 %954, %955
  %958 = select i1 %956, i64 0, i64 %957
  %959 = add i64 %953, 20
  %960 = add i64 %959, %958
  %961 = load ptr, ptr %949, align 8, !alias.scope !86
  %962 = getelementptr i8, ptr %961, i64 72
  %963 = load ptr, ptr %962, align 8, !alias.scope !86
  %result.i.i.i923 = call { i64, i64 } %963(ptr nocapture nofree nonnull readonly align 8 %949) #44, !alias.scope !86
  %964 = extractvalue { i64, i64 } %result.i.i.i923, 0
  %965 = extractvalue { i64, i64 } %result.i.i.i923, 1
  %966 = call i64 @llvm.umax.i64(i64 %954, i64 %965) #41
  %967 = call i64 @llvm.umax.i64(i64 %966, i64 noundef 8) #41, !range !16
  %968 = urem i64 %960, %965
  %969 = icmp eq i64 %968, 0
  %970 = sub i64 %965, %968
  %971 = select i1 %969, i64 0, i64 %970
  %972 = add i64 %964, %960
  %973 = add i64 %972, %971
  %974 = urem i64 %973, %967
  %975 = icmp eq i64 %974, 0
  %976 = sub i64 %967, %974
  %977 = select i1 %975, i64 0, i64 %976
  %978 = add i64 %977, %973
  %result.i9.i924 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %978) #48
  store ptr %947, ptr %result.i9.i924, align 8
  %979 = getelementptr inbounds i8, ptr %result.i9.i924, i64 8
  store ptr %949, ptr %979, align 8
  %980 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i924)
  %981 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %982 = load ptr, ptr %947, align 8
  %983 = getelementptr i8, ptr %982, i64 72
  %984 = load ptr, ptr %983, align 8
  %result.i.i38.i925 = call { i64, i64 } %984(ptr nocapture nofree nonnull readonly align 8 %947) #44
  %985 = extractvalue { i64, i64 } %result.i.i38.i925, 1
  %986 = urem i64 20, %985
  %987 = icmp eq i64 %986, 0
  %reass.sub3227 = sub i64 %985, %986
  %988 = add i64 %reass.sub3227, 20
  %989 = select i1 %987, i64 20, i64 %988
  %990 = getelementptr i8, ptr %result.i9.i924, i64 %989
  %991 = getelementptr i8, ptr %982, i64 64
  %992 = load ptr, ptr %991, align 8
  call void %992({ ptr, i160 } %907, ptr nocapture nofree nonnull readonly align 8 %947, ptr nocapture nofree writeonly %990) #45
  %993 = load ptr, ptr %result.i9.i924, align 8
  %994 = load ptr, ptr %993, align 8
  %995 = getelementptr i8, ptr %994, i64 72
  %996 = load ptr, ptr %995, align 8
  %result.i1.i39.i927 = call { i64, i64 } %996(ptr nocapture nofree nonnull readonly align 8 %993) #44
  %997 = extractvalue { i64, i64 } %result.i1.i39.i927, 0
  %998 = extractvalue { i64, i64 } %result.i1.i39.i927, 1
  %999 = urem i64 20, %998
  %1000 = icmp eq i64 %999, 0
  %1001 = sub i64 %998, %999
  %1002 = select i1 %1000, i64 0, i64 %1001
  %1003 = add i64 %997, 20
  %1004 = add i64 %1003, %1002
  %1005 = load ptr, ptr %979, align 8
  %1006 = load ptr, ptr %1005, align 8
  %1007 = getelementptr i8, ptr %1006, i64 72
  %1008 = load ptr, ptr %1007, align 8
  %result.i.i40.i928 = call { i64, i64 } %1008(ptr nocapture nofree nonnull readonly align 8 %1005) #44
  %1009 = extractvalue { i64, i64 } %result.i.i40.i928, 1
  %1010 = urem i64 %1004, %1009
  %1011 = icmp eq i64 %1010, 0
  %1012 = sub i64 %1009, %1010
  %1013 = select i1 %1011, i64 0, i64 %1012
  %1014 = getelementptr i8, ptr %result.i9.i924, i64 %1004
  %1015 = getelementptr i8, ptr %1014, i64 %1013
  %1016 = getelementptr i8, ptr %1006, i64 64
  %1017 = load ptr, ptr %1016, align 8
  call void %1017({ ptr, i160 } %908, ptr nocapture nofree nonnull readonly align 8 %1005, ptr nocapture nofree writeonly %1015) #45
  %1018 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1019 = getelementptr inbounds i8, ptr %result.i9.i924, i64 16
  store i32 %910, ptr %1019, align 8
  store ptr @Entry, ptr %918, align 8
  %1020 = ptrtoint ptr %result.i9.i924 to i64
  store i64 %1020, ptr %920, align 4
  %.sroa_idx30.i929 = getelementptr i8, ptr %918, i64 24
  store i32 10, ptr %.sroa_idx30.i929, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit364

1021:                                             ; preds = %._crit_edge.i917, %923, %._crit_edge3
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1022 = add i32 %910, 2127912214
  %1023 = shl i32 %910, 12
  %1024 = add i32 %1022, %1023
  %1025 = ashr i32 %1024, 19
  %1026 = xor i32 %1024, %1025
  %1027 = xor i32 %1026, -949894596
  %1028 = add i32 %1027, 374761393
  %1029 = shl i32 %1027, 5
  %1030 = add i32 %1028, %1029
  %1031 = add i32 %1030, -744332180
  %1032 = shl i32 %1030, 9
  %1033 = xor i32 %1031, %1032
  %1034 = add i32 %1033, -42973499
  %1035 = shl i32 %1033, 3
  %1036 = add i32 %1034, %1035
  %1037 = ashr i32 %1036, 16
  %1038 = xor i32 %1036, %1037
  %1039 = xor i32 %1038, -1252372727
  %1040 = load i32, ptr %83, align 8
  %1041 = add i32 %1040, -1
  %1042 = and i32 %1041, %1039
  %1043 = load ptr, ptr %85, align 8
  %1044 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1045 = sext i32 %1042 to i64
  %1046 = shl nsw i64 %1045, 5
  %1047 = getelementptr i8, ptr %1043, i64 %1046
  %1048 = load ptr, ptr %1047, align 8
  %1049 = getelementptr i8, ptr %1047, i64 8
  %1050 = icmp ne ptr %1048, @nil_typ
  %1051 = icmp ne ptr %1048, null
  %.not66.i961 = and i1 %1050, %1051
  br i1 %.not66.i961, label %1052, label %1150

1052:                                             ; preds = %1021
  %1053 = load i64, ptr %1049, align 4
  %.sroa_idx.i963 = getelementptr i8, ptr %1047, i64 16
  %1054 = load i64, ptr %.sroa_idx.i963, align 4
  %1055 = inttoptr i64 %1053 to ptr
  %1056 = inttoptr i64 %1054 to ptr
  %hash_coef_ptr.i.i11.i964 = getelementptr i8, ptr %1048, i64 8
  %tbl_size_ptr.i.i12.i965 = getelementptr i8, ptr %1048, i64 16
  %offset_tbl_ptr.i.i13.i966 = getelementptr i8, ptr %1048, i64 40
  %hash_coef.i.i14.i967 = load i64, ptr %hash_coef_ptr.i.i11.i964, align 4, !noalias !89
  %tbl_size.i.i15.i968 = load i64, ptr %tbl_size_ptr.i.i12.i965, align 4, !noalias !89
  %offset_tbl.i.i16.i969 = load ptr, ptr %offset_tbl_ptr.i.i13.i966, align 8, !noalias !89
  %product.i.i.i17.i970 = mul i64 %hash_coef.i.i14.i967, 4015701072841558310
  %shifted.i.i.i18.i971 = lshr i64 %product.i.i.i17.i970, 32
  %xored.i.i.i19.i972 = xor i64 %shifted.i.i.i18.i971, %product.i.i.i17.i970
  %hash.i.i.i20.i973 = and i64 %xored.i.i.i19.i972, %tbl_size.i.i15.i968
  %offset_ptr.i.i21.i974 = getelementptr i32, ptr %offset_tbl.i.i16.i969, i64 %hash.i.i.i20.i973
  %offset.i.i22.i975 = load i32, ptr %offset_ptr.i.i21.i974, align 4, !noalias !89
  %1057 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1048, 0
  %1058 = insertvalue { ptr, ptr, ptr, i32 } %1057, ptr %1055, 1
  %1059 = insertvalue { ptr, ptr, ptr, i32 } %1058, ptr %1056, 2
  %1060 = insertvalue { ptr, ptr, ptr, i32 } %1059, i32 %offset.i.i22.i975, 3
  %1061 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1062 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1048) #40
  %1063 = sext i32 %offset.i.i22.i975 to i64
  %1064 = getelementptr ptr, ptr %1048, i64 %1063
  %1065 = getelementptr i8, ptr %1064, i64 64
  %1066 = load ptr, ptr %1065, align 8
  %result.i8.i976 = call ptr %1066({ ptr, ptr, ptr, i32 } %1060, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1067 = call i32 %result.i8.i976({ ptr, ptr, ptr, i32 } %1060, { ptr, ptr, ptr, i32 } %1060, ptr nonnull align 8 %2) #53
  %1068 = icmp eq i32 %1067, %910
  br i1 %1068, label %._crit_edge.i977, label %1150

._crit_edge.i977:                                 ; preds = %1052
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1048)
  %1071 = getelementptr i8, ptr %1064, i64 48
  %1072 = load ptr, ptr %1071, align 8
  %result.i7.i978 = call ptr %1072({ ptr, ptr, ptr, i32 } %1060, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1073 = call { ptr, i160 } %result.i7.i978({ ptr, ptr, ptr, i32 } %1060, { ptr, ptr, ptr, i32 } %1060, ptr nonnull align 8 %2) #53
  %1074 = load ptr, ptr %82, align 8
  %1075 = call i1 %1074({ ptr, i160 } %1073, { ptr, i160 } %907) #53
  br i1 %1075, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit990, label %1150

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit990: ; preds = %._crit_edge.i977
  %1076 = load ptr, ptr %result.i60, align 8
  %1077 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1078 = load ptr, ptr %76, align 8
  %1079 = load ptr, ptr %1076, align 8, !alias.scope !92
  %1080 = getelementptr i8, ptr %1079, i64 72
  %1081 = load ptr, ptr %1080, align 8, !alias.scope !92
  %result.i1.i.i982 = call { i64, i64 } %1081(ptr nocapture nofree nonnull readonly align 8 %1076) #44, !alias.scope !92
  %1082 = extractvalue { i64, i64 } %result.i1.i.i982, 0
  %1083 = extractvalue { i64, i64 } %result.i1.i.i982, 1
  %1084 = urem i64 20, %1083
  %1085 = icmp eq i64 %1084, 0
  %1086 = sub i64 %1083, %1084
  %1087 = select i1 %1085, i64 0, i64 %1086
  %1088 = add i64 %1082, 20
  %1089 = add i64 %1088, %1087
  %1090 = load ptr, ptr %1078, align 8, !alias.scope !92
  %1091 = getelementptr i8, ptr %1090, i64 72
  %1092 = load ptr, ptr %1091, align 8, !alias.scope !92
  %result.i.i.i983 = call { i64, i64 } %1092(ptr nocapture nofree nonnull readonly align 8 %1078) #44, !alias.scope !92
  %1093 = extractvalue { i64, i64 } %result.i.i.i983, 0
  %1094 = extractvalue { i64, i64 } %result.i.i.i983, 1
  %1095 = call i64 @llvm.umax.i64(i64 %1083, i64 %1094) #41
  %1096 = call i64 @llvm.umax.i64(i64 %1095, i64 noundef 8) #41, !range !16
  %1097 = urem i64 %1089, %1094
  %1098 = icmp eq i64 %1097, 0
  %1099 = sub i64 %1094, %1097
  %1100 = select i1 %1098, i64 0, i64 %1099
  %1101 = add i64 %1093, %1089
  %1102 = add i64 %1101, %1100
  %1103 = urem i64 %1102, %1096
  %1104 = icmp eq i64 %1103, 0
  %1105 = sub i64 %1096, %1103
  %1106 = select i1 %1104, i64 0, i64 %1105
  %1107 = add i64 %1106, %1102
  %result.i9.i984 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1107) #48
  store ptr %1076, ptr %result.i9.i984, align 8
  %1108 = getelementptr inbounds i8, ptr %result.i9.i984, i64 8
  store ptr %1078, ptr %1108, align 8
  %1109 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i984)
  %1110 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1111 = load ptr, ptr %1076, align 8
  %1112 = getelementptr i8, ptr %1111, i64 72
  %1113 = load ptr, ptr %1112, align 8
  %result.i.i38.i985 = call { i64, i64 } %1113(ptr nocapture nofree nonnull readonly align 8 %1076) #44
  %1114 = extractvalue { i64, i64 } %result.i.i38.i985, 1
  %1115 = urem i64 20, %1114
  %1116 = icmp eq i64 %1115, 0
  %reass.sub3226 = sub i64 %1114, %1115
  %1117 = add i64 %reass.sub3226, 20
  %1118 = select i1 %1116, i64 20, i64 %1117
  %1119 = getelementptr i8, ptr %result.i9.i984, i64 %1118
  %1120 = getelementptr i8, ptr %1111, i64 64
  %1121 = load ptr, ptr %1120, align 8
  call void %1121({ ptr, i160 } %907, ptr nocapture nofree nonnull readonly align 8 %1076, ptr nocapture nofree writeonly %1119) #45
  %1122 = load ptr, ptr %result.i9.i984, align 8
  %1123 = load ptr, ptr %1122, align 8
  %1124 = getelementptr i8, ptr %1123, i64 72
  %1125 = load ptr, ptr %1124, align 8
  %result.i1.i39.i987 = call { i64, i64 } %1125(ptr nocapture nofree nonnull readonly align 8 %1122) #44
  %1126 = extractvalue { i64, i64 } %result.i1.i39.i987, 0
  %1127 = extractvalue { i64, i64 } %result.i1.i39.i987, 1
  %1128 = urem i64 20, %1127
  %1129 = icmp eq i64 %1128, 0
  %1130 = sub i64 %1127, %1128
  %1131 = select i1 %1129, i64 0, i64 %1130
  %1132 = add i64 %1126, 20
  %1133 = add i64 %1132, %1131
  %1134 = load ptr, ptr %1108, align 8
  %1135 = load ptr, ptr %1134, align 8
  %1136 = getelementptr i8, ptr %1135, i64 72
  %1137 = load ptr, ptr %1136, align 8
  %result.i.i40.i988 = call { i64, i64 } %1137(ptr nocapture nofree nonnull readonly align 8 %1134) #44
  %1138 = extractvalue { i64, i64 } %result.i.i40.i988, 1
  %1139 = urem i64 %1133, %1138
  %1140 = icmp eq i64 %1139, 0
  %1141 = sub i64 %1138, %1139
  %1142 = select i1 %1140, i64 0, i64 %1141
  %1143 = getelementptr i8, ptr %result.i9.i984, i64 %1133
  %1144 = getelementptr i8, ptr %1143, i64 %1142
  %1145 = getelementptr i8, ptr %1135, i64 64
  %1146 = load ptr, ptr %1145, align 8
  call void %1146({ ptr, i160 } %908, ptr nocapture nofree nonnull readonly align 8 %1134, ptr nocapture nofree writeonly %1144) #45
  %1147 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1148 = getelementptr inbounds i8, ptr %result.i9.i984, i64 16
  store i32 %910, ptr %1148, align 8
  store ptr @Entry, ptr %1047, align 8
  %1149 = ptrtoint ptr %result.i9.i984 to i64
  store i64 %1149, ptr %1049, align 4
  %.sroa_idx30.i989 = getelementptr i8, ptr %1047, i64 24
  store i32 10, ptr %.sroa_idx30.i989, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit364

1150:                                             ; preds = %._crit_edge.i977, %1052, %1021
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1151 = load i32, ptr %87, align 4
  %1152 = load i32, ptr %83, align 8
  %.not.i322 = icmp slt i32 %1151, %1152
  br i1 %.not.i322, label %._crit_edge.i324, label %1153

1153:                                             ; preds = %1150
  %1154 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1155 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1156 = load ptr, ptr %84, align 8
  %1157 = load ptr, ptr %85, align 8
  %1158 = shl i32 %1152, 1
  %spec.select.i1007 = call i32 @llvm.smax.i32(i32 %1158, i32 noundef 16) #40
  store i32 %spec.select.i1007, ptr %83, align 8
  %1159 = zext nneg i32 %spec.select.i1007 to i64
  %1160 = shl nuw nsw i64 %1159, 5
  %result.i5.i1008 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1160) #48
  store ptr %result.i5.i1008, ptr %84, align 8
  %result.i4.i1009 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1160) #48
  store ptr %result.i4.i1009, ptr %85, align 8
  store i32 0, ptr %87, align 4
  %1161 = icmp sgt i32 %1152, 0
  br i1 %1161, label %.lr.ph.i1770, label %._crit_edge.i324

.lr.ph.i1770:                                     ; preds = %1153
  %wide.trip.count.i1783 = zext nneg i32 %1152 to i64
  br label %1162

1162:                                             ; preds = %._crit_edge.i1786, %.lr.ph.i1770
  %indvars.iv.i1784 = phi i64 [ 0, %.lr.ph.i1770 ], [ %indvars.iv.next.i1787, %._crit_edge.i1786 ]
  %1163 = shl nuw nsw i64 %indvars.iv.i1784, 5
  %1164 = getelementptr i8, ptr %1156, i64 %1163
  %1165 = load ptr, ptr %1164, align 8
  %1166 = icmp ne ptr %1165, @nil_typ
  %1167 = icmp ne ptr %1165, null
  %.not17.i1785 = and i1 %1166, %1167
  br i1 %.not17.i1785, label %1168, label %._crit_edge.i1786

1168:                                             ; preds = %1162
  %1169 = getelementptr i8, ptr %1164, i64 8
  %1170 = load i64, ptr %1169, align 4
  %.sroa_idx.i1789 = getelementptr i8, ptr %1164, i64 16
  %1171 = load i64, ptr %.sroa_idx.i1789, align 4
  %hash_coef_ptr.i.i6.i1790 = getelementptr i8, ptr %1165, i64 8
  %tbl_size_ptr.i.i7.i1791 = getelementptr i8, ptr %1165, i64 16
  %offset_tbl_ptr.i.i8.i1792 = getelementptr i8, ptr %1165, i64 40
  %1172 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  %hash_coef.i.i21.i2535 = load i64, ptr %hash_coef_ptr.i.i6.i1790, align 4, !noalias !95
  %tbl_size.i.i22.i2536 = load i64, ptr %tbl_size_ptr.i.i7.i1791, align 4, !noalias !95
  %offset_tbl.i.i23.i2537 = load ptr, ptr %offset_tbl_ptr.i.i8.i1792, align 8, !noalias !95
  %product.i.i.i24.i2538 = mul i64 %hash_coef.i.i21.i2535, 4015701072841558310
  %shifted.i.i.i25.i2539 = lshr i64 %product.i.i.i24.i2538, 32
  %xored.i.i.i26.i2540 = xor i64 %shifted.i.i.i25.i2539, %product.i.i.i24.i2538
  %hash.i.i.i27.i2541 = and i64 %xored.i.i.i26.i2540, %tbl_size.i.i22.i2536
  %offset_ptr.i.i28.i2542 = getelementptr i32, ptr %offset_tbl.i.i23.i2537, i64 %hash.i.i.i27.i2541
  %offset.i.i29.i2543 = load i32, ptr %offset_ptr.i.i28.i2542, align 4, !noalias !95
  %1173 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1174 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1175 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1176

1176:                                             ; preds = %.cont.i2566, %1168
  %.0290.i2544 = phi i32 [ 0, %1168 ], [ %1209, %.cont.i2566 ]
  %.074289.i2545 = phi i1 [ true, %1168 ], [ %1210, %.cont.i2566 ]
  %.sroa.0.0288.i2546 = phi ptr [ %1165, %1168 ], [ %1199, %.cont.i2566 ]
  %.sroa.6.0287.i2547.in = phi i64 [ %1170, %1168 ], [ %1201, %.cont.i2566 ]
  %.sroa.12.0286.i2548.in = phi i64 [ %1171, %1168 ], [ %1202, %.cont.i2566 ]
  %.sroa.17.0285.i2549 = phi i32 [ %offset.i.i29.i2543, %1168 ], [ %offset.i.i57.i2578, %.cont.i2566 ]
  %.sroa.12.0286.i2548 = inttoptr i64 %.sroa.12.0286.i2548.in to ptr
  %.sroa.6.0287.i2547 = inttoptr i64 %.sroa.6.0287.i2547.in to ptr
  %1177 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2546, 0
  %1178 = insertvalue { ptr, ptr, ptr, i32 } %1177, ptr %.sroa.6.0287.i2547, 1
  %1179 = insertvalue { ptr, ptr, ptr, i32 } %1178, ptr %.sroa.12.0286.i2548, 2
  %1180 = insertvalue { ptr, ptr, ptr, i32 } %1179, i32 %.sroa.17.0285.i2549, 3
  %1181 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2546)
  %1182 = sext i32 %.sroa.17.0285.i2549 to i64
  %1183 = getelementptr ptr, ptr %.sroa.0.0288.i2546, i64 %1182
  %1184 = getelementptr i8, ptr %1183, i64 64
  %1185 = load ptr, ptr %1184, align 8
  %result.i15.i2550 = call ptr %1185({ ptr, ptr, ptr, i32 } %1180, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1186 = call i32 %result.i15.i2550({ ptr, ptr, ptr, i32 } %1180, { ptr, ptr, ptr, i32 } %1180, ptr nonnull align 8 %2) #53
  %..i2551 = select i1 %.074289.i2545, ptr %24, ptr %26
  %.188.i2552 = select i1 %.074289.i2545, i64 104, i64 112
  %.189.i2553 = select i1 %.074289.i2545, ptr %25, ptr %27
  %.190.i2554 = select i1 %.074289.i2545, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2551, align 8
  %1187 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2551)
  %1188 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2552
  %1189 = load ptr, ptr %1188, align 8
  store ptr @i32_typ, ptr %.189.i2553, align 8
  %result.i14.i2555 = call ptr %1189({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2553) #46
  %1190 = call i32 %result.i14.i2555({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 dereferenceable(8) %..i2551, i32 %1186) #53
  %1191 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1192 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2554
  %1193 = load ptr, ptr %1192, align 8
  %1194 = load ptr, ptr %1193, align 8
  %1195 = call { ptr } %1194(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i2556 = extractvalue { ptr } %1195, 0
  %1196 = sext i32 %1190 to i64
  %1197 = shl nsw i64 %1196, 5
  %1198 = getelementptr i8, ptr %.fca.0.extract55.i2556, i64 %1197
  %1199 = load ptr, ptr %1198, align 8
  %1200 = getelementptr i8, ptr %1198, i64 8
  %1201 = load i64, ptr %1200, align 4
  %.sroa_idx.i2557 = getelementptr i8, ptr %1198, i64 16
  %1202 = load i64, ptr %.sroa_idx.i2557, align 4
  %1203 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1204 = call { ptr } %1194(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i2558 = extractvalue { ptr } %1204, 0
  %1205 = getelementptr i8, ptr %.fca.0.extract52.i2558, i64 %1197
  store ptr %.sroa.0.0288.i2546, ptr %1205, align 8
  %1206 = getelementptr i8, ptr %1205, i64 8
  store i64 %.sroa.6.0287.i2547.in, ptr %1206, align 4
  %.sroa_idx104.i2559 = getelementptr i8, ptr %1205, i64 16
  store i64 %.sroa.12.0286.i2548.in, ptr %.sroa_idx104.i2559, align 4
  %.sroa_idx105.i2560 = getelementptr i8, ptr %1205, i64 24
  store i32 %.sroa.17.0285.i2549, ptr %.sroa_idx105.i2560, align 4
  %1207 = icmp ne ptr %1199, @nil_typ
  %1208 = icmp ne ptr %1199, null
  %.not94.i2561 = and i1 %1207, %1208
  br i1 %.not94.i2561, label %.cont.i2566, label %1213

.cont.i2566:                                      ; preds = %1176
  %1209 = add nuw nsw i32 %.0290.i2544, 1
  %1210 = xor i1 %.074289.i2545, true
  %hash_coef_ptr.i.i46.i2567 = getelementptr i8, ptr %1199, i64 8
  %tbl_size_ptr.i.i47.i2568 = getelementptr i8, ptr %1199, i64 16
  %offset_tbl_ptr.i.i48.i2569 = getelementptr i8, ptr %1199, i64 40
  %hash_coef.i.i49.i2570 = load i64, ptr %hash_coef_ptr.i.i46.i2567, align 4
  %tbl_size.i.i50.i2571 = load i64, ptr %tbl_size_ptr.i.i47.i2568, align 4
  %offset_tbl.i.i51.i2572 = load ptr, ptr %offset_tbl_ptr.i.i48.i2569, align 8
  %product.i.i.i52.i2573 = mul i64 %hash_coef.i.i49.i2570, 4015701072841558310
  %shifted.i.i.i53.i2574 = lshr i64 %product.i.i.i52.i2573, 32
  %xored.i.i.i54.i2575 = xor i64 %shifted.i.i.i53.i2574, %product.i.i.i52.i2573
  %hash.i.i.i55.i2576 = and i64 %xored.i.i.i54.i2575, %tbl_size.i.i50.i2571
  %offset_ptr.i.i56.i2577 = getelementptr i32, ptr %offset_tbl.i.i51.i2572, i64 %hash.i.i.i55.i2576
  %offset.i.i57.i2578 = load i32, ptr %offset_ptr.i.i56.i2577, align 4
  %1211 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1212 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2579 = icmp eq i32 %1209, 100
  br i1 %exitcond.not.i2579, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2588, label %1176

1213:                                             ; preds = %1176
  %1214 = load i32, ptr %87, align 4
  %1215 = add i32 %1214, 1
  %1216 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1215, ptr %87, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2588

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2588: ; preds = %1213, %.cont.i2566
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  br label %._crit_edge.i1786

._crit_edge.i1786:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2588, %1162
  %indvars.iv.next.i1787 = add nuw nsw i64 %indvars.iv.i1784, 1
  %exitcond.not.i1788 = icmp eq i64 %indvars.iv.next.i1787, %wide.trip.count.i1783
  br i1 %exitcond.not.i1788, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1806, label %1162

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1806: ; preds = %._crit_edge.i1824, %._crit_edge.i1786
  %indvars.iv.i1822 = phi i64 [ %indvars.iv.next.i1825, %._crit_edge.i1824 ], [ 0, %._crit_edge.i1786 ]
  %1217 = shl nuw nsw i64 %indvars.iv.i1822, 5
  %1218 = getelementptr i8, ptr %1157, i64 %1217
  %1219 = load ptr, ptr %1218, align 8
  %1220 = icmp ne ptr %1219, @nil_typ
  %1221 = icmp ne ptr %1219, null
  %.not17.i1823 = and i1 %1220, %1221
  br i1 %.not17.i1823, label %1222, label %._crit_edge.i1824

1222:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1806
  %1223 = getelementptr i8, ptr %1218, i64 8
  %1224 = load i64, ptr %1223, align 4
  %.sroa_idx.i1827 = getelementptr i8, ptr %1218, i64 16
  %1225 = load i64, ptr %.sroa_idx.i1827, align 4
  %hash_coef_ptr.i.i6.i1828 = getelementptr i8, ptr %1219, i64 8
  %tbl_size_ptr.i.i7.i1829 = getelementptr i8, ptr %1219, i64 16
  %offset_tbl_ptr.i.i8.i1830 = getelementptr i8, ptr %1219, i64 40
  %1226 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  %hash_coef.i.i21.i2606 = load i64, ptr %hash_coef_ptr.i.i6.i1828, align 4, !noalias !98
  %tbl_size.i.i22.i2607 = load i64, ptr %tbl_size_ptr.i.i7.i1829, align 4, !noalias !98
  %offset_tbl.i.i23.i2608 = load ptr, ptr %offset_tbl_ptr.i.i8.i1830, align 8, !noalias !98
  %product.i.i.i24.i2609 = mul i64 %hash_coef.i.i21.i2606, 4015701072841558310
  %shifted.i.i.i25.i2610 = lshr i64 %product.i.i.i24.i2609, 32
  %xored.i.i.i26.i2611 = xor i64 %shifted.i.i.i25.i2610, %product.i.i.i24.i2609
  %hash.i.i.i27.i2612 = and i64 %xored.i.i.i26.i2611, %tbl_size.i.i22.i2607
  %offset_ptr.i.i28.i2613 = getelementptr i32, ptr %offset_tbl.i.i23.i2608, i64 %hash.i.i.i27.i2612
  %offset.i.i29.i2614 = load i32, ptr %offset_ptr.i.i28.i2613, align 4, !noalias !98
  %1227 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1228 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1229 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1230

1230:                                             ; preds = %.cont.i2637, %1222
  %.0290.i2615 = phi i32 [ 0, %1222 ], [ %1263, %.cont.i2637 ]
  %.074289.i2616 = phi i1 [ true, %1222 ], [ %1264, %.cont.i2637 ]
  %.sroa.0.0288.i2617 = phi ptr [ %1219, %1222 ], [ %1253, %.cont.i2637 ]
  %.sroa.6.0287.i2618.in = phi i64 [ %1224, %1222 ], [ %1255, %.cont.i2637 ]
  %.sroa.12.0286.i2619.in = phi i64 [ %1225, %1222 ], [ %1256, %.cont.i2637 ]
  %.sroa.17.0285.i2620 = phi i32 [ %offset.i.i29.i2614, %1222 ], [ %offset.i.i57.i2649, %.cont.i2637 ]
  %.sroa.12.0286.i2619 = inttoptr i64 %.sroa.12.0286.i2619.in to ptr
  %.sroa.6.0287.i2618 = inttoptr i64 %.sroa.6.0287.i2618.in to ptr
  %1231 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2617, 0
  %1232 = insertvalue { ptr, ptr, ptr, i32 } %1231, ptr %.sroa.6.0287.i2618, 1
  %1233 = insertvalue { ptr, ptr, ptr, i32 } %1232, ptr %.sroa.12.0286.i2619, 2
  %1234 = insertvalue { ptr, ptr, ptr, i32 } %1233, i32 %.sroa.17.0285.i2620, 3
  %1235 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2617)
  %1236 = sext i32 %.sroa.17.0285.i2620 to i64
  %1237 = getelementptr ptr, ptr %.sroa.0.0288.i2617, i64 %1236
  %1238 = getelementptr i8, ptr %1237, i64 64
  %1239 = load ptr, ptr %1238, align 8
  %result.i15.i2621 = call ptr %1239({ ptr, ptr, ptr, i32 } %1234, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1240 = call i32 %result.i15.i2621({ ptr, ptr, ptr, i32 } %1234, { ptr, ptr, ptr, i32 } %1234, ptr nonnull align 8 %2) #53
  %..i2622 = select i1 %.074289.i2616, ptr %20, ptr %22
  %.188.i2623 = select i1 %.074289.i2616, i64 104, i64 112
  %.189.i2624 = select i1 %.074289.i2616, ptr %21, ptr %23
  %.190.i2625 = select i1 %.074289.i2616, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2622, align 8
  %1241 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2622)
  %1242 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2623
  %1243 = load ptr, ptr %1242, align 8
  store ptr @i32_typ, ptr %.189.i2624, align 8
  %result.i14.i2626 = call ptr %1243({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2624) #46
  %1244 = call i32 %result.i14.i2626({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 dereferenceable(8) %..i2622, i32 %1240) #53
  %1245 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1246 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2625
  %1247 = load ptr, ptr %1246, align 8
  %1248 = load ptr, ptr %1247, align 8
  %1249 = call { ptr } %1248(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i2627 = extractvalue { ptr } %1249, 0
  %1250 = sext i32 %1244 to i64
  %1251 = shl nsw i64 %1250, 5
  %1252 = getelementptr i8, ptr %.fca.0.extract55.i2627, i64 %1251
  %1253 = load ptr, ptr %1252, align 8
  %1254 = getelementptr i8, ptr %1252, i64 8
  %1255 = load i64, ptr %1254, align 4
  %.sroa_idx.i2628 = getelementptr i8, ptr %1252, i64 16
  %1256 = load i64, ptr %.sroa_idx.i2628, align 4
  %1257 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1258 = call { ptr } %1248(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i2629 = extractvalue { ptr } %1258, 0
  %1259 = getelementptr i8, ptr %.fca.0.extract52.i2629, i64 %1251
  store ptr %.sroa.0.0288.i2617, ptr %1259, align 8
  %1260 = getelementptr i8, ptr %1259, i64 8
  store i64 %.sroa.6.0287.i2618.in, ptr %1260, align 4
  %.sroa_idx104.i2630 = getelementptr i8, ptr %1259, i64 16
  store i64 %.sroa.12.0286.i2619.in, ptr %.sroa_idx104.i2630, align 4
  %.sroa_idx105.i2631 = getelementptr i8, ptr %1259, i64 24
  store i32 %.sroa.17.0285.i2620, ptr %.sroa_idx105.i2631, align 4
  %1261 = icmp ne ptr %1253, @nil_typ
  %1262 = icmp ne ptr %1253, null
  %.not94.i2632 = and i1 %1261, %1262
  br i1 %.not94.i2632, label %.cont.i2637, label %1267

.cont.i2637:                                      ; preds = %1230
  %1263 = add nuw nsw i32 %.0290.i2615, 1
  %1264 = xor i1 %.074289.i2616, true
  %hash_coef_ptr.i.i46.i2638 = getelementptr i8, ptr %1253, i64 8
  %tbl_size_ptr.i.i47.i2639 = getelementptr i8, ptr %1253, i64 16
  %offset_tbl_ptr.i.i48.i2640 = getelementptr i8, ptr %1253, i64 40
  %hash_coef.i.i49.i2641 = load i64, ptr %hash_coef_ptr.i.i46.i2638, align 4
  %tbl_size.i.i50.i2642 = load i64, ptr %tbl_size_ptr.i.i47.i2639, align 4
  %offset_tbl.i.i51.i2643 = load ptr, ptr %offset_tbl_ptr.i.i48.i2640, align 8
  %product.i.i.i52.i2644 = mul i64 %hash_coef.i.i49.i2641, 4015701072841558310
  %shifted.i.i.i53.i2645 = lshr i64 %product.i.i.i52.i2644, 32
  %xored.i.i.i54.i2646 = xor i64 %shifted.i.i.i53.i2645, %product.i.i.i52.i2644
  %hash.i.i.i55.i2647 = and i64 %xored.i.i.i54.i2646, %tbl_size.i.i50.i2642
  %offset_ptr.i.i56.i2648 = getelementptr i32, ptr %offset_tbl.i.i51.i2643, i64 %hash.i.i.i55.i2647
  %offset.i.i57.i2649 = load i32, ptr %offset_ptr.i.i56.i2648, align 4
  %1265 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1266 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2650 = icmp eq i32 %1263, 100
  br i1 %exitcond.not.i2650, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2659, label %1230

1267:                                             ; preds = %1230
  %1268 = load i32, ptr %87, align 4
  %1269 = add i32 %1268, 1
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1269, ptr %87, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2659

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2659: ; preds = %1267, %.cont.i2637
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  br label %._crit_edge.i1824

._crit_edge.i1824:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2659, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1806
  %indvars.iv.next.i1825 = add nuw nsw i64 %indvars.iv.i1822, 1
  %exitcond.not.i1826 = icmp eq i64 %indvars.iv.next.i1825, %wide.trip.count.i1783
  br i1 %exitcond.not.i1826, label %._crit_edge.i324, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1806

._crit_edge.i324:                                 ; preds = %._crit_edge.i1824, %1153, %1150
  %1271 = load ptr, ptr %result.i60, align 8
  %1272 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1273 = load ptr, ptr %76, align 8
  %1274 = load ptr, ptr %1271, align 8
  %1275 = getelementptr i8, ptr %1274, i64 72
  %1276 = load ptr, ptr %1275, align 8
  %result.i1.i.i327 = call { i64, i64 } %1276(ptr nocapture nofree nonnull readonly align 8 %1271) #44
  %1277 = extractvalue { i64, i64 } %result.i1.i.i327, 0
  %1278 = extractvalue { i64, i64 } %result.i1.i.i327, 1
  %1279 = urem i64 20, %1278
  %1280 = icmp eq i64 %1279, 0
  %1281 = sub i64 %1278, %1279
  %1282 = select i1 %1280, i64 0, i64 %1281
  %1283 = add i64 %1277, 20
  %1284 = add i64 %1283, %1282
  %1285 = load ptr, ptr %1273, align 8
  %1286 = getelementptr i8, ptr %1285, i64 72
  %1287 = load ptr, ptr %1286, align 8
  %result.i.i.i328 = call { i64, i64 } %1287(ptr nocapture nofree nonnull readonly align 8 %1273) #44
  %1288 = extractvalue { i64, i64 } %result.i.i.i328, 0
  %1289 = extractvalue { i64, i64 } %result.i.i.i328, 1
  %1290 = call i64 @llvm.umax.i64(i64 %1278, i64 %1289) #41
  %1291 = call i64 @llvm.umax.i64(i64 %1290, i64 noundef 8) #41, !range !16
  %1292 = urem i64 %1284, %1289
  %1293 = icmp eq i64 %1292, 0
  %1294 = sub i64 %1289, %1292
  %1295 = select i1 %1293, i64 0, i64 %1294
  %1296 = add i64 %1288, %1284
  %1297 = add i64 %1296, %1295
  %1298 = urem i64 %1297, %1291
  %1299 = icmp eq i64 %1298, 0
  %1300 = sub i64 %1291, %1298
  %1301 = select i1 %1299, i64 0, i64 %1300
  %1302 = add i64 %1301, %1297
  %result.i22.i329 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1302) #48
  store ptr %1271, ptr %result.i22.i329, align 8
  %1303 = getelementptr inbounds i8, ptr %result.i22.i329, i64 8
  store ptr %1273, ptr %1303, align 8
  %1304 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i329)
  %1305 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1306 = load ptr, ptr %1271, align 8
  %1307 = getelementptr i8, ptr %1306, i64 72
  %1308 = load ptr, ptr %1307, align 8
  %result.i.i127.i330 = call { i64, i64 } %1308(ptr nocapture nofree nonnull readonly align 8 %1271) #44
  %1309 = extractvalue { i64, i64 } %result.i.i127.i330, 1
  %1310 = urem i64 20, %1309
  %1311 = icmp eq i64 %1310, 0
  %reass.sub = sub i64 %1309, %1310
  %1312 = add i64 %reass.sub, 20
  %1313 = select i1 %1311, i64 20, i64 %1312
  %1314 = getelementptr i8, ptr %result.i22.i329, i64 %1313
  %1315 = getelementptr i8, ptr %1306, i64 64
  %1316 = load ptr, ptr %1315, align 8
  call void %1316({ ptr, i160 } %907, ptr nocapture nofree nonnull readonly align 8 %1271, ptr nocapture nofree writeonly %1314) #45
  %1317 = load ptr, ptr %result.i22.i329, align 8
  %1318 = load ptr, ptr %1317, align 8
  %1319 = getelementptr i8, ptr %1318, i64 72
  %1320 = load ptr, ptr %1319, align 8
  %result.i1.i128.i332 = call { i64, i64 } %1320(ptr nocapture nofree nonnull readonly align 8 %1317) #44
  %1321 = extractvalue { i64, i64 } %result.i1.i128.i332, 0
  %1322 = extractvalue { i64, i64 } %result.i1.i128.i332, 1
  %1323 = urem i64 20, %1322
  %1324 = icmp eq i64 %1323, 0
  %1325 = sub i64 %1322, %1323
  %1326 = select i1 %1324, i64 0, i64 %1325
  %1327 = add i64 %1321, 20
  %1328 = add i64 %1327, %1326
  %1329 = load ptr, ptr %1303, align 8
  %1330 = load ptr, ptr %1329, align 8
  %1331 = getelementptr i8, ptr %1330, i64 72
  %1332 = load ptr, ptr %1331, align 8
  %result.i.i129.i333 = call { i64, i64 } %1332(ptr nocapture nofree nonnull readonly align 8 %1329) #44
  %1333 = extractvalue { i64, i64 } %result.i.i129.i333, 1
  %1334 = urem i64 %1328, %1333
  %1335 = icmp eq i64 %1334, 0
  %1336 = sub i64 %1333, %1334
  %1337 = select i1 %1335, i64 0, i64 %1336
  %1338 = getelementptr i8, ptr %result.i22.i329, i64 %1328
  %1339 = getelementptr i8, ptr %1338, i64 %1337
  %1340 = getelementptr i8, ptr %1330, i64 64
  %1341 = load ptr, ptr %1340, align 8
  call void %1341({ ptr, i160 } %908, ptr nocapture nofree nonnull readonly align 8 %1329, ptr nocapture nofree writeonly %1339) #45
  %1342 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1343 = getelementptr inbounds i8, ptr %result.i22.i329, i64 16
  store i32 %910, ptr %1343, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  %1344 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1345 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1346 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1347

1347:                                             ; preds = %.cont.i1065, %._crit_edge.i324
  %.0290.i1043 = phi i32 [ 0, %._crit_edge.i324 ], [ %1382, %.cont.i1065 ]
  %.074289.i1044 = phi i1 [ true, %._crit_edge.i324 ], [ %1383, %.cont.i1065 ]
  %.sroa.0.0288.i1045 = phi ptr [ @Entry, %._crit_edge.i324 ], [ %1370, %.cont.i1065 ]
  %.sroa.6.0287.i1046 = phi ptr [ %result.i22.i329, %._crit_edge.i324 ], [ %1384, %.cont.i1065 ]
  %.sroa.12.0286.i1047 = phi ptr [ undef, %._crit_edge.i324 ], [ %1385, %.cont.i1065 ]
  %.sroa.17.0285.i1048 = phi i32 [ 10, %._crit_edge.i324 ], [ %offset.i.i57.i1077, %.cont.i1065 ]
  %1348 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1045, 0
  %1349 = insertvalue { ptr, ptr, ptr, i32 } %1348, ptr %.sroa.6.0287.i1046, 1
  %1350 = insertvalue { ptr, ptr, ptr, i32 } %1349, ptr %.sroa.12.0286.i1047, 2
  %1351 = insertvalue { ptr, ptr, ptr, i32 } %1350, i32 %.sroa.17.0285.i1048, 3
  %1352 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1045)
  %1353 = sext i32 %.sroa.17.0285.i1048 to i64
  %1354 = getelementptr ptr, ptr %.sroa.0.0288.i1045, i64 %1353
  %1355 = getelementptr i8, ptr %1354, i64 64
  %1356 = load ptr, ptr %1355, align 8
  %result.i15.i1049 = call ptr %1356({ ptr, ptr, ptr, i32 } %1351, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1357 = call i32 %result.i15.i1049({ ptr, ptr, ptr, i32 } %1351, { ptr, ptr, ptr, i32 } %1351, ptr nonnull align 8 %2) #53
  %..i1050 = select i1 %.074289.i1044, ptr %56, ptr %58
  %.188.i1051 = select i1 %.074289.i1044, i64 104, i64 112
  %.189.i1052 = select i1 %.074289.i1044, ptr %57, ptr %59
  %.190.i1053 = select i1 %.074289.i1044, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1050, align 8
  %1358 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1050)
  %1359 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1051
  %1360 = load ptr, ptr %1359, align 8
  store ptr @i32_typ, ptr %.189.i1052, align 8
  %result.i14.i1054 = call ptr %1360({ ptr, ptr, ptr, i32 } %900, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1052) #46
  %1361 = call i32 %result.i14.i1054({ ptr, ptr, ptr, i32 } %900, { ptr, ptr, ptr, i32 } %900, ptr nonnull align 8 dereferenceable(8) %..i1050, i32 %1357) #53
  %1362 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1363 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1053
  %1364 = load ptr, ptr %1363, align 8
  %1365 = load ptr, ptr %1364, align 8
  %1366 = call { ptr } %1365(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i1055 = extractvalue { ptr } %1366, 0
  %1367 = sext i32 %1361 to i64
  %1368 = shl nsw i64 %1367, 5
  %1369 = getelementptr i8, ptr %.fca.0.extract55.i1055, i64 %1368
  %1370 = load ptr, ptr %1369, align 8
  %1371 = getelementptr i8, ptr %1369, i64 8
  %1372 = load i64, ptr %1371, align 4
  %.sroa_idx.i1056 = getelementptr i8, ptr %1369, i64 16
  %1373 = load i64, ptr %.sroa_idx.i1056, align 4
  %1374 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1375 = call { ptr } %1365(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i1057 = extractvalue { ptr } %1375, 0
  %1376 = getelementptr i8, ptr %.fca.0.extract52.i1057, i64 %1368
  store ptr %.sroa.0.0288.i1045, ptr %1376, align 8
  %1377 = getelementptr i8, ptr %1376, i64 8
  %1378 = ptrtoint ptr %.sroa.6.0287.i1046 to i64
  %1379 = ptrtoint ptr %.sroa.12.0286.i1047 to i64
  store i64 %1378, ptr %1377, align 4
  %.sroa_idx104.i1058 = getelementptr i8, ptr %1376, i64 16
  store i64 %1379, ptr %.sroa_idx104.i1058, align 4
  %.sroa_idx105.i1059 = getelementptr i8, ptr %1376, i64 24
  store i32 %.sroa.17.0285.i1048, ptr %.sroa_idx105.i1059, align 4
  %1380 = icmp ne ptr %1370, @nil_typ
  %1381 = icmp ne ptr %1370, null
  %.not94.i1060 = and i1 %1380, %1381
  br i1 %.not94.i1060, label %.cont.i1065, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1087

.cont.i1065:                                      ; preds = %1347
  %1382 = add nuw nsw i32 %.0290.i1043, 1
  %1383 = xor i1 %.074289.i1044, true
  %1384 = inttoptr i64 %1372 to ptr
  %1385 = inttoptr i64 %1373 to ptr
  %hash_coef_ptr.i.i46.i1066 = getelementptr i8, ptr %1370, i64 8
  %tbl_size_ptr.i.i47.i1067 = getelementptr i8, ptr %1370, i64 16
  %offset_tbl_ptr.i.i48.i1068 = getelementptr i8, ptr %1370, i64 40
  %hash_coef.i.i49.i1069 = load i64, ptr %hash_coef_ptr.i.i46.i1066, align 4
  %tbl_size.i.i50.i1070 = load i64, ptr %tbl_size_ptr.i.i47.i1067, align 4
  %offset_tbl.i.i51.i1071 = load ptr, ptr %offset_tbl_ptr.i.i48.i1068, align 8
  %product.i.i.i52.i1072 = mul i64 %hash_coef.i.i49.i1069, 4015701072841558310
  %shifted.i.i.i53.i1073 = lshr i64 %product.i.i.i52.i1072, 32
  %xored.i.i.i54.i1074 = xor i64 %shifted.i.i.i53.i1073, %product.i.i.i52.i1072
  %hash.i.i.i55.i1075 = and i64 %xored.i.i.i54.i1074, %tbl_size.i.i50.i1070
  %offset_ptr.i.i56.i1076 = getelementptr i32, ptr %offset_tbl.i.i51.i1071, i64 %hash.i.i.i55.i1075
  %offset.i.i57.i1077 = load i32, ptr %offset_ptr.i.i56.i1076, align 4
  %1386 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1387 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1078 = icmp eq i32 %1382, 100
  br i1 %exitcond.not.i1078, label %1391, label %1347

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1087: ; preds = %1347
  %1388 = load i32, ptr %87, align 4
  %1389 = add i32 %1388, 1
  %1390 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1389, ptr %87, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  br label %CuckooMap_insert_keyK_valueV.exit364

1391:                                             ; preds = %.cont.i1065
  %hash_coef_ptr.i.i46.i1066.le = getelementptr i8, ptr %1370, i64 8
  %tbl_size_ptr.i.i47.i1067.le = getelementptr i8, ptr %1370, i64 16
  %offset_tbl_ptr.i.i48.i1068.le = getelementptr i8, ptr %1370, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  %1392 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1393 = load ptr, ptr %84, align 8
  %1394 = load ptr, ptr %85, align 8
  %1395 = load i32, ptr %83, align 8
  %1396 = shl i32 %1395, 1
  %spec.select.i1104 = call i32 @llvm.smax.i32(i32 %1396, i32 noundef 16) #40
  store i32 %spec.select.i1104, ptr %83, align 8
  %1397 = zext nneg i32 %spec.select.i1104 to i64
  %1398 = shl nuw nsw i64 %1397, 5
  %result.i5.i1105 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1398) #48
  store ptr %result.i5.i1105, ptr %84, align 8
  %result.i4.i1106 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1398) #48
  store ptr %result.i4.i1106, ptr %85, align 8
  store i32 0, ptr %87, align 4
  %1399 = icmp sgt i32 %1395, 0
  br i1 %1399, label %.lr.ph.i1846, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920

.lr.ph.i1846:                                     ; preds = %1391
  %wide.trip.count.i1859 = zext nneg i32 %1395 to i64
  br label %1400

1400:                                             ; preds = %._crit_edge.i1862, %.lr.ph.i1846
  %indvars.iv.i1860 = phi i64 [ 0, %.lr.ph.i1846 ], [ %indvars.iv.next.i1863, %._crit_edge.i1862 ]
  %1401 = shl nuw nsw i64 %indvars.iv.i1860, 5
  %1402 = getelementptr i8, ptr %1393, i64 %1401
  %1403 = load ptr, ptr %1402, align 8
  %1404 = icmp ne ptr %1403, @nil_typ
  %1405 = icmp ne ptr %1403, null
  %.not17.i1861 = and i1 %1404, %1405
  br i1 %.not17.i1861, label %1406, label %._crit_edge.i1862

1406:                                             ; preds = %1400
  %1407 = getelementptr i8, ptr %1402, i64 8
  %1408 = load i64, ptr %1407, align 4
  %.sroa_idx.i1865 = getelementptr i8, ptr %1402, i64 16
  %1409 = load i64, ptr %.sroa_idx.i1865, align 4
  %hash_coef_ptr.i.i6.i1866 = getelementptr i8, ptr %1403, i64 8
  %tbl_size_ptr.i.i7.i1867 = getelementptr i8, ptr %1403, i64 16
  %offset_tbl_ptr.i.i8.i1868 = getelementptr i8, ptr %1403, i64 40
  %1410 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %hash_coef.i.i21.i2677 = load i64, ptr %hash_coef_ptr.i.i6.i1866, align 4, !noalias !101
  %tbl_size.i.i22.i2678 = load i64, ptr %tbl_size_ptr.i.i7.i1867, align 4, !noalias !101
  %offset_tbl.i.i23.i2679 = load ptr, ptr %offset_tbl_ptr.i.i8.i1868, align 8, !noalias !101
  %product.i.i.i24.i2680 = mul i64 %hash_coef.i.i21.i2677, 4015701072841558310
  %shifted.i.i.i25.i2681 = lshr i64 %product.i.i.i24.i2680, 32
  %xored.i.i.i26.i2682 = xor i64 %shifted.i.i.i25.i2681, %product.i.i.i24.i2680
  %hash.i.i.i27.i2683 = and i64 %xored.i.i.i26.i2682, %tbl_size.i.i22.i2678
  %offset_ptr.i.i28.i2684 = getelementptr i32, ptr %offset_tbl.i.i23.i2679, i64 %hash.i.i.i27.i2683
  %offset.i.i29.i2685 = load i32, ptr %offset_ptr.i.i28.i2684, align 4, !noalias !101
  %1411 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1412 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1413 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1414

1414:                                             ; preds = %.cont.i2708, %1406
  %.0290.i2686 = phi i32 [ 0, %1406 ], [ %1447, %.cont.i2708 ]
  %.074289.i2687 = phi i1 [ true, %1406 ], [ %1448, %.cont.i2708 ]
  %.sroa.0.0288.i2688 = phi ptr [ %1403, %1406 ], [ %1437, %.cont.i2708 ]
  %.sroa.6.0287.i2689.in = phi i64 [ %1408, %1406 ], [ %1439, %.cont.i2708 ]
  %.sroa.12.0286.i2690.in = phi i64 [ %1409, %1406 ], [ %1440, %.cont.i2708 ]
  %.sroa.17.0285.i2691 = phi i32 [ %offset.i.i29.i2685, %1406 ], [ %offset.i.i57.i2720, %.cont.i2708 ]
  %.sroa.12.0286.i2690 = inttoptr i64 %.sroa.12.0286.i2690.in to ptr
  %.sroa.6.0287.i2689 = inttoptr i64 %.sroa.6.0287.i2689.in to ptr
  %1415 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2688, 0
  %1416 = insertvalue { ptr, ptr, ptr, i32 } %1415, ptr %.sroa.6.0287.i2689, 1
  %1417 = insertvalue { ptr, ptr, ptr, i32 } %1416, ptr %.sroa.12.0286.i2690, 2
  %1418 = insertvalue { ptr, ptr, ptr, i32 } %1417, i32 %.sroa.17.0285.i2691, 3
  %1419 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2688)
  %1420 = sext i32 %.sroa.17.0285.i2691 to i64
  %1421 = getelementptr ptr, ptr %.sroa.0.0288.i2688, i64 %1420
  %1422 = getelementptr i8, ptr %1421, i64 64
  %1423 = load ptr, ptr %1422, align 8
  %result.i15.i2692 = call ptr %1423({ ptr, ptr, ptr, i32 } %1418, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1424 = call i32 %result.i15.i2692({ ptr, ptr, ptr, i32 } %1418, { ptr, ptr, ptr, i32 } %1418, ptr nonnull align 8 %2) #53
  %..i2693 = select i1 %.074289.i2687, ptr %16, ptr %18
  %.188.i2694 = select i1 %.074289.i2687, i64 104, i64 112
  %.189.i2695 = select i1 %.074289.i2687, ptr %17, ptr %19
  %.190.i2696 = select i1 %.074289.i2687, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2693, align 8
  %1425 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2693)
  %1426 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2694
  %1427 = load ptr, ptr %1426, align 8
  store ptr @i32_typ, ptr %.189.i2695, align 8
  %result.i14.i2697 = call ptr %1427({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2695) #46
  %1428 = call i32 %result.i14.i2697({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 dereferenceable(8) %..i2693, i32 %1424) #53
  %1429 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1430 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2696
  %1431 = load ptr, ptr %1430, align 8
  %1432 = load ptr, ptr %1431, align 8
  %1433 = call { ptr } %1432(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i2698 = extractvalue { ptr } %1433, 0
  %1434 = sext i32 %1428 to i64
  %1435 = shl nsw i64 %1434, 5
  %1436 = getelementptr i8, ptr %.fca.0.extract55.i2698, i64 %1435
  %1437 = load ptr, ptr %1436, align 8
  %1438 = getelementptr i8, ptr %1436, i64 8
  %1439 = load i64, ptr %1438, align 4
  %.sroa_idx.i2699 = getelementptr i8, ptr %1436, i64 16
  %1440 = load i64, ptr %.sroa_idx.i2699, align 4
  %1441 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1442 = call { ptr } %1432(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i2700 = extractvalue { ptr } %1442, 0
  %1443 = getelementptr i8, ptr %.fca.0.extract52.i2700, i64 %1435
  store ptr %.sroa.0.0288.i2688, ptr %1443, align 8
  %1444 = getelementptr i8, ptr %1443, i64 8
  store i64 %.sroa.6.0287.i2689.in, ptr %1444, align 4
  %.sroa_idx104.i2701 = getelementptr i8, ptr %1443, i64 16
  store i64 %.sroa.12.0286.i2690.in, ptr %.sroa_idx104.i2701, align 4
  %.sroa_idx105.i2702 = getelementptr i8, ptr %1443, i64 24
  store i32 %.sroa.17.0285.i2691, ptr %.sroa_idx105.i2702, align 4
  %1445 = icmp ne ptr %1437, @nil_typ
  %1446 = icmp ne ptr %1437, null
  %.not94.i2703 = and i1 %1445, %1446
  br i1 %.not94.i2703, label %.cont.i2708, label %1451

.cont.i2708:                                      ; preds = %1414
  %1447 = add nuw nsw i32 %.0290.i2686, 1
  %1448 = xor i1 %.074289.i2687, true
  %hash_coef_ptr.i.i46.i2709 = getelementptr i8, ptr %1437, i64 8
  %tbl_size_ptr.i.i47.i2710 = getelementptr i8, ptr %1437, i64 16
  %offset_tbl_ptr.i.i48.i2711 = getelementptr i8, ptr %1437, i64 40
  %hash_coef.i.i49.i2712 = load i64, ptr %hash_coef_ptr.i.i46.i2709, align 4
  %tbl_size.i.i50.i2713 = load i64, ptr %tbl_size_ptr.i.i47.i2710, align 4
  %offset_tbl.i.i51.i2714 = load ptr, ptr %offset_tbl_ptr.i.i48.i2711, align 8
  %product.i.i.i52.i2715 = mul i64 %hash_coef.i.i49.i2712, 4015701072841558310
  %shifted.i.i.i53.i2716 = lshr i64 %product.i.i.i52.i2715, 32
  %xored.i.i.i54.i2717 = xor i64 %shifted.i.i.i53.i2716, %product.i.i.i52.i2715
  %hash.i.i.i55.i2718 = and i64 %xored.i.i.i54.i2717, %tbl_size.i.i50.i2713
  %offset_ptr.i.i56.i2719 = getelementptr i32, ptr %offset_tbl.i.i51.i2714, i64 %hash.i.i.i55.i2718
  %offset.i.i57.i2720 = load i32, ptr %offset_ptr.i.i56.i2719, align 4
  %1449 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1450 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2721 = icmp eq i32 %1447, 100
  br i1 %exitcond.not.i2721, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2730, label %1414

1451:                                             ; preds = %1414
  %1452 = load i32, ptr %87, align 4
  %1453 = add i32 %1452, 1
  %1454 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1453, ptr %87, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2730

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2730: ; preds = %1451, %.cont.i2708
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  br label %._crit_edge.i1862

._crit_edge.i1862:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2730, %1400
  %indvars.iv.next.i1863 = add nuw nsw i64 %indvars.iv.i1860, 1
  %exitcond.not.i1864 = icmp eq i64 %indvars.iv.next.i1863, %wide.trip.count.i1859
  br i1 %exitcond.not.i1864, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1882, label %1400

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1882: ; preds = %._crit_edge.i1900, %._crit_edge.i1862
  %indvars.iv.i1898 = phi i64 [ %indvars.iv.next.i1901, %._crit_edge.i1900 ], [ 0, %._crit_edge.i1862 ]
  %1455 = shl nuw nsw i64 %indvars.iv.i1898, 5
  %1456 = getelementptr i8, ptr %1394, i64 %1455
  %1457 = load ptr, ptr %1456, align 8
  %1458 = icmp ne ptr %1457, @nil_typ
  %1459 = icmp ne ptr %1457, null
  %.not17.i1899 = and i1 %1458, %1459
  br i1 %.not17.i1899, label %1460, label %._crit_edge.i1900

1460:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1882
  %1461 = getelementptr i8, ptr %1456, i64 8
  %1462 = load i64, ptr %1461, align 4
  %.sroa_idx.i1903 = getelementptr i8, ptr %1456, i64 16
  %1463 = load i64, ptr %.sroa_idx.i1903, align 4
  %hash_coef_ptr.i.i6.i1904 = getelementptr i8, ptr %1457, i64 8
  %tbl_size_ptr.i.i7.i1905 = getelementptr i8, ptr %1457, i64 16
  %offset_tbl_ptr.i.i8.i1906 = getelementptr i8, ptr %1457, i64 40
  %1464 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  %hash_coef.i.i21.i2748 = load i64, ptr %hash_coef_ptr.i.i6.i1904, align 4, !noalias !104
  %tbl_size.i.i22.i2749 = load i64, ptr %tbl_size_ptr.i.i7.i1905, align 4, !noalias !104
  %offset_tbl.i.i23.i2750 = load ptr, ptr %offset_tbl_ptr.i.i8.i1906, align 8, !noalias !104
  %product.i.i.i24.i2751 = mul i64 %hash_coef.i.i21.i2748, 4015701072841558310
  %shifted.i.i.i25.i2752 = lshr i64 %product.i.i.i24.i2751, 32
  %xored.i.i.i26.i2753 = xor i64 %shifted.i.i.i25.i2752, %product.i.i.i24.i2751
  %hash.i.i.i27.i2754 = and i64 %xored.i.i.i26.i2753, %tbl_size.i.i22.i2749
  %offset_ptr.i.i28.i2755 = getelementptr i32, ptr %offset_tbl.i.i23.i2750, i64 %hash.i.i.i27.i2754
  %offset.i.i29.i2756 = load i32, ptr %offset_ptr.i.i28.i2755, align 4, !noalias !104
  %1465 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1466 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1467 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1468

1468:                                             ; preds = %.cont.i2779, %1460
  %.0290.i2757 = phi i32 [ 0, %1460 ], [ %1501, %.cont.i2779 ]
  %.074289.i2758 = phi i1 [ true, %1460 ], [ %1502, %.cont.i2779 ]
  %.sroa.0.0288.i2759 = phi ptr [ %1457, %1460 ], [ %1491, %.cont.i2779 ]
  %.sroa.6.0287.i2760.in = phi i64 [ %1462, %1460 ], [ %1493, %.cont.i2779 ]
  %.sroa.12.0286.i2761.in = phi i64 [ %1463, %1460 ], [ %1494, %.cont.i2779 ]
  %.sroa.17.0285.i2762 = phi i32 [ %offset.i.i29.i2756, %1460 ], [ %offset.i.i57.i2791, %.cont.i2779 ]
  %.sroa.12.0286.i2761 = inttoptr i64 %.sroa.12.0286.i2761.in to ptr
  %.sroa.6.0287.i2760 = inttoptr i64 %.sroa.6.0287.i2760.in to ptr
  %1469 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2759, 0
  %1470 = insertvalue { ptr, ptr, ptr, i32 } %1469, ptr %.sroa.6.0287.i2760, 1
  %1471 = insertvalue { ptr, ptr, ptr, i32 } %1470, ptr %.sroa.12.0286.i2761, 2
  %1472 = insertvalue { ptr, ptr, ptr, i32 } %1471, i32 %.sroa.17.0285.i2762, 3
  %1473 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2759)
  %1474 = sext i32 %.sroa.17.0285.i2762 to i64
  %1475 = getelementptr ptr, ptr %.sroa.0.0288.i2759, i64 %1474
  %1476 = getelementptr i8, ptr %1475, i64 64
  %1477 = load ptr, ptr %1476, align 8
  %result.i15.i2763 = call ptr %1477({ ptr, ptr, ptr, i32 } %1472, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1478 = call i32 %result.i15.i2763({ ptr, ptr, ptr, i32 } %1472, { ptr, ptr, ptr, i32 } %1472, ptr nonnull align 8 %2) #53
  %..i2764 = select i1 %.074289.i2758, ptr %12, ptr %14
  %.188.i2765 = select i1 %.074289.i2758, i64 104, i64 112
  %.189.i2766 = select i1 %.074289.i2758, ptr %13, ptr %15
  %.190.i2767 = select i1 %.074289.i2758, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2764, align 8
  %1479 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2764)
  %1480 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2765
  %1481 = load ptr, ptr %1480, align 8
  store ptr @i32_typ, ptr %.189.i2766, align 8
  %result.i14.i2768 = call ptr %1481({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2766) #46
  %1482 = call i32 %result.i14.i2768({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 dereferenceable(8) %..i2764, i32 %1478) #53
  %1483 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1484 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2767
  %1485 = load ptr, ptr %1484, align 8
  %1486 = load ptr, ptr %1485, align 8
  %1487 = call { ptr } %1486(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i2769 = extractvalue { ptr } %1487, 0
  %1488 = sext i32 %1482 to i64
  %1489 = shl nsw i64 %1488, 5
  %1490 = getelementptr i8, ptr %.fca.0.extract55.i2769, i64 %1489
  %1491 = load ptr, ptr %1490, align 8
  %1492 = getelementptr i8, ptr %1490, i64 8
  %1493 = load i64, ptr %1492, align 4
  %.sroa_idx.i2770 = getelementptr i8, ptr %1490, i64 16
  %1494 = load i64, ptr %.sroa_idx.i2770, align 4
  %1495 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1496 = call { ptr } %1486(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i2771 = extractvalue { ptr } %1496, 0
  %1497 = getelementptr i8, ptr %.fca.0.extract52.i2771, i64 %1489
  store ptr %.sroa.0.0288.i2759, ptr %1497, align 8
  %1498 = getelementptr i8, ptr %1497, i64 8
  store i64 %.sroa.6.0287.i2760.in, ptr %1498, align 4
  %.sroa_idx104.i2772 = getelementptr i8, ptr %1497, i64 16
  store i64 %.sroa.12.0286.i2761.in, ptr %.sroa_idx104.i2772, align 4
  %.sroa_idx105.i2773 = getelementptr i8, ptr %1497, i64 24
  store i32 %.sroa.17.0285.i2762, ptr %.sroa_idx105.i2773, align 4
  %1499 = icmp ne ptr %1491, @nil_typ
  %1500 = icmp ne ptr %1491, null
  %.not94.i2774 = and i1 %1499, %1500
  br i1 %.not94.i2774, label %.cont.i2779, label %1505

.cont.i2779:                                      ; preds = %1468
  %1501 = add nuw nsw i32 %.0290.i2757, 1
  %1502 = xor i1 %.074289.i2758, true
  %hash_coef_ptr.i.i46.i2780 = getelementptr i8, ptr %1491, i64 8
  %tbl_size_ptr.i.i47.i2781 = getelementptr i8, ptr %1491, i64 16
  %offset_tbl_ptr.i.i48.i2782 = getelementptr i8, ptr %1491, i64 40
  %hash_coef.i.i49.i2783 = load i64, ptr %hash_coef_ptr.i.i46.i2780, align 4
  %tbl_size.i.i50.i2784 = load i64, ptr %tbl_size_ptr.i.i47.i2781, align 4
  %offset_tbl.i.i51.i2785 = load ptr, ptr %offset_tbl_ptr.i.i48.i2782, align 8
  %product.i.i.i52.i2786 = mul i64 %hash_coef.i.i49.i2783, 4015701072841558310
  %shifted.i.i.i53.i2787 = lshr i64 %product.i.i.i52.i2786, 32
  %xored.i.i.i54.i2788 = xor i64 %shifted.i.i.i53.i2787, %product.i.i.i52.i2786
  %hash.i.i.i55.i2789 = and i64 %xored.i.i.i54.i2788, %tbl_size.i.i50.i2784
  %offset_ptr.i.i56.i2790 = getelementptr i32, ptr %offset_tbl.i.i51.i2785, i64 %hash.i.i.i55.i2789
  %offset.i.i57.i2791 = load i32, ptr %offset_ptr.i.i56.i2790, align 4
  %1503 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1504 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2792 = icmp eq i32 %1501, 100
  br i1 %exitcond.not.i2792, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2801, label %1468

1505:                                             ; preds = %1468
  %1506 = load i32, ptr %87, align 4
  %1507 = add i32 %1506, 1
  %1508 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1507, ptr %87, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2801

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2801: ; preds = %1505, %.cont.i2779
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  br label %._crit_edge.i1900

._crit_edge.i1900:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2801, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1882
  %indvars.iv.next.i1901 = add nuw nsw i64 %indvars.iv.i1898, 1
  %exitcond.not.i1902 = icmp eq i64 %indvars.iv.next.i1901, %wide.trip.count.i1859
  br i1 %exitcond.not.i1902, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1882

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920: ; preds = %._crit_edge.i1900, %1391
  %1509 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %hash_coef.i.i21.i1130 = load i64, ptr %hash_coef_ptr.i.i46.i1066.le, align 4, !noalias !107
  %tbl_size.i.i22.i1131 = load i64, ptr %tbl_size_ptr.i.i47.i1067.le, align 4, !noalias !107
  %offset_tbl.i.i23.i1132 = load ptr, ptr %offset_tbl_ptr.i.i48.i1068.le, align 8, !noalias !107
  %product.i.i.i24.i1133 = mul i64 %hash_coef.i.i21.i1130, 4015701072841558310
  %shifted.i.i.i25.i1134 = lshr i64 %product.i.i.i24.i1133, 32
  %xored.i.i.i26.i1135 = xor i64 %shifted.i.i.i25.i1134, %product.i.i.i24.i1133
  %hash.i.i.i27.i1136 = and i64 %xored.i.i.i26.i1135, %tbl_size.i.i22.i1131
  %offset_ptr.i.i28.i1137 = getelementptr i32, ptr %offset_tbl.i.i23.i1132, i64 %hash.i.i.i27.i1136
  %offset.i.i29.i1138 = load i32, ptr %offset_ptr.i.i28.i1137, align 4, !noalias !107
  %1510 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1511 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1513

1513:                                             ; preds = %.cont.i1162, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920
  %.0290.i1140 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920 ], [ %1546, %.cont.i1162 ]
  %.074289.i1141 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920 ], [ %1547, %.cont.i1162 ]
  %.sroa.0.0288.i1142 = phi ptr [ %1370, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920 ], [ %1536, %.cont.i1162 ]
  %.sroa.6.0287.i1143.in = phi i64 [ %1372, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920 ], [ %1538, %.cont.i1162 ]
  %.sroa.12.0286.i1144.in = phi i64 [ %1373, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920 ], [ %1539, %.cont.i1162 ]
  %.sroa.17.0285.i1145 = phi i32 [ %offset.i.i29.i1138, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1920 ], [ %offset.i.i57.i1174, %.cont.i1162 ]
  %.sroa.12.0286.i1144 = inttoptr i64 %.sroa.12.0286.i1144.in to ptr
  %.sroa.6.0287.i1143 = inttoptr i64 %.sroa.6.0287.i1143.in to ptr
  %1514 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1142, 0
  %1515 = insertvalue { ptr, ptr, ptr, i32 } %1514, ptr %.sroa.6.0287.i1143, 1
  %1516 = insertvalue { ptr, ptr, ptr, i32 } %1515, ptr %.sroa.12.0286.i1144, 2
  %1517 = insertvalue { ptr, ptr, ptr, i32 } %1516, i32 %.sroa.17.0285.i1145, 3
  %1518 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1142)
  %1519 = sext i32 %.sroa.17.0285.i1145 to i64
  %1520 = getelementptr ptr, ptr %.sroa.0.0288.i1142, i64 %1519
  %1521 = getelementptr i8, ptr %1520, i64 64
  %1522 = load ptr, ptr %1521, align 8
  %result.i15.i1146 = call ptr %1522({ ptr, ptr, ptr, i32 } %1517, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1523 = call i32 %result.i15.i1146({ ptr, ptr, ptr, i32 } %1517, { ptr, ptr, ptr, i32 } %1517, ptr nonnull align 8 %2) #53
  %..i1147 = select i1 %.074289.i1141, ptr %52, ptr %54
  %.188.i1148 = select i1 %.074289.i1141, i64 104, i64 112
  %.189.i1149 = select i1 %.074289.i1141, ptr %53, ptr %55
  %.190.i1150 = select i1 %.074289.i1141, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1147, align 8
  %1524 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1147)
  %1525 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1148
  %1526 = load ptr, ptr %1525, align 8
  store ptr @i32_typ, ptr %.189.i1149, align 8
  %result.i14.i1151 = call ptr %1526({ ptr, ptr, ptr, i32 } %900, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1149) #46
  %1527 = call i32 %result.i14.i1151({ ptr, ptr, ptr, i32 } %900, { ptr, ptr, ptr, i32 } %900, ptr nonnull align 8 dereferenceable(8) %..i1147, i32 %1523) #53
  %1528 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1529 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1150
  %1530 = load ptr, ptr %1529, align 8
  %1531 = load ptr, ptr %1530, align 8
  %1532 = call { ptr } %1531(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i1152 = extractvalue { ptr } %1532, 0
  %1533 = sext i32 %1527 to i64
  %1534 = shl nsw i64 %1533, 5
  %1535 = getelementptr i8, ptr %.fca.0.extract55.i1152, i64 %1534
  %1536 = load ptr, ptr %1535, align 8
  %1537 = getelementptr i8, ptr %1535, i64 8
  %1538 = load i64, ptr %1537, align 4
  %.sroa_idx.i1153 = getelementptr i8, ptr %1535, i64 16
  %1539 = load i64, ptr %.sroa_idx.i1153, align 4
  %1540 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1541 = call { ptr } %1531(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i1154 = extractvalue { ptr } %1541, 0
  %1542 = getelementptr i8, ptr %.fca.0.extract52.i1154, i64 %1534
  store ptr %.sroa.0.0288.i1142, ptr %1542, align 8
  %1543 = getelementptr i8, ptr %1542, i64 8
  store i64 %.sroa.6.0287.i1143.in, ptr %1543, align 4
  %.sroa_idx104.i1155 = getelementptr i8, ptr %1542, i64 16
  store i64 %.sroa.12.0286.i1144.in, ptr %.sroa_idx104.i1155, align 4
  %.sroa_idx105.i1156 = getelementptr i8, ptr %1542, i64 24
  store i32 %.sroa.17.0285.i1145, ptr %.sroa_idx105.i1156, align 4
  %1544 = icmp ne ptr %1536, @nil_typ
  %1545 = icmp ne ptr %1536, null
  %.not94.i1157 = and i1 %1544, %1545
  br i1 %.not94.i1157, label %.cont.i1162, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1184

.cont.i1162:                                      ; preds = %1513
  %1546 = add nuw nsw i32 %.0290.i1140, 1
  %1547 = xor i1 %.074289.i1141, true
  %hash_coef_ptr.i.i46.i1163 = getelementptr i8, ptr %1536, i64 8
  %tbl_size_ptr.i.i47.i1164 = getelementptr i8, ptr %1536, i64 16
  %offset_tbl_ptr.i.i48.i1165 = getelementptr i8, ptr %1536, i64 40
  %hash_coef.i.i49.i1166 = load i64, ptr %hash_coef_ptr.i.i46.i1163, align 4
  %tbl_size.i.i50.i1167 = load i64, ptr %tbl_size_ptr.i.i47.i1164, align 4
  %offset_tbl.i.i51.i1168 = load ptr, ptr %offset_tbl_ptr.i.i48.i1165, align 8
  %product.i.i.i52.i1169 = mul i64 %hash_coef.i.i49.i1166, 4015701072841558310
  %shifted.i.i.i53.i1170 = lshr i64 %product.i.i.i52.i1169, 32
  %xored.i.i.i54.i1171 = xor i64 %shifted.i.i.i53.i1170, %product.i.i.i52.i1169
  %hash.i.i.i55.i1172 = and i64 %xored.i.i.i54.i1171, %tbl_size.i.i50.i1167
  %offset_ptr.i.i56.i1173 = getelementptr i32, ptr %offset_tbl.i.i51.i1168, i64 %hash.i.i.i55.i1172
  %offset.i.i57.i1174 = load i32, ptr %offset_ptr.i.i56.i1173, align 4
  %1548 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1175 = icmp eq i32 %1546, 100
  br i1 %exitcond.not.i1175, label %1553, label %1513

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1184: ; preds = %1513
  %1550 = load i32, ptr %87, align 4
  %1551 = add i32 %1550, 1
  %1552 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1551, ptr %87, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  br label %CuckooMap_insert_keyK_valueV.exit364

1553:                                             ; preds = %.cont.i1162
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %1554 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1555 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1556 = load ptr, ptr %84, align 8
  %1557 = load ptr, ptr %85, align 8
  %1558 = load i32, ptr %83, align 8
  %1559 = shl i32 %1558, 1
  %spec.select.i1201 = call i32 @llvm.smax.i32(i32 %1559, i32 noundef 16) #40
  store i32 %spec.select.i1201, ptr %83, align 8
  %1560 = zext nneg i32 %spec.select.i1201 to i64
  %1561 = shl nuw nsw i64 %1560, 5
  %result.i5.i1202 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1561) #48
  store ptr %result.i5.i1202, ptr %84, align 8
  %result.i4.i1203 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1561) #48
  store ptr %result.i4.i1203, ptr %85, align 8
  store i32 0, ptr %87, align 4
  %1562 = icmp sgt i32 %1558, 0
  br i1 %1562, label %.lr.ph.i1922, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1958.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1958.thread: ; preds = %1553
  %1563 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit364

.lr.ph.i1922:                                     ; preds = %1553
  %wide.trip.count.i1935 = zext nneg i32 %1558 to i64
  br label %1564

1564:                                             ; preds = %._crit_edge.i1938, %.lr.ph.i1922
  %indvars.iv.i1936 = phi i64 [ 0, %.lr.ph.i1922 ], [ %indvars.iv.next.i1939, %._crit_edge.i1938 ]
  %1565 = shl nuw nsw i64 %indvars.iv.i1936, 5
  %1566 = getelementptr i8, ptr %1556, i64 %1565
  %1567 = load ptr, ptr %1566, align 8
  %1568 = icmp ne ptr %1567, @nil_typ
  %1569 = icmp ne ptr %1567, null
  %.not17.i1937 = and i1 %1568, %1569
  br i1 %.not17.i1937, label %1570, label %._crit_edge.i1938

1570:                                             ; preds = %1564
  %1571 = getelementptr i8, ptr %1566, i64 8
  %1572 = load i64, ptr %1571, align 4
  %.sroa_idx.i1941 = getelementptr i8, ptr %1566, i64 16
  %1573 = load i64, ptr %.sroa_idx.i1941, align 4
  %hash_coef_ptr.i.i6.i1942 = getelementptr i8, ptr %1567, i64 8
  %tbl_size_ptr.i.i7.i1943 = getelementptr i8, ptr %1567, i64 16
  %offset_tbl_ptr.i.i8.i1944 = getelementptr i8, ptr %1567, i64 40
  %1574 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %hash_coef.i.i21.i2819 = load i64, ptr %hash_coef_ptr.i.i6.i1942, align 4, !noalias !110
  %tbl_size.i.i22.i2820 = load i64, ptr %tbl_size_ptr.i.i7.i1943, align 4, !noalias !110
  %offset_tbl.i.i23.i2821 = load ptr, ptr %offset_tbl_ptr.i.i8.i1944, align 8, !noalias !110
  %product.i.i.i24.i2822 = mul i64 %hash_coef.i.i21.i2819, 4015701072841558310
  %shifted.i.i.i25.i2823 = lshr i64 %product.i.i.i24.i2822, 32
  %xored.i.i.i26.i2824 = xor i64 %shifted.i.i.i25.i2823, %product.i.i.i24.i2822
  %hash.i.i.i27.i2825 = and i64 %xored.i.i.i26.i2824, %tbl_size.i.i22.i2820
  %offset_ptr.i.i28.i2826 = getelementptr i32, ptr %offset_tbl.i.i23.i2821, i64 %hash.i.i.i27.i2825
  %offset.i.i29.i2827 = load i32, ptr %offset_ptr.i.i28.i2826, align 4, !noalias !110
  %1575 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1576 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1577 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1578

1578:                                             ; preds = %.cont.i2850, %1570
  %.0290.i2828 = phi i32 [ 0, %1570 ], [ %1611, %.cont.i2850 ]
  %.074289.i2829 = phi i1 [ true, %1570 ], [ %1612, %.cont.i2850 ]
  %.sroa.0.0288.i2830 = phi ptr [ %1567, %1570 ], [ %1601, %.cont.i2850 ]
  %.sroa.6.0287.i2831.in = phi i64 [ %1572, %1570 ], [ %1603, %.cont.i2850 ]
  %.sroa.12.0286.i2832.in = phi i64 [ %1573, %1570 ], [ %1604, %.cont.i2850 ]
  %.sroa.17.0285.i2833 = phi i32 [ %offset.i.i29.i2827, %1570 ], [ %offset.i.i57.i2862, %.cont.i2850 ]
  %.sroa.12.0286.i2832 = inttoptr i64 %.sroa.12.0286.i2832.in to ptr
  %.sroa.6.0287.i2831 = inttoptr i64 %.sroa.6.0287.i2831.in to ptr
  %1579 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2830, 0
  %1580 = insertvalue { ptr, ptr, ptr, i32 } %1579, ptr %.sroa.6.0287.i2831, 1
  %1581 = insertvalue { ptr, ptr, ptr, i32 } %1580, ptr %.sroa.12.0286.i2832, 2
  %1582 = insertvalue { ptr, ptr, ptr, i32 } %1581, i32 %.sroa.17.0285.i2833, 3
  %1583 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2830)
  %1584 = sext i32 %.sroa.17.0285.i2833 to i64
  %1585 = getelementptr ptr, ptr %.sroa.0.0288.i2830, i64 %1584
  %1586 = getelementptr i8, ptr %1585, i64 64
  %1587 = load ptr, ptr %1586, align 8
  %result.i15.i2834 = call ptr %1587({ ptr, ptr, ptr, i32 } %1582, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1588 = call i32 %result.i15.i2834({ ptr, ptr, ptr, i32 } %1582, { ptr, ptr, ptr, i32 } %1582, ptr nonnull align 8 %2) #53
  %..i2835 = select i1 %.074289.i2829, ptr %8, ptr %10
  %.188.i2836 = select i1 %.074289.i2829, i64 104, i64 112
  %.189.i2837 = select i1 %.074289.i2829, ptr %9, ptr %11
  %.190.i2838 = select i1 %.074289.i2829, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2835, align 8
  %1589 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2835)
  %1590 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2836
  %1591 = load ptr, ptr %1590, align 8
  store ptr @i32_typ, ptr %.189.i2837, align 8
  %result.i14.i2839 = call ptr %1591({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2837) #46
  %1592 = call i32 %result.i14.i2839({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 dereferenceable(8) %..i2835, i32 %1588) #53
  %1593 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1594 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2838
  %1595 = load ptr, ptr %1594, align 8
  %1596 = load ptr, ptr %1595, align 8
  %1597 = call { ptr } %1596(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i2840 = extractvalue { ptr } %1597, 0
  %1598 = sext i32 %1592 to i64
  %1599 = shl nsw i64 %1598, 5
  %1600 = getelementptr i8, ptr %.fca.0.extract55.i2840, i64 %1599
  %1601 = load ptr, ptr %1600, align 8
  %1602 = getelementptr i8, ptr %1600, i64 8
  %1603 = load i64, ptr %1602, align 4
  %.sroa_idx.i2841 = getelementptr i8, ptr %1600, i64 16
  %1604 = load i64, ptr %.sroa_idx.i2841, align 4
  %1605 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1606 = call { ptr } %1596(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i2842 = extractvalue { ptr } %1606, 0
  %1607 = getelementptr i8, ptr %.fca.0.extract52.i2842, i64 %1599
  store ptr %.sroa.0.0288.i2830, ptr %1607, align 8
  %1608 = getelementptr i8, ptr %1607, i64 8
  store i64 %.sroa.6.0287.i2831.in, ptr %1608, align 4
  %.sroa_idx104.i2843 = getelementptr i8, ptr %1607, i64 16
  store i64 %.sroa.12.0286.i2832.in, ptr %.sroa_idx104.i2843, align 4
  %.sroa_idx105.i2844 = getelementptr i8, ptr %1607, i64 24
  store i32 %.sroa.17.0285.i2833, ptr %.sroa_idx105.i2844, align 4
  %1609 = icmp ne ptr %1601, @nil_typ
  %1610 = icmp ne ptr %1601, null
  %.not94.i2845 = and i1 %1609, %1610
  br i1 %.not94.i2845, label %.cont.i2850, label %1615

.cont.i2850:                                      ; preds = %1578
  %1611 = add nuw nsw i32 %.0290.i2828, 1
  %1612 = xor i1 %.074289.i2829, true
  %hash_coef_ptr.i.i46.i2851 = getelementptr i8, ptr %1601, i64 8
  %tbl_size_ptr.i.i47.i2852 = getelementptr i8, ptr %1601, i64 16
  %offset_tbl_ptr.i.i48.i2853 = getelementptr i8, ptr %1601, i64 40
  %hash_coef.i.i49.i2854 = load i64, ptr %hash_coef_ptr.i.i46.i2851, align 4
  %tbl_size.i.i50.i2855 = load i64, ptr %tbl_size_ptr.i.i47.i2852, align 4
  %offset_tbl.i.i51.i2856 = load ptr, ptr %offset_tbl_ptr.i.i48.i2853, align 8
  %product.i.i.i52.i2857 = mul i64 %hash_coef.i.i49.i2854, 4015701072841558310
  %shifted.i.i.i53.i2858 = lshr i64 %product.i.i.i52.i2857, 32
  %xored.i.i.i54.i2859 = xor i64 %shifted.i.i.i53.i2858, %product.i.i.i52.i2857
  %hash.i.i.i55.i2860 = and i64 %xored.i.i.i54.i2859, %tbl_size.i.i50.i2855
  %offset_ptr.i.i56.i2861 = getelementptr i32, ptr %offset_tbl.i.i51.i2856, i64 %hash.i.i.i55.i2860
  %offset.i.i57.i2862 = load i32, ptr %offset_ptr.i.i56.i2861, align 4
  %1613 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1614 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2863 = icmp eq i32 %1611, 100
  br i1 %exitcond.not.i2863, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2872, label %1578

1615:                                             ; preds = %1578
  %1616 = load i32, ptr %87, align 4
  %1617 = add i32 %1616, 1
  %1618 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1617, ptr %87, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2872

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2872: ; preds = %1615, %.cont.i2850
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  br label %._crit_edge.i1938

._crit_edge.i1938:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2872, %1564
  %indvars.iv.next.i1939 = add nuw nsw i64 %indvars.iv.i1936, 1
  %exitcond.not.i1940 = icmp eq i64 %indvars.iv.next.i1939, %wide.trip.count.i1935
  br i1 %exitcond.not.i1940, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1958, label %1564

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1958: ; preds = %._crit_edge.i1938
  %1619 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %1620

1620:                                             ; preds = %._crit_edge.i1976, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1958
  %indvars.iv.i1974 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1958 ], [ %indvars.iv.next.i1977, %._crit_edge.i1976 ]
  %1621 = shl nuw nsw i64 %indvars.iv.i1974, 5
  %1622 = getelementptr i8, ptr %1557, i64 %1621
  %1623 = load ptr, ptr %1622, align 8
  %1624 = icmp ne ptr %1623, @nil_typ
  %1625 = icmp ne ptr %1623, null
  %.not17.i1975 = and i1 %1624, %1625
  br i1 %.not17.i1975, label %1626, label %._crit_edge.i1976

1626:                                             ; preds = %1620
  %1627 = getelementptr i8, ptr %1622, i64 8
  %1628 = load i64, ptr %1627, align 4
  %.sroa_idx.i1979 = getelementptr i8, ptr %1622, i64 16
  %1629 = load i64, ptr %.sroa_idx.i1979, align 4
  %hash_coef_ptr.i.i6.i1980 = getelementptr i8, ptr %1623, i64 8
  %tbl_size_ptr.i.i7.i1981 = getelementptr i8, ptr %1623, i64 16
  %offset_tbl_ptr.i.i8.i1982 = getelementptr i8, ptr %1623, i64 40
  %1630 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %hash_coef.i.i21.i2890 = load i64, ptr %hash_coef_ptr.i.i6.i1980, align 4, !noalias !113
  %tbl_size.i.i22.i2891 = load i64, ptr %tbl_size_ptr.i.i7.i1981, align 4, !noalias !113
  %offset_tbl.i.i23.i2892 = load ptr, ptr %offset_tbl_ptr.i.i8.i1982, align 8, !noalias !113
  %product.i.i.i24.i2893 = mul i64 %hash_coef.i.i21.i2890, 4015701072841558310
  %shifted.i.i.i25.i2894 = lshr i64 %product.i.i.i24.i2893, 32
  %xored.i.i.i26.i2895 = xor i64 %shifted.i.i.i25.i2894, %product.i.i.i24.i2893
  %hash.i.i.i27.i2896 = and i64 %xored.i.i.i26.i2895, %tbl_size.i.i22.i2891
  %offset_ptr.i.i28.i2897 = getelementptr i32, ptr %offset_tbl.i.i23.i2892, i64 %hash.i.i.i27.i2896
  %offset.i.i29.i2898 = load i32, ptr %offset_ptr.i.i28.i2897, align 4, !noalias !113
  %1631 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1632 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1633 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1634

1634:                                             ; preds = %.cont.i2921, %1626
  %.0290.i2899 = phi i32 [ 0, %1626 ], [ %1667, %.cont.i2921 ]
  %.074289.i2900 = phi i1 [ true, %1626 ], [ %1668, %.cont.i2921 ]
  %.sroa.0.0288.i2901 = phi ptr [ %1623, %1626 ], [ %1657, %.cont.i2921 ]
  %.sroa.6.0287.i2902.in = phi i64 [ %1628, %1626 ], [ %1659, %.cont.i2921 ]
  %.sroa.12.0286.i2903.in = phi i64 [ %1629, %1626 ], [ %1660, %.cont.i2921 ]
  %.sroa.17.0285.i2904 = phi i32 [ %offset.i.i29.i2898, %1626 ], [ %offset.i.i57.i2933, %.cont.i2921 ]
  %.sroa.12.0286.i2903 = inttoptr i64 %.sroa.12.0286.i2903.in to ptr
  %.sroa.6.0287.i2902 = inttoptr i64 %.sroa.6.0287.i2902.in to ptr
  %1635 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2901, 0
  %1636 = insertvalue { ptr, ptr, ptr, i32 } %1635, ptr %.sroa.6.0287.i2902, 1
  %1637 = insertvalue { ptr, ptr, ptr, i32 } %1636, ptr %.sroa.12.0286.i2903, 2
  %1638 = insertvalue { ptr, ptr, ptr, i32 } %1637, i32 %.sroa.17.0285.i2904, 3
  %1639 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2901)
  %1640 = sext i32 %.sroa.17.0285.i2904 to i64
  %1641 = getelementptr ptr, ptr %.sroa.0.0288.i2901, i64 %1640
  %1642 = getelementptr i8, ptr %1641, i64 64
  %1643 = load ptr, ptr %1642, align 8
  %result.i15.i2905 = call ptr %1643({ ptr, ptr, ptr, i32 } %1638, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1644 = call i32 %result.i15.i2905({ ptr, ptr, ptr, i32 } %1638, { ptr, ptr, ptr, i32 } %1638, ptr nonnull align 8 %2) #53
  %..i2906 = select i1 %.074289.i2900, ptr %4, ptr %6
  %.188.i2907 = select i1 %.074289.i2900, i64 104, i64 112
  %.189.i2908 = select i1 %.074289.i2900, ptr %5, ptr %7
  %.190.i2909 = select i1 %.074289.i2900, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2906, align 8
  %1645 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2906)
  %1646 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2907
  %1647 = load ptr, ptr %1646, align 8
  store ptr @i32_typ, ptr %.189.i2908, align 8
  %result.i14.i2910 = call ptr %1647({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2908) #46
  %1648 = call i32 %result.i14.i2910({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 dereferenceable(8) %..i2906, i32 %1644) #53
  %1649 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1650 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2909
  %1651 = load ptr, ptr %1650, align 8
  %1652 = load ptr, ptr %1651, align 8
  %1653 = call { ptr } %1652(ptr nonnull %result.i60) #43
  %.fca.0.extract55.i2911 = extractvalue { ptr } %1653, 0
  %1654 = sext i32 %1648 to i64
  %1655 = shl nsw i64 %1654, 5
  %1656 = getelementptr i8, ptr %.fca.0.extract55.i2911, i64 %1655
  %1657 = load ptr, ptr %1656, align 8
  %1658 = getelementptr i8, ptr %1656, i64 8
  %1659 = load i64, ptr %1658, align 4
  %.sroa_idx.i2912 = getelementptr i8, ptr %1656, i64 16
  %1660 = load i64, ptr %.sroa_idx.i2912, align 4
  %1661 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1662 = call { ptr } %1652(ptr nonnull %result.i60) #43
  %.fca.0.extract52.i2913 = extractvalue { ptr } %1662, 0
  %1663 = getelementptr i8, ptr %.fca.0.extract52.i2913, i64 %1655
  store ptr %.sroa.0.0288.i2901, ptr %1663, align 8
  %1664 = getelementptr i8, ptr %1663, i64 8
  store i64 %.sroa.6.0287.i2902.in, ptr %1664, align 4
  %.sroa_idx104.i2914 = getelementptr i8, ptr %1663, i64 16
  store i64 %.sroa.12.0286.i2903.in, ptr %.sroa_idx104.i2914, align 4
  %.sroa_idx105.i2915 = getelementptr i8, ptr %1663, i64 24
  store i32 %.sroa.17.0285.i2904, ptr %.sroa_idx105.i2915, align 4
  %1665 = icmp ne ptr %1657, @nil_typ
  %1666 = icmp ne ptr %1657, null
  %.not94.i2916 = and i1 %1665, %1666
  br i1 %.not94.i2916, label %.cont.i2921, label %1671

.cont.i2921:                                      ; preds = %1634
  %1667 = add nuw nsw i32 %.0290.i2899, 1
  %1668 = xor i1 %.074289.i2900, true
  %hash_coef_ptr.i.i46.i2922 = getelementptr i8, ptr %1657, i64 8
  %tbl_size_ptr.i.i47.i2923 = getelementptr i8, ptr %1657, i64 16
  %offset_tbl_ptr.i.i48.i2924 = getelementptr i8, ptr %1657, i64 40
  %hash_coef.i.i49.i2925 = load i64, ptr %hash_coef_ptr.i.i46.i2922, align 4
  %tbl_size.i.i50.i2926 = load i64, ptr %tbl_size_ptr.i.i47.i2923, align 4
  %offset_tbl.i.i51.i2927 = load ptr, ptr %offset_tbl_ptr.i.i48.i2924, align 8
  %product.i.i.i52.i2928 = mul i64 %hash_coef.i.i49.i2925, 4015701072841558310
  %shifted.i.i.i53.i2929 = lshr i64 %product.i.i.i52.i2928, 32
  %xored.i.i.i54.i2930 = xor i64 %shifted.i.i.i53.i2929, %product.i.i.i52.i2928
  %hash.i.i.i55.i2931 = and i64 %xored.i.i.i54.i2930, %tbl_size.i.i50.i2926
  %offset_ptr.i.i56.i2932 = getelementptr i32, ptr %offset_tbl.i.i51.i2927, i64 %hash.i.i.i55.i2931
  %offset.i.i57.i2933 = load i32, ptr %offset_ptr.i.i56.i2932, align 4
  %1669 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1670 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2934 = icmp eq i32 %1667, 100
  br i1 %exitcond.not.i2934, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2943, label %1634

1671:                                             ; preds = %1634
  %1672 = load i32, ptr %87, align 4
  %1673 = add i32 %1672, 1
  %1674 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1673, ptr %87, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2943

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2943: ; preds = %1671, %.cont.i2921
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  br label %._crit_edge.i1976

._crit_edge.i1976:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2943, %1620
  %indvars.iv.next.i1977 = add nuw nsw i64 %indvars.iv.i1974, 1
  %exitcond.not.i1978 = icmp eq i64 %indvars.iv.next.i1977, %wide.trip.count.i1935
  br i1 %exitcond.not.i1978, label %CuckooMap_insert_keyK_valueV.exit364, label %1620

CuckooMap_insert_keyK_valueV.exit364:             ; preds = %._crit_edge.i1976, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1958.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1184, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1087, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit990, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit930
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %indvars.iv.next498 = add nuw nsw i64 %indvars.iv497, 1
  %exitcond166.not = icmp eq i64 %indvars.iv.next498, %111
  br i1 %exitcond166.not, label %._crit_edge5, label %._crit_edge3

._crit_edge5:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit364
  %1675 = call i64 @clock()
  %.sroa.0213.0.insert.ext = zext i32 %spec.select to i160
  %1676 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0213.0.insert.ext, 1
  %1677 = load ptr, ptr %81, align 8
  %1678 = call i32 %1677({ ptr, i160 } %1676) #53
  %1679 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1680 = load i32, ptr %83, align 8
  %1681 = add i32 %1680, -1
  %1682 = and i32 %1681, %1678
  %1683 = load ptr, ptr %84, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1684 = sext i32 %1682 to i64
  %1685 = shl nsw i64 %1684, 5
  %1686 = getelementptr i8, ptr %1683, i64 %1685
  %1687 = load ptr, ptr %1686, align 8
  %1688 = icmp ne ptr %1687, @nil_typ
  %1689 = icmp ne ptr %1687, null
  %.not45.i = and i1 %1688, %1689
  br i1 %.not45.i, label %1690, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

1690:                                             ; preds = %._crit_edge5
  %1691 = getelementptr i8, ptr %1686, i64 8
  %1692 = load i64, ptr %1691, align 4
  %.sroa_idx.i1249 = getelementptr i8, ptr %1686, i64 16
  %1693 = load i64, ptr %.sroa_idx.i1249, align 4
  %1694 = inttoptr i64 %1692 to ptr
  %1695 = inttoptr i64 %1693 to ptr
  %hash_coef_ptr.i.i4.i = getelementptr i8, ptr %1687, i64 8
  %tbl_size_ptr.i.i5.i = getelementptr i8, ptr %1687, i64 16
  %offset_tbl_ptr.i.i6.i = getelementptr i8, ptr %1687, i64 40
  %hash_coef.i.i7.i = load i64, ptr %hash_coef_ptr.i.i4.i, align 4, !noalias !116
  %tbl_size.i.i8.i = load i64, ptr %tbl_size_ptr.i.i5.i, align 4, !noalias !116
  %offset_tbl.i.i9.i = load ptr, ptr %offset_tbl_ptr.i.i6.i, align 8, !noalias !116
  %product.i.i.i10.i = mul i64 %hash_coef.i.i7.i, 4015701072841558310
  %shifted.i.i.i11.i = lshr i64 %product.i.i.i10.i, 32
  %xored.i.i.i12.i = xor i64 %shifted.i.i.i11.i, %product.i.i.i10.i
  %hash.i.i.i13.i = and i64 %xored.i.i.i12.i, %tbl_size.i.i8.i
  %offset_ptr.i.i14.i = getelementptr i32, ptr %offset_tbl.i.i9.i, i64 %hash.i.i.i13.i
  %offset.i.i15.i = load i32, ptr %offset_ptr.i.i14.i, align 4, !noalias !116
  %1696 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1687, 0
  %1697 = insertvalue { ptr, ptr, ptr, i32 } %1696, ptr %1694, 1
  %1698 = insertvalue { ptr, ptr, ptr, i32 } %1697, ptr %1695, 2
  %1699 = insertvalue { ptr, ptr, ptr, i32 } %1698, i32 %offset.i.i15.i, 3
  %1700 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1701 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1687) #40
  %1702 = sext i32 %offset.i.i15.i to i64
  %1703 = getelementptr ptr, ptr %1687, i64 %1702
  %1704 = getelementptr i8, ptr %1703, i64 64
  %1705 = load ptr, ptr %1704, align 8
  %result.i2.i1250 = call ptr %1705({ ptr, ptr, ptr, i32 } %1699, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1706 = call i32 %result.i2.i1250({ ptr, ptr, ptr, i32 } %1699, { ptr, ptr, ptr, i32 } %1699, ptr nonnull align 8 %2) #53
  %1707 = icmp eq i32 %1706, %1678
  br i1 %1707, label %._crit_edge.i1251, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1251:                                ; preds = %1690
  %1708 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1709 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1687)
  %1710 = getelementptr i8, ptr %1703, i64 48
  %1711 = load ptr, ptr %1710, align 8
  %result.i1.i1252 = call ptr %1711({ ptr, ptr, ptr, i32 } %1699, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1712 = call { ptr, i160 } %result.i1.i1252({ ptr, ptr, ptr, i32 } %1699, { ptr, ptr, ptr, i32 } %1699, ptr nonnull align 8 %2) #53
  %1713 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1714 = load ptr, ptr %82, align 8
  %1715 = call i1 %1714({ ptr, i160 } %1712, { ptr, i160 } %1676) #53
  br i1 %1715, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1251, %1690, %._crit_edge5
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1723

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1251
  %1716 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1717 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1687)
  %1718 = getelementptr i8, ptr %1703, i64 56
  %1719 = load ptr, ptr %1718, align 8
  %result.i.i1253 = call ptr %1719({ ptr, ptr, ptr, i32 } %1699, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1720 = call { ptr, i160 } %result.i.i1253({ ptr, ptr, ptr, i32 } %1699, { ptr, ptr, ptr, i32 } %1699, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i = extractvalue { ptr, i160 } %1720, 0
  %.fca.1.extract23.i = extractvalue { ptr, i160 } %1720, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1721 = icmp ne ptr %.fca.0.extract22.i, @nil_typ
  %1722 = icmp ne ptr %.fca.0.extract22.i, null
  %.not63.i = and i1 %1721, %1722
  %extract.t1352 = trunc i160 %.fca.1.extract23.i to i32
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %1723

1723:                                             ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %1724 = add i32 %1678, 2127912214
  %1725 = shl i32 %1678, 12
  %1726 = add i32 %1724, %1725
  %1727 = ashr i32 %1726, 19
  %1728 = xor i32 %1726, %1727
  %1729 = xor i32 %1728, -949894596
  %1730 = add i32 %1729, 374761393
  %1731 = shl i32 %1729, 5
  %1732 = add i32 %1730, %1731
  %1733 = add i32 %1732, -744332180
  %1734 = shl i32 %1732, 9
  %1735 = xor i32 %1733, %1734
  %1736 = add i32 %1735, -42973499
  %1737 = shl i32 %1735, 3
  %1738 = add i32 %1736, %1737
  %1739 = ashr i32 %1738, 16
  %1740 = xor i32 %1738, %1739
  %1741 = xor i32 %1740, -1252372727
  %1742 = load i32, ptr %83, align 8
  %1743 = add i32 %1742, -1
  %1744 = and i32 %1743, %1741
  %1745 = load ptr, ptr %85, align 8
  %1746 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1747 = sext i32 %1744 to i64
  %1748 = shl nsw i64 %1747, 5
  %1749 = getelementptr i8, ptr %1745, i64 %1748
  %1750 = load ptr, ptr %1749, align 8
  %1751 = icmp ne ptr %1750, @nil_typ
  %1752 = icmp ne ptr %1750, null
  %.not45.i1284 = and i1 %1751, %1752
  br i1 %.not45.i1284, label %1753, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309

1753:                                             ; preds = %1723
  %1754 = getelementptr i8, ptr %1749, i64 8
  %1755 = load i64, ptr %1754, align 4
  %.sroa_idx.i1289 = getelementptr i8, ptr %1749, i64 16
  %1756 = load i64, ptr %.sroa_idx.i1289, align 4
  %1757 = inttoptr i64 %1755 to ptr
  %1758 = inttoptr i64 %1756 to ptr
  %hash_coef_ptr.i.i4.i1290 = getelementptr i8, ptr %1750, i64 8
  %tbl_size_ptr.i.i5.i1291 = getelementptr i8, ptr %1750, i64 16
  %offset_tbl_ptr.i.i6.i1292 = getelementptr i8, ptr %1750, i64 40
  %hash_coef.i.i7.i1293 = load i64, ptr %hash_coef_ptr.i.i4.i1290, align 4, !noalias !119
  %tbl_size.i.i8.i1294 = load i64, ptr %tbl_size_ptr.i.i5.i1291, align 4, !noalias !119
  %offset_tbl.i.i9.i1295 = load ptr, ptr %offset_tbl_ptr.i.i6.i1292, align 8, !noalias !119
  %product.i.i.i10.i1296 = mul i64 %hash_coef.i.i7.i1293, 4015701072841558310
  %shifted.i.i.i11.i1297 = lshr i64 %product.i.i.i10.i1296, 32
  %xored.i.i.i12.i1298 = xor i64 %shifted.i.i.i11.i1297, %product.i.i.i10.i1296
  %hash.i.i.i13.i1299 = and i64 %xored.i.i.i12.i1298, %tbl_size.i.i8.i1294
  %offset_ptr.i.i14.i1300 = getelementptr i32, ptr %offset_tbl.i.i9.i1295, i64 %hash.i.i.i13.i1299
  %offset.i.i15.i1301 = load i32, ptr %offset_ptr.i.i14.i1300, align 4, !noalias !119
  %1759 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1750, 0
  %1760 = insertvalue { ptr, ptr, ptr, i32 } %1759, ptr %1757, 1
  %1761 = insertvalue { ptr, ptr, ptr, i32 } %1760, ptr %1758, 2
  %1762 = insertvalue { ptr, ptr, ptr, i32 } %1761, i32 %offset.i.i15.i1301, 3
  %1763 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1764 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1750) #40
  %1765 = sext i32 %offset.i.i15.i1301 to i64
  %1766 = getelementptr ptr, ptr %1750, i64 %1765
  %1767 = getelementptr i8, ptr %1766, i64 64
  %1768 = load ptr, ptr %1767, align 8
  %result.i2.i1302 = call ptr %1768({ ptr, ptr, ptr, i32 } %1762, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1769 = call i32 %result.i2.i1302({ ptr, ptr, ptr, i32 } %1762, { ptr, ptr, ptr, i32 } %1762, ptr nonnull align 8 %2) #53
  %1770 = icmp eq i32 %1769, %1678
  br i1 %1770, label %._crit_edge.i1303, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309

._crit_edge.i1303:                                ; preds = %1753
  %1771 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1772 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1750)
  %1773 = getelementptr i8, ptr %1766, i64 48
  %1774 = load ptr, ptr %1773, align 8
  %result.i1.i1304 = call ptr %1774({ ptr, ptr, ptr, i32 } %1762, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1775 = call { ptr, i160 } %result.i1.i1304({ ptr, ptr, ptr, i32 } %1762, { ptr, ptr, ptr, i32 } %1762, ptr nonnull align 8 %2) #53
  %1776 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1777 = load ptr, ptr %82, align 8
  %1778 = call i1 %1777({ ptr, i160 } %1775, { ptr, i160 } %1676) #53
  br i1 %1778, label %1779, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309

1779:                                             ; preds = %._crit_edge.i1303
  %1780 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1781 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1750)
  %1782 = getelementptr i8, ptr %1766, i64 56
  %1783 = load ptr, ptr %1782, align 8
  %result.i.i1306 = call ptr %1783({ ptr, ptr, ptr, i32 } %1762, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1784 = call { ptr, i160 } %result.i.i1306({ ptr, ptr, ptr, i32 } %1762, { ptr, ptr, ptr, i32 } %1762, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1307 = extractvalue { ptr, i160 } %1784, 0
  %.fca.1.extract23.i1308 = extractvalue { ptr, i160 } %1784, 1
  %1785 = trunc i160 %.fca.1.extract23.i1308 to i32
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309: ; preds = %1779, %._crit_edge.i1303, %1753, %1723
  %.reg2mem43.sroa.3.0.i1285 = phi i32 [ %1785, %1779 ], [ poison, %._crit_edge.i1303 ], [ poison, %1723 ], [ poison, %1753 ]
  %.reg2mem41.0.i1286 = phi ptr [ %.fca.0.extract22.i1307, %1779 ], [ @nil_typ, %._crit_edge.i1303 ], [ @nil_typ, %1723 ], [ @nil_typ, %1753 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %.not.i388 = icmp eq ptr %.reg2mem41.0.i1286, null
  %1786 = select i1 %.not.i388, ptr @nil_typ, ptr %.reg2mem41.0.i1286
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not63.i1351.off0 = phi i32 [ %.reg2mem43.sroa.3.0.i1285, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309 ], [ %extract.t1352, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem56.0.i = phi ptr [ %1786, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1309 ], [ %.fca.0.extract22.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %1787 = icmp ne ptr %.reg2mem56.0.i, @nil_typ
  %1788 = icmp ne ptr %.reg2mem56.0.i, null
  %.not271 = and i1 %1787, %1788
  br i1 %.not271, label %._crit_edge6, label %._crit_edge7

._crit_edge6:                                     ; preds = %CuckooMap_get_keyK.exit
  %1789 = add i32 %spec.select, 1
  %.not275 = icmp eq i32 %1789, %.not63.i1351.off0
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge6, %CuckooMap_get_keyK.exit
  %.3264 = phi i1 [ %.not275, %._crit_edge6 ], [ false, %CuckooMap_get_keyK.exit ]
  %1790 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1791 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1792 = load i32, ptr %87, align 4
  %.not276 = icmp eq i32 %1792, %.pre
  %1793 = select i1 %.not276, i1 %.3264, i1 false
  br label %._crit_edge.lr.ph.i

1794:                                             ; preds = %1
  %1795 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1796 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1797 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1798 = call i64 @clock()
  %1799 = call i64 @clock()
  %1800 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1801 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1802 = load i32, ptr %87, align 4
  %.not = icmp eq i32 %1802, 0
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %1794, %._crit_edge7
  %1803 = phi i64 [ %896, %._crit_edge7 ], [ %1798, %1794 ]
  %1804 = phi i32 [ %.pre, %._crit_edge7 ], [ 0, %1794 ]
  %1805 = phi i64 [ %1675, %._crit_edge7 ], [ %1799, %1794 ]
  %.reg2mem21.0.in = phi i1 [ %1793, %._crit_edge7 ], [ %.not, %1794 ]
  %1806 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1807 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1808 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i.i1418.h2s3193, align 16
  %1809 = sub i64 %1805, %1803
  %1810 = getelementptr inbounds i8, ptr %result.i.i1418.h2s3193, i64 13
  store i8 0, ptr %1810, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(14) %result.i.i1418.h2s3193) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i.i.i.h2s3191, align 16
  %1811 = getelementptr inbounds i8, ptr %result.i.i.i.h2s3191, i64 14
  store i8 0, ptr %1811, align 2
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.h2s3191) #53
  %1812 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #55
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i.i304.i.h2s3189, align 16
  %1813 = getelementptr inbounds i8, ptr %result.i.i304.i.h2s3189, i64 14
  store i8 0, ptr %1813, align 2
  %puts.i229.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.h2s3189) #53
  %1814 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1809) #55
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i.i324.i.h2s3187, align 4
  %1815 = getelementptr inbounds i8, ptr %result.i.i324.i.h2s3187, i64 3
  store i8 0, ptr %1815, align 1
  %puts.i249.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.h2s3187) #53
  br i1 %107, label %._crit_edge.lr.ph.i345.i, label %._crit_edge.lr.ph.i1434

._crit_edge.lr.ph.i345.i:                         ; preds = %._crit_edge.lr.ph.i
  %1816 = zext nneg i32 %0 to i64
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i.i344.i.h2s3185, align 16
  %1817 = mul i64 %1809, 1000000
  %1818 = sdiv i64 %1817, %1816
  %1819 = getelementptr inbounds i8, ptr %result.i.i344.i.h2s3185, i64 15
  store i8 0, ptr %1819, align 1
  %puts.i269.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.h2s3185) #53
  %1820 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1818) #55
  %1821 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i.i364.i.h2s3183, align 4
  %1822 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1823 = getelementptr inbounds i8, ptr %result.i.i364.i.h2s3183, i64 3
  store i8 0, ptr %1823, align 1
  %puts.i289.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.h2s3183) #53
  br label %._crit_edge.lr.ph.i1434

._crit_edge.lr.ph.i1434:                          ; preds = %._crit_edge.lr.ph.i345.i, %._crit_edge.lr.ph.i
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1824 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i.i1433.h2s3181, align 1
  %1826 = getelementptr inbounds i8, ptr %result.i.i1433.h2s3181, i64 18
  store i8 0, ptr %1826, align 1
  %puts.i529 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i1433.h2s3181) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %. = select i1 %.reg2mem21.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.313 = select i1 %.reg2mem21.0.in, ptr %68, ptr %72
  %.314 = select i1 %.reg2mem21.0.in, ptr %69, ptr %73
  %.315 = select i1 %.reg2mem21.0.in, ptr %70, ptr %74
  %.316 = select i1 %.reg2mem21.0.in, ptr %71, ptr %75
  store ptr @_parameterization_Bufferi8, ptr %.313, align 8
  %.313.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem21.0.in, ptr %68, ptr %72
  %.313.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.313.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.313.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.313.sroa.sel325.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem21.0.in, ptr %68, ptr %72
  %.313.sroa.sel325.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.313.sroa.sel325.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.313.sroa.sel325.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1827 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.313)
  store ptr @buffer_typ, ptr %.314, align 8
  %.314.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem21.0.in, ptr %69, ptr %73
  %.314.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.314.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.314.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.314.sroa.sel320.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem21.0.in, ptr %69, ptr %73
  %.314.sroa.sel320.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.314.sroa.sel320.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.314.sroa.sel320.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1828 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.314) #40
  store ptr @_parameterization_String, ptr %.315, align 8
  %1829 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.315)
  store ptr @String, ptr %.316, align 8
  %1830 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.316) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1831 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1832 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <4 x i8> %., ptr %result.i.i1453.h2s3180, align 4
  %1833 = getelementptr inbounds i8, ptr %result.i.i1453.h2s3180, i64 4
  store i8 0, ptr %1833, align 4
  %puts.i550 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i1453.h2s3180) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1834 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1835 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %result.i.i1473.h2s3178, align 1
  %1836 = getelementptr inbounds i8, ptr %result.i.i1473.h2s3178, i64 27
  store i8 0, ptr %1836, align 1
  %puts.i571 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(28) %result.i.i1473.h2s3178) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1837 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1804) #55
  %1838 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1839 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1840 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store i8 41, ptr %result.i.i1493.h2s3177, align 2
  %1841 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1842 = getelementptr inbounds i8, ptr %result.i.i1493.h2s3177, i64 1
  store i8 0, ptr %1842, align 1
  %puts.i593 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i.i1493.h2s3177) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr #18 {
  %2 = alloca {}, align 8
  %result.i.i798.h2s1656 = alloca [5 x i8], align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(5) %result.i.i798.h2s1656, i8 0, i64 5, i1 false)
  %result.i.i778.h2s1657 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i.i778.h2s1657, i8 0, i64 19, i1 false)
  %result.i.i364.i.h2s1659 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i364.i.h2s1659, align 4
  %result.i.i344.i.h2s1661 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i344.i.h2s1661, i8 0, i64 16, i1 false)
  %result.i.i324.i.h2s1663 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i324.i.h2s1663, align 4
  %result.i.i304.i.h2s1665 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i304.i.h2s1665, i8 0, i64 15, i1 false)
  %result.i.i.i.h2s1667 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i.i.h2s1667, i8 0, i64 15, i1 false)
  %result.i.i758.h2s1669 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i.i758.h2s1669, i8 0, i64 19, i1 false)
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca { ptr }, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca { ptr }, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [1 x ptr], align 8
  %34 = alloca { ptr }, align 8
  %oldProtect.i37 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %35 = alloca [3 x ptr], align 8
  %36 = alloca { ptr, ptr, ptr }, align 8
  %37 = alloca [1 x ptr], align 8
  %38 = alloca { ptr }, align 8
  %39 = alloca [3 x ptr], align 8
  %40 = alloca { ptr, ptr, ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %result.i35 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i35, align 8
  %43 = getelementptr inbounds i8, ptr %result.i35, i64 8
  store ptr @_parameterization_i32, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %result.i35, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i35) #40
  %result.i34 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  %result.i36 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i34, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i34, ptr noalias nofree noundef nonnull readnone @drgmnjsbrc, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i24 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i34) #47
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i34) #40
  %result.i33 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i37) #40
  %result.i38 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i33, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i37) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i37) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i33, ptr noalias nofree noundef nonnull readnone @uvhofywczn, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i33) #47
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i33) #40
  %48 = getelementptr inbounds i8, ptr %result.i35, i64 48
  store ptr %ret.i24, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %result.i35, i64 56
  store ptr %ret.i, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i35, i64 40
  store i32 8, ptr %50, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %51 = getelementptr inbounds i8, ptr %result.i35, i64 24
  store ptr %result.i1.i, ptr %51, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %52 = getelementptr inbounds i8, ptr %result.i35, i64 32
  store ptr %result.i.i, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %54 = getelementptr inbounds i8, ptr %result.i35, i64 44
  store i32 0, ptr %54, align 4
  %55 = icmp sgt i32 %0, 0
  br i1 %55, label %._crit_edge.preheader, label %._crit_edge1._crit_edge.thread

._crit_edge1._crit_edge.thread:                   ; preds = %1
  %56 = call i64 @clock()
  br label %._crit_edge.lr.ph.i759

._crit_edge.preheader:                            ; preds = %1
  %wide.trip.count = zext nneg i32 %0 to i64
  %57 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i35, 1
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr undef, 2
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 10, 3
  %60 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 10, 3
  br label %._crit_edge

._crit_edge:                                      ; preds = %CuckooMap_insert_keyK_valueV.exit, %._crit_edge.preheader
  %indvars.iv = phi i64 [ 0, %._crit_edge.preheader ], [ %indvars.iv.next, %CuckooMap_insert_keyK_valueV.exit ]
  %.0148108 = phi i64 [ 0, %._crit_edge.preheader ], [ %830, %CuckooMap_insert_keyK_valueV.exit ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %.sroa.0142.0.insert.ext = zext nneg i64 %indvars.iv to i160
  %61 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0142.0.insert.ext, 1
  %.sroa.0139.0.insert.ext = zext nneg i64 %indvars.iv.next to i160
  %62 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0139.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %63 = load ptr, ptr %48, align 8
  %64 = call i32 %63({ ptr, i160 } %61) #53
  %65 = load i32, ptr %50, align 8
  %66 = add i32 %65, -1
  %67 = and i32 %66, %64
  %68 = load ptr, ptr %51, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %70 = sext i32 %67 to i64
  %71 = shl nsw i64 %70, 5
  %72 = getelementptr i8, ptr %68, i64 %71
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr i8, ptr %72, i64 8
  %75 = icmp ne ptr %73, @nil_typ
  %76 = icmp ne ptr %73, null
  %.not66.i = and i1 %75, %76
  br i1 %.not66.i, label %77, label %175

77:                                               ; preds = %._crit_edge
  %78 = load i64, ptr %74, align 4
  %.sroa_idx.i = getelementptr i8, ptr %72, i64 16
  %79 = load i64, ptr %.sroa_idx.i, align 4
  %80 = inttoptr i64 %78 to ptr
  %81 = inttoptr i64 %79 to ptr
  %hash_coef_ptr.i.i11.i = getelementptr i8, ptr %73, i64 8
  %tbl_size_ptr.i.i12.i = getelementptr i8, ptr %73, i64 16
  %offset_tbl_ptr.i.i13.i = getelementptr i8, ptr %73, i64 40
  %hash_coef.i.i14.i = load i64, ptr %hash_coef_ptr.i.i11.i, align 4, !noalias !122
  %tbl_size.i.i15.i = load i64, ptr %tbl_size_ptr.i.i12.i, align 4, !noalias !122
  %offset_tbl.i.i16.i = load ptr, ptr %offset_tbl_ptr.i.i13.i, align 8, !noalias !122
  %product.i.i.i17.i = mul i64 %hash_coef.i.i14.i, 4015701072841558310
  %shifted.i.i.i18.i = lshr i64 %product.i.i.i17.i, 32
  %xored.i.i.i19.i = xor i64 %shifted.i.i.i18.i, %product.i.i.i17.i
  %hash.i.i.i20.i = and i64 %xored.i.i.i19.i, %tbl_size.i.i15.i
  %offset_ptr.i.i21.i = getelementptr i32, ptr %offset_tbl.i.i16.i, i64 %hash.i.i.i20.i
  %offset.i.i22.i = load i32, ptr %offset_ptr.i.i21.i, align 4, !noalias !122
  %82 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %73, 0
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %80, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %81, 2
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %offset.i.i22.i, 3
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %73) #40
  %88 = sext i32 %offset.i.i22.i to i64
  %89 = getelementptr ptr, ptr %73, i64 %88
  %90 = getelementptr i8, ptr %89, i64 64
  %91 = load ptr, ptr %90, align 8
  %result.i8.i = call ptr %91({ ptr, ptr, ptr, i32 } %85, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %92 = call i32 %result.i8.i({ ptr, ptr, ptr, i32 } %85, { ptr, ptr, ptr, i32 } %85, ptr nonnull align 8 %2) #53
  %93 = icmp eq i32 %92, %64
  br i1 %93, label %._crit_edge.i364, label %175

._crit_edge.i364:                                 ; preds = %77
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %73)
  %96 = getelementptr i8, ptr %89, i64 48
  %97 = load ptr, ptr %96, align 8
  %result.i7.i = call ptr %97({ ptr, ptr, ptr, i32 } %85, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %98 = call { ptr, i160 } %result.i7.i({ ptr, ptr, ptr, i32 } %85, { ptr, ptr, ptr, i32 } %85, ptr nonnull align 8 %2) #53
  %99 = load ptr, ptr %49, align 8
  %100 = call i1 %99({ ptr, i160 } %98, { ptr, i160 } %61) #53
  br i1 %100, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %175

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i364
  %101 = load ptr, ptr %result.i35, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %103 = load ptr, ptr %43, align 8
  %104 = load ptr, ptr %101, align 8, !alias.scope !125
  %105 = getelementptr i8, ptr %104, i64 72
  %106 = load ptr, ptr %105, align 8, !alias.scope !125
  %result.i1.i.i = call { i64, i64 } %106(ptr nocapture nofree nonnull readonly align 8 %101) #44, !alias.scope !125
  %107 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %108 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %109 = urem i64 20, %108
  %110 = icmp eq i64 %109, 0
  %111 = sub i64 %108, %109
  %112 = select i1 %110, i64 0, i64 %111
  %113 = add i64 %107, 20
  %114 = add i64 %113, %112
  %115 = load ptr, ptr %103, align 8, !alias.scope !125
  %116 = getelementptr i8, ptr %115, i64 72
  %117 = load ptr, ptr %116, align 8, !alias.scope !125
  %result.i.i.i365 = call { i64, i64 } %117(ptr nocapture nofree nonnull readonly align 8 %103) #44, !alias.scope !125
  %118 = extractvalue { i64, i64 } %result.i.i.i365, 0
  %119 = extractvalue { i64, i64 } %result.i.i.i365, 1
  %120 = call i64 @llvm.umax.i64(i64 %108, i64 %119) #41
  %121 = call i64 @llvm.umax.i64(i64 %120, i64 noundef 8) #41, !range !16
  %122 = urem i64 %114, %119
  %123 = icmp eq i64 %122, 0
  %124 = sub i64 %119, %122
  %125 = select i1 %123, i64 0, i64 %124
  %126 = add i64 %118, %114
  %127 = add i64 %126, %125
  %128 = urem i64 %127, %121
  %129 = icmp eq i64 %128, 0
  %130 = sub i64 %121, %128
  %131 = select i1 %129, i64 0, i64 %130
  %132 = add i64 %131, %127
  %result.i9.i = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %132) #48
  store ptr %101, ptr %result.i9.i, align 8
  %133 = getelementptr inbounds i8, ptr %result.i9.i, i64 8
  store ptr %103, ptr %133, align 8
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %136 = load ptr, ptr %101, align 8
  %137 = getelementptr i8, ptr %136, i64 72
  %138 = load ptr, ptr %137, align 8
  %result.i.i38.i = call { i64, i64 } %138(ptr nocapture nofree nonnull readonly align 8 %101) #44
  %139 = extractvalue { i64, i64 } %result.i.i38.i, 1
  %140 = urem i64 20, %139
  %141 = icmp eq i64 %140, 0
  %reass.sub = sub i64 %139, %140
  %142 = add i64 %reass.sub, 20
  %143 = select i1 %141, i64 20, i64 %142
  %144 = getelementptr i8, ptr %result.i9.i, i64 %143
  %145 = getelementptr i8, ptr %136, i64 64
  %146 = load ptr, ptr %145, align 8
  call void %146({ ptr, i160 } %61, ptr nocapture nofree nonnull readonly align 8 %101, ptr nocapture nofree writeonly %144) #45
  %147 = load ptr, ptr %result.i9.i, align 8
  %148 = load ptr, ptr %147, align 8
  %149 = getelementptr i8, ptr %148, i64 72
  %150 = load ptr, ptr %149, align 8
  %result.i1.i39.i = call { i64, i64 } %150(ptr nocapture nofree nonnull readonly align 8 %147) #44
  %151 = extractvalue { i64, i64 } %result.i1.i39.i, 0
  %152 = extractvalue { i64, i64 } %result.i1.i39.i, 1
  %153 = urem i64 20, %152
  %154 = icmp eq i64 %153, 0
  %155 = sub i64 %152, %153
  %156 = select i1 %154, i64 0, i64 %155
  %157 = add i64 %151, 20
  %158 = add i64 %157, %156
  %159 = load ptr, ptr %133, align 8
  %160 = load ptr, ptr %159, align 8
  %161 = getelementptr i8, ptr %160, i64 72
  %162 = load ptr, ptr %161, align 8
  %result.i.i40.i = call { i64, i64 } %162(ptr nocapture nofree nonnull readonly align 8 %159) #44
  %163 = extractvalue { i64, i64 } %result.i.i40.i, 1
  %164 = urem i64 %158, %163
  %165 = icmp eq i64 %164, 0
  %166 = sub i64 %163, %164
  %167 = select i1 %165, i64 0, i64 %166
  %168 = getelementptr i8, ptr %result.i9.i, i64 %158
  %169 = getelementptr i8, ptr %168, i64 %167
  %170 = getelementptr i8, ptr %160, i64 64
  %171 = load ptr, ptr %170, align 8
  call void %171({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %159, ptr nocapture nofree writeonly %169) #45
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %173 = getelementptr inbounds i8, ptr %result.i9.i, i64 16
  store i32 %64, ptr %173, align 8
  store ptr @Entry, ptr %72, align 8
  %174 = ptrtoint ptr %result.i9.i to i64
  store i64 %174, ptr %74, align 4
  %.sroa_idx30.i = getelementptr i8, ptr %72, i64 24
  store i32 10, ptr %.sroa_idx30.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

175:                                              ; preds = %._crit_edge.i364, %77, %._crit_edge
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %176 = add i32 %64, 2127912214
  %177 = shl i32 %64, 12
  %178 = add i32 %176, %177
  %179 = ashr i32 %178, 19
  %180 = xor i32 %178, %179
  %181 = xor i32 %180, -949894596
  %182 = add i32 %181, 374761393
  %183 = shl i32 %181, 5
  %184 = add i32 %182, %183
  %185 = add i32 %184, -744332180
  %186 = shl i32 %184, 9
  %187 = xor i32 %185, %186
  %188 = add i32 %187, -42973499
  %189 = shl i32 %187, 3
  %190 = add i32 %188, %189
  %191 = ashr i32 %190, 16
  %192 = xor i32 %190, %191
  %193 = xor i32 %192, -1252372727
  %194 = load i32, ptr %50, align 8
  %195 = add i32 %194, -1
  %196 = and i32 %195, %193
  %197 = load ptr, ptr %52, align 8
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %199 = sext i32 %196 to i64
  %200 = shl nsw i64 %199, 5
  %201 = getelementptr i8, ptr %197, i64 %200
  %202 = load ptr, ptr %201, align 8
  %203 = getelementptr i8, ptr %201, i64 8
  %204 = icmp ne ptr %202, @nil_typ
  %205 = icmp ne ptr %202, null
  %.not66.i395 = and i1 %204, %205
  br i1 %.not66.i395, label %206, label %304

206:                                              ; preds = %175
  %207 = load i64, ptr %203, align 4
  %.sroa_idx.i397 = getelementptr i8, ptr %201, i64 16
  %208 = load i64, ptr %.sroa_idx.i397, align 4
  %209 = inttoptr i64 %207 to ptr
  %210 = inttoptr i64 %208 to ptr
  %hash_coef_ptr.i.i11.i398 = getelementptr i8, ptr %202, i64 8
  %tbl_size_ptr.i.i12.i399 = getelementptr i8, ptr %202, i64 16
  %offset_tbl_ptr.i.i13.i400 = getelementptr i8, ptr %202, i64 40
  %hash_coef.i.i14.i401 = load i64, ptr %hash_coef_ptr.i.i11.i398, align 4, !noalias !128
  %tbl_size.i.i15.i402 = load i64, ptr %tbl_size_ptr.i.i12.i399, align 4, !noalias !128
  %offset_tbl.i.i16.i403 = load ptr, ptr %offset_tbl_ptr.i.i13.i400, align 8, !noalias !128
  %product.i.i.i17.i404 = mul i64 %hash_coef.i.i14.i401, 4015701072841558310
  %shifted.i.i.i18.i405 = lshr i64 %product.i.i.i17.i404, 32
  %xored.i.i.i19.i406 = xor i64 %shifted.i.i.i18.i405, %product.i.i.i17.i404
  %hash.i.i.i20.i407 = and i64 %xored.i.i.i19.i406, %tbl_size.i.i15.i402
  %offset_ptr.i.i21.i408 = getelementptr i32, ptr %offset_tbl.i.i16.i403, i64 %hash.i.i.i20.i407
  %offset.i.i22.i409 = load i32, ptr %offset_ptr.i.i21.i408, align 4, !noalias !128
  %211 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %202, 0
  %212 = insertvalue { ptr, ptr, ptr, i32 } %211, ptr %209, 1
  %213 = insertvalue { ptr, ptr, ptr, i32 } %212, ptr %210, 2
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, i32 %offset.i.i22.i409, 3
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %202) #40
  %217 = sext i32 %offset.i.i22.i409 to i64
  %218 = getelementptr ptr, ptr %202, i64 %217
  %219 = getelementptr i8, ptr %218, i64 64
  %220 = load ptr, ptr %219, align 8
  %result.i8.i410 = call ptr %220({ ptr, ptr, ptr, i32 } %214, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %221 = call i32 %result.i8.i410({ ptr, ptr, ptr, i32 } %214, { ptr, ptr, ptr, i32 } %214, ptr nonnull align 8 %2) #53
  %222 = icmp eq i32 %221, %64
  br i1 %222, label %._crit_edge.i411, label %304

._crit_edge.i411:                                 ; preds = %206
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %202)
  %225 = getelementptr i8, ptr %218, i64 48
  %226 = load ptr, ptr %225, align 8
  %result.i7.i412 = call ptr %226({ ptr, ptr, ptr, i32 } %214, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %227 = call { ptr, i160 } %result.i7.i412({ ptr, ptr, ptr, i32 } %214, { ptr, ptr, ptr, i32 } %214, ptr nonnull align 8 %2) #53
  %228 = load ptr, ptr %49, align 8
  %229 = call i1 %228({ ptr, i160 } %227, { ptr, i160 } %61) #53
  br i1 %229, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit424, label %304

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit424: ; preds = %._crit_edge.i411
  %230 = load ptr, ptr %result.i35, align 8
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %232 = load ptr, ptr %43, align 8
  %233 = load ptr, ptr %230, align 8, !alias.scope !131
  %234 = getelementptr i8, ptr %233, i64 72
  %235 = load ptr, ptr %234, align 8, !alias.scope !131
  %result.i1.i.i416 = call { i64, i64 } %235(ptr nocapture nofree nonnull readonly align 8 %230) #44, !alias.scope !131
  %236 = extractvalue { i64, i64 } %result.i1.i.i416, 0
  %237 = extractvalue { i64, i64 } %result.i1.i.i416, 1
  %238 = urem i64 20, %237
  %239 = icmp eq i64 %238, 0
  %240 = sub i64 %237, %238
  %241 = select i1 %239, i64 0, i64 %240
  %242 = add i64 %236, 20
  %243 = add i64 %242, %241
  %244 = load ptr, ptr %232, align 8, !alias.scope !131
  %245 = getelementptr i8, ptr %244, i64 72
  %246 = load ptr, ptr %245, align 8, !alias.scope !131
  %result.i.i.i417 = call { i64, i64 } %246(ptr nocapture nofree nonnull readonly align 8 %232) #44, !alias.scope !131
  %247 = extractvalue { i64, i64 } %result.i.i.i417, 0
  %248 = extractvalue { i64, i64 } %result.i.i.i417, 1
  %249 = call i64 @llvm.umax.i64(i64 %237, i64 %248) #41
  %250 = call i64 @llvm.umax.i64(i64 %249, i64 noundef 8) #41, !range !16
  %251 = urem i64 %243, %248
  %252 = icmp eq i64 %251, 0
  %253 = sub i64 %248, %251
  %254 = select i1 %252, i64 0, i64 %253
  %255 = add i64 %247, %243
  %256 = add i64 %255, %254
  %257 = urem i64 %256, %250
  %258 = icmp eq i64 %257, 0
  %259 = sub i64 %250, %257
  %260 = select i1 %258, i64 0, i64 %259
  %261 = add i64 %260, %256
  %result.i9.i418 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %261) #48
  store ptr %230, ptr %result.i9.i418, align 8
  %262 = getelementptr inbounds i8, ptr %result.i9.i418, i64 8
  store ptr %232, ptr %262, align 8
  %263 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i418)
  %264 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %265 = load ptr, ptr %230, align 8
  %266 = getelementptr i8, ptr %265, i64 72
  %267 = load ptr, ptr %266, align 8
  %result.i.i38.i419 = call { i64, i64 } %267(ptr nocapture nofree nonnull readonly align 8 %230) #44
  %268 = extractvalue { i64, i64 } %result.i.i38.i419, 1
  %269 = urem i64 20, %268
  %270 = icmp eq i64 %269, 0
  %reass.sub1691 = sub i64 %268, %269
  %271 = add i64 %reass.sub1691, 20
  %272 = select i1 %270, i64 20, i64 %271
  %273 = getelementptr i8, ptr %result.i9.i418, i64 %272
  %274 = getelementptr i8, ptr %265, i64 64
  %275 = load ptr, ptr %274, align 8
  call void %275({ ptr, i160 } %61, ptr nocapture nofree nonnull readonly align 8 %230, ptr nocapture nofree writeonly %273) #45
  %276 = load ptr, ptr %result.i9.i418, align 8
  %277 = load ptr, ptr %276, align 8
  %278 = getelementptr i8, ptr %277, i64 72
  %279 = load ptr, ptr %278, align 8
  %result.i1.i39.i421 = call { i64, i64 } %279(ptr nocapture nofree nonnull readonly align 8 %276) #44
  %280 = extractvalue { i64, i64 } %result.i1.i39.i421, 0
  %281 = extractvalue { i64, i64 } %result.i1.i39.i421, 1
  %282 = urem i64 20, %281
  %283 = icmp eq i64 %282, 0
  %284 = sub i64 %281, %282
  %285 = select i1 %283, i64 0, i64 %284
  %286 = add i64 %280, 20
  %287 = add i64 %286, %285
  %288 = load ptr, ptr %262, align 8
  %289 = load ptr, ptr %288, align 8
  %290 = getelementptr i8, ptr %289, i64 72
  %291 = load ptr, ptr %290, align 8
  %result.i.i40.i422 = call { i64, i64 } %291(ptr nocapture nofree nonnull readonly align 8 %288) #44
  %292 = extractvalue { i64, i64 } %result.i.i40.i422, 1
  %293 = urem i64 %287, %292
  %294 = icmp eq i64 %293, 0
  %295 = sub i64 %292, %293
  %296 = select i1 %294, i64 0, i64 %295
  %297 = getelementptr i8, ptr %result.i9.i418, i64 %287
  %298 = getelementptr i8, ptr %297, i64 %296
  %299 = getelementptr i8, ptr %289, i64 64
  %300 = load ptr, ptr %299, align 8
  call void %300({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %288, ptr nocapture nofree writeonly %298) #45
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %302 = getelementptr inbounds i8, ptr %result.i9.i418, i64 16
  store i32 %64, ptr %302, align 8
  store ptr @Entry, ptr %201, align 8
  %303 = ptrtoint ptr %result.i9.i418 to i64
  store i64 %303, ptr %203, align 4
  %.sroa_idx30.i423 = getelementptr i8, ptr %201, i64 24
  store i32 10, ptr %.sroa_idx30.i423, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

304:                                              ; preds = %._crit_edge.i411, %206, %175
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %305 = load i32, ptr %54, align 4
  %306 = load i32, ptr %50, align 8
  %.not.i = icmp slt i32 %305, %306
  br i1 %.not.i, label %._crit_edge.i, label %307

307:                                              ; preds = %304
  %308 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %310 = load ptr, ptr %51, align 8
  %311 = load ptr, ptr %52, align 8
  %312 = shl i32 %306, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %312, i32 noundef 16) #40
  store i32 %spec.select.i, ptr %50, align 8
  %313 = zext nneg i32 %spec.select.i to i64
  %314 = shl nuw nsw i64 %313, 5
  %result.i5.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %314) #48
  store ptr %result.i5.i, ptr %51, align 8
  %result.i4.i440 = call noalias ptr @bump_malloc_wrapper(i64 noundef %314) #48
  store ptr %result.i4.i440, ptr %52, align 8
  store i32 0, ptr %54, align 4
  %315 = icmp sgt i32 %306, 0
  br i1 %315, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %307
  %wide.trip.count.i = zext nneg i32 %306 to i64
  br label %316

316:                                              ; preds = %._crit_edge.i852, %.lr.ph.i
  %indvars.iv.i851 = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i853, %._crit_edge.i852 ]
  %317 = shl nuw nsw i64 %indvars.iv.i851, 5
  %318 = getelementptr i8, ptr %310, i64 %317
  %319 = load ptr, ptr %318, align 8
  %320 = icmp ne ptr %319, @nil_typ
  %321 = icmp ne ptr %319, null
  %.not17.i = and i1 %320, %321
  br i1 %.not17.i, label %322, label %._crit_edge.i852

322:                                              ; preds = %316
  %323 = getelementptr i8, ptr %318, i64 8
  %324 = load i64, ptr %323, align 4
  %.sroa_idx.i855 = getelementptr i8, ptr %318, i64 16
  %325 = load i64, ptr %.sroa_idx.i855, align 4
  %hash_coef_ptr.i.i6.i = getelementptr i8, ptr %319, i64 8
  %tbl_size_ptr.i.i7.i = getelementptr i8, ptr %319, i64 16
  %offset_tbl_ptr.i.i8.i = getelementptr i8, ptr %319, i64 40
  %326 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i6.i, align 4, !noalias !134
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i7.i, align 4, !noalias !134
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i8.i, align 8, !noalias !134
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i29.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !134
  %327 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %330

330:                                              ; preds = %.cont.i1146, %322
  %.0290.i1128 = phi i32 [ 0, %322 ], [ %363, %.cont.i1146 ]
  %.074289.i1129 = phi i1 [ true, %322 ], [ %364, %.cont.i1146 ]
  %.sroa.0.0288.i1130 = phi ptr [ %319, %322 ], [ %353, %.cont.i1146 ]
  %.sroa.6.0287.i1131.in = phi i64 [ %324, %322 ], [ %355, %.cont.i1146 ]
  %.sroa.12.0286.i1132.in = phi i64 [ %325, %322 ], [ %356, %.cont.i1146 ]
  %.sroa.17.0285.i1133 = phi i32 [ %offset.i.i29.i, %322 ], [ %offset.i.i57.i1158, %.cont.i1146 ]
  %.sroa.12.0286.i1132 = inttoptr i64 %.sroa.12.0286.i1132.in to ptr
  %.sroa.6.0287.i1131 = inttoptr i64 %.sroa.6.0287.i1131.in to ptr
  %331 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1130, 0
  %332 = insertvalue { ptr, ptr, ptr, i32 } %331, ptr %.sroa.6.0287.i1131, 1
  %333 = insertvalue { ptr, ptr, ptr, i32 } %332, ptr %.sroa.12.0286.i1132, 2
  %334 = insertvalue { ptr, ptr, ptr, i32 } %333, i32 %.sroa.17.0285.i1133, 3
  %335 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1130)
  %336 = sext i32 %.sroa.17.0285.i1133 to i64
  %337 = getelementptr ptr, ptr %.sroa.0.0288.i1130, i64 %336
  %338 = getelementptr i8, ptr %337, i64 64
  %339 = load ptr, ptr %338, align 8
  %result.i15.i1134 = call ptr %339({ ptr, ptr, ptr, i32 } %334, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %340 = call i32 %result.i15.i1134({ ptr, ptr, ptr, i32 } %334, { ptr, ptr, ptr, i32 } %334, ptr nonnull align 8 %2) #53
  %..i1135 = select i1 %.074289.i1129, ptr %23, ptr %25
  %.188.i1136 = select i1 %.074289.i1129, i64 104, i64 112
  %.189.i1137 = select i1 %.074289.i1129, ptr %24, ptr %26
  %.190.i1138 = select i1 %.074289.i1129, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1135, align 8
  %341 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1135)
  %342 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1136
  %343 = load ptr, ptr %342, align 8
  store ptr @i32_typ, ptr %.189.i1137, align 8
  %result.i14.i1139 = call ptr %343({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1137) #46
  %344 = call i32 %result.i14.i1139({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1135, i32 %340) #53
  %345 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %346 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1138
  %347 = load ptr, ptr %346, align 8
  %348 = load ptr, ptr %347, align 8
  %349 = call { ptr } %348(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i1140 = extractvalue { ptr } %349, 0
  %350 = sext i32 %344 to i64
  %351 = shl nsw i64 %350, 5
  %352 = getelementptr i8, ptr %.fca.0.extract55.i1140, i64 %351
  %353 = load ptr, ptr %352, align 8
  %354 = getelementptr i8, ptr %352, i64 8
  %355 = load i64, ptr %354, align 4
  %.sroa_idx.i1141 = getelementptr i8, ptr %352, i64 16
  %356 = load i64, ptr %.sroa_idx.i1141, align 4
  %357 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %358 = call { ptr } %348(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i1142 = extractvalue { ptr } %358, 0
  %359 = getelementptr i8, ptr %.fca.0.extract52.i1142, i64 %351
  store ptr %.sroa.0.0288.i1130, ptr %359, align 8
  %360 = getelementptr i8, ptr %359, i64 8
  store i64 %.sroa.6.0287.i1131.in, ptr %360, align 4
  %.sroa_idx104.i1143 = getelementptr i8, ptr %359, i64 16
  store i64 %.sroa.12.0286.i1132.in, ptr %.sroa_idx104.i1143, align 4
  %.sroa_idx105.i1144 = getelementptr i8, ptr %359, i64 24
  store i32 %.sroa.17.0285.i1133, ptr %.sroa_idx105.i1144, align 4
  %361 = icmp ne ptr %353, @nil_typ
  %362 = icmp ne ptr %353, null
  %.not94.i1145 = and i1 %361, %362
  br i1 %.not94.i1145, label %.cont.i1146, label %367

.cont.i1146:                                      ; preds = %330
  %363 = add nuw nsw i32 %.0290.i1128, 1
  %364 = xor i1 %.074289.i1129, true
  %hash_coef_ptr.i.i46.i1147 = getelementptr i8, ptr %353, i64 8
  %tbl_size_ptr.i.i47.i1148 = getelementptr i8, ptr %353, i64 16
  %offset_tbl_ptr.i.i48.i1149 = getelementptr i8, ptr %353, i64 40
  %hash_coef.i.i49.i1150 = load i64, ptr %hash_coef_ptr.i.i46.i1147, align 4
  %tbl_size.i.i50.i1151 = load i64, ptr %tbl_size_ptr.i.i47.i1148, align 4
  %offset_tbl.i.i51.i1152 = load ptr, ptr %offset_tbl_ptr.i.i48.i1149, align 8
  %product.i.i.i52.i1153 = mul i64 %hash_coef.i.i49.i1150, 4015701072841558310
  %shifted.i.i.i53.i1154 = lshr i64 %product.i.i.i52.i1153, 32
  %xored.i.i.i54.i1155 = xor i64 %shifted.i.i.i53.i1154, %product.i.i.i52.i1153
  %hash.i.i.i55.i1156 = and i64 %xored.i.i.i54.i1155, %tbl_size.i.i50.i1151
  %offset_ptr.i.i56.i1157 = getelementptr i32, ptr %offset_tbl.i.i51.i1152, i64 %hash.i.i.i55.i1156
  %offset.i.i57.i1158 = load i32, ptr %offset_ptr.i.i56.i1157, align 4
  %365 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %366 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1159 = icmp eq i32 %363, 100
  br i1 %exitcond.not.i1159, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161, label %330

367:                                              ; preds = %330
  %368 = load i32, ptr %54, align 4
  %369 = add i32 %368, 1
  %370 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %369, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161: ; preds = %367, %.cont.i1146
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  br label %._crit_edge.i852

._crit_edge.i852:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161, %316
  %indvars.iv.next.i853 = add nuw nsw i64 %indvars.iv.i851, 1
  %exitcond.not.i854 = icmp eq i64 %indvars.iv.next.i853, %wide.trip.count.i
  br i1 %exitcond.not.i854, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit, label %316

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit: ; preds = %._crit_edge.i874, %._crit_edge.i852
  %indvars.iv.i872 = phi i64 [ %indvars.iv.next.i875, %._crit_edge.i874 ], [ 0, %._crit_edge.i852 ]
  %371 = shl nuw nsw i64 %indvars.iv.i872, 5
  %372 = getelementptr i8, ptr %311, i64 %371
  %373 = load ptr, ptr %372, align 8
  %374 = icmp ne ptr %373, @nil_typ
  %375 = icmp ne ptr %373, null
  %.not17.i873 = and i1 %374, %375
  br i1 %.not17.i873, label %376, label %._crit_edge.i874

376:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %377 = getelementptr i8, ptr %372, i64 8
  %378 = load i64, ptr %377, align 4
  %.sroa_idx.i877 = getelementptr i8, ptr %372, i64 16
  %379 = load i64, ptr %.sroa_idx.i877, align 4
  %hash_coef_ptr.i.i6.i878 = getelementptr i8, ptr %373, i64 8
  %tbl_size_ptr.i.i7.i879 = getelementptr i8, ptr %373, i64 16
  %offset_tbl_ptr.i.i8.i880 = getelementptr i8, ptr %373, i64 40
  %380 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  %hash_coef.i.i21.i1179 = load i64, ptr %hash_coef_ptr.i.i6.i878, align 4, !noalias !137
  %tbl_size.i.i22.i1180 = load i64, ptr %tbl_size_ptr.i.i7.i879, align 4, !noalias !137
  %offset_tbl.i.i23.i1181 = load ptr, ptr %offset_tbl_ptr.i.i8.i880, align 8, !noalias !137
  %product.i.i.i24.i1182 = mul i64 %hash_coef.i.i21.i1179, 4015701072841558310
  %shifted.i.i.i25.i1183 = lshr i64 %product.i.i.i24.i1182, 32
  %xored.i.i.i26.i1184 = xor i64 %shifted.i.i.i25.i1183, %product.i.i.i24.i1182
  %hash.i.i.i27.i1185 = and i64 %xored.i.i.i26.i1184, %tbl_size.i.i22.i1180
  %offset_ptr.i.i28.i1186 = getelementptr i32, ptr %offset_tbl.i.i23.i1181, i64 %hash.i.i.i27.i1185
  %offset.i.i29.i1187 = load i32, ptr %offset_ptr.i.i28.i1186, align 4, !noalias !137
  %381 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %382 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %383 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %384

384:                                              ; preds = %.cont.i1210, %376
  %.0290.i1188 = phi i32 [ 0, %376 ], [ %417, %.cont.i1210 ]
  %.074289.i1189 = phi i1 [ true, %376 ], [ %418, %.cont.i1210 ]
  %.sroa.0.0288.i1190 = phi ptr [ %373, %376 ], [ %407, %.cont.i1210 ]
  %.sroa.6.0287.i1191.in = phi i64 [ %378, %376 ], [ %409, %.cont.i1210 ]
  %.sroa.12.0286.i1192.in = phi i64 [ %379, %376 ], [ %410, %.cont.i1210 ]
  %.sroa.17.0285.i1193 = phi i32 [ %offset.i.i29.i1187, %376 ], [ %offset.i.i57.i1222, %.cont.i1210 ]
  %.sroa.12.0286.i1192 = inttoptr i64 %.sroa.12.0286.i1192.in to ptr
  %.sroa.6.0287.i1191 = inttoptr i64 %.sroa.6.0287.i1191.in to ptr
  %385 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1190, 0
  %386 = insertvalue { ptr, ptr, ptr, i32 } %385, ptr %.sroa.6.0287.i1191, 1
  %387 = insertvalue { ptr, ptr, ptr, i32 } %386, ptr %.sroa.12.0286.i1192, 2
  %388 = insertvalue { ptr, ptr, ptr, i32 } %387, i32 %.sroa.17.0285.i1193, 3
  %389 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1190)
  %390 = sext i32 %.sroa.17.0285.i1193 to i64
  %391 = getelementptr ptr, ptr %.sroa.0.0288.i1190, i64 %390
  %392 = getelementptr i8, ptr %391, i64 64
  %393 = load ptr, ptr %392, align 8
  %result.i15.i1194 = call ptr %393({ ptr, ptr, ptr, i32 } %388, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %394 = call i32 %result.i15.i1194({ ptr, ptr, ptr, i32 } %388, { ptr, ptr, ptr, i32 } %388, ptr nonnull align 8 %2) #53
  %..i1195 = select i1 %.074289.i1189, ptr %19, ptr %21
  %.188.i1196 = select i1 %.074289.i1189, i64 104, i64 112
  %.189.i1197 = select i1 %.074289.i1189, ptr %20, ptr %22
  %.190.i1198 = select i1 %.074289.i1189, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1195, align 8
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1195)
  %396 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1196
  %397 = load ptr, ptr %396, align 8
  store ptr @i32_typ, ptr %.189.i1197, align 8
  %result.i14.i1199 = call ptr %397({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1197) #46
  %398 = call i32 %result.i14.i1199({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1195, i32 %394) #53
  %399 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %400 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1198
  %401 = load ptr, ptr %400, align 8
  %402 = load ptr, ptr %401, align 8
  %403 = call { ptr } %402(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i1200 = extractvalue { ptr } %403, 0
  %404 = sext i32 %398 to i64
  %405 = shl nsw i64 %404, 5
  %406 = getelementptr i8, ptr %.fca.0.extract55.i1200, i64 %405
  %407 = load ptr, ptr %406, align 8
  %408 = getelementptr i8, ptr %406, i64 8
  %409 = load i64, ptr %408, align 4
  %.sroa_idx.i1201 = getelementptr i8, ptr %406, i64 16
  %410 = load i64, ptr %.sroa_idx.i1201, align 4
  %411 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %412 = call { ptr } %402(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i1202 = extractvalue { ptr } %412, 0
  %413 = getelementptr i8, ptr %.fca.0.extract52.i1202, i64 %405
  store ptr %.sroa.0.0288.i1190, ptr %413, align 8
  %414 = getelementptr i8, ptr %413, i64 8
  store i64 %.sroa.6.0287.i1191.in, ptr %414, align 4
  %.sroa_idx104.i1203 = getelementptr i8, ptr %413, i64 16
  store i64 %.sroa.12.0286.i1192.in, ptr %.sroa_idx104.i1203, align 4
  %.sroa_idx105.i1204 = getelementptr i8, ptr %413, i64 24
  store i32 %.sroa.17.0285.i1193, ptr %.sroa_idx105.i1204, align 4
  %415 = icmp ne ptr %407, @nil_typ
  %416 = icmp ne ptr %407, null
  %.not94.i1205 = and i1 %415, %416
  br i1 %.not94.i1205, label %.cont.i1210, label %421

.cont.i1210:                                      ; preds = %384
  %417 = add nuw nsw i32 %.0290.i1188, 1
  %418 = xor i1 %.074289.i1189, true
  %hash_coef_ptr.i.i46.i1211 = getelementptr i8, ptr %407, i64 8
  %tbl_size_ptr.i.i47.i1212 = getelementptr i8, ptr %407, i64 16
  %offset_tbl_ptr.i.i48.i1213 = getelementptr i8, ptr %407, i64 40
  %hash_coef.i.i49.i1214 = load i64, ptr %hash_coef_ptr.i.i46.i1211, align 4
  %tbl_size.i.i50.i1215 = load i64, ptr %tbl_size_ptr.i.i47.i1212, align 4
  %offset_tbl.i.i51.i1216 = load ptr, ptr %offset_tbl_ptr.i.i48.i1213, align 8
  %product.i.i.i52.i1217 = mul i64 %hash_coef.i.i49.i1214, 4015701072841558310
  %shifted.i.i.i53.i1218 = lshr i64 %product.i.i.i52.i1217, 32
  %xored.i.i.i54.i1219 = xor i64 %shifted.i.i.i53.i1218, %product.i.i.i52.i1217
  %hash.i.i.i55.i1220 = and i64 %xored.i.i.i54.i1219, %tbl_size.i.i50.i1215
  %offset_ptr.i.i56.i1221 = getelementptr i32, ptr %offset_tbl.i.i51.i1216, i64 %hash.i.i.i55.i1220
  %offset.i.i57.i1222 = load i32, ptr %offset_ptr.i.i56.i1221, align 4
  %419 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %420 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1223 = icmp eq i32 %417, 100
  br i1 %exitcond.not.i1223, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232, label %384

421:                                              ; preds = %384
  %422 = load i32, ptr %54, align 4
  %423 = add i32 %422, 1
  %424 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %423, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232: ; preds = %421, %.cont.i1210
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  br label %._crit_edge.i874

._crit_edge.i874:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %indvars.iv.next.i875 = add nuw nsw i64 %indvars.iv.i872, 1
  %exitcond.not.i876 = icmp eq i64 %indvars.iv.next.i875, %wide.trip.count.i
  br i1 %exitcond.not.i876, label %._crit_edge.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit

._crit_edge.i:                                    ; preds = %._crit_edge.i874, %307, %304
  %425 = load ptr, ptr %result.i35, align 8
  %426 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %427 = load ptr, ptr %43, align 8
  %428 = load ptr, ptr %425, align 8
  %429 = getelementptr i8, ptr %428, i64 72
  %430 = load ptr, ptr %429, align 8
  %result.i1.i.i156 = call { i64, i64 } %430(ptr nocapture nofree nonnull readonly align 8 %425) #44
  %431 = extractvalue { i64, i64 } %result.i1.i.i156, 0
  %432 = extractvalue { i64, i64 } %result.i1.i.i156, 1
  %433 = urem i64 20, %432
  %434 = icmp eq i64 %433, 0
  %435 = sub i64 %432, %433
  %436 = select i1 %434, i64 0, i64 %435
  %437 = add i64 %431, 20
  %438 = add i64 %437, %436
  %439 = load ptr, ptr %427, align 8
  %440 = getelementptr i8, ptr %439, i64 72
  %441 = load ptr, ptr %440, align 8
  %result.i.i.i157 = call { i64, i64 } %441(ptr nocapture nofree nonnull readonly align 8 %427) #44
  %442 = extractvalue { i64, i64 } %result.i.i.i157, 0
  %443 = extractvalue { i64, i64 } %result.i.i.i157, 1
  %444 = call i64 @llvm.umax.i64(i64 %432, i64 %443) #41
  %445 = call i64 @llvm.umax.i64(i64 %444, i64 noundef 8) #41, !range !16
  %446 = urem i64 %438, %443
  %447 = icmp eq i64 %446, 0
  %448 = sub i64 %443, %446
  %449 = select i1 %447, i64 0, i64 %448
  %450 = add i64 %442, %438
  %451 = add i64 %450, %449
  %452 = urem i64 %451, %445
  %453 = icmp eq i64 %452, 0
  %454 = sub i64 %445, %452
  %455 = select i1 %453, i64 0, i64 %454
  %456 = add i64 %455, %451
  %result.i22.i158 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %456) #48
  store ptr %425, ptr %result.i22.i158, align 8
  %457 = getelementptr inbounds i8, ptr %result.i22.i158, i64 8
  store ptr %427, ptr %457, align 8
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i158)
  %459 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %460 = load ptr, ptr %425, align 8
  %461 = getelementptr i8, ptr %460, i64 72
  %462 = load ptr, ptr %461, align 8
  %result.i.i127.i = call { i64, i64 } %462(ptr nocapture nofree nonnull readonly align 8 %425) #44
  %463 = extractvalue { i64, i64 } %result.i.i127.i, 1
  %464 = urem i64 20, %463
  %465 = icmp eq i64 %464, 0
  %reass.sub1690 = sub i64 %463, %464
  %466 = add i64 %reass.sub1690, 20
  %467 = select i1 %465, i64 20, i64 %466
  %468 = getelementptr i8, ptr %result.i22.i158, i64 %467
  %469 = getelementptr i8, ptr %460, i64 64
  %470 = load ptr, ptr %469, align 8
  call void %470({ ptr, i160 } %61, ptr nocapture nofree nonnull readonly align 8 %425, ptr nocapture nofree writeonly %468) #45
  %471 = load ptr, ptr %result.i22.i158, align 8
  %472 = load ptr, ptr %471, align 8
  %473 = getelementptr i8, ptr %472, i64 72
  %474 = load ptr, ptr %473, align 8
  %result.i1.i128.i = call { i64, i64 } %474(ptr nocapture nofree nonnull readonly align 8 %471) #44
  %475 = extractvalue { i64, i64 } %result.i1.i128.i, 0
  %476 = extractvalue { i64, i64 } %result.i1.i128.i, 1
  %477 = urem i64 20, %476
  %478 = icmp eq i64 %477, 0
  %479 = sub i64 %476, %477
  %480 = select i1 %478, i64 0, i64 %479
  %481 = add i64 %475, 20
  %482 = add i64 %481, %480
  %483 = load ptr, ptr %457, align 8
  %484 = load ptr, ptr %483, align 8
  %485 = getelementptr i8, ptr %484, i64 72
  %486 = load ptr, ptr %485, align 8
  %result.i.i129.i = call { i64, i64 } %486(ptr nocapture nofree nonnull readonly align 8 %483) #44
  %487 = extractvalue { i64, i64 } %result.i.i129.i, 1
  %488 = urem i64 %482, %487
  %489 = icmp eq i64 %488, 0
  %490 = sub i64 %487, %488
  %491 = select i1 %489, i64 0, i64 %490
  %492 = getelementptr i8, ptr %result.i22.i158, i64 %482
  %493 = getelementptr i8, ptr %492, i64 %491
  %494 = getelementptr i8, ptr %484, i64 64
  %495 = load ptr, ptr %494, align 8
  call void %495({ ptr, i160 } %62, ptr nocapture nofree nonnull readonly align 8 %483, ptr nocapture nofree writeonly %493) #45
  %496 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %497 = getelementptr inbounds i8, ptr %result.i22.i158, i64 16
  store i32 %64, ptr %497, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %498 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %499 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %500 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %501

501:                                              ; preds = %.cont.i, %._crit_edge.i
  %.0290.i = phi i32 [ 0, %._crit_edge.i ], [ %536, %.cont.i ]
  %.074289.i = phi i1 [ true, %._crit_edge.i ], [ %537, %.cont.i ]
  %.sroa.0.0288.i = phi ptr [ @Entry, %._crit_edge.i ], [ %524, %.cont.i ]
  %.sroa.6.0287.i = phi ptr [ %result.i22.i158, %._crit_edge.i ], [ %538, %.cont.i ]
  %.sroa.12.0286.i = phi ptr [ undef, %._crit_edge.i ], [ %539, %.cont.i ]
  %.sroa.17.0285.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i57.i, %.cont.i ]
  %502 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i, 0
  %503 = insertvalue { ptr, ptr, ptr, i32 } %502, ptr %.sroa.6.0287.i, 1
  %504 = insertvalue { ptr, ptr, ptr, i32 } %503, ptr %.sroa.12.0286.i, 2
  %505 = insertvalue { ptr, ptr, ptr, i32 } %504, i32 %.sroa.17.0285.i, 3
  %506 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i)
  %507 = sext i32 %.sroa.17.0285.i to i64
  %508 = getelementptr ptr, ptr %.sroa.0.0288.i, i64 %507
  %509 = getelementptr i8, ptr %508, i64 64
  %510 = load ptr, ptr %509, align 8
  %result.i15.i = call ptr %510({ ptr, ptr, ptr, i32 } %505, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %511 = call i32 %result.i15.i({ ptr, ptr, ptr, i32 } %505, { ptr, ptr, ptr, i32 } %505, ptr nonnull align 8 %2) #53
  %..i = select i1 %.074289.i, ptr %31, ptr %33
  %.188.i = select i1 %.074289.i, i64 104, i64 112
  %.189.i = select i1 %.074289.i, ptr %32, ptr %34
  %.190.i = select i1 %.074289.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i, align 8
  %512 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i)
  %513 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i
  %514 = load ptr, ptr %513, align 8
  store ptr @i32_typ, ptr %.189.i, align 8
  %result.i14.i = call ptr %514({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i) #46
  %515 = call i32 %result.i14.i({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 dereferenceable(8) %..i, i32 %511) #53
  %516 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %517 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i
  %518 = load ptr, ptr %517, align 8
  %519 = load ptr, ptr %518, align 8
  %520 = call { ptr } %519(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i = extractvalue { ptr } %520, 0
  %521 = sext i32 %515 to i64
  %522 = shl nsw i64 %521, 5
  %523 = getelementptr i8, ptr %.fca.0.extract55.i, i64 %522
  %524 = load ptr, ptr %523, align 8
  %525 = getelementptr i8, ptr %523, i64 8
  %526 = load i64, ptr %525, align 4
  %.sroa_idx.i459 = getelementptr i8, ptr %523, i64 16
  %527 = load i64, ptr %.sroa_idx.i459, align 4
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %529 = call { ptr } %519(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i = extractvalue { ptr } %529, 0
  %530 = getelementptr i8, ptr %.fca.0.extract52.i, i64 %522
  store ptr %.sroa.0.0288.i, ptr %530, align 8
  %531 = getelementptr i8, ptr %530, i64 8
  %532 = ptrtoint ptr %.sroa.6.0287.i to i64
  %533 = ptrtoint ptr %.sroa.12.0286.i to i64
  store i64 %532, ptr %531, align 4
  %.sroa_idx104.i = getelementptr i8, ptr %530, i64 16
  store i64 %533, ptr %.sroa_idx104.i, align 4
  %.sroa_idx105.i = getelementptr i8, ptr %530, i64 24
  store i32 %.sroa.17.0285.i, ptr %.sroa_idx105.i, align 4
  %534 = icmp ne ptr %524, @nil_typ
  %535 = icmp ne ptr %524, null
  %.not94.i = and i1 %534, %535
  br i1 %.not94.i, label %.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

.cont.i:                                          ; preds = %501
  %536 = add nuw nsw i32 %.0290.i, 1
  %537 = xor i1 %.074289.i, true
  %538 = inttoptr i64 %526 to ptr
  %539 = inttoptr i64 %527 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %524, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %524, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %524, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4
  %540 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i = icmp eq i32 %536, 100
  br i1 %exitcond.not.i, label %545, label %501

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %501
  %542 = load i32, ptr %54, align 4
  %543 = add i32 %542, 1
  %544 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %543, ptr %54, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  br label %CuckooMap_insert_keyK_valueV.exit

545:                                              ; preds = %.cont.i
  %hash_coef_ptr.i.i46.i.le = getelementptr i8, ptr %524, i64 8
  %tbl_size_ptr.i.i47.i.le = getelementptr i8, ptr %524, i64 16
  %offset_tbl_ptr.i.i48.i.le = getelementptr i8, ptr %524, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %546 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %548 = load ptr, ptr %51, align 8
  %549 = load ptr, ptr %52, align 8
  %550 = load i32, ptr %50, align 8
  %551 = shl i32 %550, 1
  %spec.select.i477 = call i32 @llvm.smax.i32(i32 %551, i32 noundef 16) #40
  store i32 %spec.select.i477, ptr %50, align 8
  %552 = zext nneg i32 %spec.select.i477 to i64
  %553 = shl nuw nsw i64 %552, 5
  %result.i5.i478 = call noalias ptr @bump_malloc_wrapper(i64 noundef %553) #48
  store ptr %result.i5.i478, ptr %51, align 8
  %result.i4.i479 = call noalias ptr @bump_malloc_wrapper(i64 noundef %553) #48
  store ptr %result.i4.i479, ptr %52, align 8
  store i32 0, ptr %54, align 4
  %554 = icmp sgt i32 %550, 0
  br i1 %554, label %.lr.ph.i896, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970

.lr.ph.i896:                                      ; preds = %545
  %wide.trip.count.i909 = zext nneg i32 %550 to i64
  br label %555

555:                                              ; preds = %._crit_edge.i912, %.lr.ph.i896
  %indvars.iv.i910 = phi i64 [ 0, %.lr.ph.i896 ], [ %indvars.iv.next.i913, %._crit_edge.i912 ]
  %556 = shl nuw nsw i64 %indvars.iv.i910, 5
  %557 = getelementptr i8, ptr %548, i64 %556
  %558 = load ptr, ptr %557, align 8
  %559 = icmp ne ptr %558, @nil_typ
  %560 = icmp ne ptr %558, null
  %.not17.i911 = and i1 %559, %560
  br i1 %.not17.i911, label %561, label %._crit_edge.i912

561:                                              ; preds = %555
  %562 = getelementptr i8, ptr %557, i64 8
  %563 = load i64, ptr %562, align 4
  %.sroa_idx.i915 = getelementptr i8, ptr %557, i64 16
  %564 = load i64, ptr %.sroa_idx.i915, align 4
  %hash_coef_ptr.i.i6.i916 = getelementptr i8, ptr %558, i64 8
  %tbl_size_ptr.i.i7.i917 = getelementptr i8, ptr %558, i64 16
  %offset_tbl_ptr.i.i8.i918 = getelementptr i8, ptr %558, i64 40
  %565 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  %hash_coef.i.i21.i1250 = load i64, ptr %hash_coef_ptr.i.i6.i916, align 4, !noalias !140
  %tbl_size.i.i22.i1251 = load i64, ptr %tbl_size_ptr.i.i7.i917, align 4, !noalias !140
  %offset_tbl.i.i23.i1252 = load ptr, ptr %offset_tbl_ptr.i.i8.i918, align 8, !noalias !140
  %product.i.i.i24.i1253 = mul i64 %hash_coef.i.i21.i1250, 4015701072841558310
  %shifted.i.i.i25.i1254 = lshr i64 %product.i.i.i24.i1253, 32
  %xored.i.i.i26.i1255 = xor i64 %shifted.i.i.i25.i1254, %product.i.i.i24.i1253
  %hash.i.i.i27.i1256 = and i64 %xored.i.i.i26.i1255, %tbl_size.i.i22.i1251
  %offset_ptr.i.i28.i1257 = getelementptr i32, ptr %offset_tbl.i.i23.i1252, i64 %hash.i.i.i27.i1256
  %offset.i.i29.i1258 = load i32, ptr %offset_ptr.i.i28.i1257, align 4, !noalias !140
  %566 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %568 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %569

569:                                              ; preds = %.cont.i1281, %561
  %.0290.i1259 = phi i32 [ 0, %561 ], [ %602, %.cont.i1281 ]
  %.074289.i1260 = phi i1 [ true, %561 ], [ %603, %.cont.i1281 ]
  %.sroa.0.0288.i1261 = phi ptr [ %558, %561 ], [ %592, %.cont.i1281 ]
  %.sroa.6.0287.i1262.in = phi i64 [ %563, %561 ], [ %594, %.cont.i1281 ]
  %.sroa.12.0286.i1263.in = phi i64 [ %564, %561 ], [ %595, %.cont.i1281 ]
  %.sroa.17.0285.i1264 = phi i32 [ %offset.i.i29.i1258, %561 ], [ %offset.i.i57.i1293, %.cont.i1281 ]
  %.sroa.12.0286.i1263 = inttoptr i64 %.sroa.12.0286.i1263.in to ptr
  %.sroa.6.0287.i1262 = inttoptr i64 %.sroa.6.0287.i1262.in to ptr
  %570 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1261, 0
  %571 = insertvalue { ptr, ptr, ptr, i32 } %570, ptr %.sroa.6.0287.i1262, 1
  %572 = insertvalue { ptr, ptr, ptr, i32 } %571, ptr %.sroa.12.0286.i1263, 2
  %573 = insertvalue { ptr, ptr, ptr, i32 } %572, i32 %.sroa.17.0285.i1264, 3
  %574 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1261)
  %575 = sext i32 %.sroa.17.0285.i1264 to i64
  %576 = getelementptr ptr, ptr %.sroa.0.0288.i1261, i64 %575
  %577 = getelementptr i8, ptr %576, i64 64
  %578 = load ptr, ptr %577, align 8
  %result.i15.i1265 = call ptr %578({ ptr, ptr, ptr, i32 } %573, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %579 = call i32 %result.i15.i1265({ ptr, ptr, ptr, i32 } %573, { ptr, ptr, ptr, i32 } %573, ptr nonnull align 8 %2) #53
  %..i1266 = select i1 %.074289.i1260, ptr %15, ptr %17
  %.188.i1267 = select i1 %.074289.i1260, i64 104, i64 112
  %.189.i1268 = select i1 %.074289.i1260, ptr %16, ptr %18
  %.190.i1269 = select i1 %.074289.i1260, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1266, align 8
  %580 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1266)
  %581 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1267
  %582 = load ptr, ptr %581, align 8
  store ptr @i32_typ, ptr %.189.i1268, align 8
  %result.i14.i1270 = call ptr %582({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1268) #46
  %583 = call i32 %result.i14.i1270({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1266, i32 %579) #53
  %584 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %585 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1269
  %586 = load ptr, ptr %585, align 8
  %587 = load ptr, ptr %586, align 8
  %588 = call { ptr } %587(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i1271 = extractvalue { ptr } %588, 0
  %589 = sext i32 %583 to i64
  %590 = shl nsw i64 %589, 5
  %591 = getelementptr i8, ptr %.fca.0.extract55.i1271, i64 %590
  %592 = load ptr, ptr %591, align 8
  %593 = getelementptr i8, ptr %591, i64 8
  %594 = load i64, ptr %593, align 4
  %.sroa_idx.i1272 = getelementptr i8, ptr %591, i64 16
  %595 = load i64, ptr %.sroa_idx.i1272, align 4
  %596 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %597 = call { ptr } %587(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i1273 = extractvalue { ptr } %597, 0
  %598 = getelementptr i8, ptr %.fca.0.extract52.i1273, i64 %590
  store ptr %.sroa.0.0288.i1261, ptr %598, align 8
  %599 = getelementptr i8, ptr %598, i64 8
  store i64 %.sroa.6.0287.i1262.in, ptr %599, align 4
  %.sroa_idx104.i1274 = getelementptr i8, ptr %598, i64 16
  store i64 %.sroa.12.0286.i1263.in, ptr %.sroa_idx104.i1274, align 4
  %.sroa_idx105.i1275 = getelementptr i8, ptr %598, i64 24
  store i32 %.sroa.17.0285.i1264, ptr %.sroa_idx105.i1275, align 4
  %600 = icmp ne ptr %592, @nil_typ
  %601 = icmp ne ptr %592, null
  %.not94.i1276 = and i1 %600, %601
  br i1 %.not94.i1276, label %.cont.i1281, label %606

.cont.i1281:                                      ; preds = %569
  %602 = add nuw nsw i32 %.0290.i1259, 1
  %603 = xor i1 %.074289.i1260, true
  %hash_coef_ptr.i.i46.i1282 = getelementptr i8, ptr %592, i64 8
  %tbl_size_ptr.i.i47.i1283 = getelementptr i8, ptr %592, i64 16
  %offset_tbl_ptr.i.i48.i1284 = getelementptr i8, ptr %592, i64 40
  %hash_coef.i.i49.i1285 = load i64, ptr %hash_coef_ptr.i.i46.i1282, align 4
  %tbl_size.i.i50.i1286 = load i64, ptr %tbl_size_ptr.i.i47.i1283, align 4
  %offset_tbl.i.i51.i1287 = load ptr, ptr %offset_tbl_ptr.i.i48.i1284, align 8
  %product.i.i.i52.i1288 = mul i64 %hash_coef.i.i49.i1285, 4015701072841558310
  %shifted.i.i.i53.i1289 = lshr i64 %product.i.i.i52.i1288, 32
  %xored.i.i.i54.i1290 = xor i64 %shifted.i.i.i53.i1289, %product.i.i.i52.i1288
  %hash.i.i.i55.i1291 = and i64 %xored.i.i.i54.i1290, %tbl_size.i.i50.i1286
  %offset_ptr.i.i56.i1292 = getelementptr i32, ptr %offset_tbl.i.i51.i1287, i64 %hash.i.i.i55.i1291
  %offset.i.i57.i1293 = load i32, ptr %offset_ptr.i.i56.i1292, align 4
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %605 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1294 = icmp eq i32 %602, 100
  br i1 %exitcond.not.i1294, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303, label %569

606:                                              ; preds = %569
  %607 = load i32, ptr %54, align 4
  %608 = add i32 %607, 1
  %609 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %608, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303: ; preds = %606, %.cont.i1281
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  br label %._crit_edge.i912

._crit_edge.i912:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303, %555
  %indvars.iv.next.i913 = add nuw nsw i64 %indvars.iv.i910, 1
  %exitcond.not.i914 = icmp eq i64 %indvars.iv.next.i913, %wide.trip.count.i909
  br i1 %exitcond.not.i914, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932, label %555

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932: ; preds = %._crit_edge.i950, %._crit_edge.i912
  %indvars.iv.i948 = phi i64 [ %indvars.iv.next.i951, %._crit_edge.i950 ], [ 0, %._crit_edge.i912 ]
  %610 = shl nuw nsw i64 %indvars.iv.i948, 5
  %611 = getelementptr i8, ptr %549, i64 %610
  %612 = load ptr, ptr %611, align 8
  %613 = icmp ne ptr %612, @nil_typ
  %614 = icmp ne ptr %612, null
  %.not17.i949 = and i1 %613, %614
  br i1 %.not17.i949, label %615, label %._crit_edge.i950

615:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932
  %616 = getelementptr i8, ptr %611, i64 8
  %617 = load i64, ptr %616, align 4
  %.sroa_idx.i953 = getelementptr i8, ptr %611, i64 16
  %618 = load i64, ptr %.sroa_idx.i953, align 4
  %hash_coef_ptr.i.i6.i954 = getelementptr i8, ptr %612, i64 8
  %tbl_size_ptr.i.i7.i955 = getelementptr i8, ptr %612, i64 16
  %offset_tbl_ptr.i.i8.i956 = getelementptr i8, ptr %612, i64 40
  %619 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %hash_coef.i.i21.i1321 = load i64, ptr %hash_coef_ptr.i.i6.i954, align 4, !noalias !143
  %tbl_size.i.i22.i1322 = load i64, ptr %tbl_size_ptr.i.i7.i955, align 4, !noalias !143
  %offset_tbl.i.i23.i1323 = load ptr, ptr %offset_tbl_ptr.i.i8.i956, align 8, !noalias !143
  %product.i.i.i24.i1324 = mul i64 %hash_coef.i.i21.i1321, 4015701072841558310
  %shifted.i.i.i25.i1325 = lshr i64 %product.i.i.i24.i1324, 32
  %xored.i.i.i26.i1326 = xor i64 %shifted.i.i.i25.i1325, %product.i.i.i24.i1324
  %hash.i.i.i27.i1327 = and i64 %xored.i.i.i26.i1326, %tbl_size.i.i22.i1322
  %offset_ptr.i.i28.i1328 = getelementptr i32, ptr %offset_tbl.i.i23.i1323, i64 %hash.i.i.i27.i1327
  %offset.i.i29.i1329 = load i32, ptr %offset_ptr.i.i28.i1328, align 4, !noalias !143
  %620 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %621 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %622 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %623

623:                                              ; preds = %.cont.i1352, %615
  %.0290.i1330 = phi i32 [ 0, %615 ], [ %656, %.cont.i1352 ]
  %.074289.i1331 = phi i1 [ true, %615 ], [ %657, %.cont.i1352 ]
  %.sroa.0.0288.i1332 = phi ptr [ %612, %615 ], [ %646, %.cont.i1352 ]
  %.sroa.6.0287.i1333.in = phi i64 [ %617, %615 ], [ %648, %.cont.i1352 ]
  %.sroa.12.0286.i1334.in = phi i64 [ %618, %615 ], [ %649, %.cont.i1352 ]
  %.sroa.17.0285.i1335 = phi i32 [ %offset.i.i29.i1329, %615 ], [ %offset.i.i57.i1364, %.cont.i1352 ]
  %.sroa.12.0286.i1334 = inttoptr i64 %.sroa.12.0286.i1334.in to ptr
  %.sroa.6.0287.i1333 = inttoptr i64 %.sroa.6.0287.i1333.in to ptr
  %624 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1332, 0
  %625 = insertvalue { ptr, ptr, ptr, i32 } %624, ptr %.sroa.6.0287.i1333, 1
  %626 = insertvalue { ptr, ptr, ptr, i32 } %625, ptr %.sroa.12.0286.i1334, 2
  %627 = insertvalue { ptr, ptr, ptr, i32 } %626, i32 %.sroa.17.0285.i1335, 3
  %628 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1332)
  %629 = sext i32 %.sroa.17.0285.i1335 to i64
  %630 = getelementptr ptr, ptr %.sroa.0.0288.i1332, i64 %629
  %631 = getelementptr i8, ptr %630, i64 64
  %632 = load ptr, ptr %631, align 8
  %result.i15.i1336 = call ptr %632({ ptr, ptr, ptr, i32 } %627, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %633 = call i32 %result.i15.i1336({ ptr, ptr, ptr, i32 } %627, { ptr, ptr, ptr, i32 } %627, ptr nonnull align 8 %2) #53
  %..i1337 = select i1 %.074289.i1331, ptr %11, ptr %13
  %.188.i1338 = select i1 %.074289.i1331, i64 104, i64 112
  %.189.i1339 = select i1 %.074289.i1331, ptr %12, ptr %14
  %.190.i1340 = select i1 %.074289.i1331, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1337, align 8
  %634 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1337)
  %635 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1338
  %636 = load ptr, ptr %635, align 8
  store ptr @i32_typ, ptr %.189.i1339, align 8
  %result.i14.i1341 = call ptr %636({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1339) #46
  %637 = call i32 %result.i14.i1341({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1337, i32 %633) #53
  %638 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %639 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1340
  %640 = load ptr, ptr %639, align 8
  %641 = load ptr, ptr %640, align 8
  %642 = call { ptr } %641(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i1342 = extractvalue { ptr } %642, 0
  %643 = sext i32 %637 to i64
  %644 = shl nsw i64 %643, 5
  %645 = getelementptr i8, ptr %.fca.0.extract55.i1342, i64 %644
  %646 = load ptr, ptr %645, align 8
  %647 = getelementptr i8, ptr %645, i64 8
  %648 = load i64, ptr %647, align 4
  %.sroa_idx.i1343 = getelementptr i8, ptr %645, i64 16
  %649 = load i64, ptr %.sroa_idx.i1343, align 4
  %650 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %651 = call { ptr } %641(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i1344 = extractvalue { ptr } %651, 0
  %652 = getelementptr i8, ptr %.fca.0.extract52.i1344, i64 %644
  store ptr %.sroa.0.0288.i1332, ptr %652, align 8
  %653 = getelementptr i8, ptr %652, i64 8
  store i64 %.sroa.6.0287.i1333.in, ptr %653, align 4
  %.sroa_idx104.i1345 = getelementptr i8, ptr %652, i64 16
  store i64 %.sroa.12.0286.i1334.in, ptr %.sroa_idx104.i1345, align 4
  %.sroa_idx105.i1346 = getelementptr i8, ptr %652, i64 24
  store i32 %.sroa.17.0285.i1335, ptr %.sroa_idx105.i1346, align 4
  %654 = icmp ne ptr %646, @nil_typ
  %655 = icmp ne ptr %646, null
  %.not94.i1347 = and i1 %654, %655
  br i1 %.not94.i1347, label %.cont.i1352, label %660

.cont.i1352:                                      ; preds = %623
  %656 = add nuw nsw i32 %.0290.i1330, 1
  %657 = xor i1 %.074289.i1331, true
  %hash_coef_ptr.i.i46.i1353 = getelementptr i8, ptr %646, i64 8
  %tbl_size_ptr.i.i47.i1354 = getelementptr i8, ptr %646, i64 16
  %offset_tbl_ptr.i.i48.i1355 = getelementptr i8, ptr %646, i64 40
  %hash_coef.i.i49.i1356 = load i64, ptr %hash_coef_ptr.i.i46.i1353, align 4
  %tbl_size.i.i50.i1357 = load i64, ptr %tbl_size_ptr.i.i47.i1354, align 4
  %offset_tbl.i.i51.i1358 = load ptr, ptr %offset_tbl_ptr.i.i48.i1355, align 8
  %product.i.i.i52.i1359 = mul i64 %hash_coef.i.i49.i1356, 4015701072841558310
  %shifted.i.i.i53.i1360 = lshr i64 %product.i.i.i52.i1359, 32
  %xored.i.i.i54.i1361 = xor i64 %shifted.i.i.i53.i1360, %product.i.i.i52.i1359
  %hash.i.i.i55.i1362 = and i64 %xored.i.i.i54.i1361, %tbl_size.i.i50.i1357
  %offset_ptr.i.i56.i1363 = getelementptr i32, ptr %offset_tbl.i.i51.i1358, i64 %hash.i.i.i55.i1362
  %offset.i.i57.i1364 = load i32, ptr %offset_ptr.i.i56.i1363, align 4
  %658 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1365 = icmp eq i32 %656, 100
  br i1 %exitcond.not.i1365, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374, label %623

660:                                              ; preds = %623
  %661 = load i32, ptr %54, align 4
  %662 = add i32 %661, 1
  %663 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %662, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374: ; preds = %660, %.cont.i1352
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  br label %._crit_edge.i950

._crit_edge.i950:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932
  %indvars.iv.next.i951 = add nuw nsw i64 %indvars.iv.i948, 1
  %exitcond.not.i952 = icmp eq i64 %indvars.iv.next.i951, %wide.trip.count.i909
  br i1 %exitcond.not.i952, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970: ; preds = %._crit_edge.i950, %545
  %664 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %hash_coef.i.i21.i503 = load i64, ptr %hash_coef_ptr.i.i46.i.le, align 4, !noalias !146
  %tbl_size.i.i22.i504 = load i64, ptr %tbl_size_ptr.i.i47.i.le, align 4, !noalias !146
  %offset_tbl.i.i23.i505 = load ptr, ptr %offset_tbl_ptr.i.i48.i.le, align 8, !noalias !146
  %product.i.i.i24.i506 = mul i64 %hash_coef.i.i21.i503, 4015701072841558310
  %shifted.i.i.i25.i507 = lshr i64 %product.i.i.i24.i506, 32
  %xored.i.i.i26.i508 = xor i64 %shifted.i.i.i25.i507, %product.i.i.i24.i506
  %hash.i.i.i27.i509 = and i64 %xored.i.i.i26.i508, %tbl_size.i.i22.i504
  %offset_ptr.i.i28.i510 = getelementptr i32, ptr %offset_tbl.i.i23.i505, i64 %hash.i.i.i27.i509
  %offset.i.i29.i511 = load i32, ptr %offset_ptr.i.i28.i510, align 4, !noalias !146
  %665 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %667 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %668

668:                                              ; preds = %.cont.i535, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970
  %.0290.i513 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970 ], [ %701, %.cont.i535 ]
  %.074289.i514 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970 ], [ %702, %.cont.i535 ]
  %.sroa.0.0288.i515 = phi ptr [ %524, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970 ], [ %691, %.cont.i535 ]
  %.sroa.6.0287.i516.in = phi i64 [ %526, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970 ], [ %693, %.cont.i535 ]
  %.sroa.12.0286.i517.in = phi i64 [ %527, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970 ], [ %694, %.cont.i535 ]
  %.sroa.17.0285.i518 = phi i32 [ %offset.i.i29.i511, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970 ], [ %offset.i.i57.i547, %.cont.i535 ]
  %.sroa.12.0286.i517 = inttoptr i64 %.sroa.12.0286.i517.in to ptr
  %.sroa.6.0287.i516 = inttoptr i64 %.sroa.6.0287.i516.in to ptr
  %669 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i515, 0
  %670 = insertvalue { ptr, ptr, ptr, i32 } %669, ptr %.sroa.6.0287.i516, 1
  %671 = insertvalue { ptr, ptr, ptr, i32 } %670, ptr %.sroa.12.0286.i517, 2
  %672 = insertvalue { ptr, ptr, ptr, i32 } %671, i32 %.sroa.17.0285.i518, 3
  %673 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i515)
  %674 = sext i32 %.sroa.17.0285.i518 to i64
  %675 = getelementptr ptr, ptr %.sroa.0.0288.i515, i64 %674
  %676 = getelementptr i8, ptr %675, i64 64
  %677 = load ptr, ptr %676, align 8
  %result.i15.i519 = call ptr %677({ ptr, ptr, ptr, i32 } %672, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %678 = call i32 %result.i15.i519({ ptr, ptr, ptr, i32 } %672, { ptr, ptr, ptr, i32 } %672, ptr nonnull align 8 %2) #53
  %..i520 = select i1 %.074289.i514, ptr %27, ptr %29
  %.188.i521 = select i1 %.074289.i514, i64 104, i64 112
  %.189.i522 = select i1 %.074289.i514, ptr %28, ptr %30
  %.190.i523 = select i1 %.074289.i514, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i520, align 8
  %679 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i520)
  %680 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i521
  %681 = load ptr, ptr %680, align 8
  store ptr @i32_typ, ptr %.189.i522, align 8
  %result.i14.i524 = call ptr %681({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i522) #46
  %682 = call i32 %result.i14.i524({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 dereferenceable(8) %..i520, i32 %678) #53
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %684 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i523
  %685 = load ptr, ptr %684, align 8
  %686 = load ptr, ptr %685, align 8
  %687 = call { ptr } %686(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i525 = extractvalue { ptr } %687, 0
  %688 = sext i32 %682 to i64
  %689 = shl nsw i64 %688, 5
  %690 = getelementptr i8, ptr %.fca.0.extract55.i525, i64 %689
  %691 = load ptr, ptr %690, align 8
  %692 = getelementptr i8, ptr %690, i64 8
  %693 = load i64, ptr %692, align 4
  %.sroa_idx.i526 = getelementptr i8, ptr %690, i64 16
  %694 = load i64, ptr %.sroa_idx.i526, align 4
  %695 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %696 = call { ptr } %686(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i527 = extractvalue { ptr } %696, 0
  %697 = getelementptr i8, ptr %.fca.0.extract52.i527, i64 %689
  store ptr %.sroa.0.0288.i515, ptr %697, align 8
  %698 = getelementptr i8, ptr %697, i64 8
  store i64 %.sroa.6.0287.i516.in, ptr %698, align 4
  %.sroa_idx104.i528 = getelementptr i8, ptr %697, i64 16
  store i64 %.sroa.12.0286.i517.in, ptr %.sroa_idx104.i528, align 4
  %.sroa_idx105.i529 = getelementptr i8, ptr %697, i64 24
  store i32 %.sroa.17.0285.i518, ptr %.sroa_idx105.i529, align 4
  %699 = icmp ne ptr %691, @nil_typ
  %700 = icmp ne ptr %691, null
  %.not94.i530 = and i1 %699, %700
  br i1 %.not94.i530, label %.cont.i535, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit557

.cont.i535:                                       ; preds = %668
  %701 = add nuw nsw i32 %.0290.i513, 1
  %702 = xor i1 %.074289.i514, true
  %hash_coef_ptr.i.i46.i536 = getelementptr i8, ptr %691, i64 8
  %tbl_size_ptr.i.i47.i537 = getelementptr i8, ptr %691, i64 16
  %offset_tbl_ptr.i.i48.i538 = getelementptr i8, ptr %691, i64 40
  %hash_coef.i.i49.i539 = load i64, ptr %hash_coef_ptr.i.i46.i536, align 4
  %tbl_size.i.i50.i540 = load i64, ptr %tbl_size_ptr.i.i47.i537, align 4
  %offset_tbl.i.i51.i541 = load ptr, ptr %offset_tbl_ptr.i.i48.i538, align 8
  %product.i.i.i52.i542 = mul i64 %hash_coef.i.i49.i539, 4015701072841558310
  %shifted.i.i.i53.i543 = lshr i64 %product.i.i.i52.i542, 32
  %xored.i.i.i54.i544 = xor i64 %shifted.i.i.i53.i543, %product.i.i.i52.i542
  %hash.i.i.i55.i545 = and i64 %xored.i.i.i54.i544, %tbl_size.i.i50.i540
  %offset_ptr.i.i56.i546 = getelementptr i32, ptr %offset_tbl.i.i51.i541, i64 %hash.i.i.i55.i545
  %offset.i.i57.i547 = load i32, ptr %offset_ptr.i.i56.i546, align 4
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %704 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i548 = icmp eq i32 %701, 100
  br i1 %exitcond.not.i548, label %708, label %668

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit557: ; preds = %668
  %705 = load i32, ptr %54, align 4
  %706 = add i32 %705, 1
  %707 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %706, ptr %54, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  br label %CuckooMap_insert_keyK_valueV.exit

708:                                              ; preds = %.cont.i535
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %709 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %710 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %711 = load ptr, ptr %51, align 8
  %712 = load ptr, ptr %52, align 8
  %713 = load i32, ptr %50, align 8
  %714 = shl i32 %713, 1
  %spec.select.i574 = call i32 @llvm.smax.i32(i32 %714, i32 noundef 16) #40
  store i32 %spec.select.i574, ptr %50, align 8
  %715 = zext nneg i32 %spec.select.i574 to i64
  %716 = shl nuw nsw i64 %715, 5
  %result.i5.i575 = call noalias ptr @bump_malloc_wrapper(i64 noundef %716) #48
  store ptr %result.i5.i575, ptr %51, align 8
  %result.i4.i576 = call noalias ptr @bump_malloc_wrapper(i64 noundef %716) #48
  store ptr %result.i4.i576, ptr %52, align 8
  store i32 0, ptr %54, align 4
  %717 = icmp sgt i32 %713, 0
  br i1 %717, label %.lr.ph.i972, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.thread: ; preds = %708
  %718 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i972:                                      ; preds = %708
  %wide.trip.count.i985 = zext nneg i32 %713 to i64
  br label %719

719:                                              ; preds = %._crit_edge.i988, %.lr.ph.i972
  %indvars.iv.i986 = phi i64 [ 0, %.lr.ph.i972 ], [ %indvars.iv.next.i989, %._crit_edge.i988 ]
  %720 = shl nuw nsw i64 %indvars.iv.i986, 5
  %721 = getelementptr i8, ptr %711, i64 %720
  %722 = load ptr, ptr %721, align 8
  %723 = icmp ne ptr %722, @nil_typ
  %724 = icmp ne ptr %722, null
  %.not17.i987 = and i1 %723, %724
  br i1 %.not17.i987, label %725, label %._crit_edge.i988

725:                                              ; preds = %719
  %726 = getelementptr i8, ptr %721, i64 8
  %727 = load i64, ptr %726, align 4
  %.sroa_idx.i991 = getelementptr i8, ptr %721, i64 16
  %728 = load i64, ptr %.sroa_idx.i991, align 4
  %hash_coef_ptr.i.i6.i992 = getelementptr i8, ptr %722, i64 8
  %tbl_size_ptr.i.i7.i993 = getelementptr i8, ptr %722, i64 16
  %offset_tbl_ptr.i.i8.i994 = getelementptr i8, ptr %722, i64 40
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  %hash_coef.i.i21.i1392 = load i64, ptr %hash_coef_ptr.i.i6.i992, align 4, !noalias !149
  %tbl_size.i.i22.i1393 = load i64, ptr %tbl_size_ptr.i.i7.i993, align 4, !noalias !149
  %offset_tbl.i.i23.i1394 = load ptr, ptr %offset_tbl_ptr.i.i8.i994, align 8, !noalias !149
  %product.i.i.i24.i1395 = mul i64 %hash_coef.i.i21.i1392, 4015701072841558310
  %shifted.i.i.i25.i1396 = lshr i64 %product.i.i.i24.i1395, 32
  %xored.i.i.i26.i1397 = xor i64 %shifted.i.i.i25.i1396, %product.i.i.i24.i1395
  %hash.i.i.i27.i1398 = and i64 %xored.i.i.i26.i1397, %tbl_size.i.i22.i1393
  %offset_ptr.i.i28.i1399 = getelementptr i32, ptr %offset_tbl.i.i23.i1394, i64 %hash.i.i.i27.i1398
  %offset.i.i29.i1400 = load i32, ptr %offset_ptr.i.i28.i1399, align 4, !noalias !149
  %730 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %731 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %732 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %733

733:                                              ; preds = %.cont.i1423, %725
  %.0290.i1401 = phi i32 [ 0, %725 ], [ %766, %.cont.i1423 ]
  %.074289.i1402 = phi i1 [ true, %725 ], [ %767, %.cont.i1423 ]
  %.sroa.0.0288.i1403 = phi ptr [ %722, %725 ], [ %756, %.cont.i1423 ]
  %.sroa.6.0287.i1404.in = phi i64 [ %727, %725 ], [ %758, %.cont.i1423 ]
  %.sroa.12.0286.i1405.in = phi i64 [ %728, %725 ], [ %759, %.cont.i1423 ]
  %.sroa.17.0285.i1406 = phi i32 [ %offset.i.i29.i1400, %725 ], [ %offset.i.i57.i1435, %.cont.i1423 ]
  %.sroa.12.0286.i1405 = inttoptr i64 %.sroa.12.0286.i1405.in to ptr
  %.sroa.6.0287.i1404 = inttoptr i64 %.sroa.6.0287.i1404.in to ptr
  %734 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1403, 0
  %735 = insertvalue { ptr, ptr, ptr, i32 } %734, ptr %.sroa.6.0287.i1404, 1
  %736 = insertvalue { ptr, ptr, ptr, i32 } %735, ptr %.sroa.12.0286.i1405, 2
  %737 = insertvalue { ptr, ptr, ptr, i32 } %736, i32 %.sroa.17.0285.i1406, 3
  %738 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1403)
  %739 = sext i32 %.sroa.17.0285.i1406 to i64
  %740 = getelementptr ptr, ptr %.sroa.0.0288.i1403, i64 %739
  %741 = getelementptr i8, ptr %740, i64 64
  %742 = load ptr, ptr %741, align 8
  %result.i15.i1407 = call ptr %742({ ptr, ptr, ptr, i32 } %737, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %743 = call i32 %result.i15.i1407({ ptr, ptr, ptr, i32 } %737, { ptr, ptr, ptr, i32 } %737, ptr nonnull align 8 %2) #53
  %..i1408 = select i1 %.074289.i1402, ptr %7, ptr %9
  %.188.i1409 = select i1 %.074289.i1402, i64 104, i64 112
  %.189.i1410 = select i1 %.074289.i1402, ptr %8, ptr %10
  %.190.i1411 = select i1 %.074289.i1402, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1408, align 8
  %744 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1408)
  %745 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1409
  %746 = load ptr, ptr %745, align 8
  store ptr @i32_typ, ptr %.189.i1410, align 8
  %result.i14.i1412 = call ptr %746({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1410) #46
  %747 = call i32 %result.i14.i1412({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1408, i32 %743) #53
  %748 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %749 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1411
  %750 = load ptr, ptr %749, align 8
  %751 = load ptr, ptr %750, align 8
  %752 = call { ptr } %751(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i1413 = extractvalue { ptr } %752, 0
  %753 = sext i32 %747 to i64
  %754 = shl nsw i64 %753, 5
  %755 = getelementptr i8, ptr %.fca.0.extract55.i1413, i64 %754
  %756 = load ptr, ptr %755, align 8
  %757 = getelementptr i8, ptr %755, i64 8
  %758 = load i64, ptr %757, align 4
  %.sroa_idx.i1414 = getelementptr i8, ptr %755, i64 16
  %759 = load i64, ptr %.sroa_idx.i1414, align 4
  %760 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %761 = call { ptr } %751(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i1415 = extractvalue { ptr } %761, 0
  %762 = getelementptr i8, ptr %.fca.0.extract52.i1415, i64 %754
  store ptr %.sroa.0.0288.i1403, ptr %762, align 8
  %763 = getelementptr i8, ptr %762, i64 8
  store i64 %.sroa.6.0287.i1404.in, ptr %763, align 4
  %.sroa_idx104.i1416 = getelementptr i8, ptr %762, i64 16
  store i64 %.sroa.12.0286.i1405.in, ptr %.sroa_idx104.i1416, align 4
  %.sroa_idx105.i1417 = getelementptr i8, ptr %762, i64 24
  store i32 %.sroa.17.0285.i1406, ptr %.sroa_idx105.i1417, align 4
  %764 = icmp ne ptr %756, @nil_typ
  %765 = icmp ne ptr %756, null
  %.not94.i1418 = and i1 %764, %765
  br i1 %.not94.i1418, label %.cont.i1423, label %770

.cont.i1423:                                      ; preds = %733
  %766 = add nuw nsw i32 %.0290.i1401, 1
  %767 = xor i1 %.074289.i1402, true
  %hash_coef_ptr.i.i46.i1424 = getelementptr i8, ptr %756, i64 8
  %tbl_size_ptr.i.i47.i1425 = getelementptr i8, ptr %756, i64 16
  %offset_tbl_ptr.i.i48.i1426 = getelementptr i8, ptr %756, i64 40
  %hash_coef.i.i49.i1427 = load i64, ptr %hash_coef_ptr.i.i46.i1424, align 4
  %tbl_size.i.i50.i1428 = load i64, ptr %tbl_size_ptr.i.i47.i1425, align 4
  %offset_tbl.i.i51.i1429 = load ptr, ptr %offset_tbl_ptr.i.i48.i1426, align 8
  %product.i.i.i52.i1430 = mul i64 %hash_coef.i.i49.i1427, 4015701072841558310
  %shifted.i.i.i53.i1431 = lshr i64 %product.i.i.i52.i1430, 32
  %xored.i.i.i54.i1432 = xor i64 %shifted.i.i.i53.i1431, %product.i.i.i52.i1430
  %hash.i.i.i55.i1433 = and i64 %xored.i.i.i54.i1432, %tbl_size.i.i50.i1428
  %offset_ptr.i.i56.i1434 = getelementptr i32, ptr %offset_tbl.i.i51.i1429, i64 %hash.i.i.i55.i1433
  %offset.i.i57.i1435 = load i32, ptr %offset_ptr.i.i56.i1434, align 4
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1436 = icmp eq i32 %766, 100
  br i1 %exitcond.not.i1436, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445, label %733

770:                                              ; preds = %733
  %771 = load i32, ptr %54, align 4
  %772 = add i32 %771, 1
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %772, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445: ; preds = %770, %.cont.i1423
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  br label %._crit_edge.i988

._crit_edge.i988:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445, %719
  %indvars.iv.next.i989 = add nuw nsw i64 %indvars.iv.i986, 1
  %exitcond.not.i990 = icmp eq i64 %indvars.iv.next.i989, %wide.trip.count.i985
  br i1 %exitcond.not.i990, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008, label %719

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008: ; preds = %._crit_edge.i988
  %774 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %775

775:                                              ; preds = %._crit_edge.i1026, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008
  %indvars.iv.i1024 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008 ], [ %indvars.iv.next.i1027, %._crit_edge.i1026 ]
  %776 = shl nuw nsw i64 %indvars.iv.i1024, 5
  %777 = getelementptr i8, ptr %712, i64 %776
  %778 = load ptr, ptr %777, align 8
  %779 = icmp ne ptr %778, @nil_typ
  %780 = icmp ne ptr %778, null
  %.not17.i1025 = and i1 %779, %780
  br i1 %.not17.i1025, label %781, label %._crit_edge.i1026

781:                                              ; preds = %775
  %782 = getelementptr i8, ptr %777, i64 8
  %783 = load i64, ptr %782, align 4
  %.sroa_idx.i1029 = getelementptr i8, ptr %777, i64 16
  %784 = load i64, ptr %.sroa_idx.i1029, align 4
  %hash_coef_ptr.i.i6.i1030 = getelementptr i8, ptr %778, i64 8
  %tbl_size_ptr.i.i7.i1031 = getelementptr i8, ptr %778, i64 16
  %offset_tbl_ptr.i.i8.i1032 = getelementptr i8, ptr %778, i64 40
  %785 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %hash_coef.i.i21.i1463 = load i64, ptr %hash_coef_ptr.i.i6.i1030, align 4, !noalias !152
  %tbl_size.i.i22.i1464 = load i64, ptr %tbl_size_ptr.i.i7.i1031, align 4, !noalias !152
  %offset_tbl.i.i23.i1465 = load ptr, ptr %offset_tbl_ptr.i.i8.i1032, align 8, !noalias !152
  %product.i.i.i24.i1466 = mul i64 %hash_coef.i.i21.i1463, 4015701072841558310
  %shifted.i.i.i25.i1467 = lshr i64 %product.i.i.i24.i1466, 32
  %xored.i.i.i26.i1468 = xor i64 %shifted.i.i.i25.i1467, %product.i.i.i24.i1466
  %hash.i.i.i27.i1469 = and i64 %xored.i.i.i26.i1468, %tbl_size.i.i22.i1464
  %offset_ptr.i.i28.i1470 = getelementptr i32, ptr %offset_tbl.i.i23.i1465, i64 %hash.i.i.i27.i1469
  %offset.i.i29.i1471 = load i32, ptr %offset_ptr.i.i28.i1470, align 4, !noalias !152
  %786 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %787 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %788 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %789

789:                                              ; preds = %.cont.i1494, %781
  %.0290.i1472 = phi i32 [ 0, %781 ], [ %822, %.cont.i1494 ]
  %.074289.i1473 = phi i1 [ true, %781 ], [ %823, %.cont.i1494 ]
  %.sroa.0.0288.i1474 = phi ptr [ %778, %781 ], [ %812, %.cont.i1494 ]
  %.sroa.6.0287.i1475.in = phi i64 [ %783, %781 ], [ %814, %.cont.i1494 ]
  %.sroa.12.0286.i1476.in = phi i64 [ %784, %781 ], [ %815, %.cont.i1494 ]
  %.sroa.17.0285.i1477 = phi i32 [ %offset.i.i29.i1471, %781 ], [ %offset.i.i57.i1506, %.cont.i1494 ]
  %.sroa.12.0286.i1476 = inttoptr i64 %.sroa.12.0286.i1476.in to ptr
  %.sroa.6.0287.i1475 = inttoptr i64 %.sroa.6.0287.i1475.in to ptr
  %790 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1474, 0
  %791 = insertvalue { ptr, ptr, ptr, i32 } %790, ptr %.sroa.6.0287.i1475, 1
  %792 = insertvalue { ptr, ptr, ptr, i32 } %791, ptr %.sroa.12.0286.i1476, 2
  %793 = insertvalue { ptr, ptr, ptr, i32 } %792, i32 %.sroa.17.0285.i1477, 3
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1474)
  %795 = sext i32 %.sroa.17.0285.i1477 to i64
  %796 = getelementptr ptr, ptr %.sroa.0.0288.i1474, i64 %795
  %797 = getelementptr i8, ptr %796, i64 64
  %798 = load ptr, ptr %797, align 8
  %result.i15.i1478 = call ptr %798({ ptr, ptr, ptr, i32 } %793, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %799 = call i32 %result.i15.i1478({ ptr, ptr, ptr, i32 } %793, { ptr, ptr, ptr, i32 } %793, ptr nonnull align 8 %2) #53
  %..i1479 = select i1 %.074289.i1473, ptr %3, ptr %5
  %.188.i1480 = select i1 %.074289.i1473, i64 104, i64 112
  %.189.i1481 = select i1 %.074289.i1473, ptr %4, ptr %6
  %.190.i1482 = select i1 %.074289.i1473, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1479, align 8
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1479)
  %801 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1480
  %802 = load ptr, ptr %801, align 8
  store ptr @i32_typ, ptr %.189.i1481, align 8
  %result.i14.i1483 = call ptr %802({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1481) #46
  %803 = call i32 %result.i14.i1483({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 dereferenceable(8) %..i1479, i32 %799) #53
  %804 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %805 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1482
  %806 = load ptr, ptr %805, align 8
  %807 = load ptr, ptr %806, align 8
  %808 = call { ptr } %807(ptr nonnull %result.i35) #43
  %.fca.0.extract55.i1484 = extractvalue { ptr } %808, 0
  %809 = sext i32 %803 to i64
  %810 = shl nsw i64 %809, 5
  %811 = getelementptr i8, ptr %.fca.0.extract55.i1484, i64 %810
  %812 = load ptr, ptr %811, align 8
  %813 = getelementptr i8, ptr %811, i64 8
  %814 = load i64, ptr %813, align 4
  %.sroa_idx.i1485 = getelementptr i8, ptr %811, i64 16
  %815 = load i64, ptr %.sroa_idx.i1485, align 4
  %816 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %817 = call { ptr } %807(ptr nonnull %result.i35) #43
  %.fca.0.extract52.i1486 = extractvalue { ptr } %817, 0
  %818 = getelementptr i8, ptr %.fca.0.extract52.i1486, i64 %810
  store ptr %.sroa.0.0288.i1474, ptr %818, align 8
  %819 = getelementptr i8, ptr %818, i64 8
  store i64 %.sroa.6.0287.i1475.in, ptr %819, align 4
  %.sroa_idx104.i1487 = getelementptr i8, ptr %818, i64 16
  store i64 %.sroa.12.0286.i1476.in, ptr %.sroa_idx104.i1487, align 4
  %.sroa_idx105.i1488 = getelementptr i8, ptr %818, i64 24
  store i32 %.sroa.17.0285.i1477, ptr %.sroa_idx105.i1488, align 4
  %820 = icmp ne ptr %812, @nil_typ
  %821 = icmp ne ptr %812, null
  %.not94.i1489 = and i1 %820, %821
  br i1 %.not94.i1489, label %.cont.i1494, label %826

.cont.i1494:                                      ; preds = %789
  %822 = add nuw nsw i32 %.0290.i1472, 1
  %823 = xor i1 %.074289.i1473, true
  %hash_coef_ptr.i.i46.i1495 = getelementptr i8, ptr %812, i64 8
  %tbl_size_ptr.i.i47.i1496 = getelementptr i8, ptr %812, i64 16
  %offset_tbl_ptr.i.i48.i1497 = getelementptr i8, ptr %812, i64 40
  %hash_coef.i.i49.i1498 = load i64, ptr %hash_coef_ptr.i.i46.i1495, align 4
  %tbl_size.i.i50.i1499 = load i64, ptr %tbl_size_ptr.i.i47.i1496, align 4
  %offset_tbl.i.i51.i1500 = load ptr, ptr %offset_tbl_ptr.i.i48.i1497, align 8
  %product.i.i.i52.i1501 = mul i64 %hash_coef.i.i49.i1498, 4015701072841558310
  %shifted.i.i.i53.i1502 = lshr i64 %product.i.i.i52.i1501, 32
  %xored.i.i.i54.i1503 = xor i64 %shifted.i.i.i53.i1502, %product.i.i.i52.i1501
  %hash.i.i.i55.i1504 = and i64 %xored.i.i.i54.i1503, %tbl_size.i.i50.i1499
  %offset_ptr.i.i56.i1505 = getelementptr i32, ptr %offset_tbl.i.i51.i1500, i64 %hash.i.i.i55.i1504
  %offset.i.i57.i1506 = load i32, ptr %offset_ptr.i.i56.i1505, align 4
  %824 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %825 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1507 = icmp eq i32 %822, 100
  br i1 %exitcond.not.i1507, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516, label %789

826:                                              ; preds = %789
  %827 = load i32, ptr %54, align 4
  %828 = add i32 %827, 1
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %828, ptr %54, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516: ; preds = %826, %.cont.i1494
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  br label %._crit_edge.i1026

._crit_edge.i1026:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516, %775
  %indvars.iv.next.i1027 = add nuw nsw i64 %indvars.iv.i1024, 1
  %exitcond.not.i1028 = icmp eq i64 %indvars.iv.next.i1027, %wide.trip.count.i985
  br i1 %exitcond.not.i1028, label %CuckooMap_insert_keyK_valueV.exit, label %775

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i1026, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit557, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit424, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %830 = add i64 %.0148108, %indvars.iv.next
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %CuckooMap_insert_keyK_valueV.exit
  %831 = call i64 @clock()
  %832 = load <55 x i8>, ptr @lwoib_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  br label %833

833:                                              ; preds = %._crit_edge2, %.lr.ph
  %.2117 = phi i32 [ 0, %.lr.ph ], [ %959, %._crit_edge2 ]
  %.0150116 = phi i64 [ 0, %.lr.ph ], [ %.1151, %._crit_edge2 ]
  %.0153115 = phi i1 [ true, %.lr.ph ], [ %.1154, %._crit_edge2 ]
  %.sroa.0126.0.insert.ext = zext nneg i32 %.2117 to i160
  %834 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0126.0.insert.ext, 1
  %835 = load ptr, ptr %48, align 8
  %836 = call i32 %835({ ptr, i160 } %834) #53
  %837 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %838 = load i32, ptr %50, align 8
  %839 = add i32 %838, -1
  %840 = and i32 %839, %836
  %841 = load ptr, ptr %51, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %842 = sext i32 %840 to i64
  %843 = shl nsw i64 %842, 5
  %844 = getelementptr i8, ptr %841, i64 %843
  %845 = load ptr, ptr %844, align 8
  %846 = icmp ne ptr %845, @nil_typ
  %847 = icmp ne ptr %845, null
  %.not45.i = and i1 %846, %847
  br i1 %.not45.i, label %848, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

848:                                              ; preds = %833
  %849 = getelementptr i8, ptr %844, i64 8
  %850 = load i64, ptr %849, align 4
  %.sroa_idx.i622 = getelementptr i8, ptr %844, i64 16
  %851 = load i64, ptr %.sroa_idx.i622, align 4
  %852 = inttoptr i64 %850 to ptr
  %853 = inttoptr i64 %851 to ptr
  %hash_coef_ptr.i.i4.i = getelementptr i8, ptr %845, i64 8
  %tbl_size_ptr.i.i5.i = getelementptr i8, ptr %845, i64 16
  %offset_tbl_ptr.i.i6.i = getelementptr i8, ptr %845, i64 40
  %hash_coef.i.i7.i = load i64, ptr %hash_coef_ptr.i.i4.i, align 4, !noalias !155
  %tbl_size.i.i8.i = load i64, ptr %tbl_size_ptr.i.i5.i, align 4, !noalias !155
  %offset_tbl.i.i9.i = load ptr, ptr %offset_tbl_ptr.i.i6.i, align 8, !noalias !155
  %product.i.i.i10.i = mul i64 %hash_coef.i.i7.i, 4015701072841558310
  %shifted.i.i.i11.i = lshr i64 %product.i.i.i10.i, 32
  %xored.i.i.i12.i = xor i64 %shifted.i.i.i11.i, %product.i.i.i10.i
  %hash.i.i.i13.i = and i64 %xored.i.i.i12.i, %tbl_size.i.i8.i
  %offset_ptr.i.i14.i = getelementptr i32, ptr %offset_tbl.i.i9.i, i64 %hash.i.i.i13.i
  %offset.i.i15.i = load i32, ptr %offset_ptr.i.i14.i, align 4, !noalias !155
  %854 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %845, 0
  %855 = insertvalue { ptr, ptr, ptr, i32 } %854, ptr %852, 1
  %856 = insertvalue { ptr, ptr, ptr, i32 } %855, ptr %853, 2
  %857 = insertvalue { ptr, ptr, ptr, i32 } %856, i32 %offset.i.i15.i, 3
  %858 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %859 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %845) #40
  %860 = sext i32 %offset.i.i15.i to i64
  %861 = getelementptr ptr, ptr %845, i64 %860
  %862 = getelementptr i8, ptr %861, i64 64
  %863 = load ptr, ptr %862, align 8
  %result.i2.i623 = call ptr %863({ ptr, ptr, ptr, i32 } %857, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %864 = call i32 %result.i2.i623({ ptr, ptr, ptr, i32 } %857, { ptr, ptr, ptr, i32 } %857, ptr nonnull align 8 %2) #53
  %865 = icmp eq i32 %864, %836
  br i1 %865, label %._crit_edge.i624, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i624:                                 ; preds = %848
  %866 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %867 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %845)
  %868 = getelementptr i8, ptr %861, i64 48
  %869 = load ptr, ptr %868, align 8
  %result.i1.i625 = call ptr %869({ ptr, ptr, ptr, i32 } %857, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %870 = call { ptr, i160 } %result.i1.i625({ ptr, ptr, ptr, i32 } %857, { ptr, ptr, ptr, i32 } %857, ptr nonnull align 8 %2) #53
  %871 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %872 = load ptr, ptr %49, align 8
  %873 = call i1 %872({ ptr, i160 } %870, { ptr, i160 } %834) #53
  br i1 %873, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i624, %848, %833
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %882

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i624
  %874 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %875 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %845)
  %876 = getelementptr i8, ptr %861, i64 56
  %877 = load ptr, ptr %876, align 8
  %result.i.i626 = call ptr %877({ ptr, ptr, ptr, i32 } %857, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %878 = call { ptr, i160 } %result.i.i626({ ptr, ptr, ptr, i32 } %857, { ptr, ptr, ptr, i32 } %857, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i = extractvalue { ptr, i160 } %878, 0
  %.fca.1.extract23.i = extractvalue { ptr, i160 } %878, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %879 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %880 = icmp ne ptr %.fca.0.extract22.i, @nil_typ
  %881 = icmp ne ptr %.fca.0.extract22.i, null
  %.not63.i = and i1 %880, %881
  %extract.t713 = trunc i160 %.fca.1.extract23.i to i64
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %882

882:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %883 = add i32 %836, 2127912214
  %884 = shl i32 %836, 12
  %885 = add i32 %883, %884
  %886 = ashr i32 %885, 19
  %887 = xor i32 %885, %886
  %888 = xor i32 %887, -949894596
  %889 = add i32 %888, 374761393
  %890 = shl i32 %888, 5
  %891 = add i32 %889, %890
  %892 = add i32 %891, -744332180
  %893 = shl i32 %891, 9
  %894 = xor i32 %892, %893
  %895 = add i32 %894, -42973499
  %896 = shl i32 %894, 3
  %897 = add i32 %895, %896
  %898 = ashr i32 %897, 16
  %899 = xor i32 %897, %898
  %900 = xor i32 %899, -1252372727
  %901 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %902 = load i32, ptr %50, align 8
  %903 = add i32 %902, -1
  %904 = and i32 %903, %900
  %905 = load ptr, ptr %52, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %906 = sext i32 %904 to i64
  %907 = shl nsw i64 %906, 5
  %908 = getelementptr i8, ptr %905, i64 %907
  %909 = load ptr, ptr %908, align 8
  %910 = icmp ne ptr %909, @nil_typ
  %911 = icmp ne ptr %909, null
  %.not45.i657 = and i1 %910, %911
  br i1 %.not45.i657, label %912, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682

912:                                              ; preds = %882
  %913 = getelementptr i8, ptr %908, i64 8
  %914 = load i64, ptr %913, align 4
  %.sroa_idx.i662 = getelementptr i8, ptr %908, i64 16
  %915 = load i64, ptr %.sroa_idx.i662, align 4
  %916 = inttoptr i64 %914 to ptr
  %917 = inttoptr i64 %915 to ptr
  %hash_coef_ptr.i.i4.i663 = getelementptr i8, ptr %909, i64 8
  %tbl_size_ptr.i.i5.i664 = getelementptr i8, ptr %909, i64 16
  %offset_tbl_ptr.i.i6.i665 = getelementptr i8, ptr %909, i64 40
  %hash_coef.i.i7.i666 = load i64, ptr %hash_coef_ptr.i.i4.i663, align 4, !noalias !158
  %tbl_size.i.i8.i667 = load i64, ptr %tbl_size_ptr.i.i5.i664, align 4, !noalias !158
  %offset_tbl.i.i9.i668 = load ptr, ptr %offset_tbl_ptr.i.i6.i665, align 8, !noalias !158
  %product.i.i.i10.i669 = mul i64 %hash_coef.i.i7.i666, 4015701072841558310
  %shifted.i.i.i11.i670 = lshr i64 %product.i.i.i10.i669, 32
  %xored.i.i.i12.i671 = xor i64 %shifted.i.i.i11.i670, %product.i.i.i10.i669
  %hash.i.i.i13.i672 = and i64 %xored.i.i.i12.i671, %tbl_size.i.i8.i667
  %offset_ptr.i.i14.i673 = getelementptr i32, ptr %offset_tbl.i.i9.i668, i64 %hash.i.i.i13.i672
  %offset.i.i15.i674 = load i32, ptr %offset_ptr.i.i14.i673, align 4, !noalias !158
  %918 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %909, 0
  %919 = insertvalue { ptr, ptr, ptr, i32 } %918, ptr %916, 1
  %920 = insertvalue { ptr, ptr, ptr, i32 } %919, ptr %917, 2
  %921 = insertvalue { ptr, ptr, ptr, i32 } %920, i32 %offset.i.i15.i674, 3
  %922 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %923 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %909) #40
  %924 = sext i32 %offset.i.i15.i674 to i64
  %925 = getelementptr ptr, ptr %909, i64 %924
  %926 = getelementptr i8, ptr %925, i64 64
  %927 = load ptr, ptr %926, align 8
  %result.i2.i675 = call ptr %927({ ptr, ptr, ptr, i32 } %921, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %928 = call i32 %result.i2.i675({ ptr, ptr, ptr, i32 } %921, { ptr, ptr, ptr, i32 } %921, ptr nonnull align 8 %2) #53
  %929 = icmp eq i32 %928, %836
  br i1 %929, label %._crit_edge.i676, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682

._crit_edge.i676:                                 ; preds = %912
  %930 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %931 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %909)
  %932 = getelementptr i8, ptr %925, i64 48
  %933 = load ptr, ptr %932, align 8
  %result.i1.i677 = call ptr %933({ ptr, ptr, ptr, i32 } %921, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %934 = call { ptr, i160 } %result.i1.i677({ ptr, ptr, ptr, i32 } %921, { ptr, ptr, ptr, i32 } %921, ptr nonnull align 8 %2) #53
  %935 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %936 = load ptr, ptr %49, align 8
  %937 = call i1 %936({ ptr, i160 } %934, { ptr, i160 } %834) #53
  br i1 %937, label %938, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682

938:                                              ; preds = %._crit_edge.i676
  %939 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %940 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %909)
  %941 = getelementptr i8, ptr %925, i64 56
  %942 = load ptr, ptr %941, align 8
  %result.i.i679 = call ptr %942({ ptr, ptr, ptr, i32 } %921, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %943 = call { ptr, i160 } %result.i.i679({ ptr, ptr, ptr, i32 } %921, { ptr, ptr, ptr, i32 } %921, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i680 = extractvalue { ptr, i160 } %943, 0
  %.fca.1.extract23.i681 = extractvalue { ptr, i160 } %943, 1
  %944 = trunc i160 %.fca.1.extract23.i681 to i64
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682: ; preds = %938, %._crit_edge.i676, %912, %882
  %.reg2mem43.sroa.3.0.i658 = phi i64 [ %944, %938 ], [ poison, %._crit_edge.i676 ], [ poison, %882 ], [ poison, %912 ]
  %.reg2mem41.0.i659 = phi ptr [ %.fca.0.extract22.i680, %938 ], [ @nil_typ, %._crit_edge.i676 ], [ @nil_typ, %882 ], [ @nil_typ, %912 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %945 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i178 = icmp eq ptr %.reg2mem41.0.i659, null
  %946 = select i1 %.not.i178, ptr @nil_typ, ptr %.reg2mem41.0.i659
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not63.i712.off0 = phi i64 [ %.reg2mem43.sroa.3.0.i658, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682 ], [ %extract.t713, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem56.0.i = phi ptr [ %946, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682 ], [ %.fca.0.extract22.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %947 = icmp ne ptr %.reg2mem56.0.i, @nil_typ
  %948 = icmp ne ptr %.reg2mem56.0.i, null
  %.not159 = and i1 %947, %948
  br i1 %.not159, label %949, label %._crit_edge.lr.ph.i

949:                                              ; preds = %CuckooMap_get_keyK.exit
  %sext = shl i64 %.not63.i712.off0, 32
  %950 = ashr exact i64 %sext, 32
  %951 = add i64 %950, %.0150116
  br label %._crit_edge2

._crit_edge.lr.ph.i:                              ; preds = %CuckooMap_get_keyK.exit
  %result.i32.h2s1671 = alloca [56 x i8], align 1
  %952 = getelementptr inbounds i8, ptr %result.i32.h2s1671, i64 55
  store i8 0, ptr %952, align 1
  store <55 x i8> %832, ptr %result.i32.h2s1671, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %953 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %954 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %result.i.i743.h2s1672 = alloca [56 x i8], align 1
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(56) %result.i.i743.h2s1672, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(56) %result.i32.h2s1671, i64 noundef 55, i1 noundef false)
  %955 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %956 = getelementptr inbounds i8, ptr %result.i.i743.h2s1672, i64 55
  store i8 0, ptr %956, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(56) %result.i.i743.h2s1672) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %957 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %958 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2117) #55
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %._crit_edge.lr.ph.i, %949
  %.1154 = phi i1 [ %.0153115, %949 ], [ false, %._crit_edge.lr.ph.i ]
  %.1151 = phi i64 [ %951, %949 ], [ %.0150116, %._crit_edge.lr.ph.i ]
  %959 = add nuw nsw i32 %.2117, 1
  %exitcond129.not = icmp eq i32 %959, %0
  br i1 %exitcond129.not, label %._crit_edge.lr.ph.i759, label %833

._crit_edge.lr.ph.i759:                           ; preds = %._crit_edge2, %._crit_edge1._crit_edge.thread
  %960 = phi i64 [ %56, %._crit_edge1._crit_edge.thread ], [ %831, %._crit_edge2 ]
  %.0148.lcssa138 = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %830, %._crit_edge2 ]
  %.0153.lcssa = phi i1 [ true, %._crit_edge1._crit_edge.thread ], [ %.1154, %._crit_edge2 ]
  %.0150.lcssa = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %.1151, %._crit_edge2 ]
  %961 = call i64 @clock()
  %962 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %963 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %964 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i.i758.h2s1669, align 1
  %965 = sub i64 %961, %960
  %966 = getelementptr inbounds i8, ptr %result.i.i758.h2s1669, i64 18
  store i8 0, ptr %966, align 1
  %puts.i278 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i758.h2s1669) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i.i.i.h2s1667, align 16
  %967 = getelementptr inbounds i8, ptr %result.i.i.i.h2s1667, i64 14
  store i8 0, ptr %967, align 2
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.h2s1667) #53
  %968 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #55
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i.i304.i.h2s1665, align 16
  %969 = getelementptr inbounds i8, ptr %result.i.i304.i.h2s1665, i64 14
  store i8 0, ptr %969, align 2
  %puts.i229.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.h2s1665) #53
  %970 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %965) #55
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i.i324.i.h2s1663, align 4
  %971 = getelementptr inbounds i8, ptr %result.i.i324.i.h2s1663, i64 3
  store i8 0, ptr %971, align 1
  %puts.i249.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.h2s1663) #53
  br i1 %55, label %._crit_edge.lr.ph.i345.i, label %._crit_edge.lr.ph.i779

._crit_edge.lr.ph.i345.i:                         ; preds = %._crit_edge.lr.ph.i759
  %972 = zext nneg i32 %0 to i64
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i.i344.i.h2s1661, align 16
  %973 = mul i64 %965, 1000000
  %974 = sdiv i64 %973, %972
  %975 = getelementptr inbounds i8, ptr %result.i.i344.i.h2s1661, i64 15
  store i8 0, ptr %975, align 1
  %puts.i269.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.h2s1661) #53
  %976 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %974) #55
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i.i364.i.h2s1659, align 4
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %979 = getelementptr inbounds i8, ptr %result.i.i364.i.h2s1659, i64 3
  store i8 0, ptr %979, align 1
  %puts.i289.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.h2s1659) #53
  br label %._crit_edge.lr.ph.i779

._crit_edge.lr.ph.i779:                           ; preds = %._crit_edge.lr.ph.i345.i, %._crit_edge.lr.ph.i759
  %.not = icmp eq i64 %.0150.lcssa, %.0148.lcssa138
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %980 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %981 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i.i778.h2s1657, align 1
  %spec.select = select i1 %.not, i1 %.0153.lcssa, i1 false
  %982 = getelementptr inbounds i8, ptr %result.i.i778.h2s1657, i64 18
  store i8 0, ptr %982, align 1
  %puts.i299 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i778.h2s1657) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %. = select i1 %spec.select, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.194 = select i1 %spec.select, ptr %35, ptr %39
  %.195 = select i1 %spec.select, ptr %36, ptr %40
  %.196 = select i1 %spec.select, ptr %37, ptr %41
  %.197 = select i1 %spec.select, ptr %38, ptr %42
  store ptr @_parameterization_Bufferi8, ptr %.194, align 8
  %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select, ptr %35, ptr %39
  %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select, ptr %35, ptr %39
  %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %983 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.194)
  store ptr @buffer_typ, ptr %.195, align 8
  %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select, ptr %36, ptr %40
  %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select, ptr %36, ptr %40
  %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.195) #40
  store ptr @_parameterization_String, ptr %.196, align 8
  %985 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.196)
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %.197, align 8
  %987 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.197) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %988 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %989 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <4 x i8> %., ptr %result.i.i798.h2s1656, align 4
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %991 = getelementptr inbounds i8, ptr %result.i.i798.h2s1656, i64 4
  store i8 0, ptr %991, align 4
  %puts.i320 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i798.h2s1656) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr #18 {
  %2 = alloca {}, align 8
  %result.i.i1706.h2s3398 = alloca [5 x i8], align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(5) %result.i.i1706.h2s3398, i8 0, i64 5, i1 false)
  %result.i.i1686.h2s3399 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i.i1686.h2s3399, i8 0, i64 19, i1 false)
  %result.i.i364.i.h2s3401 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i364.i.h2s3401, align 4
  %result.i.i344.i.h2s3403 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i344.i.h2s3403, i8 0, i64 16, i1 false)
  %result.i.i324.i.h2s3405 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i324.i.h2s3405, align 4
  %result.i.i304.i.h2s3407 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i304.i.h2s3407, i8 0, i64 15, i1 false)
  %result.i.i.i.h2s3409 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i.i.h2s3409, i8 0, i64 15, i1 false)
  %result.i.i1666.h2s3411 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i1666.h2s3411, i8 0, i64 15, i1 false)
  %result.i.i1626.h2s3413 = alloca [34 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(34) %result.i.i1626.h2s3413, i8 0, i64 34, i1 false)
  %result.i.i1611.h2s3415 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i.i1611.h2s3415, i8 0, i64 30, i1 false)
  %result.i59.h2s3417 = alloca [24 x i8], align 8
  %3 = getelementptr inbounds i8, ptr %result.i59.h2s3417, i64 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %3, i8 0, i64 16, i1 false)
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca { ptr }, align 8
  %20 = alloca [1 x ptr], align 8
  %21 = alloca { ptr }, align 8
  %22 = alloca [1 x ptr], align 8
  %23 = alloca { ptr }, align 8
  %24 = alloca [1 x ptr], align 8
  %25 = alloca { ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca { ptr }, align 8
  %28 = alloca [1 x ptr], align 8
  %29 = alloca { ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca { ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca { ptr }, align 8
  %36 = alloca [1 x ptr], align 8
  %37 = alloca { ptr }, align 8
  %38 = alloca [1 x ptr], align 8
  %39 = alloca { ptr }, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca { ptr }, align 8
  %42 = alloca [1 x ptr], align 8
  %43 = alloca { ptr }, align 8
  %44 = alloca [1 x ptr], align 8
  %45 = alloca { ptr }, align 8
  %46 = alloca [1 x ptr], align 8
  %47 = alloca { ptr }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca [1 x ptr], align 8
  %53 = alloca { ptr }, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca [1 x ptr], align 8
  %59 = alloca { ptr }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [1 x ptr], align 8
  %63 = alloca { ptr }, align 8
  %64 = alloca [1 x ptr], align 8
  %65 = alloca { ptr }, align 8
  %66 = alloca [1 x ptr], align 8
  %67 = alloca { ptr }, align 8
  %oldProtect.i69 = alloca i32, align 4
  %oldProtect.i67 = alloca i32, align 4
  %oldProtect.i65 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %68 = alloca [2 x ptr], align 8
  %69 = alloca [2 x ptr], align 8
  %.sroa.0237.sroa.0 = alloca i8, align 8
  %70 = alloca [3 x ptr], align 8
  %71 = alloca { ptr, ptr, ptr }, align 8
  %72 = alloca [1 x ptr], align 8
  %73 = alloca { ptr }, align 8
  %74 = alloca [3 x ptr], align 8
  %75 = alloca { ptr, ptr, ptr }, align 8
  %76 = alloca [1 x ptr], align 8
  %77 = alloca { ptr }, align 8
  %result.i63 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i63, align 8
  %78 = getelementptr inbounds i8, ptr %result.i63, i64 8
  store ptr @_parameterization_i32, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i63, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %79, align 8
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i63) #40
  %result.i62 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  %result.i64 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i62, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i62, ptr noalias nofree noundef nonnull readnone @oxgghllhom, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i43 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i62) #47
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i62) #40
  %result.i61 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i65) #40
  %result.i66 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i61, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i65) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i65) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i61, ptr noalias nofree noundef nonnull readnone @vaxeopwwdi, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i42 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i61) #47
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i61) #40
  %83 = getelementptr inbounds i8, ptr %result.i63, i64 48
  store ptr %ret.i43, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i63, i64 56
  store ptr %ret.i42, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %result.i63, i64 40
  store i32 8, ptr %85, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %86 = getelementptr inbounds i8, ptr %result.i63, i64 24
  store ptr %result.i1.i, ptr %86, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %87 = getelementptr inbounds i8, ptr %result.i63, i64 32
  store ptr %result.i.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i63, i64 44
  store i32 0, ptr %88, align 4
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  store ptr @_parameterization_i32, ptr %result.i59.h2s3417, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i59.h2s3417) #40
  %91 = getelementptr inbounds i8, ptr %result.i59.h2s3417, i64 20
  store i32 %0, ptr %91, align 4
  %92 = sext i32 %0 to i64
  %93 = shl nsw i64 %92, 2
  %result.i2.i264 = call noalias ptr @bump_malloc_wrapper(i64 noundef %93) #48
  %94 = getelementptr inbounds i8, ptr %result.i59.h2s3417, i64 8
  store ptr %result.i2.i264, ptr %94, align 8
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #40
  %96 = getelementptr inbounds i8, ptr %result.i59.h2s3417, i64 16
  store i32 0, ptr %96, align 8
  %result.i58 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i58, align 8
  %97 = getelementptr inbounds i8, ptr %result.i58, i64 8
  store ptr @_parameterization_Bool, ptr %97, align 8
  %98 = getelementptr inbounds i8, ptr %result.i58, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i58) #40
  %result.i57 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i67) #40
  %result.i68 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i57, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i67) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i67) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i57, ptr noalias nofree noundef nonnull readnone @hkbtwjjhqj, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i41 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i57) #47
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i57) #40
  %result.i56 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i69) #40
  %result.i70 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i56, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i69) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i69) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i56, ptr noalias nofree noundef nonnull readnone @cfjkgytwfj, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i56) #47
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i56) #40
  %102 = getelementptr inbounds i8, ptr %result.i58, i64 48
  store ptr %ret.i41, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %result.i58, i64 56
  store ptr %ret.i, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %result.i58, i64 40
  store i32 8, ptr %104, align 8
  %result.i1.i278 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %105 = getelementptr inbounds i8, ptr %result.i58, i64 24
  store ptr %result.i1.i278, ptr %105, align 8
  %result.i.i279 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %106 = getelementptr inbounds i8, ptr %result.i58, i64 32
  store ptr %result.i.i279, ptr %106, align 8
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %108 = getelementptr inbounds i8, ptr %result.i58, i64 44
  store i32 0, ptr %108, align 4
  %109 = mul i32 %0, 10
  %110 = getelementptr inbounds i8, ptr %68, i64 8
  %111 = getelementptr inbounds i8, ptr %69, i64 8
  %.promoted = load ptr, ptr %110, align 8
  %.promoted197 = load ptr, ptr %111, align 8
  %112 = icmp sgt i32 %0, 0
  %113 = icmp sgt i32 %109, 0
  %spec.select202 = and i1 %112, %113
  br i1 %spec.select202, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %116 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i58, 1
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr undef, 2
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, i32 10, 3
  %119 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i63, 1
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr undef, 2
  %121 = insertvalue { ptr, ptr, ptr, i32 } %120, i32 10, 3
  %122 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 10, 3
  %123 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 10, 3
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  br label %125

125:                                              ; preds = %._crit_edge1, %.lr.ph
  %result.i60.h2s3418.sroa.0.0 = phi i32 [ 456, %.lr.ph ], [ %128, %._crit_edge1 ]
  %.0277208 = phi i32 [ 0, %.lr.ph ], [ %1792, %._crit_edge1 ]
  %.0279207 = phi i32 [ 0, %.lr.ph ], [ %.1280, %._crit_edge1 ]
  %.0288206 = phi i64 [ 0, %.lr.ph ], [ %.1289, %._crit_edge1 ]
  %_parameterization_i32196205 = phi ptr [ %.promoted, %.lr.ph ], [ %_parameterization_i32, %._crit_edge1 ]
  %_parameterization_i32199204 = phi ptr [ %.promoted197, %.lr.ph ], [ %_parameterization_i32198, %._crit_edge1 ]
  %126 = mul i32 %result.i60.h2s3418.sroa.0.0, 1103515245
  %127 = add i32 %126, 12345
  %128 = and i32 %127, 2147483647
  %.sroa.0265.0.insert.ext = zext nneg i32 %128 to i160
  %129 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0265.0.insert.ext, 1
  %130 = load ptr, ptr %102, align 8
  %131 = call i32 %130({ ptr, i160 } %129) #53
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %133 = load i32, ptr %104, align 8
  %134 = add i32 %133, -1
  %135 = and i32 %134, %131
  %136 = load ptr, ptr %105, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %137 = sext i32 %135 to i64
  %138 = shl nsw i64 %137, 5
  %139 = getelementptr i8, ptr %136, i64 %138
  %140 = load ptr, ptr %139, align 8
  %141 = icmp ne ptr %140, @nil_typ
  %142 = icmp ne ptr %140, null
  %.not45.i = and i1 %141, %142
  br i1 %.not45.i, label %143, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

143:                                              ; preds = %125
  %144 = getelementptr i8, ptr %139, i64 8
  %145 = load i64, ptr %144, align 4
  %.sroa_idx.i = getelementptr i8, ptr %139, i64 16
  %146 = load i64, ptr %.sroa_idx.i, align 4
  %147 = inttoptr i64 %145 to ptr
  %148 = inttoptr i64 %146 to ptr
  %hash_coef_ptr.i.i4.i = getelementptr i8, ptr %140, i64 8
  %tbl_size_ptr.i.i5.i = getelementptr i8, ptr %140, i64 16
  %offset_tbl_ptr.i.i6.i = getelementptr i8, ptr %140, i64 40
  %hash_coef.i.i7.i = load i64, ptr %hash_coef_ptr.i.i4.i, align 4, !noalias !161
  %tbl_size.i.i8.i = load i64, ptr %tbl_size_ptr.i.i5.i, align 4, !noalias !161
  %offset_tbl.i.i9.i = load ptr, ptr %offset_tbl_ptr.i.i6.i, align 8, !noalias !161
  %product.i.i.i10.i = mul i64 %hash_coef.i.i7.i, 4015701072841558310
  %shifted.i.i.i11.i = lshr i64 %product.i.i.i10.i, 32
  %xored.i.i.i12.i = xor i64 %shifted.i.i.i11.i, %product.i.i.i10.i
  %hash.i.i.i13.i = and i64 %xored.i.i.i12.i, %tbl_size.i.i8.i
  %offset_ptr.i.i14.i = getelementptr i32, ptr %offset_tbl.i.i9.i, i64 %hash.i.i.i13.i
  %offset.i.i15.i = load i32, ptr %offset_ptr.i.i14.i, align 4, !noalias !161
  %149 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %140, 0
  %150 = insertvalue { ptr, ptr, ptr, i32 } %149, ptr %147, 1
  %151 = insertvalue { ptr, ptr, ptr, i32 } %150, ptr %148, 2
  %152 = insertvalue { ptr, ptr, ptr, i32 } %151, i32 %offset.i.i15.i, 3
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %140) #40
  %155 = sext i32 %offset.i.i15.i to i64
  %156 = getelementptr ptr, ptr %140, i64 %155
  %157 = getelementptr i8, ptr %156, i64 64
  %158 = load ptr, ptr %157, align 8
  %result.i2.i714 = call ptr %158({ ptr, ptr, ptr, i32 } %152, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %159 = call i32 %result.i2.i714({ ptr, ptr, ptr, i32 } %152, { ptr, ptr, ptr, i32 } %152, ptr nonnull align 8 %2) #53
  %160 = icmp eq i32 %159, %131
  br i1 %160, label %._crit_edge.i715, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i715:                                 ; preds = %143
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %140)
  %163 = getelementptr i8, ptr %156, i64 48
  %164 = load ptr, ptr %163, align 8
  %result.i1.i716 = call ptr %164({ ptr, ptr, ptr, i32 } %152, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %165 = call { ptr, i160 } %result.i1.i716({ ptr, ptr, ptr, i32 } %152, { ptr, ptr, ptr, i32 } %152, ptr nonnull align 8 %2) #53
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %167 = load ptr, ptr %103, align 8
  %168 = call i1 %167({ ptr, i160 } %165, { ptr, i160 } %129) #53
  br i1 %168, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i715, %143, %125
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %177

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i715
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %140)
  %171 = getelementptr i8, ptr %156, i64 56
  %172 = load ptr, ptr %171, align 8
  %result.i.i717 = call ptr %172({ ptr, ptr, ptr, i32 } %152, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %173 = call { ptr, i160 } %result.i.i717({ ptr, ptr, ptr, i32 } %152, { ptr, ptr, ptr, i32 } %152, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i = extractvalue { ptr, i160 } %173, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %175 = icmp ne ptr %.fca.0.extract22.i, @nil_typ
  %176 = icmp ne ptr %.fca.0.extract22.i, null
  %.not63.i = and i1 %175, %176
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %177

177:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %178 = add i32 %131, 2127912214
  %179 = shl i32 %131, 12
  %180 = add i32 %178, %179
  %181 = ashr i32 %180, 19
  %182 = xor i32 %180, %181
  %183 = xor i32 %182, -949894596
  %184 = add i32 %183, 374761393
  %185 = shl i32 %183, 5
  %186 = add i32 %184, %185
  %187 = add i32 %186, -744332180
  %188 = shl i32 %186, 9
  %189 = xor i32 %187, %188
  %190 = add i32 %189, -42973499
  %191 = shl i32 %189, 3
  %192 = add i32 %190, %191
  %193 = ashr i32 %192, 16
  %194 = xor i32 %192, %193
  %195 = xor i32 %194, -1252372727
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %197 = load i32, ptr %104, align 8
  %198 = add i32 %197, -1
  %199 = and i32 %198, %195
  %200 = load ptr, ptr %106, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %201 = sext i32 %199 to i64
  %202 = shl nsw i64 %201, 5
  %203 = getelementptr i8, ptr %200, i64 %202
  %204 = load ptr, ptr %203, align 8
  %205 = icmp ne ptr %204, @nil_typ
  %206 = icmp ne ptr %204, null
  %.not45.i746 = and i1 %205, %206
  br i1 %.not45.i746, label %207, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit771

207:                                              ; preds = %177
  %208 = getelementptr i8, ptr %203, i64 8
  %209 = load i64, ptr %208, align 4
  %.sroa_idx.i751 = getelementptr i8, ptr %203, i64 16
  %210 = load i64, ptr %.sroa_idx.i751, align 4
  %211 = inttoptr i64 %209 to ptr
  %212 = inttoptr i64 %210 to ptr
  %hash_coef_ptr.i.i4.i752 = getelementptr i8, ptr %204, i64 8
  %tbl_size_ptr.i.i5.i753 = getelementptr i8, ptr %204, i64 16
  %offset_tbl_ptr.i.i6.i754 = getelementptr i8, ptr %204, i64 40
  %hash_coef.i.i7.i755 = load i64, ptr %hash_coef_ptr.i.i4.i752, align 4, !noalias !164
  %tbl_size.i.i8.i756 = load i64, ptr %tbl_size_ptr.i.i5.i753, align 4, !noalias !164
  %offset_tbl.i.i9.i757 = load ptr, ptr %offset_tbl_ptr.i.i6.i754, align 8, !noalias !164
  %product.i.i.i10.i758 = mul i64 %hash_coef.i.i7.i755, 4015701072841558310
  %shifted.i.i.i11.i759 = lshr i64 %product.i.i.i10.i758, 32
  %xored.i.i.i12.i760 = xor i64 %shifted.i.i.i11.i759, %product.i.i.i10.i758
  %hash.i.i.i13.i761 = and i64 %xored.i.i.i12.i760, %tbl_size.i.i8.i756
  %offset_ptr.i.i14.i762 = getelementptr i32, ptr %offset_tbl.i.i9.i757, i64 %hash.i.i.i13.i761
  %offset.i.i15.i763 = load i32, ptr %offset_ptr.i.i14.i762, align 4, !noalias !164
  %213 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %204, 0
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr %211, 1
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %212, 2
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, i32 %offset.i.i15.i763, 3
  %217 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %204) #40
  %219 = sext i32 %offset.i.i15.i763 to i64
  %220 = getelementptr ptr, ptr %204, i64 %219
  %221 = getelementptr i8, ptr %220, i64 64
  %222 = load ptr, ptr %221, align 8
  %result.i2.i764 = call ptr %222({ ptr, ptr, ptr, i32 } %216, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %223 = call i32 %result.i2.i764({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull align 8 %2) #53
  %224 = icmp eq i32 %223, %131
  br i1 %224, label %._crit_edge.i765, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit771

._crit_edge.i765:                                 ; preds = %207
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %226 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %204)
  %227 = getelementptr i8, ptr %220, i64 48
  %228 = load ptr, ptr %227, align 8
  %result.i1.i766 = call ptr %228({ ptr, ptr, ptr, i32 } %216, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %229 = call { ptr, i160 } %result.i1.i766({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull align 8 %2) #53
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %231 = load ptr, ptr %103, align 8
  %232 = call i1 %231({ ptr, i160 } %229, { ptr, i160 } %129) #53
  br i1 %232, label %233, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit771

233:                                              ; preds = %._crit_edge.i765
  %234 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %235 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %204)
  %236 = getelementptr i8, ptr %220, i64 56
  %237 = load ptr, ptr %236, align 8
  %result.i.i768 = call ptr %237({ ptr, ptr, ptr, i32 } %216, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %238 = call { ptr, i160 } %result.i.i768({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i769 = extractvalue { ptr, i160 } %238, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit771

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit771: ; preds = %233, %._crit_edge.i765, %207, %177
  %.reg2mem41.0.i748 = phi ptr [ %.fca.0.extract22.i769, %233 ], [ @nil_typ, %._crit_edge.i765 ], [ @nil_typ, %177 ], [ @nil_typ, %207 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %239 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i = icmp eq ptr %.reg2mem41.0.i748, null
  %240 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem41.0.i748
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit771, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.reg2mem56.0.i = phi ptr [ %240, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit771 ], [ %.fca.0.extract22.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %241 = icmp eq ptr %.reg2mem56.0.i, @nil_typ
  %242 = icmp eq ptr %.reg2mem56.0.i, null
  %243 = or i1 %241, %242
  br i1 %243, label %244, label %._crit_edge1

244:                                              ; preds = %CuckooMap_get_keyK.exit
  %245 = add nuw i32 %128, 1
  %.sroa.0247.0.insert.ext = zext i32 %245 to i160
  %246 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0247.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %68, align 8
  %247 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %68)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %248 = load ptr, ptr %83, align 8
  %249 = call i32 %248({ ptr, i160 } %129) #53
  %250 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %251 = load i32, ptr %85, align 8
  %252 = add i32 %251, -1
  %253 = and i32 %252, %249
  %254 = load ptr, ptr %86, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %255 = sext i32 %253 to i64
  %256 = shl nsw i64 %255, 5
  %257 = getelementptr i8, ptr %254, i64 %256
  %258 = load ptr, ptr %257, align 8
  %259 = getelementptr i8, ptr %257, i64 8
  %260 = icmp ne ptr %258, @nil_typ
  %261 = icmp ne ptr %258, null
  %.not66.i = and i1 %260, %261
  br i1 %.not66.i, label %262, label %360

262:                                              ; preds = %244
  %263 = load i64, ptr %259, align 4
  %.sroa_idx.i812 = getelementptr i8, ptr %257, i64 16
  %264 = load i64, ptr %.sroa_idx.i812, align 4
  %265 = inttoptr i64 %263 to ptr
  %266 = inttoptr i64 %264 to ptr
  %hash_coef_ptr.i.i11.i = getelementptr i8, ptr %258, i64 8
  %tbl_size_ptr.i.i12.i = getelementptr i8, ptr %258, i64 16
  %offset_tbl_ptr.i.i13.i = getelementptr i8, ptr %258, i64 40
  %hash_coef.i.i14.i = load i64, ptr %hash_coef_ptr.i.i11.i, align 4, !noalias !167
  %tbl_size.i.i15.i = load i64, ptr %tbl_size_ptr.i.i12.i, align 4, !noalias !167
  %offset_tbl.i.i16.i = load ptr, ptr %offset_tbl_ptr.i.i13.i, align 8, !noalias !167
  %product.i.i.i17.i = mul i64 %hash_coef.i.i14.i, 4015701072841558310
  %shifted.i.i.i18.i = lshr i64 %product.i.i.i17.i, 32
  %xored.i.i.i19.i = xor i64 %shifted.i.i.i18.i, %product.i.i.i17.i
  %hash.i.i.i20.i = and i64 %xored.i.i.i19.i, %tbl_size.i.i15.i
  %offset_ptr.i.i21.i = getelementptr i32, ptr %offset_tbl.i.i16.i, i64 %hash.i.i.i20.i
  %offset.i.i22.i = load i32, ptr %offset_ptr.i.i21.i, align 4, !noalias !167
  %267 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %258, 0
  %268 = insertvalue { ptr, ptr, ptr, i32 } %267, ptr %265, 1
  %269 = insertvalue { ptr, ptr, ptr, i32 } %268, ptr %266, 2
  %270 = insertvalue { ptr, ptr, ptr, i32 } %269, i32 %offset.i.i22.i, 3
  %271 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %272 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %258) #40
  %273 = sext i32 %offset.i.i22.i to i64
  %274 = getelementptr ptr, ptr %258, i64 %273
  %275 = getelementptr i8, ptr %274, i64 64
  %276 = load ptr, ptr %275, align 8
  %result.i8.i813 = call ptr %276({ ptr, ptr, ptr, i32 } %270, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %277 = call i32 %result.i8.i813({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } %270, ptr nonnull align 8 %2) #53
  %278 = icmp eq i32 %277, %249
  br i1 %278, label %._crit_edge.i814, label %360

._crit_edge.i814:                                 ; preds = %262
  %279 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %258)
  %281 = getelementptr i8, ptr %274, i64 48
  %282 = load ptr, ptr %281, align 8
  %result.i7.i = call ptr %282({ ptr, ptr, ptr, i32 } %270, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %283 = call { ptr, i160 } %result.i7.i({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } %270, ptr nonnull align 8 %2) #53
  %284 = load ptr, ptr %84, align 8
  %285 = call i1 %284({ ptr, i160 } %283, { ptr, i160 } %129) #53
  br i1 %285, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %360

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i814
  %286 = load ptr, ptr %result.i63, align 8
  %287 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %288 = load ptr, ptr %78, align 8
  %289 = load ptr, ptr %286, align 8, !alias.scope !170
  %290 = getelementptr i8, ptr %289, i64 72
  %291 = load ptr, ptr %290, align 8, !alias.scope !170
  %result.i1.i.i = call { i64, i64 } %291(ptr nocapture nofree nonnull readonly align 8 %286) #44, !alias.scope !170
  %292 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %293 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %294 = urem i64 20, %293
  %295 = icmp eq i64 %294, 0
  %296 = sub i64 %293, %294
  %297 = select i1 %295, i64 0, i64 %296
  %298 = add i64 %292, 20
  %299 = add i64 %298, %297
  %300 = load ptr, ptr %288, align 8, !alias.scope !170
  %301 = getelementptr i8, ptr %300, i64 72
  %302 = load ptr, ptr %301, align 8, !alias.scope !170
  %result.i.i.i815 = call { i64, i64 } %302(ptr nocapture nofree nonnull readonly align 8 %288) #44, !alias.scope !170
  %303 = extractvalue { i64, i64 } %result.i.i.i815, 0
  %304 = extractvalue { i64, i64 } %result.i.i.i815, 1
  %305 = call i64 @llvm.umax.i64(i64 %293, i64 %304) #41
  %306 = call i64 @llvm.umax.i64(i64 %305, i64 noundef 8) #41, !range !16
  %307 = urem i64 %299, %304
  %308 = icmp eq i64 %307, 0
  %309 = sub i64 %304, %307
  %310 = select i1 %308, i64 0, i64 %309
  %311 = add i64 %303, %299
  %312 = add i64 %311, %310
  %313 = urem i64 %312, %306
  %314 = icmp eq i64 %313, 0
  %315 = sub i64 %306, %313
  %316 = select i1 %314, i64 0, i64 %315
  %317 = add i64 %316, %312
  %result.i9.i816 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %317) #48
  store ptr %286, ptr %result.i9.i816, align 8
  %318 = getelementptr inbounds i8, ptr %result.i9.i816, i64 8
  store ptr %288, ptr %318, align 8
  %319 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i816)
  %320 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %321 = load ptr, ptr %286, align 8
  %322 = getelementptr i8, ptr %321, i64 72
  %323 = load ptr, ptr %322, align 8
  %result.i.i38.i = call { i64, i64 } %323(ptr nocapture nofree nonnull readonly align 8 %286) #44
  %324 = extractvalue { i64, i64 } %result.i.i38.i, 1
  %325 = urem i64 20, %324
  %326 = icmp eq i64 %325, 0
  %reass.sub3450 = sub i64 %324, %325
  %327 = add i64 %reass.sub3450, 20
  %328 = select i1 %326, i64 20, i64 %327
  %329 = getelementptr i8, ptr %result.i9.i816, i64 %328
  %330 = getelementptr i8, ptr %321, i64 64
  %331 = load ptr, ptr %330, align 8
  call void %331({ ptr, i160 } %129, ptr nocapture nofree nonnull readonly align 8 %286, ptr nocapture nofree writeonly %329) #45
  %332 = load ptr, ptr %result.i9.i816, align 8
  %333 = load ptr, ptr %332, align 8
  %334 = getelementptr i8, ptr %333, i64 72
  %335 = load ptr, ptr %334, align 8
  %result.i1.i39.i = call { i64, i64 } %335(ptr nocapture nofree nonnull readonly align 8 %332) #44
  %336 = extractvalue { i64, i64 } %result.i1.i39.i, 0
  %337 = extractvalue { i64, i64 } %result.i1.i39.i, 1
  %338 = urem i64 20, %337
  %339 = icmp eq i64 %338, 0
  %340 = sub i64 %337, %338
  %341 = select i1 %339, i64 0, i64 %340
  %342 = add i64 %336, 20
  %343 = add i64 %342, %341
  %344 = load ptr, ptr %318, align 8
  %345 = load ptr, ptr %344, align 8
  %346 = getelementptr i8, ptr %345, i64 72
  %347 = load ptr, ptr %346, align 8
  %result.i.i40.i = call { i64, i64 } %347(ptr nocapture nofree nonnull readonly align 8 %344) #44
  %348 = extractvalue { i64, i64 } %result.i.i40.i, 1
  %349 = urem i64 %343, %348
  %350 = icmp eq i64 %349, 0
  %351 = sub i64 %348, %349
  %352 = select i1 %350, i64 0, i64 %351
  %353 = getelementptr i8, ptr %result.i9.i816, i64 %343
  %354 = getelementptr i8, ptr %353, i64 %352
  %355 = getelementptr i8, ptr %345, i64 64
  %356 = load ptr, ptr %355, align 8
  call void %356({ ptr, i160 } %246, ptr nocapture nofree nonnull readonly align 8 %344, ptr nocapture nofree writeonly %354) #45
  %357 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %358 = getelementptr inbounds i8, ptr %result.i9.i816, i64 16
  store i32 %249, ptr %358, align 8
  store ptr @Entry, ptr %257, align 8
  %359 = ptrtoint ptr %result.i9.i816 to i64
  store i64 %359, ptr %259, align 4
  %.sroa_idx30.i = getelementptr i8, ptr %257, i64 24
  store i32 10, ptr %.sroa_idx30.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

360:                                              ; preds = %._crit_edge.i814, %262, %244
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %361 = add i32 %249, 2127912214
  %362 = shl i32 %249, 12
  %363 = add i32 %361, %362
  %364 = ashr i32 %363, 19
  %365 = xor i32 %363, %364
  %366 = xor i32 %365, -949894596
  %367 = add i32 %366, 374761393
  %368 = shl i32 %366, 5
  %369 = add i32 %367, %368
  %370 = add i32 %369, -744332180
  %371 = shl i32 %369, 9
  %372 = xor i32 %370, %371
  %373 = add i32 %372, -42973499
  %374 = shl i32 %372, 3
  %375 = add i32 %373, %374
  %376 = ashr i32 %375, 16
  %377 = xor i32 %375, %376
  %378 = xor i32 %377, -1252372727
  %379 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %380 = load i32, ptr %85, align 8
  %381 = add i32 %380, -1
  %382 = and i32 %381, %378
  %383 = load ptr, ptr %87, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %384 = sext i32 %382 to i64
  %385 = shl nsw i64 %384, 5
  %386 = getelementptr i8, ptr %383, i64 %385
  %387 = load ptr, ptr %386, align 8
  %388 = getelementptr i8, ptr %386, i64 8
  %389 = icmp ne ptr %387, @nil_typ
  %390 = icmp ne ptr %387, null
  %.not66.i846 = and i1 %389, %390
  br i1 %.not66.i846, label %391, label %489

391:                                              ; preds = %360
  %392 = load i64, ptr %388, align 4
  %.sroa_idx.i848 = getelementptr i8, ptr %386, i64 16
  %393 = load i64, ptr %.sroa_idx.i848, align 4
  %394 = inttoptr i64 %392 to ptr
  %395 = inttoptr i64 %393 to ptr
  %hash_coef_ptr.i.i11.i849 = getelementptr i8, ptr %387, i64 8
  %tbl_size_ptr.i.i12.i850 = getelementptr i8, ptr %387, i64 16
  %offset_tbl_ptr.i.i13.i851 = getelementptr i8, ptr %387, i64 40
  %hash_coef.i.i14.i852 = load i64, ptr %hash_coef_ptr.i.i11.i849, align 4, !noalias !173
  %tbl_size.i.i15.i853 = load i64, ptr %tbl_size_ptr.i.i12.i850, align 4, !noalias !173
  %offset_tbl.i.i16.i854 = load ptr, ptr %offset_tbl_ptr.i.i13.i851, align 8, !noalias !173
  %product.i.i.i17.i855 = mul i64 %hash_coef.i.i14.i852, 4015701072841558310
  %shifted.i.i.i18.i856 = lshr i64 %product.i.i.i17.i855, 32
  %xored.i.i.i19.i857 = xor i64 %shifted.i.i.i18.i856, %product.i.i.i17.i855
  %hash.i.i.i20.i858 = and i64 %xored.i.i.i19.i857, %tbl_size.i.i15.i853
  %offset_ptr.i.i21.i859 = getelementptr i32, ptr %offset_tbl.i.i16.i854, i64 %hash.i.i.i20.i858
  %offset.i.i22.i860 = load i32, ptr %offset_ptr.i.i21.i859, align 4, !noalias !173
  %396 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %387, 0
  %397 = insertvalue { ptr, ptr, ptr, i32 } %396, ptr %394, 1
  %398 = insertvalue { ptr, ptr, ptr, i32 } %397, ptr %395, 2
  %399 = insertvalue { ptr, ptr, ptr, i32 } %398, i32 %offset.i.i22.i860, 3
  %400 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %387) #40
  %402 = sext i32 %offset.i.i22.i860 to i64
  %403 = getelementptr ptr, ptr %387, i64 %402
  %404 = getelementptr i8, ptr %403, i64 64
  %405 = load ptr, ptr %404, align 8
  %result.i8.i861 = call ptr %405({ ptr, ptr, ptr, i32 } %399, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %406 = call i32 %result.i8.i861({ ptr, ptr, ptr, i32 } %399, { ptr, ptr, ptr, i32 } %399, ptr nonnull align 8 %2) #53
  %407 = icmp eq i32 %406, %249
  br i1 %407, label %._crit_edge.i862, label %489

._crit_edge.i862:                                 ; preds = %391
  %408 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %409 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %387)
  %410 = getelementptr i8, ptr %403, i64 48
  %411 = load ptr, ptr %410, align 8
  %result.i7.i863 = call ptr %411({ ptr, ptr, ptr, i32 } %399, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %412 = call { ptr, i160 } %result.i7.i863({ ptr, ptr, ptr, i32 } %399, { ptr, ptr, ptr, i32 } %399, ptr nonnull align 8 %2) #53
  %413 = load ptr, ptr %84, align 8
  %414 = call i1 %413({ ptr, i160 } %412, { ptr, i160 } %129) #53
  br i1 %414, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit875, label %489

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit875: ; preds = %._crit_edge.i862
  %415 = load ptr, ptr %result.i63, align 8
  %416 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %417 = load ptr, ptr %78, align 8
  %418 = load ptr, ptr %415, align 8, !alias.scope !176
  %419 = getelementptr i8, ptr %418, i64 72
  %420 = load ptr, ptr %419, align 8, !alias.scope !176
  %result.i1.i.i867 = call { i64, i64 } %420(ptr nocapture nofree nonnull readonly align 8 %415) #44, !alias.scope !176
  %421 = extractvalue { i64, i64 } %result.i1.i.i867, 0
  %422 = extractvalue { i64, i64 } %result.i1.i.i867, 1
  %423 = urem i64 20, %422
  %424 = icmp eq i64 %423, 0
  %425 = sub i64 %422, %423
  %426 = select i1 %424, i64 0, i64 %425
  %427 = add i64 %421, 20
  %428 = add i64 %427, %426
  %429 = load ptr, ptr %417, align 8, !alias.scope !176
  %430 = getelementptr i8, ptr %429, i64 72
  %431 = load ptr, ptr %430, align 8, !alias.scope !176
  %result.i.i.i868 = call { i64, i64 } %431(ptr nocapture nofree nonnull readonly align 8 %417) #44, !alias.scope !176
  %432 = extractvalue { i64, i64 } %result.i.i.i868, 0
  %433 = extractvalue { i64, i64 } %result.i.i.i868, 1
  %434 = call i64 @llvm.umax.i64(i64 %422, i64 %433) #41
  %435 = call i64 @llvm.umax.i64(i64 %434, i64 noundef 8) #41, !range !16
  %436 = urem i64 %428, %433
  %437 = icmp eq i64 %436, 0
  %438 = sub i64 %433, %436
  %439 = select i1 %437, i64 0, i64 %438
  %440 = add i64 %432, %428
  %441 = add i64 %440, %439
  %442 = urem i64 %441, %435
  %443 = icmp eq i64 %442, 0
  %444 = sub i64 %435, %442
  %445 = select i1 %443, i64 0, i64 %444
  %446 = add i64 %445, %441
  %result.i9.i869 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %446) #48
  store ptr %415, ptr %result.i9.i869, align 8
  %447 = getelementptr inbounds i8, ptr %result.i9.i869, i64 8
  store ptr %417, ptr %447, align 8
  %448 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i869)
  %449 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %450 = load ptr, ptr %415, align 8
  %451 = getelementptr i8, ptr %450, i64 72
  %452 = load ptr, ptr %451, align 8
  %result.i.i38.i870 = call { i64, i64 } %452(ptr nocapture nofree nonnull readonly align 8 %415) #44
  %453 = extractvalue { i64, i64 } %result.i.i38.i870, 1
  %454 = urem i64 20, %453
  %455 = icmp eq i64 %454, 0
  %reass.sub3449 = sub i64 %453, %454
  %456 = add i64 %reass.sub3449, 20
  %457 = select i1 %455, i64 20, i64 %456
  %458 = getelementptr i8, ptr %result.i9.i869, i64 %457
  %459 = getelementptr i8, ptr %450, i64 64
  %460 = load ptr, ptr %459, align 8
  call void %460({ ptr, i160 } %129, ptr nocapture nofree nonnull readonly align 8 %415, ptr nocapture nofree writeonly %458) #45
  %461 = load ptr, ptr %result.i9.i869, align 8
  %462 = load ptr, ptr %461, align 8
  %463 = getelementptr i8, ptr %462, i64 72
  %464 = load ptr, ptr %463, align 8
  %result.i1.i39.i872 = call { i64, i64 } %464(ptr nocapture nofree nonnull readonly align 8 %461) #44
  %465 = extractvalue { i64, i64 } %result.i1.i39.i872, 0
  %466 = extractvalue { i64, i64 } %result.i1.i39.i872, 1
  %467 = urem i64 20, %466
  %468 = icmp eq i64 %467, 0
  %469 = sub i64 %466, %467
  %470 = select i1 %468, i64 0, i64 %469
  %471 = add i64 %465, 20
  %472 = add i64 %471, %470
  %473 = load ptr, ptr %447, align 8
  %474 = load ptr, ptr %473, align 8
  %475 = getelementptr i8, ptr %474, i64 72
  %476 = load ptr, ptr %475, align 8
  %result.i.i40.i873 = call { i64, i64 } %476(ptr nocapture nofree nonnull readonly align 8 %473) #44
  %477 = extractvalue { i64, i64 } %result.i.i40.i873, 1
  %478 = urem i64 %472, %477
  %479 = icmp eq i64 %478, 0
  %480 = sub i64 %477, %478
  %481 = select i1 %479, i64 0, i64 %480
  %482 = getelementptr i8, ptr %result.i9.i869, i64 %472
  %483 = getelementptr i8, ptr %482, i64 %481
  %484 = getelementptr i8, ptr %474, i64 64
  %485 = load ptr, ptr %484, align 8
  call void %485({ ptr, i160 } %246, ptr nocapture nofree nonnull readonly align 8 %473, ptr nocapture nofree writeonly %483) #45
  %486 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %487 = getelementptr inbounds i8, ptr %result.i9.i869, i64 16
  store i32 %249, ptr %487, align 8
  store ptr @Entry, ptr %386, align 8
  %488 = ptrtoint ptr %result.i9.i869 to i64
  store i64 %488, ptr %388, align 4
  %.sroa_idx30.i874 = getelementptr i8, ptr %386, i64 24
  store i32 10, ptr %.sroa_idx30.i874, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

489:                                              ; preds = %._crit_edge.i862, %391, %360
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %490 = load i32, ptr %88, align 4
  %491 = load i32, ptr %85, align 8
  %.not.i331 = icmp slt i32 %490, %491
  br i1 %.not.i331, label %._crit_edge.i, label %492

492:                                              ; preds = %489
  %493 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %494 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %495 = load ptr, ptr %86, align 8
  %496 = load ptr, ptr %87, align 8
  %497 = shl i32 %491, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %497, i32 noundef 16) #40
  store i32 %spec.select.i, ptr %85, align 8
  %498 = zext nneg i32 %spec.select.i to i64
  %499 = shl nuw nsw i64 %498, 5
  %result.i5.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %499) #48
  store ptr %result.i5.i, ptr %86, align 8
  %result.i4.i890 = call noalias ptr @bump_malloc_wrapper(i64 noundef %499) #48
  store ptr %result.i4.i890, ptr %87, align 8
  store i32 0, ptr %88, align 4
  %500 = icmp sgt i32 %491, 0
  br i1 %500, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %492
  %wide.trip.count.i = zext nneg i32 %491 to i64
  br label %501

501:                                              ; preds = %._crit_edge.i1789, %.lr.ph.i
  %indvars.iv.i1788 = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i1790, %._crit_edge.i1789 ]
  %502 = shl nuw nsw i64 %indvars.iv.i1788, 5
  %503 = getelementptr i8, ptr %495, i64 %502
  %504 = load ptr, ptr %503, align 8
  %505 = icmp ne ptr %504, @nil_typ
  %506 = icmp ne ptr %504, null
  %.not17.i = and i1 %505, %506
  br i1 %.not17.i, label %507, label %._crit_edge.i1789

507:                                              ; preds = %501
  %508 = getelementptr i8, ptr %503, i64 8
  %509 = load i64, ptr %508, align 4
  %.sroa_idx.i1792 = getelementptr i8, ptr %503, i64 16
  %510 = load i64, ptr %.sroa_idx.i1792, align 4
  %hash_coef_ptr.i.i6.i = getelementptr i8, ptr %504, i64 8
  %tbl_size_ptr.i.i7.i = getelementptr i8, ptr %504, i64 16
  %offset_tbl_ptr.i.i8.i = getelementptr i8, ptr %504, i64 40
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i6.i, align 4, !noalias !179
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i7.i, align 4, !noalias !179
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i8.i, align 8, !noalias !179
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i29.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !179
  %512 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %513 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %515

515:                                              ; preds = %.cont.i2364, %507
  %.0290.i2346 = phi i32 [ 0, %507 ], [ %548, %.cont.i2364 ]
  %.074289.i2347 = phi i1 [ true, %507 ], [ %549, %.cont.i2364 ]
  %.sroa.0.0288.i2348 = phi ptr [ %504, %507 ], [ %538, %.cont.i2364 ]
  %.sroa.6.0287.i2349.in = phi i64 [ %509, %507 ], [ %540, %.cont.i2364 ]
  %.sroa.12.0286.i2350.in = phi i64 [ %510, %507 ], [ %541, %.cont.i2364 ]
  %.sroa.17.0285.i2351 = phi i32 [ %offset.i.i29.i, %507 ], [ %offset.i.i57.i2376, %.cont.i2364 ]
  %.sroa.12.0286.i2350 = inttoptr i64 %.sroa.12.0286.i2350.in to ptr
  %.sroa.6.0287.i2349 = inttoptr i64 %.sroa.6.0287.i2349.in to ptr
  %516 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2348, 0
  %517 = insertvalue { ptr, ptr, ptr, i32 } %516, ptr %.sroa.6.0287.i2349, 1
  %518 = insertvalue { ptr, ptr, ptr, i32 } %517, ptr %.sroa.12.0286.i2350, 2
  %519 = insertvalue { ptr, ptr, ptr, i32 } %518, i32 %.sroa.17.0285.i2351, 3
  %520 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2348)
  %521 = sext i32 %.sroa.17.0285.i2351 to i64
  %522 = getelementptr ptr, ptr %.sroa.0.0288.i2348, i64 %521
  %523 = getelementptr i8, ptr %522, i64 64
  %524 = load ptr, ptr %523, align 8
  %result.i15.i2352 = call ptr %524({ ptr, ptr, ptr, i32 } %519, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %525 = call i32 %result.i15.i2352({ ptr, ptr, ptr, i32 } %519, { ptr, ptr, ptr, i32 } %519, ptr nonnull align 8 %2) #53
  %..i2353 = select i1 %.074289.i2347, ptr %48, ptr %50
  %.188.i2354 = select i1 %.074289.i2347, i64 104, i64 112
  %.189.i2355 = select i1 %.074289.i2347, ptr %49, ptr %51
  %.190.i2356 = select i1 %.074289.i2347, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2353, align 8
  %526 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2353)
  %527 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2354
  %528 = load ptr, ptr %527, align 8
  store ptr @i32_typ, ptr %.189.i2355, align 8
  %result.i14.i2357 = call ptr %528({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2355) #46
  %529 = call i32 %result.i14.i2357({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i2353, i32 %525) #53
  %530 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %531 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2356
  %532 = load ptr, ptr %531, align 8
  %533 = load ptr, ptr %532, align 8
  %534 = call { ptr } %533(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i2358 = extractvalue { ptr } %534, 0
  %535 = sext i32 %529 to i64
  %536 = shl nsw i64 %535, 5
  %537 = getelementptr i8, ptr %.fca.0.extract55.i2358, i64 %536
  %538 = load ptr, ptr %537, align 8
  %539 = getelementptr i8, ptr %537, i64 8
  %540 = load i64, ptr %539, align 4
  %.sroa_idx.i2359 = getelementptr i8, ptr %537, i64 16
  %541 = load i64, ptr %.sroa_idx.i2359, align 4
  %542 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %543 = call { ptr } %533(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i2360 = extractvalue { ptr } %543, 0
  %544 = getelementptr i8, ptr %.fca.0.extract52.i2360, i64 %536
  store ptr %.sroa.0.0288.i2348, ptr %544, align 8
  %545 = getelementptr i8, ptr %544, i64 8
  store i64 %.sroa.6.0287.i2349.in, ptr %545, align 4
  %.sroa_idx104.i2361 = getelementptr i8, ptr %544, i64 16
  store i64 %.sroa.12.0286.i2350.in, ptr %.sroa_idx104.i2361, align 4
  %.sroa_idx105.i2362 = getelementptr i8, ptr %544, i64 24
  store i32 %.sroa.17.0285.i2351, ptr %.sroa_idx105.i2362, align 4
  %546 = icmp ne ptr %538, @nil_typ
  %547 = icmp ne ptr %538, null
  %.not94.i2363 = and i1 %546, %547
  br i1 %.not94.i2363, label %.cont.i2364, label %552

.cont.i2364:                                      ; preds = %515
  %548 = add nuw nsw i32 %.0290.i2346, 1
  %549 = xor i1 %.074289.i2347, true
  %hash_coef_ptr.i.i46.i2365 = getelementptr i8, ptr %538, i64 8
  %tbl_size_ptr.i.i47.i2366 = getelementptr i8, ptr %538, i64 16
  %offset_tbl_ptr.i.i48.i2367 = getelementptr i8, ptr %538, i64 40
  %hash_coef.i.i49.i2368 = load i64, ptr %hash_coef_ptr.i.i46.i2365, align 4
  %tbl_size.i.i50.i2369 = load i64, ptr %tbl_size_ptr.i.i47.i2366, align 4
  %offset_tbl.i.i51.i2370 = load ptr, ptr %offset_tbl_ptr.i.i48.i2367, align 8
  %product.i.i.i52.i2371 = mul i64 %hash_coef.i.i49.i2368, 4015701072841558310
  %shifted.i.i.i53.i2372 = lshr i64 %product.i.i.i52.i2371, 32
  %xored.i.i.i54.i2373 = xor i64 %shifted.i.i.i53.i2372, %product.i.i.i52.i2371
  %hash.i.i.i55.i2374 = and i64 %xored.i.i.i54.i2373, %tbl_size.i.i50.i2369
  %offset_ptr.i.i56.i2375 = getelementptr i32, ptr %offset_tbl.i.i51.i2370, i64 %hash.i.i.i55.i2374
  %offset.i.i57.i2376 = load i32, ptr %offset_ptr.i.i56.i2375, align 4
  %550 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %551 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2377 = icmp eq i32 %548, 100
  br i1 %exitcond.not.i2377, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2379, label %515

552:                                              ; preds = %515
  %553 = load i32, ptr %88, align 4
  %554 = add i32 %553, 1
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %554, ptr %88, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2379

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2379: ; preds = %552, %.cont.i2364
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  br label %._crit_edge.i1789

._crit_edge.i1789:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2379, %501
  %indvars.iv.next.i1790 = add nuw nsw i64 %indvars.iv.i1788, 1
  %exitcond.not.i1791 = icmp eq i64 %indvars.iv.next.i1790, %wide.trip.count.i
  br i1 %exitcond.not.i1791, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit, label %501

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit: ; preds = %._crit_edge.i1812, %._crit_edge.i1789
  %indvars.iv.i1810 = phi i64 [ %indvars.iv.next.i1813, %._crit_edge.i1812 ], [ 0, %._crit_edge.i1789 ]
  %556 = shl nuw nsw i64 %indvars.iv.i1810, 5
  %557 = getelementptr i8, ptr %496, i64 %556
  %558 = load ptr, ptr %557, align 8
  %559 = icmp ne ptr %558, @nil_typ
  %560 = icmp ne ptr %558, null
  %.not17.i1811 = and i1 %559, %560
  br i1 %.not17.i1811, label %561, label %._crit_edge.i1812

561:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %562 = getelementptr i8, ptr %557, i64 8
  %563 = load i64, ptr %562, align 4
  %.sroa_idx.i1815 = getelementptr i8, ptr %557, i64 16
  %564 = load i64, ptr %.sroa_idx.i1815, align 4
  %hash_coef_ptr.i.i6.i1816 = getelementptr i8, ptr %558, i64 8
  %tbl_size_ptr.i.i7.i1817 = getelementptr i8, ptr %558, i64 16
  %offset_tbl_ptr.i.i8.i1818 = getelementptr i8, ptr %558, i64 40
  %565 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  %hash_coef.i.i21.i2397 = load i64, ptr %hash_coef_ptr.i.i6.i1816, align 4, !noalias !182
  %tbl_size.i.i22.i2398 = load i64, ptr %tbl_size_ptr.i.i7.i1817, align 4, !noalias !182
  %offset_tbl.i.i23.i2399 = load ptr, ptr %offset_tbl_ptr.i.i8.i1818, align 8, !noalias !182
  %product.i.i.i24.i2400 = mul i64 %hash_coef.i.i21.i2397, 4015701072841558310
  %shifted.i.i.i25.i2401 = lshr i64 %product.i.i.i24.i2400, 32
  %xored.i.i.i26.i2402 = xor i64 %shifted.i.i.i25.i2401, %product.i.i.i24.i2400
  %hash.i.i.i27.i2403 = and i64 %xored.i.i.i26.i2402, %tbl_size.i.i22.i2398
  %offset_ptr.i.i28.i2404 = getelementptr i32, ptr %offset_tbl.i.i23.i2399, i64 %hash.i.i.i27.i2403
  %offset.i.i29.i2405 = load i32, ptr %offset_ptr.i.i28.i2404, align 4, !noalias !182
  %566 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %568 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %569

569:                                              ; preds = %.cont.i2428, %561
  %.0290.i2406 = phi i32 [ 0, %561 ], [ %602, %.cont.i2428 ]
  %.074289.i2407 = phi i1 [ true, %561 ], [ %603, %.cont.i2428 ]
  %.sroa.0.0288.i2408 = phi ptr [ %558, %561 ], [ %592, %.cont.i2428 ]
  %.sroa.6.0287.i2409.in = phi i64 [ %563, %561 ], [ %594, %.cont.i2428 ]
  %.sroa.12.0286.i2410.in = phi i64 [ %564, %561 ], [ %595, %.cont.i2428 ]
  %.sroa.17.0285.i2411 = phi i32 [ %offset.i.i29.i2405, %561 ], [ %offset.i.i57.i2440, %.cont.i2428 ]
  %.sroa.12.0286.i2410 = inttoptr i64 %.sroa.12.0286.i2410.in to ptr
  %.sroa.6.0287.i2409 = inttoptr i64 %.sroa.6.0287.i2409.in to ptr
  %570 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2408, 0
  %571 = insertvalue { ptr, ptr, ptr, i32 } %570, ptr %.sroa.6.0287.i2409, 1
  %572 = insertvalue { ptr, ptr, ptr, i32 } %571, ptr %.sroa.12.0286.i2410, 2
  %573 = insertvalue { ptr, ptr, ptr, i32 } %572, i32 %.sroa.17.0285.i2411, 3
  %574 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2408)
  %575 = sext i32 %.sroa.17.0285.i2411 to i64
  %576 = getelementptr ptr, ptr %.sroa.0.0288.i2408, i64 %575
  %577 = getelementptr i8, ptr %576, i64 64
  %578 = load ptr, ptr %577, align 8
  %result.i15.i2412 = call ptr %578({ ptr, ptr, ptr, i32 } %573, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %579 = call i32 %result.i15.i2412({ ptr, ptr, ptr, i32 } %573, { ptr, ptr, ptr, i32 } %573, ptr nonnull align 8 %2) #53
  %..i2413 = select i1 %.074289.i2407, ptr %44, ptr %46
  %.188.i2414 = select i1 %.074289.i2407, i64 104, i64 112
  %.189.i2415 = select i1 %.074289.i2407, ptr %45, ptr %47
  %.190.i2416 = select i1 %.074289.i2407, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2413, align 8
  %580 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2413)
  %581 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2414
  %582 = load ptr, ptr %581, align 8
  store ptr @i32_typ, ptr %.189.i2415, align 8
  %result.i14.i2417 = call ptr %582({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2415) #46
  %583 = call i32 %result.i14.i2417({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i2413, i32 %579) #53
  %584 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %585 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2416
  %586 = load ptr, ptr %585, align 8
  %587 = load ptr, ptr %586, align 8
  %588 = call { ptr } %587(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i2418 = extractvalue { ptr } %588, 0
  %589 = sext i32 %583 to i64
  %590 = shl nsw i64 %589, 5
  %591 = getelementptr i8, ptr %.fca.0.extract55.i2418, i64 %590
  %592 = load ptr, ptr %591, align 8
  %593 = getelementptr i8, ptr %591, i64 8
  %594 = load i64, ptr %593, align 4
  %.sroa_idx.i2419 = getelementptr i8, ptr %591, i64 16
  %595 = load i64, ptr %.sroa_idx.i2419, align 4
  %596 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %597 = call { ptr } %587(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i2420 = extractvalue { ptr } %597, 0
  %598 = getelementptr i8, ptr %.fca.0.extract52.i2420, i64 %590
  store ptr %.sroa.0.0288.i2408, ptr %598, align 8
  %599 = getelementptr i8, ptr %598, i64 8
  store i64 %.sroa.6.0287.i2409.in, ptr %599, align 4
  %.sroa_idx104.i2421 = getelementptr i8, ptr %598, i64 16
  store i64 %.sroa.12.0286.i2410.in, ptr %.sroa_idx104.i2421, align 4
  %.sroa_idx105.i2422 = getelementptr i8, ptr %598, i64 24
  store i32 %.sroa.17.0285.i2411, ptr %.sroa_idx105.i2422, align 4
  %600 = icmp ne ptr %592, @nil_typ
  %601 = icmp ne ptr %592, null
  %.not94.i2423 = and i1 %600, %601
  br i1 %.not94.i2423, label %.cont.i2428, label %606

.cont.i2428:                                      ; preds = %569
  %602 = add nuw nsw i32 %.0290.i2406, 1
  %603 = xor i1 %.074289.i2407, true
  %hash_coef_ptr.i.i46.i2429 = getelementptr i8, ptr %592, i64 8
  %tbl_size_ptr.i.i47.i2430 = getelementptr i8, ptr %592, i64 16
  %offset_tbl_ptr.i.i48.i2431 = getelementptr i8, ptr %592, i64 40
  %hash_coef.i.i49.i2432 = load i64, ptr %hash_coef_ptr.i.i46.i2429, align 4
  %tbl_size.i.i50.i2433 = load i64, ptr %tbl_size_ptr.i.i47.i2430, align 4
  %offset_tbl.i.i51.i2434 = load ptr, ptr %offset_tbl_ptr.i.i48.i2431, align 8
  %product.i.i.i52.i2435 = mul i64 %hash_coef.i.i49.i2432, 4015701072841558310
  %shifted.i.i.i53.i2436 = lshr i64 %product.i.i.i52.i2435, 32
  %xored.i.i.i54.i2437 = xor i64 %shifted.i.i.i53.i2436, %product.i.i.i52.i2435
  %hash.i.i.i55.i2438 = and i64 %xored.i.i.i54.i2437, %tbl_size.i.i50.i2433
  %offset_ptr.i.i56.i2439 = getelementptr i32, ptr %offset_tbl.i.i51.i2434, i64 %hash.i.i.i55.i2438
  %offset.i.i57.i2440 = load i32, ptr %offset_ptr.i.i56.i2439, align 4
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %605 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2441 = icmp eq i32 %602, 100
  br i1 %exitcond.not.i2441, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2450, label %569

606:                                              ; preds = %569
  %607 = load i32, ptr %88, align 4
  %608 = add i32 %607, 1
  %609 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %608, ptr %88, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2450

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2450: ; preds = %606, %.cont.i2428
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  br label %._crit_edge.i1812

._crit_edge.i1812:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2450, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %indvars.iv.next.i1813 = add nuw nsw i64 %indvars.iv.i1810, 1
  %exitcond.not.i1814 = icmp eq i64 %indvars.iv.next.i1813, %wide.trip.count.i
  br i1 %exitcond.not.i1814, label %._crit_edge.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit

._crit_edge.i:                                    ; preds = %._crit_edge.i1812, %492, %489
  %610 = load ptr, ptr %result.i63, align 8
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %612 = load ptr, ptr %78, align 8
  %613 = load ptr, ptr %610, align 8
  %614 = getelementptr i8, ptr %613, i64 72
  %615 = load ptr, ptr %614, align 8
  %result.i1.i.i334 = call { i64, i64 } %615(ptr nocapture nofree nonnull readonly align 8 %610) #44
  %616 = extractvalue { i64, i64 } %result.i1.i.i334, 0
  %617 = extractvalue { i64, i64 } %result.i1.i.i334, 1
  %618 = urem i64 20, %617
  %619 = icmp eq i64 %618, 0
  %620 = sub i64 %617, %618
  %621 = select i1 %619, i64 0, i64 %620
  %622 = add i64 %616, 20
  %623 = add i64 %622, %621
  %624 = load ptr, ptr %612, align 8
  %625 = getelementptr i8, ptr %624, i64 72
  %626 = load ptr, ptr %625, align 8
  %result.i.i.i335 = call { i64, i64 } %626(ptr nocapture nofree nonnull readonly align 8 %612) #44
  %627 = extractvalue { i64, i64 } %result.i.i.i335, 0
  %628 = extractvalue { i64, i64 } %result.i.i.i335, 1
  %629 = call i64 @llvm.umax.i64(i64 %617, i64 %628) #41
  %630 = call i64 @llvm.umax.i64(i64 %629, i64 noundef 8) #41, !range !16
  %631 = urem i64 %623, %628
  %632 = icmp eq i64 %631, 0
  %633 = sub i64 %628, %631
  %634 = select i1 %632, i64 0, i64 %633
  %635 = add i64 %627, %623
  %636 = add i64 %635, %634
  %637 = urem i64 %636, %630
  %638 = icmp eq i64 %637, 0
  %639 = sub i64 %630, %637
  %640 = select i1 %638, i64 0, i64 %639
  %641 = add i64 %640, %636
  %result.i22.i336 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %641) #48
  store ptr %610, ptr %result.i22.i336, align 8
  %642 = getelementptr inbounds i8, ptr %result.i22.i336, i64 8
  store ptr %612, ptr %642, align 8
  %643 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i336)
  %644 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %645 = load ptr, ptr %610, align 8
  %646 = getelementptr i8, ptr %645, i64 72
  %647 = load ptr, ptr %646, align 8
  %result.i.i127.i = call { i64, i64 } %647(ptr nocapture nofree nonnull readonly align 8 %610) #44
  %648 = extractvalue { i64, i64 } %result.i.i127.i, 1
  %649 = urem i64 20, %648
  %650 = icmp eq i64 %649, 0
  %reass.sub3448 = sub i64 %648, %649
  %651 = add i64 %reass.sub3448, 20
  %652 = select i1 %650, i64 20, i64 %651
  %653 = getelementptr i8, ptr %result.i22.i336, i64 %652
  %654 = getelementptr i8, ptr %645, i64 64
  %655 = load ptr, ptr %654, align 8
  call void %655({ ptr, i160 } %129, ptr nocapture nofree nonnull readonly align 8 %610, ptr nocapture nofree writeonly %653) #45
  %656 = load ptr, ptr %result.i22.i336, align 8
  %657 = load ptr, ptr %656, align 8
  %658 = getelementptr i8, ptr %657, i64 72
  %659 = load ptr, ptr %658, align 8
  %result.i1.i128.i = call { i64, i64 } %659(ptr nocapture nofree nonnull readonly align 8 %656) #44
  %660 = extractvalue { i64, i64 } %result.i1.i128.i, 0
  %661 = extractvalue { i64, i64 } %result.i1.i128.i, 1
  %662 = urem i64 20, %661
  %663 = icmp eq i64 %662, 0
  %664 = sub i64 %661, %662
  %665 = select i1 %663, i64 0, i64 %664
  %666 = add i64 %660, 20
  %667 = add i64 %666, %665
  %668 = load ptr, ptr %642, align 8
  %669 = load ptr, ptr %668, align 8
  %670 = getelementptr i8, ptr %669, i64 72
  %671 = load ptr, ptr %670, align 8
  %result.i.i129.i = call { i64, i64 } %671(ptr nocapture nofree nonnull readonly align 8 %668) #44
  %672 = extractvalue { i64, i64 } %result.i.i129.i, 1
  %673 = urem i64 %667, %672
  %674 = icmp eq i64 %673, 0
  %675 = sub i64 %672, %673
  %676 = select i1 %674, i64 0, i64 %675
  %677 = getelementptr i8, ptr %result.i22.i336, i64 %667
  %678 = getelementptr i8, ptr %677, i64 %676
  %679 = getelementptr i8, ptr %669, i64 64
  %680 = load ptr, ptr %679, align 8
  call void %680({ ptr, i160 } %246, ptr nocapture nofree nonnull readonly align 8 %668, ptr nocapture nofree writeonly %678) #45
  %681 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %682 = getelementptr inbounds i8, ptr %result.i22.i336, i64 16
  store i32 %249, ptr %682, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %684 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %685 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %686

686:                                              ; preds = %.cont.i, %._crit_edge.i
  %.0290.i = phi i32 [ 0, %._crit_edge.i ], [ %721, %.cont.i ]
  %.074289.i = phi i1 [ true, %._crit_edge.i ], [ %722, %.cont.i ]
  %.sroa.0.0288.i = phi ptr [ @Entry, %._crit_edge.i ], [ %709, %.cont.i ]
  %.sroa.6.0287.i = phi ptr [ %result.i22.i336, %._crit_edge.i ], [ %723, %.cont.i ]
  %.sroa.12.0286.i = phi ptr [ undef, %._crit_edge.i ], [ %724, %.cont.i ]
  %.sroa.17.0285.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i57.i, %.cont.i ]
  %687 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i, 0
  %688 = insertvalue { ptr, ptr, ptr, i32 } %687, ptr %.sroa.6.0287.i, 1
  %689 = insertvalue { ptr, ptr, ptr, i32 } %688, ptr %.sroa.12.0286.i, 2
  %690 = insertvalue { ptr, ptr, ptr, i32 } %689, i32 %.sroa.17.0285.i, 3
  %691 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i)
  %692 = sext i32 %.sroa.17.0285.i to i64
  %693 = getelementptr ptr, ptr %.sroa.0.0288.i, i64 %692
  %694 = getelementptr i8, ptr %693, i64 64
  %695 = load ptr, ptr %694, align 8
  %result.i15.i = call ptr %695({ ptr, ptr, ptr, i32 } %690, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %696 = call i32 %result.i15.i({ ptr, ptr, ptr, i32 } %690, { ptr, ptr, ptr, i32 } %690, ptr nonnull align 8 %2) #53
  %..i = select i1 %.074289.i, ptr %64, ptr %66
  %.188.i = select i1 %.074289.i, i64 104, i64 112
  %.189.i = select i1 %.074289.i, ptr %65, ptr %67
  %.190.i = select i1 %.074289.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i, align 8
  %697 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i)
  %698 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i
  %699 = load ptr, ptr %698, align 8
  store ptr @i32_typ, ptr %.189.i, align 8
  %result.i14.i = call ptr %699({ ptr, ptr, ptr, i32 } %121, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i) #46
  %700 = call i32 %result.i14.i({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull align 8 dereferenceable(8) %..i, i32 %696) #53
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %702 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i
  %703 = load ptr, ptr %702, align 8
  %704 = load ptr, ptr %703, align 8
  %705 = call { ptr } %704(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i = extractvalue { ptr } %705, 0
  %706 = sext i32 %700 to i64
  %707 = shl nsw i64 %706, 5
  %708 = getelementptr i8, ptr %.fca.0.extract55.i, i64 %707
  %709 = load ptr, ptr %708, align 8
  %710 = getelementptr i8, ptr %708, i64 8
  %711 = load i64, ptr %710, align 4
  %.sroa_idx.i909 = getelementptr i8, ptr %708, i64 16
  %712 = load i64, ptr %.sroa_idx.i909, align 4
  %713 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %714 = call { ptr } %704(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i = extractvalue { ptr } %714, 0
  %715 = getelementptr i8, ptr %.fca.0.extract52.i, i64 %707
  store ptr %.sroa.0.0288.i, ptr %715, align 8
  %716 = getelementptr i8, ptr %715, i64 8
  %717 = ptrtoint ptr %.sroa.6.0287.i to i64
  %718 = ptrtoint ptr %.sroa.12.0286.i to i64
  store i64 %717, ptr %716, align 4
  %.sroa_idx104.i = getelementptr i8, ptr %715, i64 16
  store i64 %718, ptr %.sroa_idx104.i, align 4
  %.sroa_idx105.i = getelementptr i8, ptr %715, i64 24
  store i32 %.sroa.17.0285.i, ptr %.sroa_idx105.i, align 4
  %719 = icmp ne ptr %709, @nil_typ
  %720 = icmp ne ptr %709, null
  %.not94.i = and i1 %719, %720
  br i1 %.not94.i, label %.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

.cont.i:                                          ; preds = %686
  %721 = add nuw nsw i32 %.0290.i, 1
  %722 = xor i1 %.074289.i, true
  %723 = inttoptr i64 %711 to ptr
  %724 = inttoptr i64 %712 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %709, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %709, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %709, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4
  %725 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %726 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i = icmp eq i32 %721, 100
  br i1 %exitcond.not.i, label %730, label %686

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %686
  %727 = load i32, ptr %88, align 4
  %728 = add i32 %727, 1
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %728, ptr %88, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  br label %CuckooMap_insert_keyK_valueV.exit

730:                                              ; preds = %.cont.i
  %hash_coef_ptr.i.i46.i.le = getelementptr i8, ptr %709, i64 8
  %tbl_size_ptr.i.i47.i.le = getelementptr i8, ptr %709, i64 16
  %offset_tbl_ptr.i.i48.i.le = getelementptr i8, ptr %709, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %731 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %732 = load ptr, ptr %86, align 8
  %733 = load ptr, ptr %87, align 8
  %734 = load i32, ptr %85, align 8
  %735 = shl i32 %734, 1
  %spec.select.i926 = call i32 @llvm.smax.i32(i32 %735, i32 noundef 16) #40
  store i32 %spec.select.i926, ptr %85, align 8
  %736 = zext nneg i32 %spec.select.i926 to i64
  %737 = shl nuw nsw i64 %736, 5
  %result.i5.i927 = call noalias ptr @bump_malloc_wrapper(i64 noundef %737) #48
  store ptr %result.i5.i927, ptr %86, align 8
  %result.i4.i928 = call noalias ptr @bump_malloc_wrapper(i64 noundef %737) #48
  store ptr %result.i4.i928, ptr %87, align 8
  store i32 0, ptr %88, align 4
  %738 = icmp sgt i32 %734, 0
  br i1 %738, label %.lr.ph.i1834, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1870.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1870.thread: ; preds = %730
  %739 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908

.lr.ph.i1834:                                     ; preds = %730
  %wide.trip.count.i1847 = zext nneg i32 %734 to i64
  br label %740

740:                                              ; preds = %._crit_edge.i1850, %.lr.ph.i1834
  %indvars.iv.i1848 = phi i64 [ 0, %.lr.ph.i1834 ], [ %indvars.iv.next.i1851, %._crit_edge.i1850 ]
  %741 = shl nuw nsw i64 %indvars.iv.i1848, 5
  %742 = getelementptr i8, ptr %732, i64 %741
  %743 = load ptr, ptr %742, align 8
  %744 = icmp ne ptr %743, @nil_typ
  %745 = icmp ne ptr %743, null
  %.not17.i1849 = and i1 %744, %745
  br i1 %.not17.i1849, label %746, label %._crit_edge.i1850

746:                                              ; preds = %740
  %747 = getelementptr i8, ptr %742, i64 8
  %748 = load i64, ptr %747, align 4
  %.sroa_idx.i1853 = getelementptr i8, ptr %742, i64 16
  %749 = load i64, ptr %.sroa_idx.i1853, align 4
  %hash_coef_ptr.i.i6.i1854 = getelementptr i8, ptr %743, i64 8
  %tbl_size_ptr.i.i7.i1855 = getelementptr i8, ptr %743, i64 16
  %offset_tbl_ptr.i.i8.i1856 = getelementptr i8, ptr %743, i64 40
  %750 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  %hash_coef.i.i21.i2468 = load i64, ptr %hash_coef_ptr.i.i6.i1854, align 4, !noalias !185
  %tbl_size.i.i22.i2469 = load i64, ptr %tbl_size_ptr.i.i7.i1855, align 4, !noalias !185
  %offset_tbl.i.i23.i2470 = load ptr, ptr %offset_tbl_ptr.i.i8.i1856, align 8, !noalias !185
  %product.i.i.i24.i2471 = mul i64 %hash_coef.i.i21.i2468, 4015701072841558310
  %shifted.i.i.i25.i2472 = lshr i64 %product.i.i.i24.i2471, 32
  %xored.i.i.i26.i2473 = xor i64 %shifted.i.i.i25.i2472, %product.i.i.i24.i2471
  %hash.i.i.i27.i2474 = and i64 %xored.i.i.i26.i2473, %tbl_size.i.i22.i2469
  %offset_ptr.i.i28.i2475 = getelementptr i32, ptr %offset_tbl.i.i23.i2470, i64 %hash.i.i.i27.i2474
  %offset.i.i29.i2476 = load i32, ptr %offset_ptr.i.i28.i2475, align 4, !noalias !185
  %751 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %752 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %753 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %754

754:                                              ; preds = %.cont.i2499, %746
  %.0290.i2477 = phi i32 [ 0, %746 ], [ %787, %.cont.i2499 ]
  %.074289.i2478 = phi i1 [ true, %746 ], [ %788, %.cont.i2499 ]
  %.sroa.0.0288.i2479 = phi ptr [ %743, %746 ], [ %777, %.cont.i2499 ]
  %.sroa.6.0287.i2480.in = phi i64 [ %748, %746 ], [ %779, %.cont.i2499 ]
  %.sroa.12.0286.i2481.in = phi i64 [ %749, %746 ], [ %780, %.cont.i2499 ]
  %.sroa.17.0285.i2482 = phi i32 [ %offset.i.i29.i2476, %746 ], [ %offset.i.i57.i2511, %.cont.i2499 ]
  %.sroa.12.0286.i2481 = inttoptr i64 %.sroa.12.0286.i2481.in to ptr
  %.sroa.6.0287.i2480 = inttoptr i64 %.sroa.6.0287.i2480.in to ptr
  %755 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2479, 0
  %756 = insertvalue { ptr, ptr, ptr, i32 } %755, ptr %.sroa.6.0287.i2480, 1
  %757 = insertvalue { ptr, ptr, ptr, i32 } %756, ptr %.sroa.12.0286.i2481, 2
  %758 = insertvalue { ptr, ptr, ptr, i32 } %757, i32 %.sroa.17.0285.i2482, 3
  %759 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2479)
  %760 = sext i32 %.sroa.17.0285.i2482 to i64
  %761 = getelementptr ptr, ptr %.sroa.0.0288.i2479, i64 %760
  %762 = getelementptr i8, ptr %761, i64 64
  %763 = load ptr, ptr %762, align 8
  %result.i15.i2483 = call ptr %763({ ptr, ptr, ptr, i32 } %758, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %764 = call i32 %result.i15.i2483({ ptr, ptr, ptr, i32 } %758, { ptr, ptr, ptr, i32 } %758, ptr nonnull align 8 %2) #53
  %..i2484 = select i1 %.074289.i2478, ptr %40, ptr %42
  %.188.i2485 = select i1 %.074289.i2478, i64 104, i64 112
  %.189.i2486 = select i1 %.074289.i2478, ptr %41, ptr %43
  %.190.i2487 = select i1 %.074289.i2478, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2484, align 8
  %765 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2484)
  %766 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2485
  %767 = load ptr, ptr %766, align 8
  store ptr @i32_typ, ptr %.189.i2486, align 8
  %result.i14.i2488 = call ptr %767({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2486) #46
  %768 = call i32 %result.i14.i2488({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i2484, i32 %764) #53
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %770 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2487
  %771 = load ptr, ptr %770, align 8
  %772 = load ptr, ptr %771, align 8
  %773 = call { ptr } %772(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i2489 = extractvalue { ptr } %773, 0
  %774 = sext i32 %768 to i64
  %775 = shl nsw i64 %774, 5
  %776 = getelementptr i8, ptr %.fca.0.extract55.i2489, i64 %775
  %777 = load ptr, ptr %776, align 8
  %778 = getelementptr i8, ptr %776, i64 8
  %779 = load i64, ptr %778, align 4
  %.sroa_idx.i2490 = getelementptr i8, ptr %776, i64 16
  %780 = load i64, ptr %.sroa_idx.i2490, align 4
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %782 = call { ptr } %772(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i2491 = extractvalue { ptr } %782, 0
  %783 = getelementptr i8, ptr %.fca.0.extract52.i2491, i64 %775
  store ptr %.sroa.0.0288.i2479, ptr %783, align 8
  %784 = getelementptr i8, ptr %783, i64 8
  store i64 %.sroa.6.0287.i2480.in, ptr %784, align 4
  %.sroa_idx104.i2492 = getelementptr i8, ptr %783, i64 16
  store i64 %.sroa.12.0286.i2481.in, ptr %.sroa_idx104.i2492, align 4
  %.sroa_idx105.i2493 = getelementptr i8, ptr %783, i64 24
  store i32 %.sroa.17.0285.i2482, ptr %.sroa_idx105.i2493, align 4
  %785 = icmp ne ptr %777, @nil_typ
  %786 = icmp ne ptr %777, null
  %.not94.i2494 = and i1 %785, %786
  br i1 %.not94.i2494, label %.cont.i2499, label %791

.cont.i2499:                                      ; preds = %754
  %787 = add nuw nsw i32 %.0290.i2477, 1
  %788 = xor i1 %.074289.i2478, true
  %hash_coef_ptr.i.i46.i2500 = getelementptr i8, ptr %777, i64 8
  %tbl_size_ptr.i.i47.i2501 = getelementptr i8, ptr %777, i64 16
  %offset_tbl_ptr.i.i48.i2502 = getelementptr i8, ptr %777, i64 40
  %hash_coef.i.i49.i2503 = load i64, ptr %hash_coef_ptr.i.i46.i2500, align 4
  %tbl_size.i.i50.i2504 = load i64, ptr %tbl_size_ptr.i.i47.i2501, align 4
  %offset_tbl.i.i51.i2505 = load ptr, ptr %offset_tbl_ptr.i.i48.i2502, align 8
  %product.i.i.i52.i2506 = mul i64 %hash_coef.i.i49.i2503, 4015701072841558310
  %shifted.i.i.i53.i2507 = lshr i64 %product.i.i.i52.i2506, 32
  %xored.i.i.i54.i2508 = xor i64 %shifted.i.i.i53.i2507, %product.i.i.i52.i2506
  %hash.i.i.i55.i2509 = and i64 %xored.i.i.i54.i2508, %tbl_size.i.i50.i2504
  %offset_ptr.i.i56.i2510 = getelementptr i32, ptr %offset_tbl.i.i51.i2505, i64 %hash.i.i.i55.i2509
  %offset.i.i57.i2511 = load i32, ptr %offset_ptr.i.i56.i2510, align 4
  %789 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %790 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2512 = icmp eq i32 %787, 100
  br i1 %exitcond.not.i2512, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2521, label %754

791:                                              ; preds = %754
  %792 = load i32, ptr %88, align 4
  %793 = add i32 %792, 1
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %793, ptr %88, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2521

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2521: ; preds = %791, %.cont.i2499
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  br label %._crit_edge.i1850

._crit_edge.i1850:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2521, %740
  %indvars.iv.next.i1851 = add nuw nsw i64 %indvars.iv.i1848, 1
  %exitcond.not.i1852 = icmp eq i64 %indvars.iv.next.i1851, %wide.trip.count.i1847
  br i1 %exitcond.not.i1852, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1870, label %740

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1870: ; preds = %._crit_edge.i1850
  %795 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %796

796:                                              ; preds = %._crit_edge.i1888, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1870
  %indvars.iv.i1886 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1870 ], [ %indvars.iv.next.i1889, %._crit_edge.i1888 ]
  %797 = shl nuw nsw i64 %indvars.iv.i1886, 5
  %798 = getelementptr i8, ptr %733, i64 %797
  %799 = load ptr, ptr %798, align 8
  %800 = icmp ne ptr %799, @nil_typ
  %801 = icmp ne ptr %799, null
  %.not17.i1887 = and i1 %800, %801
  br i1 %.not17.i1887, label %802, label %._crit_edge.i1888

802:                                              ; preds = %796
  %803 = getelementptr i8, ptr %798, i64 8
  %804 = load i64, ptr %803, align 4
  %.sroa_idx.i1891 = getelementptr i8, ptr %798, i64 16
  %805 = load i64, ptr %.sroa_idx.i1891, align 4
  %hash_coef_ptr.i.i6.i1892 = getelementptr i8, ptr %799, i64 8
  %tbl_size_ptr.i.i7.i1893 = getelementptr i8, ptr %799, i64 16
  %offset_tbl_ptr.i.i8.i1894 = getelementptr i8, ptr %799, i64 40
  %806 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  %hash_coef.i.i21.i2539 = load i64, ptr %hash_coef_ptr.i.i6.i1892, align 4, !noalias !188
  %tbl_size.i.i22.i2540 = load i64, ptr %tbl_size_ptr.i.i7.i1893, align 4, !noalias !188
  %offset_tbl.i.i23.i2541 = load ptr, ptr %offset_tbl_ptr.i.i8.i1894, align 8, !noalias !188
  %product.i.i.i24.i2542 = mul i64 %hash_coef.i.i21.i2539, 4015701072841558310
  %shifted.i.i.i25.i2543 = lshr i64 %product.i.i.i24.i2542, 32
  %xored.i.i.i26.i2544 = xor i64 %shifted.i.i.i25.i2543, %product.i.i.i24.i2542
  %hash.i.i.i27.i2545 = and i64 %xored.i.i.i26.i2544, %tbl_size.i.i22.i2540
  %offset_ptr.i.i28.i2546 = getelementptr i32, ptr %offset_tbl.i.i23.i2541, i64 %hash.i.i.i27.i2545
  %offset.i.i29.i2547 = load i32, ptr %offset_ptr.i.i28.i2546, align 4, !noalias !188
  %807 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %808 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %809 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %810

810:                                              ; preds = %.cont.i2570, %802
  %.0290.i2548 = phi i32 [ 0, %802 ], [ %843, %.cont.i2570 ]
  %.074289.i2549 = phi i1 [ true, %802 ], [ %844, %.cont.i2570 ]
  %.sroa.0.0288.i2550 = phi ptr [ %799, %802 ], [ %833, %.cont.i2570 ]
  %.sroa.6.0287.i2551.in = phi i64 [ %804, %802 ], [ %835, %.cont.i2570 ]
  %.sroa.12.0286.i2552.in = phi i64 [ %805, %802 ], [ %836, %.cont.i2570 ]
  %.sroa.17.0285.i2553 = phi i32 [ %offset.i.i29.i2547, %802 ], [ %offset.i.i57.i2582, %.cont.i2570 ]
  %.sroa.12.0286.i2552 = inttoptr i64 %.sroa.12.0286.i2552.in to ptr
  %.sroa.6.0287.i2551 = inttoptr i64 %.sroa.6.0287.i2551.in to ptr
  %811 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2550, 0
  %812 = insertvalue { ptr, ptr, ptr, i32 } %811, ptr %.sroa.6.0287.i2551, 1
  %813 = insertvalue { ptr, ptr, ptr, i32 } %812, ptr %.sroa.12.0286.i2552, 2
  %814 = insertvalue { ptr, ptr, ptr, i32 } %813, i32 %.sroa.17.0285.i2553, 3
  %815 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2550)
  %816 = sext i32 %.sroa.17.0285.i2553 to i64
  %817 = getelementptr ptr, ptr %.sroa.0.0288.i2550, i64 %816
  %818 = getelementptr i8, ptr %817, i64 64
  %819 = load ptr, ptr %818, align 8
  %result.i15.i2554 = call ptr %819({ ptr, ptr, ptr, i32 } %814, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %820 = call i32 %result.i15.i2554({ ptr, ptr, ptr, i32 } %814, { ptr, ptr, ptr, i32 } %814, ptr nonnull align 8 %2) #53
  %..i2555 = select i1 %.074289.i2549, ptr %36, ptr %38
  %.188.i2556 = select i1 %.074289.i2549, i64 104, i64 112
  %.189.i2557 = select i1 %.074289.i2549, ptr %37, ptr %39
  %.190.i2558 = select i1 %.074289.i2549, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2555, align 8
  %821 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2555)
  %822 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2556
  %823 = load ptr, ptr %822, align 8
  store ptr @i32_typ, ptr %.189.i2557, align 8
  %result.i14.i2559 = call ptr %823({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2557) #46
  %824 = call i32 %result.i14.i2559({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i2555, i32 %820) #53
  %825 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %826 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2558
  %827 = load ptr, ptr %826, align 8
  %828 = load ptr, ptr %827, align 8
  %829 = call { ptr } %828(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i2560 = extractvalue { ptr } %829, 0
  %830 = sext i32 %824 to i64
  %831 = shl nsw i64 %830, 5
  %832 = getelementptr i8, ptr %.fca.0.extract55.i2560, i64 %831
  %833 = load ptr, ptr %832, align 8
  %834 = getelementptr i8, ptr %832, i64 8
  %835 = load i64, ptr %834, align 4
  %.sroa_idx.i2561 = getelementptr i8, ptr %832, i64 16
  %836 = load i64, ptr %.sroa_idx.i2561, align 4
  %837 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %838 = call { ptr } %828(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i2562 = extractvalue { ptr } %838, 0
  %839 = getelementptr i8, ptr %.fca.0.extract52.i2562, i64 %831
  store ptr %.sroa.0.0288.i2550, ptr %839, align 8
  %840 = getelementptr i8, ptr %839, i64 8
  store i64 %.sroa.6.0287.i2551.in, ptr %840, align 4
  %.sroa_idx104.i2563 = getelementptr i8, ptr %839, i64 16
  store i64 %.sroa.12.0286.i2552.in, ptr %.sroa_idx104.i2563, align 4
  %.sroa_idx105.i2564 = getelementptr i8, ptr %839, i64 24
  store i32 %.sroa.17.0285.i2553, ptr %.sroa_idx105.i2564, align 4
  %841 = icmp ne ptr %833, @nil_typ
  %842 = icmp ne ptr %833, null
  %.not94.i2565 = and i1 %841, %842
  br i1 %.not94.i2565, label %.cont.i2570, label %847

.cont.i2570:                                      ; preds = %810
  %843 = add nuw nsw i32 %.0290.i2548, 1
  %844 = xor i1 %.074289.i2549, true
  %hash_coef_ptr.i.i46.i2571 = getelementptr i8, ptr %833, i64 8
  %tbl_size_ptr.i.i47.i2572 = getelementptr i8, ptr %833, i64 16
  %offset_tbl_ptr.i.i48.i2573 = getelementptr i8, ptr %833, i64 40
  %hash_coef.i.i49.i2574 = load i64, ptr %hash_coef_ptr.i.i46.i2571, align 4
  %tbl_size.i.i50.i2575 = load i64, ptr %tbl_size_ptr.i.i47.i2572, align 4
  %offset_tbl.i.i51.i2576 = load ptr, ptr %offset_tbl_ptr.i.i48.i2573, align 8
  %product.i.i.i52.i2577 = mul i64 %hash_coef.i.i49.i2574, 4015701072841558310
  %shifted.i.i.i53.i2578 = lshr i64 %product.i.i.i52.i2577, 32
  %xored.i.i.i54.i2579 = xor i64 %shifted.i.i.i53.i2578, %product.i.i.i52.i2577
  %hash.i.i.i55.i2580 = and i64 %xored.i.i.i54.i2579, %tbl_size.i.i50.i2575
  %offset_ptr.i.i56.i2581 = getelementptr i32, ptr %offset_tbl.i.i51.i2576, i64 %hash.i.i.i55.i2580
  %offset.i.i57.i2582 = load i32, ptr %offset_ptr.i.i56.i2581, align 4
  %845 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %846 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2583 = icmp eq i32 %843, 100
  br i1 %exitcond.not.i2583, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2592, label %810

847:                                              ; preds = %810
  %848 = load i32, ptr %88, align 4
  %849 = add i32 %848, 1
  %850 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %849, ptr %88, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2592

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2592: ; preds = %847, %.cont.i2570
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  br label %._crit_edge.i1888

._crit_edge.i1888:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2592, %796
  %indvars.iv.next.i1889 = add nuw nsw i64 %indvars.iv.i1886, 1
  %exitcond.not.i1890 = icmp eq i64 %indvars.iv.next.i1889, %wide.trip.count.i1847
  br i1 %exitcond.not.i1890, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908, label %796

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908: ; preds = %._crit_edge.i1888, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1870.thread
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  %hash_coef.i.i21.i951 = load i64, ptr %hash_coef_ptr.i.i46.i.le, align 4, !noalias !191
  %tbl_size.i.i22.i952 = load i64, ptr %tbl_size_ptr.i.i47.i.le, align 4, !noalias !191
  %offset_tbl.i.i23.i953 = load ptr, ptr %offset_tbl_ptr.i.i48.i.le, align 8, !noalias !191
  %product.i.i.i24.i954 = mul i64 %hash_coef.i.i21.i951, 4015701072841558310
  %shifted.i.i.i25.i955 = lshr i64 %product.i.i.i24.i954, 32
  %xored.i.i.i26.i956 = xor i64 %shifted.i.i.i25.i955, %product.i.i.i24.i954
  %hash.i.i.i27.i957 = and i64 %xored.i.i.i26.i956, %tbl_size.i.i22.i952
  %offset_ptr.i.i28.i958 = getelementptr i32, ptr %offset_tbl.i.i23.i953, i64 %hash.i.i.i27.i957
  %offset.i.i29.i959 = load i32, ptr %offset_ptr.i.i28.i958, align 4, !noalias !191
  %851 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %852 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %853 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %854

854:                                              ; preds = %.cont.i983, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908
  %.0290.i961 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908 ], [ %887, %.cont.i983 ]
  %.074289.i962 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908 ], [ %888, %.cont.i983 ]
  %.sroa.0.0288.i963 = phi ptr [ %709, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908 ], [ %877, %.cont.i983 ]
  %.sroa.6.0287.i964.in = phi i64 [ %711, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908 ], [ %879, %.cont.i983 ]
  %.sroa.12.0286.i965.in = phi i64 [ %712, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908 ], [ %880, %.cont.i983 ]
  %.sroa.17.0285.i966 = phi i32 [ %offset.i.i29.i959, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1908 ], [ %offset.i.i57.i995, %.cont.i983 ]
  %.sroa.12.0286.i965 = inttoptr i64 %.sroa.12.0286.i965.in to ptr
  %.sroa.6.0287.i964 = inttoptr i64 %.sroa.6.0287.i964.in to ptr
  %855 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i963, 0
  %856 = insertvalue { ptr, ptr, ptr, i32 } %855, ptr %.sroa.6.0287.i964, 1
  %857 = insertvalue { ptr, ptr, ptr, i32 } %856, ptr %.sroa.12.0286.i965, 2
  %858 = insertvalue { ptr, ptr, ptr, i32 } %857, i32 %.sroa.17.0285.i966, 3
  %859 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i963)
  %860 = sext i32 %.sroa.17.0285.i966 to i64
  %861 = getelementptr ptr, ptr %.sroa.0.0288.i963, i64 %860
  %862 = getelementptr i8, ptr %861, i64 64
  %863 = load ptr, ptr %862, align 8
  %result.i15.i967 = call ptr %863({ ptr, ptr, ptr, i32 } %858, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %864 = call i32 %result.i15.i967({ ptr, ptr, ptr, i32 } %858, { ptr, ptr, ptr, i32 } %858, ptr nonnull align 8 %2) #53
  %..i968 = select i1 %.074289.i962, ptr %60, ptr %62
  %.188.i969 = select i1 %.074289.i962, i64 104, i64 112
  %.189.i970 = select i1 %.074289.i962, ptr %61, ptr %63
  %.190.i971 = select i1 %.074289.i962, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i968, align 8
  %865 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i968)
  %866 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i969
  %867 = load ptr, ptr %866, align 8
  store ptr @i32_typ, ptr %.189.i970, align 8
  %result.i14.i972 = call ptr %867({ ptr, ptr, ptr, i32 } %121, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i970) #46
  %868 = call i32 %result.i14.i972({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull align 8 dereferenceable(8) %..i968, i32 %864) #53
  %869 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %870 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i971
  %871 = load ptr, ptr %870, align 8
  %872 = load ptr, ptr %871, align 8
  %873 = call { ptr } %872(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i973 = extractvalue { ptr } %873, 0
  %874 = sext i32 %868 to i64
  %875 = shl nsw i64 %874, 5
  %876 = getelementptr i8, ptr %.fca.0.extract55.i973, i64 %875
  %877 = load ptr, ptr %876, align 8
  %878 = getelementptr i8, ptr %876, i64 8
  %879 = load i64, ptr %878, align 4
  %.sroa_idx.i974 = getelementptr i8, ptr %876, i64 16
  %880 = load i64, ptr %.sroa_idx.i974, align 4
  %881 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %882 = call { ptr } %872(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i975 = extractvalue { ptr } %882, 0
  %883 = getelementptr i8, ptr %.fca.0.extract52.i975, i64 %875
  store ptr %.sroa.0.0288.i963, ptr %883, align 8
  %884 = getelementptr i8, ptr %883, i64 8
  store i64 %.sroa.6.0287.i964.in, ptr %884, align 4
  %.sroa_idx104.i976 = getelementptr i8, ptr %883, i64 16
  store i64 %.sroa.12.0286.i965.in, ptr %.sroa_idx104.i976, align 4
  %.sroa_idx105.i977 = getelementptr i8, ptr %883, i64 24
  store i32 %.sroa.17.0285.i966, ptr %.sroa_idx105.i977, align 4
  %885 = icmp ne ptr %877, @nil_typ
  %886 = icmp ne ptr %877, null
  %.not94.i978 = and i1 %885, %886
  br i1 %.not94.i978, label %.cont.i983, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1005

.cont.i983:                                       ; preds = %854
  %887 = add nuw nsw i32 %.0290.i961, 1
  %888 = xor i1 %.074289.i962, true
  %hash_coef_ptr.i.i46.i984 = getelementptr i8, ptr %877, i64 8
  %tbl_size_ptr.i.i47.i985 = getelementptr i8, ptr %877, i64 16
  %offset_tbl_ptr.i.i48.i986 = getelementptr i8, ptr %877, i64 40
  %hash_coef.i.i49.i987 = load i64, ptr %hash_coef_ptr.i.i46.i984, align 4
  %tbl_size.i.i50.i988 = load i64, ptr %tbl_size_ptr.i.i47.i985, align 4
  %offset_tbl.i.i51.i989 = load ptr, ptr %offset_tbl_ptr.i.i48.i986, align 8
  %product.i.i.i52.i990 = mul i64 %hash_coef.i.i49.i987, 4015701072841558310
  %shifted.i.i.i53.i991 = lshr i64 %product.i.i.i52.i990, 32
  %xored.i.i.i54.i992 = xor i64 %shifted.i.i.i53.i991, %product.i.i.i52.i990
  %hash.i.i.i55.i993 = and i64 %xored.i.i.i54.i992, %tbl_size.i.i50.i988
  %offset_ptr.i.i56.i994 = getelementptr i32, ptr %offset_tbl.i.i51.i989, i64 %hash.i.i.i55.i993
  %offset.i.i57.i995 = load i32, ptr %offset_ptr.i.i56.i994, align 4
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %890 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i996 = icmp eq i32 %887, 100
  br i1 %exitcond.not.i996, label %894, label %854

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1005: ; preds = %854
  %891 = load i32, ptr %88, align 4
  %892 = add i32 %891, 1
  %893 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %892, ptr %88, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  br label %CuckooMap_insert_keyK_valueV.exit

894:                                              ; preds = %.cont.i983
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  %895 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %896 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %897 = load ptr, ptr %86, align 8
  %898 = load ptr, ptr %87, align 8
  %899 = load i32, ptr %85, align 8
  %900 = shl i32 %899, 1
  %spec.select.i1021 = call i32 @llvm.smax.i32(i32 %900, i32 noundef 16) #40
  store i32 %spec.select.i1021, ptr %85, align 8
  %901 = zext nneg i32 %spec.select.i1021 to i64
  %902 = shl nuw nsw i64 %901, 5
  %result.i5.i1022 = call noalias ptr @bump_malloc_wrapper(i64 noundef %902) #48
  store ptr %result.i5.i1022, ptr %86, align 8
  %result.i4.i1023 = call noalias ptr @bump_malloc_wrapper(i64 noundef %902) #48
  store ptr %result.i4.i1023, ptr %87, align 8
  store i32 0, ptr %88, align 4
  %903 = icmp sgt i32 %899, 0
  br i1 %903, label %.lr.ph.i1910, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1946.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1946.thread: ; preds = %894
  %904 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i1910:                                     ; preds = %894
  %wide.trip.count.i1923 = zext nneg i32 %899 to i64
  br label %905

905:                                              ; preds = %._crit_edge.i1926, %.lr.ph.i1910
  %indvars.iv.i1924 = phi i64 [ 0, %.lr.ph.i1910 ], [ %indvars.iv.next.i1927, %._crit_edge.i1926 ]
  %906 = shl nuw nsw i64 %indvars.iv.i1924, 5
  %907 = getelementptr i8, ptr %897, i64 %906
  %908 = load ptr, ptr %907, align 8
  %909 = icmp ne ptr %908, @nil_typ
  %910 = icmp ne ptr %908, null
  %.not17.i1925 = and i1 %909, %910
  br i1 %.not17.i1925, label %911, label %._crit_edge.i1926

911:                                              ; preds = %905
  %912 = getelementptr i8, ptr %907, i64 8
  %913 = load i64, ptr %912, align 4
  %.sroa_idx.i1929 = getelementptr i8, ptr %907, i64 16
  %914 = load i64, ptr %.sroa_idx.i1929, align 4
  %hash_coef_ptr.i.i6.i1930 = getelementptr i8, ptr %908, i64 8
  %tbl_size_ptr.i.i7.i1931 = getelementptr i8, ptr %908, i64 16
  %offset_tbl_ptr.i.i8.i1932 = getelementptr i8, ptr %908, i64 40
  %915 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  %hash_coef.i.i21.i2610 = load i64, ptr %hash_coef_ptr.i.i6.i1930, align 4, !noalias !194
  %tbl_size.i.i22.i2611 = load i64, ptr %tbl_size_ptr.i.i7.i1931, align 4, !noalias !194
  %offset_tbl.i.i23.i2612 = load ptr, ptr %offset_tbl_ptr.i.i8.i1932, align 8, !noalias !194
  %product.i.i.i24.i2613 = mul i64 %hash_coef.i.i21.i2610, 4015701072841558310
  %shifted.i.i.i25.i2614 = lshr i64 %product.i.i.i24.i2613, 32
  %xored.i.i.i26.i2615 = xor i64 %shifted.i.i.i25.i2614, %product.i.i.i24.i2613
  %hash.i.i.i27.i2616 = and i64 %xored.i.i.i26.i2615, %tbl_size.i.i22.i2611
  %offset_ptr.i.i28.i2617 = getelementptr i32, ptr %offset_tbl.i.i23.i2612, i64 %hash.i.i.i27.i2616
  %offset.i.i29.i2618 = load i32, ptr %offset_ptr.i.i28.i2617, align 4, !noalias !194
  %916 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %917 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %918 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %919

919:                                              ; preds = %.cont.i2641, %911
  %.0290.i2619 = phi i32 [ 0, %911 ], [ %952, %.cont.i2641 ]
  %.074289.i2620 = phi i1 [ true, %911 ], [ %953, %.cont.i2641 ]
  %.sroa.0.0288.i2621 = phi ptr [ %908, %911 ], [ %942, %.cont.i2641 ]
  %.sroa.6.0287.i2622.in = phi i64 [ %913, %911 ], [ %944, %.cont.i2641 ]
  %.sroa.12.0286.i2623.in = phi i64 [ %914, %911 ], [ %945, %.cont.i2641 ]
  %.sroa.17.0285.i2624 = phi i32 [ %offset.i.i29.i2618, %911 ], [ %offset.i.i57.i2653, %.cont.i2641 ]
  %.sroa.12.0286.i2623 = inttoptr i64 %.sroa.12.0286.i2623.in to ptr
  %.sroa.6.0287.i2622 = inttoptr i64 %.sroa.6.0287.i2622.in to ptr
  %920 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2621, 0
  %921 = insertvalue { ptr, ptr, ptr, i32 } %920, ptr %.sroa.6.0287.i2622, 1
  %922 = insertvalue { ptr, ptr, ptr, i32 } %921, ptr %.sroa.12.0286.i2623, 2
  %923 = insertvalue { ptr, ptr, ptr, i32 } %922, i32 %.sroa.17.0285.i2624, 3
  %924 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2621)
  %925 = sext i32 %.sroa.17.0285.i2624 to i64
  %926 = getelementptr ptr, ptr %.sroa.0.0288.i2621, i64 %925
  %927 = getelementptr i8, ptr %926, i64 64
  %928 = load ptr, ptr %927, align 8
  %result.i15.i2625 = call ptr %928({ ptr, ptr, ptr, i32 } %923, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %929 = call i32 %result.i15.i2625({ ptr, ptr, ptr, i32 } %923, { ptr, ptr, ptr, i32 } %923, ptr nonnull align 8 %2) #53
  %..i2626 = select i1 %.074289.i2620, ptr %32, ptr %34
  %.188.i2627 = select i1 %.074289.i2620, i64 104, i64 112
  %.189.i2628 = select i1 %.074289.i2620, ptr %33, ptr %35
  %.190.i2629 = select i1 %.074289.i2620, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2626, align 8
  %930 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2626)
  %931 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2627
  %932 = load ptr, ptr %931, align 8
  store ptr @i32_typ, ptr %.189.i2628, align 8
  %result.i14.i2630 = call ptr %932({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2628) #46
  %933 = call i32 %result.i14.i2630({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i2626, i32 %929) #53
  %934 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %935 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2629
  %936 = load ptr, ptr %935, align 8
  %937 = load ptr, ptr %936, align 8
  %938 = call { ptr } %937(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i2631 = extractvalue { ptr } %938, 0
  %939 = sext i32 %933 to i64
  %940 = shl nsw i64 %939, 5
  %941 = getelementptr i8, ptr %.fca.0.extract55.i2631, i64 %940
  %942 = load ptr, ptr %941, align 8
  %943 = getelementptr i8, ptr %941, i64 8
  %944 = load i64, ptr %943, align 4
  %.sroa_idx.i2632 = getelementptr i8, ptr %941, i64 16
  %945 = load i64, ptr %.sroa_idx.i2632, align 4
  %946 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %947 = call { ptr } %937(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i2633 = extractvalue { ptr } %947, 0
  %948 = getelementptr i8, ptr %.fca.0.extract52.i2633, i64 %940
  store ptr %.sroa.0.0288.i2621, ptr %948, align 8
  %949 = getelementptr i8, ptr %948, i64 8
  store i64 %.sroa.6.0287.i2622.in, ptr %949, align 4
  %.sroa_idx104.i2634 = getelementptr i8, ptr %948, i64 16
  store i64 %.sroa.12.0286.i2623.in, ptr %.sroa_idx104.i2634, align 4
  %.sroa_idx105.i2635 = getelementptr i8, ptr %948, i64 24
  store i32 %.sroa.17.0285.i2624, ptr %.sroa_idx105.i2635, align 4
  %950 = icmp ne ptr %942, @nil_typ
  %951 = icmp ne ptr %942, null
  %.not94.i2636 = and i1 %950, %951
  br i1 %.not94.i2636, label %.cont.i2641, label %956

.cont.i2641:                                      ; preds = %919
  %952 = add nuw nsw i32 %.0290.i2619, 1
  %953 = xor i1 %.074289.i2620, true
  %hash_coef_ptr.i.i46.i2642 = getelementptr i8, ptr %942, i64 8
  %tbl_size_ptr.i.i47.i2643 = getelementptr i8, ptr %942, i64 16
  %offset_tbl_ptr.i.i48.i2644 = getelementptr i8, ptr %942, i64 40
  %hash_coef.i.i49.i2645 = load i64, ptr %hash_coef_ptr.i.i46.i2642, align 4
  %tbl_size.i.i50.i2646 = load i64, ptr %tbl_size_ptr.i.i47.i2643, align 4
  %offset_tbl.i.i51.i2647 = load ptr, ptr %offset_tbl_ptr.i.i48.i2644, align 8
  %product.i.i.i52.i2648 = mul i64 %hash_coef.i.i49.i2645, 4015701072841558310
  %shifted.i.i.i53.i2649 = lshr i64 %product.i.i.i52.i2648, 32
  %xored.i.i.i54.i2650 = xor i64 %shifted.i.i.i53.i2649, %product.i.i.i52.i2648
  %hash.i.i.i55.i2651 = and i64 %xored.i.i.i54.i2650, %tbl_size.i.i50.i2646
  %offset_ptr.i.i56.i2652 = getelementptr i32, ptr %offset_tbl.i.i51.i2647, i64 %hash.i.i.i55.i2651
  %offset.i.i57.i2653 = load i32, ptr %offset_ptr.i.i56.i2652, align 4
  %954 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %955 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2654 = icmp eq i32 %952, 100
  br i1 %exitcond.not.i2654, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2663, label %919

956:                                              ; preds = %919
  %957 = load i32, ptr %88, align 4
  %958 = add i32 %957, 1
  %959 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %958, ptr %88, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2663

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2663: ; preds = %956, %.cont.i2641
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  br label %._crit_edge.i1926

._crit_edge.i1926:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2663, %905
  %indvars.iv.next.i1927 = add nuw nsw i64 %indvars.iv.i1924, 1
  %exitcond.not.i1928 = icmp eq i64 %indvars.iv.next.i1927, %wide.trip.count.i1923
  br i1 %exitcond.not.i1928, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1946, label %905

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1946: ; preds = %._crit_edge.i1926
  %960 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %961

961:                                              ; preds = %._crit_edge.i1964, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1946
  %indvars.iv.i1962 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1946 ], [ %indvars.iv.next.i1965, %._crit_edge.i1964 ]
  %962 = shl nuw nsw i64 %indvars.iv.i1962, 5
  %963 = getelementptr i8, ptr %898, i64 %962
  %964 = load ptr, ptr %963, align 8
  %965 = icmp ne ptr %964, @nil_typ
  %966 = icmp ne ptr %964, null
  %.not17.i1963 = and i1 %965, %966
  br i1 %.not17.i1963, label %967, label %._crit_edge.i1964

967:                                              ; preds = %961
  %968 = getelementptr i8, ptr %963, i64 8
  %969 = load i64, ptr %968, align 4
  %.sroa_idx.i1967 = getelementptr i8, ptr %963, i64 16
  %970 = load i64, ptr %.sroa_idx.i1967, align 4
  %hash_coef_ptr.i.i6.i1968 = getelementptr i8, ptr %964, i64 8
  %tbl_size_ptr.i.i7.i1969 = getelementptr i8, ptr %964, i64 16
  %offset_tbl_ptr.i.i8.i1970 = getelementptr i8, ptr %964, i64 40
  %971 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %hash_coef.i.i21.i2681 = load i64, ptr %hash_coef_ptr.i.i6.i1968, align 4, !noalias !197
  %tbl_size.i.i22.i2682 = load i64, ptr %tbl_size_ptr.i.i7.i1969, align 4, !noalias !197
  %offset_tbl.i.i23.i2683 = load ptr, ptr %offset_tbl_ptr.i.i8.i1970, align 8, !noalias !197
  %product.i.i.i24.i2684 = mul i64 %hash_coef.i.i21.i2681, 4015701072841558310
  %shifted.i.i.i25.i2685 = lshr i64 %product.i.i.i24.i2684, 32
  %xored.i.i.i26.i2686 = xor i64 %shifted.i.i.i25.i2685, %product.i.i.i24.i2684
  %hash.i.i.i27.i2687 = and i64 %xored.i.i.i26.i2686, %tbl_size.i.i22.i2682
  %offset_ptr.i.i28.i2688 = getelementptr i32, ptr %offset_tbl.i.i23.i2683, i64 %hash.i.i.i27.i2687
  %offset.i.i29.i2689 = load i32, ptr %offset_ptr.i.i28.i2688, align 4, !noalias !197
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %973 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %974 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %975

975:                                              ; preds = %.cont.i2712, %967
  %.0290.i2690 = phi i32 [ 0, %967 ], [ %1008, %.cont.i2712 ]
  %.074289.i2691 = phi i1 [ true, %967 ], [ %1009, %.cont.i2712 ]
  %.sroa.0.0288.i2692 = phi ptr [ %964, %967 ], [ %998, %.cont.i2712 ]
  %.sroa.6.0287.i2693.in = phi i64 [ %969, %967 ], [ %1000, %.cont.i2712 ]
  %.sroa.12.0286.i2694.in = phi i64 [ %970, %967 ], [ %1001, %.cont.i2712 ]
  %.sroa.17.0285.i2695 = phi i32 [ %offset.i.i29.i2689, %967 ], [ %offset.i.i57.i2724, %.cont.i2712 ]
  %.sroa.12.0286.i2694 = inttoptr i64 %.sroa.12.0286.i2694.in to ptr
  %.sroa.6.0287.i2693 = inttoptr i64 %.sroa.6.0287.i2693.in to ptr
  %976 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2692, 0
  %977 = insertvalue { ptr, ptr, ptr, i32 } %976, ptr %.sroa.6.0287.i2693, 1
  %978 = insertvalue { ptr, ptr, ptr, i32 } %977, ptr %.sroa.12.0286.i2694, 2
  %979 = insertvalue { ptr, ptr, ptr, i32 } %978, i32 %.sroa.17.0285.i2695, 3
  %980 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2692)
  %981 = sext i32 %.sroa.17.0285.i2695 to i64
  %982 = getelementptr ptr, ptr %.sroa.0.0288.i2692, i64 %981
  %983 = getelementptr i8, ptr %982, i64 64
  %984 = load ptr, ptr %983, align 8
  %result.i15.i2696 = call ptr %984({ ptr, ptr, ptr, i32 } %979, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %985 = call i32 %result.i15.i2696({ ptr, ptr, ptr, i32 } %979, { ptr, ptr, ptr, i32 } %979, ptr nonnull align 8 %2) #53
  %..i2697 = select i1 %.074289.i2691, ptr %28, ptr %30
  %.188.i2698 = select i1 %.074289.i2691, i64 104, i64 112
  %.189.i2699 = select i1 %.074289.i2691, ptr %29, ptr %31
  %.190.i2700 = select i1 %.074289.i2691, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2697, align 8
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2697)
  %987 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2698
  %988 = load ptr, ptr %987, align 8
  store ptr @i32_typ, ptr %.189.i2699, align 8
  %result.i14.i2701 = call ptr %988({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2699) #46
  %989 = call i32 %result.i14.i2701({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i2697, i32 %985) #53
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %991 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2700
  %992 = load ptr, ptr %991, align 8
  %993 = load ptr, ptr %992, align 8
  %994 = call { ptr } %993(ptr nonnull %result.i63) #43
  %.fca.0.extract55.i2702 = extractvalue { ptr } %994, 0
  %995 = sext i32 %989 to i64
  %996 = shl nsw i64 %995, 5
  %997 = getelementptr i8, ptr %.fca.0.extract55.i2702, i64 %996
  %998 = load ptr, ptr %997, align 8
  %999 = getelementptr i8, ptr %997, i64 8
  %1000 = load i64, ptr %999, align 4
  %.sroa_idx.i2703 = getelementptr i8, ptr %997, i64 16
  %1001 = load i64, ptr %.sroa_idx.i2703, align 4
  %1002 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1003 = call { ptr } %993(ptr nonnull %result.i63) #43
  %.fca.0.extract52.i2704 = extractvalue { ptr } %1003, 0
  %1004 = getelementptr i8, ptr %.fca.0.extract52.i2704, i64 %996
  store ptr %.sroa.0.0288.i2692, ptr %1004, align 8
  %1005 = getelementptr i8, ptr %1004, i64 8
  store i64 %.sroa.6.0287.i2693.in, ptr %1005, align 4
  %.sroa_idx104.i2705 = getelementptr i8, ptr %1004, i64 16
  store i64 %.sroa.12.0286.i2694.in, ptr %.sroa_idx104.i2705, align 4
  %.sroa_idx105.i2706 = getelementptr i8, ptr %1004, i64 24
  store i32 %.sroa.17.0285.i2695, ptr %.sroa_idx105.i2706, align 4
  %1006 = icmp ne ptr %998, @nil_typ
  %1007 = icmp ne ptr %998, null
  %.not94.i2707 = and i1 %1006, %1007
  br i1 %.not94.i2707, label %.cont.i2712, label %1012

.cont.i2712:                                      ; preds = %975
  %1008 = add nuw nsw i32 %.0290.i2690, 1
  %1009 = xor i1 %.074289.i2691, true
  %hash_coef_ptr.i.i46.i2713 = getelementptr i8, ptr %998, i64 8
  %tbl_size_ptr.i.i47.i2714 = getelementptr i8, ptr %998, i64 16
  %offset_tbl_ptr.i.i48.i2715 = getelementptr i8, ptr %998, i64 40
  %hash_coef.i.i49.i2716 = load i64, ptr %hash_coef_ptr.i.i46.i2713, align 4
  %tbl_size.i.i50.i2717 = load i64, ptr %tbl_size_ptr.i.i47.i2714, align 4
  %offset_tbl.i.i51.i2718 = load ptr, ptr %offset_tbl_ptr.i.i48.i2715, align 8
  %product.i.i.i52.i2719 = mul i64 %hash_coef.i.i49.i2716, 4015701072841558310
  %shifted.i.i.i53.i2720 = lshr i64 %product.i.i.i52.i2719, 32
  %xored.i.i.i54.i2721 = xor i64 %shifted.i.i.i53.i2720, %product.i.i.i52.i2719
  %hash.i.i.i55.i2722 = and i64 %xored.i.i.i54.i2721, %tbl_size.i.i50.i2717
  %offset_ptr.i.i56.i2723 = getelementptr i32, ptr %offset_tbl.i.i51.i2718, i64 %hash.i.i.i55.i2722
  %offset.i.i57.i2724 = load i32, ptr %offset_ptr.i.i56.i2723, align 4
  %1010 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1011 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2725 = icmp eq i32 %1008, 100
  br i1 %exitcond.not.i2725, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2734, label %975

1012:                                             ; preds = %975
  %1013 = load i32, ptr %88, align 4
  %1014 = add i32 %1013, 1
  %1015 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1014, ptr %88, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2734

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2734: ; preds = %1012, %.cont.i2712
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  br label %._crit_edge.i1964

._crit_edge.i1964:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2734, %961
  %indvars.iv.next.i1965 = add nuw nsw i64 %indvars.iv.i1962, 1
  %exitcond.not.i1966 = icmp eq i64 %indvars.iv.next.i1965, %wide.trip.count.i1923
  br i1 %exitcond.not.i1966, label %CuckooMap_insert_keyK_valueV.exit, label %961

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i1964, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1946.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1005, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit875, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store ptr @_parameterization_i32, ptr %69, align 8
  %1016 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %69)
  %1017 = load ptr, ptr %94, align 8
  %1018 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %1019 = sext i32 %.0279207 to i64
  %1020 = shl nsw i64 %1019, 2
  %1021 = getelementptr i8, ptr %1017, i64 %1020
  store i32 %128, ptr %1021, align 1
  store i1 true, ptr %.sroa.0237.sroa.0, align 8
  %.sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.0. = load i8, ptr %.sroa.0237.sroa.0, align 8
  %.sroa.0237.0.insert.ext = zext i8 %.sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.0. to i160
  %1022 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0237.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1023 = load ptr, ptr %102, align 8
  %1024 = call i32 %1023({ ptr, i160 } %129) #53
  %1025 = load i32, ptr %104, align 8
  %1026 = add i32 %1025, -1
  %1027 = and i32 %1026, %1024
  %1028 = load ptr, ptr %105, align 8
  %1029 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1030 = sext i32 %1027 to i64
  %1031 = shl nsw i64 %1030, 5
  %1032 = getelementptr i8, ptr %1028, i64 %1031
  %1033 = load ptr, ptr %1032, align 8
  %1034 = getelementptr i8, ptr %1032, i64 8
  %1035 = icmp ne ptr %1033, @nil_typ
  %1036 = icmp ne ptr %1033, null
  %.not66.i1070 = and i1 %1035, %1036
  br i1 %.not66.i1070, label %1037, label %1135

1037:                                             ; preds = %CuckooMap_insert_keyK_valueV.exit
  %1038 = load i64, ptr %1034, align 4
  %.sroa_idx.i1072 = getelementptr i8, ptr %1032, i64 16
  %1039 = load i64, ptr %.sroa_idx.i1072, align 4
  %1040 = inttoptr i64 %1038 to ptr
  %1041 = inttoptr i64 %1039 to ptr
  %hash_coef_ptr.i.i11.i1073 = getelementptr i8, ptr %1033, i64 8
  %tbl_size_ptr.i.i12.i1074 = getelementptr i8, ptr %1033, i64 16
  %offset_tbl_ptr.i.i13.i1075 = getelementptr i8, ptr %1033, i64 40
  %hash_coef.i.i14.i1076 = load i64, ptr %hash_coef_ptr.i.i11.i1073, align 4, !noalias !200
  %tbl_size.i.i15.i1077 = load i64, ptr %tbl_size_ptr.i.i12.i1074, align 4, !noalias !200
  %offset_tbl.i.i16.i1078 = load ptr, ptr %offset_tbl_ptr.i.i13.i1075, align 8, !noalias !200
  %product.i.i.i17.i1079 = mul i64 %hash_coef.i.i14.i1076, 4015701072841558310
  %shifted.i.i.i18.i1080 = lshr i64 %product.i.i.i17.i1079, 32
  %xored.i.i.i19.i1081 = xor i64 %shifted.i.i.i18.i1080, %product.i.i.i17.i1079
  %hash.i.i.i20.i1082 = and i64 %xored.i.i.i19.i1081, %tbl_size.i.i15.i1077
  %offset_ptr.i.i21.i1083 = getelementptr i32, ptr %offset_tbl.i.i16.i1078, i64 %hash.i.i.i20.i1082
  %offset.i.i22.i1084 = load i32, ptr %offset_ptr.i.i21.i1083, align 4, !noalias !200
  %1042 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1033, 0
  %1043 = insertvalue { ptr, ptr, ptr, i32 } %1042, ptr %1040, 1
  %1044 = insertvalue { ptr, ptr, ptr, i32 } %1043, ptr %1041, 2
  %1045 = insertvalue { ptr, ptr, ptr, i32 } %1044, i32 %offset.i.i22.i1084, 3
  %1046 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1047 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1033) #40
  %1048 = sext i32 %offset.i.i22.i1084 to i64
  %1049 = getelementptr ptr, ptr %1033, i64 %1048
  %1050 = getelementptr i8, ptr %1049, i64 64
  %1051 = load ptr, ptr %1050, align 8
  %result.i8.i1085 = call ptr %1051({ ptr, ptr, ptr, i32 } %1045, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1052 = call i32 %result.i8.i1085({ ptr, ptr, ptr, i32 } %1045, { ptr, ptr, ptr, i32 } %1045, ptr nonnull align 8 %2) #53
  %1053 = icmp eq i32 %1052, %1024
  br i1 %1053, label %._crit_edge.i1086, label %1135

._crit_edge.i1086:                                ; preds = %1037
  %1054 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1055 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1033)
  %1056 = getelementptr i8, ptr %1049, i64 48
  %1057 = load ptr, ptr %1056, align 8
  %result.i7.i1087 = call ptr %1057({ ptr, ptr, ptr, i32 } %1045, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1058 = call { ptr, i160 } %result.i7.i1087({ ptr, ptr, ptr, i32 } %1045, { ptr, ptr, ptr, i32 } %1045, ptr nonnull align 8 %2) #53
  %1059 = load ptr, ptr %103, align 8
  %1060 = call i1 %1059({ ptr, i160 } %1058, { ptr, i160 } %129) #53
  br i1 %1060, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1099, label %1135

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1099: ; preds = %._crit_edge.i1086
  %1061 = load ptr, ptr %result.i58, align 8
  %1062 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1063 = load ptr, ptr %97, align 8
  %1064 = load ptr, ptr %1061, align 8, !alias.scope !203
  %1065 = getelementptr i8, ptr %1064, i64 72
  %1066 = load ptr, ptr %1065, align 8, !alias.scope !203
  %result.i1.i.i1091 = call { i64, i64 } %1066(ptr nocapture nofree nonnull readonly align 8 %1061) #44, !alias.scope !203
  %1067 = extractvalue { i64, i64 } %result.i1.i.i1091, 0
  %1068 = extractvalue { i64, i64 } %result.i1.i.i1091, 1
  %1069 = urem i64 20, %1068
  %1070 = icmp eq i64 %1069, 0
  %1071 = sub i64 %1068, %1069
  %1072 = select i1 %1070, i64 0, i64 %1071
  %1073 = add i64 %1067, 20
  %1074 = add i64 %1073, %1072
  %1075 = load ptr, ptr %1063, align 8, !alias.scope !203
  %1076 = getelementptr i8, ptr %1075, i64 72
  %1077 = load ptr, ptr %1076, align 8, !alias.scope !203
  %result.i.i.i1092 = call { i64, i64 } %1077(ptr nocapture nofree nonnull readonly align 8 %1063) #44, !alias.scope !203
  %1078 = extractvalue { i64, i64 } %result.i.i.i1092, 0
  %1079 = extractvalue { i64, i64 } %result.i.i.i1092, 1
  %1080 = call i64 @llvm.umax.i64(i64 %1068, i64 %1079) #41
  %1081 = call i64 @llvm.umax.i64(i64 %1080, i64 noundef 8) #41, !range !16
  %1082 = urem i64 %1074, %1079
  %1083 = icmp eq i64 %1082, 0
  %1084 = sub i64 %1079, %1082
  %1085 = select i1 %1083, i64 0, i64 %1084
  %1086 = add i64 %1078, %1074
  %1087 = add i64 %1086, %1085
  %1088 = urem i64 %1087, %1081
  %1089 = icmp eq i64 %1088, 0
  %1090 = sub i64 %1081, %1088
  %1091 = select i1 %1089, i64 0, i64 %1090
  %1092 = add i64 %1091, %1087
  %result.i9.i1093 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1092) #48
  store ptr %1061, ptr %result.i9.i1093, align 8
  %1093 = getelementptr inbounds i8, ptr %result.i9.i1093, i64 8
  store ptr %1063, ptr %1093, align 8
  %1094 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1093)
  %1095 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1096 = load ptr, ptr %1061, align 8
  %1097 = getelementptr i8, ptr %1096, i64 72
  %1098 = load ptr, ptr %1097, align 8
  %result.i.i38.i1094 = call { i64, i64 } %1098(ptr nocapture nofree nonnull readonly align 8 %1061) #44
  %1099 = extractvalue { i64, i64 } %result.i.i38.i1094, 1
  %1100 = urem i64 20, %1099
  %1101 = icmp eq i64 %1100, 0
  %reass.sub3452 = sub i64 %1099, %1100
  %1102 = add i64 %reass.sub3452, 20
  %1103 = select i1 %1101, i64 20, i64 %1102
  %1104 = getelementptr i8, ptr %result.i9.i1093, i64 %1103
  %1105 = getelementptr i8, ptr %1096, i64 64
  %1106 = load ptr, ptr %1105, align 8
  call void %1106({ ptr, i160 } %129, ptr nocapture nofree nonnull readonly align 8 %1061, ptr nocapture nofree writeonly %1104) #45
  %1107 = load ptr, ptr %result.i9.i1093, align 8
  %1108 = load ptr, ptr %1107, align 8
  %1109 = getelementptr i8, ptr %1108, i64 72
  %1110 = load ptr, ptr %1109, align 8
  %result.i1.i39.i1096 = call { i64, i64 } %1110(ptr nocapture nofree nonnull readonly align 8 %1107) #44
  %1111 = extractvalue { i64, i64 } %result.i1.i39.i1096, 0
  %1112 = extractvalue { i64, i64 } %result.i1.i39.i1096, 1
  %1113 = urem i64 20, %1112
  %1114 = icmp eq i64 %1113, 0
  %1115 = sub i64 %1112, %1113
  %1116 = select i1 %1114, i64 0, i64 %1115
  %1117 = add i64 %1111, 20
  %1118 = add i64 %1117, %1116
  %1119 = load ptr, ptr %1093, align 8
  %1120 = load ptr, ptr %1119, align 8
  %1121 = getelementptr i8, ptr %1120, i64 72
  %1122 = load ptr, ptr %1121, align 8
  %result.i.i40.i1097 = call { i64, i64 } %1122(ptr nocapture nofree nonnull readonly align 8 %1119) #44
  %1123 = extractvalue { i64, i64 } %result.i.i40.i1097, 1
  %1124 = urem i64 %1118, %1123
  %1125 = icmp eq i64 %1124, 0
  %1126 = sub i64 %1123, %1124
  %1127 = select i1 %1125, i64 0, i64 %1126
  %1128 = getelementptr i8, ptr %result.i9.i1093, i64 %1118
  %1129 = getelementptr i8, ptr %1128, i64 %1127
  %1130 = getelementptr i8, ptr %1120, i64 64
  %1131 = load ptr, ptr %1130, align 8
  call void %1131({ ptr, i160 } %1022, ptr nocapture nofree nonnull readonly align 8 %1119, ptr nocapture nofree writeonly %1129) #45
  %1132 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1133 = getelementptr inbounds i8, ptr %result.i9.i1093, i64 16
  store i32 %1024, ptr %1133, align 8
  store ptr @Entry, ptr %1032, align 8
  %1134 = ptrtoint ptr %result.i9.i1093 to i64
  store i64 %1134, ptr %1034, align 4
  %.sroa_idx30.i1098 = getelementptr i8, ptr %1032, i64 24
  store i32 10, ptr %.sroa_idx30.i1098, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit423

1135:                                             ; preds = %._crit_edge.i1086, %1037, %CuckooMap_insert_keyK_valueV.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1136 = add i32 %1024, 2127912214
  %1137 = shl i32 %1024, 12
  %1138 = add i32 %1136, %1137
  %1139 = ashr i32 %1138, 19
  %1140 = xor i32 %1138, %1139
  %1141 = xor i32 %1140, -949894596
  %1142 = add i32 %1141, 374761393
  %1143 = shl i32 %1141, 5
  %1144 = add i32 %1142, %1143
  %1145 = add i32 %1144, -744332180
  %1146 = shl i32 %1144, 9
  %1147 = xor i32 %1145, %1146
  %1148 = add i32 %1147, -42973499
  %1149 = shl i32 %1147, 3
  %1150 = add i32 %1148, %1149
  %1151 = ashr i32 %1150, 16
  %1152 = xor i32 %1150, %1151
  %1153 = xor i32 %1152, -1252372727
  %1154 = load i32, ptr %104, align 8
  %1155 = add i32 %1154, -1
  %1156 = and i32 %1155, %1153
  %1157 = load ptr, ptr %106, align 8
  %1158 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1159 = sext i32 %1156 to i64
  %1160 = shl nsw i64 %1159, 5
  %1161 = getelementptr i8, ptr %1157, i64 %1160
  %1162 = load ptr, ptr %1161, align 8
  %1163 = getelementptr i8, ptr %1161, i64 8
  %1164 = icmp ne ptr %1162, @nil_typ
  %1165 = icmp ne ptr %1162, null
  %.not66.i1129 = and i1 %1164, %1165
  br i1 %.not66.i1129, label %1166, label %1264

1166:                                             ; preds = %1135
  %1167 = load i64, ptr %1163, align 4
  %.sroa_idx.i1131 = getelementptr i8, ptr %1161, i64 16
  %1168 = load i64, ptr %.sroa_idx.i1131, align 4
  %1169 = inttoptr i64 %1167 to ptr
  %1170 = inttoptr i64 %1168 to ptr
  %hash_coef_ptr.i.i11.i1132 = getelementptr i8, ptr %1162, i64 8
  %tbl_size_ptr.i.i12.i1133 = getelementptr i8, ptr %1162, i64 16
  %offset_tbl_ptr.i.i13.i1134 = getelementptr i8, ptr %1162, i64 40
  %hash_coef.i.i14.i1135 = load i64, ptr %hash_coef_ptr.i.i11.i1132, align 4, !noalias !206
  %tbl_size.i.i15.i1136 = load i64, ptr %tbl_size_ptr.i.i12.i1133, align 4, !noalias !206
  %offset_tbl.i.i16.i1137 = load ptr, ptr %offset_tbl_ptr.i.i13.i1134, align 8, !noalias !206
  %product.i.i.i17.i1138 = mul i64 %hash_coef.i.i14.i1135, 4015701072841558310
  %shifted.i.i.i18.i1139 = lshr i64 %product.i.i.i17.i1138, 32
  %xored.i.i.i19.i1140 = xor i64 %shifted.i.i.i18.i1139, %product.i.i.i17.i1138
  %hash.i.i.i20.i1141 = and i64 %xored.i.i.i19.i1140, %tbl_size.i.i15.i1136
  %offset_ptr.i.i21.i1142 = getelementptr i32, ptr %offset_tbl.i.i16.i1137, i64 %hash.i.i.i20.i1141
  %offset.i.i22.i1143 = load i32, ptr %offset_ptr.i.i21.i1142, align 4, !noalias !206
  %1171 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1162, 0
  %1172 = insertvalue { ptr, ptr, ptr, i32 } %1171, ptr %1169, 1
  %1173 = insertvalue { ptr, ptr, ptr, i32 } %1172, ptr %1170, 2
  %1174 = insertvalue { ptr, ptr, ptr, i32 } %1173, i32 %offset.i.i22.i1143, 3
  %1175 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1176 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1162) #40
  %1177 = sext i32 %offset.i.i22.i1143 to i64
  %1178 = getelementptr ptr, ptr %1162, i64 %1177
  %1179 = getelementptr i8, ptr %1178, i64 64
  %1180 = load ptr, ptr %1179, align 8
  %result.i8.i1144 = call ptr %1180({ ptr, ptr, ptr, i32 } %1174, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1181 = call i32 %result.i8.i1144({ ptr, ptr, ptr, i32 } %1174, { ptr, ptr, ptr, i32 } %1174, ptr nonnull align 8 %2) #53
  %1182 = icmp eq i32 %1181, %1024
  br i1 %1182, label %._crit_edge.i1145, label %1264

._crit_edge.i1145:                                ; preds = %1166
  %1183 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1184 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1162)
  %1185 = getelementptr i8, ptr %1178, i64 48
  %1186 = load ptr, ptr %1185, align 8
  %result.i7.i1146 = call ptr %1186({ ptr, ptr, ptr, i32 } %1174, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1187 = call { ptr, i160 } %result.i7.i1146({ ptr, ptr, ptr, i32 } %1174, { ptr, ptr, ptr, i32 } %1174, ptr nonnull align 8 %2) #53
  %1188 = load ptr, ptr %103, align 8
  %1189 = call i1 %1188({ ptr, i160 } %1187, { ptr, i160 } %129) #53
  br i1 %1189, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1158, label %1264

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1158: ; preds = %._crit_edge.i1145
  %1190 = load ptr, ptr %result.i58, align 8
  %1191 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1192 = load ptr, ptr %97, align 8
  %1193 = load ptr, ptr %1190, align 8, !alias.scope !209
  %1194 = getelementptr i8, ptr %1193, i64 72
  %1195 = load ptr, ptr %1194, align 8, !alias.scope !209
  %result.i1.i.i1150 = call { i64, i64 } %1195(ptr nocapture nofree nonnull readonly align 8 %1190) #44, !alias.scope !209
  %1196 = extractvalue { i64, i64 } %result.i1.i.i1150, 0
  %1197 = extractvalue { i64, i64 } %result.i1.i.i1150, 1
  %1198 = urem i64 20, %1197
  %1199 = icmp eq i64 %1198, 0
  %1200 = sub i64 %1197, %1198
  %1201 = select i1 %1199, i64 0, i64 %1200
  %1202 = add i64 %1196, 20
  %1203 = add i64 %1202, %1201
  %1204 = load ptr, ptr %1192, align 8, !alias.scope !209
  %1205 = getelementptr i8, ptr %1204, i64 72
  %1206 = load ptr, ptr %1205, align 8, !alias.scope !209
  %result.i.i.i1151 = call { i64, i64 } %1206(ptr nocapture nofree nonnull readonly align 8 %1192) #44, !alias.scope !209
  %1207 = extractvalue { i64, i64 } %result.i.i.i1151, 0
  %1208 = extractvalue { i64, i64 } %result.i.i.i1151, 1
  %1209 = call i64 @llvm.umax.i64(i64 %1197, i64 %1208) #41
  %1210 = call i64 @llvm.umax.i64(i64 %1209, i64 noundef 8) #41, !range !16
  %1211 = urem i64 %1203, %1208
  %1212 = icmp eq i64 %1211, 0
  %1213 = sub i64 %1208, %1211
  %1214 = select i1 %1212, i64 0, i64 %1213
  %1215 = add i64 %1207, %1203
  %1216 = add i64 %1215, %1214
  %1217 = urem i64 %1216, %1210
  %1218 = icmp eq i64 %1217, 0
  %1219 = sub i64 %1210, %1217
  %1220 = select i1 %1218, i64 0, i64 %1219
  %1221 = add i64 %1220, %1216
  %result.i9.i1152 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1221) #48
  store ptr %1190, ptr %result.i9.i1152, align 8
  %1222 = getelementptr inbounds i8, ptr %result.i9.i1152, i64 8
  store ptr %1192, ptr %1222, align 8
  %1223 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1152)
  %1224 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1225 = load ptr, ptr %1190, align 8
  %1226 = getelementptr i8, ptr %1225, i64 72
  %1227 = load ptr, ptr %1226, align 8
  %result.i.i38.i1153 = call { i64, i64 } %1227(ptr nocapture nofree nonnull readonly align 8 %1190) #44
  %1228 = extractvalue { i64, i64 } %result.i.i38.i1153, 1
  %1229 = urem i64 20, %1228
  %1230 = icmp eq i64 %1229, 0
  %reass.sub3451 = sub i64 %1228, %1229
  %1231 = add i64 %reass.sub3451, 20
  %1232 = select i1 %1230, i64 20, i64 %1231
  %1233 = getelementptr i8, ptr %result.i9.i1152, i64 %1232
  %1234 = getelementptr i8, ptr %1225, i64 64
  %1235 = load ptr, ptr %1234, align 8
  call void %1235({ ptr, i160 } %129, ptr nocapture nofree nonnull readonly align 8 %1190, ptr nocapture nofree writeonly %1233) #45
  %1236 = load ptr, ptr %result.i9.i1152, align 8
  %1237 = load ptr, ptr %1236, align 8
  %1238 = getelementptr i8, ptr %1237, i64 72
  %1239 = load ptr, ptr %1238, align 8
  %result.i1.i39.i1155 = call { i64, i64 } %1239(ptr nocapture nofree nonnull readonly align 8 %1236) #44
  %1240 = extractvalue { i64, i64 } %result.i1.i39.i1155, 0
  %1241 = extractvalue { i64, i64 } %result.i1.i39.i1155, 1
  %1242 = urem i64 20, %1241
  %1243 = icmp eq i64 %1242, 0
  %1244 = sub i64 %1241, %1242
  %1245 = select i1 %1243, i64 0, i64 %1244
  %1246 = add i64 %1240, 20
  %1247 = add i64 %1246, %1245
  %1248 = load ptr, ptr %1222, align 8
  %1249 = load ptr, ptr %1248, align 8
  %1250 = getelementptr i8, ptr %1249, i64 72
  %1251 = load ptr, ptr %1250, align 8
  %result.i.i40.i1156 = call { i64, i64 } %1251(ptr nocapture nofree nonnull readonly align 8 %1248) #44
  %1252 = extractvalue { i64, i64 } %result.i.i40.i1156, 1
  %1253 = urem i64 %1247, %1252
  %1254 = icmp eq i64 %1253, 0
  %1255 = sub i64 %1252, %1253
  %1256 = select i1 %1254, i64 0, i64 %1255
  %1257 = getelementptr i8, ptr %result.i9.i1152, i64 %1247
  %1258 = getelementptr i8, ptr %1257, i64 %1256
  %1259 = getelementptr i8, ptr %1249, i64 64
  %1260 = load ptr, ptr %1259, align 8
  call void %1260({ ptr, i160 } %1022, ptr nocapture nofree nonnull readonly align 8 %1248, ptr nocapture nofree writeonly %1258) #45
  %1261 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1262 = getelementptr inbounds i8, ptr %result.i9.i1152, i64 16
  store i32 %1024, ptr %1262, align 8
  store ptr @Entry, ptr %1161, align 8
  %1263 = ptrtoint ptr %result.i9.i1152 to i64
  store i64 %1263, ptr %1163, align 4
  %.sroa_idx30.i1157 = getelementptr i8, ptr %1161, i64 24
  store i32 10, ptr %.sroa_idx30.i1157, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit423

1264:                                             ; preds = %._crit_edge.i1145, %1166, %1135
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1265 = load i32, ptr %108, align 4
  %1266 = load i32, ptr %104, align 8
  %.not.i381 = icmp slt i32 %1265, %1266
  br i1 %.not.i381, label %._crit_edge.i383, label %1267

1267:                                             ; preds = %1264
  %1268 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1269 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1270 = load ptr, ptr %105, align 8
  %1271 = load ptr, ptr %106, align 8
  %1272 = shl i32 %1266, 1
  %spec.select.i1174 = call i32 @llvm.smax.i32(i32 %1272, i32 noundef 16) #40
  store i32 %spec.select.i1174, ptr %104, align 8
  %1273 = zext nneg i32 %spec.select.i1174 to i64
  %1274 = shl nuw nsw i64 %1273, 5
  %result.i5.i1175 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1274) #48
  store ptr %result.i5.i1175, ptr %105, align 8
  %result.i4.i1176 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1274) #48
  store ptr %result.i4.i1176, ptr %106, align 8
  store i32 0, ptr %108, align 4
  %1275 = icmp sgt i32 %1266, 0
  br i1 %1275, label %.lr.ph.i1986, label %._crit_edge.i383

.lr.ph.i1986:                                     ; preds = %1267
  %wide.trip.count.i1999 = zext nneg i32 %1266 to i64
  br label %1276

1276:                                             ; preds = %._crit_edge.i2002, %.lr.ph.i1986
  %indvars.iv.i2000 = phi i64 [ 0, %.lr.ph.i1986 ], [ %indvars.iv.next.i2003, %._crit_edge.i2002 ]
  %1277 = shl nuw nsw i64 %indvars.iv.i2000, 5
  %1278 = getelementptr i8, ptr %1270, i64 %1277
  %1279 = load ptr, ptr %1278, align 8
  %1280 = icmp ne ptr %1279, @nil_typ
  %1281 = icmp ne ptr %1279, null
  %.not17.i2001 = and i1 %1280, %1281
  br i1 %.not17.i2001, label %1282, label %._crit_edge.i2002

1282:                                             ; preds = %1276
  %1283 = getelementptr i8, ptr %1278, i64 8
  %1284 = load i64, ptr %1283, align 4
  %.sroa_idx.i2005 = getelementptr i8, ptr %1278, i64 16
  %1285 = load i64, ptr %.sroa_idx.i2005, align 4
  %hash_coef_ptr.i.i6.i2006 = getelementptr i8, ptr %1279, i64 8
  %tbl_size_ptr.i.i7.i2007 = getelementptr i8, ptr %1279, i64 16
  %offset_tbl_ptr.i.i8.i2008 = getelementptr i8, ptr %1279, i64 40
  %1286 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  %hash_coef.i.i21.i2752 = load i64, ptr %hash_coef_ptr.i.i6.i2006, align 4, !noalias !212
  %tbl_size.i.i22.i2753 = load i64, ptr %tbl_size_ptr.i.i7.i2007, align 4, !noalias !212
  %offset_tbl.i.i23.i2754 = load ptr, ptr %offset_tbl_ptr.i.i8.i2008, align 8, !noalias !212
  %product.i.i.i24.i2755 = mul i64 %hash_coef.i.i21.i2752, 4015701072841558310
  %shifted.i.i.i25.i2756 = lshr i64 %product.i.i.i24.i2755, 32
  %xored.i.i.i26.i2757 = xor i64 %shifted.i.i.i25.i2756, %product.i.i.i24.i2755
  %hash.i.i.i27.i2758 = and i64 %xored.i.i.i26.i2757, %tbl_size.i.i22.i2753
  %offset_ptr.i.i28.i2759 = getelementptr i32, ptr %offset_tbl.i.i23.i2754, i64 %hash.i.i.i27.i2758
  %offset.i.i29.i2760 = load i32, ptr %offset_ptr.i.i28.i2759, align 4, !noalias !212
  %1287 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1288 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1289 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1290

1290:                                             ; preds = %.cont.i2783, %1282
  %.0290.i2761 = phi i32 [ 0, %1282 ], [ %1323, %.cont.i2783 ]
  %.074289.i2762 = phi i1 [ true, %1282 ], [ %1324, %.cont.i2783 ]
  %.sroa.0.0288.i2763 = phi ptr [ %1279, %1282 ], [ %1313, %.cont.i2783 ]
  %.sroa.6.0287.i2764.in = phi i64 [ %1284, %1282 ], [ %1315, %.cont.i2783 ]
  %.sroa.12.0286.i2765.in = phi i64 [ %1285, %1282 ], [ %1316, %.cont.i2783 ]
  %.sroa.17.0285.i2766 = phi i32 [ %offset.i.i29.i2760, %1282 ], [ %offset.i.i57.i2795, %.cont.i2783 ]
  %.sroa.12.0286.i2765 = inttoptr i64 %.sroa.12.0286.i2765.in to ptr
  %.sroa.6.0287.i2764 = inttoptr i64 %.sroa.6.0287.i2764.in to ptr
  %1291 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2763, 0
  %1292 = insertvalue { ptr, ptr, ptr, i32 } %1291, ptr %.sroa.6.0287.i2764, 1
  %1293 = insertvalue { ptr, ptr, ptr, i32 } %1292, ptr %.sroa.12.0286.i2765, 2
  %1294 = insertvalue { ptr, ptr, ptr, i32 } %1293, i32 %.sroa.17.0285.i2766, 3
  %1295 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2763)
  %1296 = sext i32 %.sroa.17.0285.i2766 to i64
  %1297 = getelementptr ptr, ptr %.sroa.0.0288.i2763, i64 %1296
  %1298 = getelementptr i8, ptr %1297, i64 64
  %1299 = load ptr, ptr %1298, align 8
  %result.i15.i2767 = call ptr %1299({ ptr, ptr, ptr, i32 } %1294, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1300 = call i32 %result.i15.i2767({ ptr, ptr, ptr, i32 } %1294, { ptr, ptr, ptr, i32 } %1294, ptr nonnull align 8 %2) #53
  %..i2768 = select i1 %.074289.i2762, ptr %24, ptr %26
  %.188.i2769 = select i1 %.074289.i2762, i64 104, i64 112
  %.189.i2770 = select i1 %.074289.i2762, ptr %25, ptr %27
  %.190.i2771 = select i1 %.074289.i2762, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2768, align 8
  %1301 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2768)
  %1302 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2769
  %1303 = load ptr, ptr %1302, align 8
  store ptr @i32_typ, ptr %.189.i2770, align 8
  %result.i14.i2772 = call ptr %1303({ ptr, ptr, ptr, i32 } %123, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2770) #46
  %1304 = call i32 %result.i14.i2772({ ptr, ptr, ptr, i32 } %123, { ptr, ptr, ptr, i32 } %123, ptr nonnull align 8 dereferenceable(8) %..i2768, i32 %1300) #53
  %1305 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1306 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2771
  %1307 = load ptr, ptr %1306, align 8
  %1308 = load ptr, ptr %1307, align 8
  %1309 = call { ptr } %1308(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i2773 = extractvalue { ptr } %1309, 0
  %1310 = sext i32 %1304 to i64
  %1311 = shl nsw i64 %1310, 5
  %1312 = getelementptr i8, ptr %.fca.0.extract55.i2773, i64 %1311
  %1313 = load ptr, ptr %1312, align 8
  %1314 = getelementptr i8, ptr %1312, i64 8
  %1315 = load i64, ptr %1314, align 4
  %.sroa_idx.i2774 = getelementptr i8, ptr %1312, i64 16
  %1316 = load i64, ptr %.sroa_idx.i2774, align 4
  %1317 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1318 = call { ptr } %1308(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i2775 = extractvalue { ptr } %1318, 0
  %1319 = getelementptr i8, ptr %.fca.0.extract52.i2775, i64 %1311
  store ptr %.sroa.0.0288.i2763, ptr %1319, align 8
  %1320 = getelementptr i8, ptr %1319, i64 8
  store i64 %.sroa.6.0287.i2764.in, ptr %1320, align 4
  %.sroa_idx104.i2776 = getelementptr i8, ptr %1319, i64 16
  store i64 %.sroa.12.0286.i2765.in, ptr %.sroa_idx104.i2776, align 4
  %.sroa_idx105.i2777 = getelementptr i8, ptr %1319, i64 24
  store i32 %.sroa.17.0285.i2766, ptr %.sroa_idx105.i2777, align 4
  %1321 = icmp ne ptr %1313, @nil_typ
  %1322 = icmp ne ptr %1313, null
  %.not94.i2778 = and i1 %1321, %1322
  br i1 %.not94.i2778, label %.cont.i2783, label %1327

.cont.i2783:                                      ; preds = %1290
  %1323 = add nuw nsw i32 %.0290.i2761, 1
  %1324 = xor i1 %.074289.i2762, true
  %hash_coef_ptr.i.i46.i2784 = getelementptr i8, ptr %1313, i64 8
  %tbl_size_ptr.i.i47.i2785 = getelementptr i8, ptr %1313, i64 16
  %offset_tbl_ptr.i.i48.i2786 = getelementptr i8, ptr %1313, i64 40
  %hash_coef.i.i49.i2787 = load i64, ptr %hash_coef_ptr.i.i46.i2784, align 4
  %tbl_size.i.i50.i2788 = load i64, ptr %tbl_size_ptr.i.i47.i2785, align 4
  %offset_tbl.i.i51.i2789 = load ptr, ptr %offset_tbl_ptr.i.i48.i2786, align 8
  %product.i.i.i52.i2790 = mul i64 %hash_coef.i.i49.i2787, 4015701072841558310
  %shifted.i.i.i53.i2791 = lshr i64 %product.i.i.i52.i2790, 32
  %xored.i.i.i54.i2792 = xor i64 %shifted.i.i.i53.i2791, %product.i.i.i52.i2790
  %hash.i.i.i55.i2793 = and i64 %xored.i.i.i54.i2792, %tbl_size.i.i50.i2788
  %offset_ptr.i.i56.i2794 = getelementptr i32, ptr %offset_tbl.i.i51.i2789, i64 %hash.i.i.i55.i2793
  %offset.i.i57.i2795 = load i32, ptr %offset_ptr.i.i56.i2794, align 4
  %1325 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1326 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2796 = icmp eq i32 %1323, 100
  br i1 %exitcond.not.i2796, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2805, label %1290

1327:                                             ; preds = %1290
  %1328 = load i32, ptr %108, align 4
  %1329 = add i32 %1328, 1
  %1330 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1329, ptr %108, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2805

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2805: ; preds = %1327, %.cont.i2783
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  br label %._crit_edge.i2002

._crit_edge.i2002:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2805, %1276
  %indvars.iv.next.i2003 = add nuw nsw i64 %indvars.iv.i2000, 1
  %exitcond.not.i2004 = icmp eq i64 %indvars.iv.next.i2003, %wide.trip.count.i1999
  br i1 %exitcond.not.i2004, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2022, label %1276

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2022: ; preds = %._crit_edge.i2040, %._crit_edge.i2002
  %indvars.iv.i2038 = phi i64 [ %indvars.iv.next.i2041, %._crit_edge.i2040 ], [ 0, %._crit_edge.i2002 ]
  %1331 = shl nuw nsw i64 %indvars.iv.i2038, 5
  %1332 = getelementptr i8, ptr %1271, i64 %1331
  %1333 = load ptr, ptr %1332, align 8
  %1334 = icmp ne ptr %1333, @nil_typ
  %1335 = icmp ne ptr %1333, null
  %.not17.i2039 = and i1 %1334, %1335
  br i1 %.not17.i2039, label %1336, label %._crit_edge.i2040

1336:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2022
  %1337 = getelementptr i8, ptr %1332, i64 8
  %1338 = load i64, ptr %1337, align 4
  %.sroa_idx.i2043 = getelementptr i8, ptr %1332, i64 16
  %1339 = load i64, ptr %.sroa_idx.i2043, align 4
  %hash_coef_ptr.i.i6.i2044 = getelementptr i8, ptr %1333, i64 8
  %tbl_size_ptr.i.i7.i2045 = getelementptr i8, ptr %1333, i64 16
  %offset_tbl_ptr.i.i8.i2046 = getelementptr i8, ptr %1333, i64 40
  %1340 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  %hash_coef.i.i21.i2823 = load i64, ptr %hash_coef_ptr.i.i6.i2044, align 4, !noalias !215
  %tbl_size.i.i22.i2824 = load i64, ptr %tbl_size_ptr.i.i7.i2045, align 4, !noalias !215
  %offset_tbl.i.i23.i2825 = load ptr, ptr %offset_tbl_ptr.i.i8.i2046, align 8, !noalias !215
  %product.i.i.i24.i2826 = mul i64 %hash_coef.i.i21.i2823, 4015701072841558310
  %shifted.i.i.i25.i2827 = lshr i64 %product.i.i.i24.i2826, 32
  %xored.i.i.i26.i2828 = xor i64 %shifted.i.i.i25.i2827, %product.i.i.i24.i2826
  %hash.i.i.i27.i2829 = and i64 %xored.i.i.i26.i2828, %tbl_size.i.i22.i2824
  %offset_ptr.i.i28.i2830 = getelementptr i32, ptr %offset_tbl.i.i23.i2825, i64 %hash.i.i.i27.i2829
  %offset.i.i29.i2831 = load i32, ptr %offset_ptr.i.i28.i2830, align 4, !noalias !215
  %1341 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1342 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1343 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1344

1344:                                             ; preds = %.cont.i2854, %1336
  %.0290.i2832 = phi i32 [ 0, %1336 ], [ %1377, %.cont.i2854 ]
  %.074289.i2833 = phi i1 [ true, %1336 ], [ %1378, %.cont.i2854 ]
  %.sroa.0.0288.i2834 = phi ptr [ %1333, %1336 ], [ %1367, %.cont.i2854 ]
  %.sroa.6.0287.i2835.in = phi i64 [ %1338, %1336 ], [ %1369, %.cont.i2854 ]
  %.sroa.12.0286.i2836.in = phi i64 [ %1339, %1336 ], [ %1370, %.cont.i2854 ]
  %.sroa.17.0285.i2837 = phi i32 [ %offset.i.i29.i2831, %1336 ], [ %offset.i.i57.i2866, %.cont.i2854 ]
  %.sroa.12.0286.i2836 = inttoptr i64 %.sroa.12.0286.i2836.in to ptr
  %.sroa.6.0287.i2835 = inttoptr i64 %.sroa.6.0287.i2835.in to ptr
  %1345 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2834, 0
  %1346 = insertvalue { ptr, ptr, ptr, i32 } %1345, ptr %.sroa.6.0287.i2835, 1
  %1347 = insertvalue { ptr, ptr, ptr, i32 } %1346, ptr %.sroa.12.0286.i2836, 2
  %1348 = insertvalue { ptr, ptr, ptr, i32 } %1347, i32 %.sroa.17.0285.i2837, 3
  %1349 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2834)
  %1350 = sext i32 %.sroa.17.0285.i2837 to i64
  %1351 = getelementptr ptr, ptr %.sroa.0.0288.i2834, i64 %1350
  %1352 = getelementptr i8, ptr %1351, i64 64
  %1353 = load ptr, ptr %1352, align 8
  %result.i15.i2838 = call ptr %1353({ ptr, ptr, ptr, i32 } %1348, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1354 = call i32 %result.i15.i2838({ ptr, ptr, ptr, i32 } %1348, { ptr, ptr, ptr, i32 } %1348, ptr nonnull align 8 %2) #53
  %..i2839 = select i1 %.074289.i2833, ptr %20, ptr %22
  %.188.i2840 = select i1 %.074289.i2833, i64 104, i64 112
  %.189.i2841 = select i1 %.074289.i2833, ptr %21, ptr %23
  %.190.i2842 = select i1 %.074289.i2833, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2839, align 8
  %1355 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2839)
  %1356 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2840
  %1357 = load ptr, ptr %1356, align 8
  store ptr @i32_typ, ptr %.189.i2841, align 8
  %result.i14.i2843 = call ptr %1357({ ptr, ptr, ptr, i32 } %123, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2841) #46
  %1358 = call i32 %result.i14.i2843({ ptr, ptr, ptr, i32 } %123, { ptr, ptr, ptr, i32 } %123, ptr nonnull align 8 dereferenceable(8) %..i2839, i32 %1354) #53
  %1359 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1360 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2842
  %1361 = load ptr, ptr %1360, align 8
  %1362 = load ptr, ptr %1361, align 8
  %1363 = call { ptr } %1362(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i2844 = extractvalue { ptr } %1363, 0
  %1364 = sext i32 %1358 to i64
  %1365 = shl nsw i64 %1364, 5
  %1366 = getelementptr i8, ptr %.fca.0.extract55.i2844, i64 %1365
  %1367 = load ptr, ptr %1366, align 8
  %1368 = getelementptr i8, ptr %1366, i64 8
  %1369 = load i64, ptr %1368, align 4
  %.sroa_idx.i2845 = getelementptr i8, ptr %1366, i64 16
  %1370 = load i64, ptr %.sroa_idx.i2845, align 4
  %1371 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1372 = call { ptr } %1362(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i2846 = extractvalue { ptr } %1372, 0
  %1373 = getelementptr i8, ptr %.fca.0.extract52.i2846, i64 %1365
  store ptr %.sroa.0.0288.i2834, ptr %1373, align 8
  %1374 = getelementptr i8, ptr %1373, i64 8
  store i64 %.sroa.6.0287.i2835.in, ptr %1374, align 4
  %.sroa_idx104.i2847 = getelementptr i8, ptr %1373, i64 16
  store i64 %.sroa.12.0286.i2836.in, ptr %.sroa_idx104.i2847, align 4
  %.sroa_idx105.i2848 = getelementptr i8, ptr %1373, i64 24
  store i32 %.sroa.17.0285.i2837, ptr %.sroa_idx105.i2848, align 4
  %1375 = icmp ne ptr %1367, @nil_typ
  %1376 = icmp ne ptr %1367, null
  %.not94.i2849 = and i1 %1375, %1376
  br i1 %.not94.i2849, label %.cont.i2854, label %1381

.cont.i2854:                                      ; preds = %1344
  %1377 = add nuw nsw i32 %.0290.i2832, 1
  %1378 = xor i1 %.074289.i2833, true
  %hash_coef_ptr.i.i46.i2855 = getelementptr i8, ptr %1367, i64 8
  %tbl_size_ptr.i.i47.i2856 = getelementptr i8, ptr %1367, i64 16
  %offset_tbl_ptr.i.i48.i2857 = getelementptr i8, ptr %1367, i64 40
  %hash_coef.i.i49.i2858 = load i64, ptr %hash_coef_ptr.i.i46.i2855, align 4
  %tbl_size.i.i50.i2859 = load i64, ptr %tbl_size_ptr.i.i47.i2856, align 4
  %offset_tbl.i.i51.i2860 = load ptr, ptr %offset_tbl_ptr.i.i48.i2857, align 8
  %product.i.i.i52.i2861 = mul i64 %hash_coef.i.i49.i2858, 4015701072841558310
  %shifted.i.i.i53.i2862 = lshr i64 %product.i.i.i52.i2861, 32
  %xored.i.i.i54.i2863 = xor i64 %shifted.i.i.i53.i2862, %product.i.i.i52.i2861
  %hash.i.i.i55.i2864 = and i64 %xored.i.i.i54.i2863, %tbl_size.i.i50.i2859
  %offset_ptr.i.i56.i2865 = getelementptr i32, ptr %offset_tbl.i.i51.i2860, i64 %hash.i.i.i55.i2864
  %offset.i.i57.i2866 = load i32, ptr %offset_ptr.i.i56.i2865, align 4
  %1379 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1380 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2867 = icmp eq i32 %1377, 100
  br i1 %exitcond.not.i2867, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2876, label %1344

1381:                                             ; preds = %1344
  %1382 = load i32, ptr %108, align 4
  %1383 = add i32 %1382, 1
  %1384 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1383, ptr %108, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2876

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2876: ; preds = %1381, %.cont.i2854
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  br label %._crit_edge.i2040

._crit_edge.i2040:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2876, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2022
  %indvars.iv.next.i2041 = add nuw nsw i64 %indvars.iv.i2038, 1
  %exitcond.not.i2042 = icmp eq i64 %indvars.iv.next.i2041, %wide.trip.count.i1999
  br i1 %exitcond.not.i2042, label %._crit_edge.i383, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2022

._crit_edge.i383:                                 ; preds = %._crit_edge.i2040, %1267, %1264
  %1385 = load ptr, ptr %result.i58, align 8
  %1386 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1387 = load ptr, ptr %97, align 8
  %1388 = load ptr, ptr %1385, align 8
  %1389 = getelementptr i8, ptr %1388, i64 72
  %1390 = load ptr, ptr %1389, align 8
  %result.i1.i.i386 = call { i64, i64 } %1390(ptr nocapture nofree nonnull readonly align 8 %1385) #44
  %1391 = extractvalue { i64, i64 } %result.i1.i.i386, 0
  %1392 = extractvalue { i64, i64 } %result.i1.i.i386, 1
  %1393 = urem i64 20, %1392
  %1394 = icmp eq i64 %1393, 0
  %1395 = sub i64 %1392, %1393
  %1396 = select i1 %1394, i64 0, i64 %1395
  %1397 = add i64 %1391, 20
  %1398 = add i64 %1397, %1396
  %1399 = load ptr, ptr %1387, align 8
  %1400 = getelementptr i8, ptr %1399, i64 72
  %1401 = load ptr, ptr %1400, align 8
  %result.i.i.i387 = call { i64, i64 } %1401(ptr nocapture nofree nonnull readonly align 8 %1387) #44
  %1402 = extractvalue { i64, i64 } %result.i.i.i387, 0
  %1403 = extractvalue { i64, i64 } %result.i.i.i387, 1
  %1404 = call i64 @llvm.umax.i64(i64 %1392, i64 %1403) #41
  %1405 = call i64 @llvm.umax.i64(i64 %1404, i64 noundef 8) #41, !range !16
  %1406 = urem i64 %1398, %1403
  %1407 = icmp eq i64 %1406, 0
  %1408 = sub i64 %1403, %1406
  %1409 = select i1 %1407, i64 0, i64 %1408
  %1410 = add i64 %1402, %1398
  %1411 = add i64 %1410, %1409
  %1412 = urem i64 %1411, %1405
  %1413 = icmp eq i64 %1412, 0
  %1414 = sub i64 %1405, %1412
  %1415 = select i1 %1413, i64 0, i64 %1414
  %1416 = add i64 %1415, %1411
  %result.i22.i388 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1416) #48
  store ptr %1385, ptr %result.i22.i388, align 8
  %1417 = getelementptr inbounds i8, ptr %result.i22.i388, i64 8
  store ptr %1387, ptr %1417, align 8
  %1418 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i388)
  %1419 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1420 = load ptr, ptr %1385, align 8
  %1421 = getelementptr i8, ptr %1420, i64 72
  %1422 = load ptr, ptr %1421, align 8
  %result.i.i127.i389 = call { i64, i64 } %1422(ptr nocapture nofree nonnull readonly align 8 %1385) #44
  %1423 = extractvalue { i64, i64 } %result.i.i127.i389, 1
  %1424 = urem i64 20, %1423
  %1425 = icmp eq i64 %1424, 0
  %reass.sub = sub i64 %1423, %1424
  %1426 = add i64 %reass.sub, 20
  %1427 = select i1 %1425, i64 20, i64 %1426
  %1428 = getelementptr i8, ptr %result.i22.i388, i64 %1427
  %1429 = getelementptr i8, ptr %1420, i64 64
  %1430 = load ptr, ptr %1429, align 8
  call void %1430({ ptr, i160 } %129, ptr nocapture nofree nonnull readonly align 8 %1385, ptr nocapture nofree writeonly %1428) #45
  %1431 = load ptr, ptr %result.i22.i388, align 8
  %1432 = load ptr, ptr %1431, align 8
  %1433 = getelementptr i8, ptr %1432, i64 72
  %1434 = load ptr, ptr %1433, align 8
  %result.i1.i128.i391 = call { i64, i64 } %1434(ptr nocapture nofree nonnull readonly align 8 %1431) #44
  %1435 = extractvalue { i64, i64 } %result.i1.i128.i391, 0
  %1436 = extractvalue { i64, i64 } %result.i1.i128.i391, 1
  %1437 = urem i64 20, %1436
  %1438 = icmp eq i64 %1437, 0
  %1439 = sub i64 %1436, %1437
  %1440 = select i1 %1438, i64 0, i64 %1439
  %1441 = add i64 %1435, 20
  %1442 = add i64 %1441, %1440
  %1443 = load ptr, ptr %1417, align 8
  %1444 = load ptr, ptr %1443, align 8
  %1445 = getelementptr i8, ptr %1444, i64 72
  %1446 = load ptr, ptr %1445, align 8
  %result.i.i129.i392 = call { i64, i64 } %1446(ptr nocapture nofree nonnull readonly align 8 %1443) #44
  %1447 = extractvalue { i64, i64 } %result.i.i129.i392, 1
  %1448 = urem i64 %1442, %1447
  %1449 = icmp eq i64 %1448, 0
  %1450 = sub i64 %1447, %1448
  %1451 = select i1 %1449, i64 0, i64 %1450
  %1452 = getelementptr i8, ptr %result.i22.i388, i64 %1442
  %1453 = getelementptr i8, ptr %1452, i64 %1451
  %1454 = getelementptr i8, ptr %1444, i64 64
  %1455 = load ptr, ptr %1454, align 8
  call void %1455({ ptr, i160 } %1022, ptr nocapture nofree nonnull readonly align 8 %1443, ptr nocapture nofree writeonly %1453) #45
  %1456 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1457 = getelementptr inbounds i8, ptr %result.i22.i388, i64 16
  store i32 %1024, ptr %1457, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  %1458 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1459 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1460 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1461

1461:                                             ; preds = %.cont.i1231, %._crit_edge.i383
  %.0290.i1209 = phi i32 [ 0, %._crit_edge.i383 ], [ %1496, %.cont.i1231 ]
  %.074289.i1210 = phi i1 [ true, %._crit_edge.i383 ], [ %1497, %.cont.i1231 ]
  %.sroa.0.0288.i1211 = phi ptr [ @Entry, %._crit_edge.i383 ], [ %1484, %.cont.i1231 ]
  %.sroa.6.0287.i1212 = phi ptr [ %result.i22.i388, %._crit_edge.i383 ], [ %1498, %.cont.i1231 ]
  %.sroa.12.0286.i1213 = phi ptr [ undef, %._crit_edge.i383 ], [ %1499, %.cont.i1231 ]
  %.sroa.17.0285.i1214 = phi i32 [ 10, %._crit_edge.i383 ], [ %offset.i.i57.i1243, %.cont.i1231 ]
  %1462 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1211, 0
  %1463 = insertvalue { ptr, ptr, ptr, i32 } %1462, ptr %.sroa.6.0287.i1212, 1
  %1464 = insertvalue { ptr, ptr, ptr, i32 } %1463, ptr %.sroa.12.0286.i1213, 2
  %1465 = insertvalue { ptr, ptr, ptr, i32 } %1464, i32 %.sroa.17.0285.i1214, 3
  %1466 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1211)
  %1467 = sext i32 %.sroa.17.0285.i1214 to i64
  %1468 = getelementptr ptr, ptr %.sroa.0.0288.i1211, i64 %1467
  %1469 = getelementptr i8, ptr %1468, i64 64
  %1470 = load ptr, ptr %1469, align 8
  %result.i15.i1215 = call ptr %1470({ ptr, ptr, ptr, i32 } %1465, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1471 = call i32 %result.i15.i1215({ ptr, ptr, ptr, i32 } %1465, { ptr, ptr, ptr, i32 } %1465, ptr nonnull align 8 %2) #53
  %..i1216 = select i1 %.074289.i1210, ptr %56, ptr %58
  %.188.i1217 = select i1 %.074289.i1210, i64 104, i64 112
  %.189.i1218 = select i1 %.074289.i1210, ptr %57, ptr %59
  %.190.i1219 = select i1 %.074289.i1210, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1216, align 8
  %1472 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1216)
  %1473 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1217
  %1474 = load ptr, ptr %1473, align 8
  store ptr @i32_typ, ptr %.189.i1218, align 8
  %result.i14.i1220 = call ptr %1474({ ptr, ptr, ptr, i32 } %118, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1218) #46
  %1475 = call i32 %result.i14.i1220({ ptr, ptr, ptr, i32 } %118, { ptr, ptr, ptr, i32 } %118, ptr nonnull align 8 dereferenceable(8) %..i1216, i32 %1471) #53
  %1476 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1477 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1219
  %1478 = load ptr, ptr %1477, align 8
  %1479 = load ptr, ptr %1478, align 8
  %1480 = call { ptr } %1479(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i1221 = extractvalue { ptr } %1480, 0
  %1481 = sext i32 %1475 to i64
  %1482 = shl nsw i64 %1481, 5
  %1483 = getelementptr i8, ptr %.fca.0.extract55.i1221, i64 %1482
  %1484 = load ptr, ptr %1483, align 8
  %1485 = getelementptr i8, ptr %1483, i64 8
  %1486 = load i64, ptr %1485, align 4
  %.sroa_idx.i1222 = getelementptr i8, ptr %1483, i64 16
  %1487 = load i64, ptr %.sroa_idx.i1222, align 4
  %1488 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1489 = call { ptr } %1479(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i1223 = extractvalue { ptr } %1489, 0
  %1490 = getelementptr i8, ptr %.fca.0.extract52.i1223, i64 %1482
  store ptr %.sroa.0.0288.i1211, ptr %1490, align 8
  %1491 = getelementptr i8, ptr %1490, i64 8
  %1492 = ptrtoint ptr %.sroa.6.0287.i1212 to i64
  %1493 = ptrtoint ptr %.sroa.12.0286.i1213 to i64
  store i64 %1492, ptr %1491, align 4
  %.sroa_idx104.i1224 = getelementptr i8, ptr %1490, i64 16
  store i64 %1493, ptr %.sroa_idx104.i1224, align 4
  %.sroa_idx105.i1225 = getelementptr i8, ptr %1490, i64 24
  store i32 %.sroa.17.0285.i1214, ptr %.sroa_idx105.i1225, align 4
  %1494 = icmp ne ptr %1484, @nil_typ
  %1495 = icmp ne ptr %1484, null
  %.not94.i1226 = and i1 %1494, %1495
  br i1 %.not94.i1226, label %.cont.i1231, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1253

.cont.i1231:                                      ; preds = %1461
  %1496 = add nuw nsw i32 %.0290.i1209, 1
  %1497 = xor i1 %.074289.i1210, true
  %1498 = inttoptr i64 %1486 to ptr
  %1499 = inttoptr i64 %1487 to ptr
  %hash_coef_ptr.i.i46.i1232 = getelementptr i8, ptr %1484, i64 8
  %tbl_size_ptr.i.i47.i1233 = getelementptr i8, ptr %1484, i64 16
  %offset_tbl_ptr.i.i48.i1234 = getelementptr i8, ptr %1484, i64 40
  %hash_coef.i.i49.i1235 = load i64, ptr %hash_coef_ptr.i.i46.i1232, align 4
  %tbl_size.i.i50.i1236 = load i64, ptr %tbl_size_ptr.i.i47.i1233, align 4
  %offset_tbl.i.i51.i1237 = load ptr, ptr %offset_tbl_ptr.i.i48.i1234, align 8
  %product.i.i.i52.i1238 = mul i64 %hash_coef.i.i49.i1235, 4015701072841558310
  %shifted.i.i.i53.i1239 = lshr i64 %product.i.i.i52.i1238, 32
  %xored.i.i.i54.i1240 = xor i64 %shifted.i.i.i53.i1239, %product.i.i.i52.i1238
  %hash.i.i.i55.i1241 = and i64 %xored.i.i.i54.i1240, %tbl_size.i.i50.i1236
  %offset_ptr.i.i56.i1242 = getelementptr i32, ptr %offset_tbl.i.i51.i1237, i64 %hash.i.i.i55.i1241
  %offset.i.i57.i1243 = load i32, ptr %offset_ptr.i.i56.i1242, align 4
  %1500 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1244 = icmp eq i32 %1496, 100
  br i1 %exitcond.not.i1244, label %1505, label %1461

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1253: ; preds = %1461
  %1502 = load i32, ptr %108, align 4
  %1503 = add i32 %1502, 1
  %1504 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1503, ptr %108, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  br label %CuckooMap_insert_keyK_valueV.exit423

1505:                                             ; preds = %.cont.i1231
  %hash_coef_ptr.i.i46.i1232.le = getelementptr i8, ptr %1484, i64 8
  %tbl_size_ptr.i.i47.i1233.le = getelementptr i8, ptr %1484, i64 16
  %offset_tbl_ptr.i.i48.i1234.le = getelementptr i8, ptr %1484, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  %1506 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1507 = load ptr, ptr %105, align 8
  %1508 = load ptr, ptr %106, align 8
  %1509 = load i32, ptr %104, align 8
  %1510 = shl i32 %1509, 1
  %spec.select.i1269 = call i32 @llvm.smax.i32(i32 %1510, i32 noundef 16) #40
  store i32 %spec.select.i1269, ptr %104, align 8
  %1511 = zext nneg i32 %spec.select.i1269 to i64
  %1512 = shl nuw nsw i64 %1511, 5
  %result.i5.i1270 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1512) #48
  store ptr %result.i5.i1270, ptr %105, align 8
  %result.i4.i1271 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1512) #48
  store ptr %result.i4.i1271, ptr %106, align 8
  store i32 0, ptr %108, align 4
  %1513 = icmp sgt i32 %1509, 0
  br i1 %1513, label %.lr.ph.i2062, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136

.lr.ph.i2062:                                     ; preds = %1505
  %wide.trip.count.i2075 = zext nneg i32 %1509 to i64
  br label %1514

1514:                                             ; preds = %._crit_edge.i2078, %.lr.ph.i2062
  %indvars.iv.i2076 = phi i64 [ 0, %.lr.ph.i2062 ], [ %indvars.iv.next.i2079, %._crit_edge.i2078 ]
  %1515 = shl nuw nsw i64 %indvars.iv.i2076, 5
  %1516 = getelementptr i8, ptr %1507, i64 %1515
  %1517 = load ptr, ptr %1516, align 8
  %1518 = icmp ne ptr %1517, @nil_typ
  %1519 = icmp ne ptr %1517, null
  %.not17.i2077 = and i1 %1518, %1519
  br i1 %.not17.i2077, label %1520, label %._crit_edge.i2078

1520:                                             ; preds = %1514
  %1521 = getelementptr i8, ptr %1516, i64 8
  %1522 = load i64, ptr %1521, align 4
  %.sroa_idx.i2081 = getelementptr i8, ptr %1516, i64 16
  %1523 = load i64, ptr %.sroa_idx.i2081, align 4
  %hash_coef_ptr.i.i6.i2082 = getelementptr i8, ptr %1517, i64 8
  %tbl_size_ptr.i.i7.i2083 = getelementptr i8, ptr %1517, i64 16
  %offset_tbl_ptr.i.i8.i2084 = getelementptr i8, ptr %1517, i64 40
  %1524 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %hash_coef.i.i21.i2894 = load i64, ptr %hash_coef_ptr.i.i6.i2082, align 4, !noalias !218
  %tbl_size.i.i22.i2895 = load i64, ptr %tbl_size_ptr.i.i7.i2083, align 4, !noalias !218
  %offset_tbl.i.i23.i2896 = load ptr, ptr %offset_tbl_ptr.i.i8.i2084, align 8, !noalias !218
  %product.i.i.i24.i2897 = mul i64 %hash_coef.i.i21.i2894, 4015701072841558310
  %shifted.i.i.i25.i2898 = lshr i64 %product.i.i.i24.i2897, 32
  %xored.i.i.i26.i2899 = xor i64 %shifted.i.i.i25.i2898, %product.i.i.i24.i2897
  %hash.i.i.i27.i2900 = and i64 %xored.i.i.i26.i2899, %tbl_size.i.i22.i2895
  %offset_ptr.i.i28.i2901 = getelementptr i32, ptr %offset_tbl.i.i23.i2896, i64 %hash.i.i.i27.i2900
  %offset.i.i29.i2902 = load i32, ptr %offset_ptr.i.i28.i2901, align 4, !noalias !218
  %1525 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1526 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1527 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1528

1528:                                             ; preds = %.cont.i2925, %1520
  %.0290.i2903 = phi i32 [ 0, %1520 ], [ %1561, %.cont.i2925 ]
  %.074289.i2904 = phi i1 [ true, %1520 ], [ %1562, %.cont.i2925 ]
  %.sroa.0.0288.i2905 = phi ptr [ %1517, %1520 ], [ %1551, %.cont.i2925 ]
  %.sroa.6.0287.i2906.in = phi i64 [ %1522, %1520 ], [ %1553, %.cont.i2925 ]
  %.sroa.12.0286.i2907.in = phi i64 [ %1523, %1520 ], [ %1554, %.cont.i2925 ]
  %.sroa.17.0285.i2908 = phi i32 [ %offset.i.i29.i2902, %1520 ], [ %offset.i.i57.i2937, %.cont.i2925 ]
  %.sroa.12.0286.i2907 = inttoptr i64 %.sroa.12.0286.i2907.in to ptr
  %.sroa.6.0287.i2906 = inttoptr i64 %.sroa.6.0287.i2906.in to ptr
  %1529 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2905, 0
  %1530 = insertvalue { ptr, ptr, ptr, i32 } %1529, ptr %.sroa.6.0287.i2906, 1
  %1531 = insertvalue { ptr, ptr, ptr, i32 } %1530, ptr %.sroa.12.0286.i2907, 2
  %1532 = insertvalue { ptr, ptr, ptr, i32 } %1531, i32 %.sroa.17.0285.i2908, 3
  %1533 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2905)
  %1534 = sext i32 %.sroa.17.0285.i2908 to i64
  %1535 = getelementptr ptr, ptr %.sroa.0.0288.i2905, i64 %1534
  %1536 = getelementptr i8, ptr %1535, i64 64
  %1537 = load ptr, ptr %1536, align 8
  %result.i15.i2909 = call ptr %1537({ ptr, ptr, ptr, i32 } %1532, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1538 = call i32 %result.i15.i2909({ ptr, ptr, ptr, i32 } %1532, { ptr, ptr, ptr, i32 } %1532, ptr nonnull align 8 %2) #53
  %..i2910 = select i1 %.074289.i2904, ptr %16, ptr %18
  %.188.i2911 = select i1 %.074289.i2904, i64 104, i64 112
  %.189.i2912 = select i1 %.074289.i2904, ptr %17, ptr %19
  %.190.i2913 = select i1 %.074289.i2904, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2910, align 8
  %1539 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2910)
  %1540 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2911
  %1541 = load ptr, ptr %1540, align 8
  store ptr @i32_typ, ptr %.189.i2912, align 8
  %result.i14.i2914 = call ptr %1541({ ptr, ptr, ptr, i32 } %123, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2912) #46
  %1542 = call i32 %result.i14.i2914({ ptr, ptr, ptr, i32 } %123, { ptr, ptr, ptr, i32 } %123, ptr nonnull align 8 dereferenceable(8) %..i2910, i32 %1538) #53
  %1543 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1544 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2913
  %1545 = load ptr, ptr %1544, align 8
  %1546 = load ptr, ptr %1545, align 8
  %1547 = call { ptr } %1546(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i2915 = extractvalue { ptr } %1547, 0
  %1548 = sext i32 %1542 to i64
  %1549 = shl nsw i64 %1548, 5
  %1550 = getelementptr i8, ptr %.fca.0.extract55.i2915, i64 %1549
  %1551 = load ptr, ptr %1550, align 8
  %1552 = getelementptr i8, ptr %1550, i64 8
  %1553 = load i64, ptr %1552, align 4
  %.sroa_idx.i2916 = getelementptr i8, ptr %1550, i64 16
  %1554 = load i64, ptr %.sroa_idx.i2916, align 4
  %1555 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1556 = call { ptr } %1546(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i2917 = extractvalue { ptr } %1556, 0
  %1557 = getelementptr i8, ptr %.fca.0.extract52.i2917, i64 %1549
  store ptr %.sroa.0.0288.i2905, ptr %1557, align 8
  %1558 = getelementptr i8, ptr %1557, i64 8
  store i64 %.sroa.6.0287.i2906.in, ptr %1558, align 4
  %.sroa_idx104.i2918 = getelementptr i8, ptr %1557, i64 16
  store i64 %.sroa.12.0286.i2907.in, ptr %.sroa_idx104.i2918, align 4
  %.sroa_idx105.i2919 = getelementptr i8, ptr %1557, i64 24
  store i32 %.sroa.17.0285.i2908, ptr %.sroa_idx105.i2919, align 4
  %1559 = icmp ne ptr %1551, @nil_typ
  %1560 = icmp ne ptr %1551, null
  %.not94.i2920 = and i1 %1559, %1560
  br i1 %.not94.i2920, label %.cont.i2925, label %1565

.cont.i2925:                                      ; preds = %1528
  %1561 = add nuw nsw i32 %.0290.i2903, 1
  %1562 = xor i1 %.074289.i2904, true
  %hash_coef_ptr.i.i46.i2926 = getelementptr i8, ptr %1551, i64 8
  %tbl_size_ptr.i.i47.i2927 = getelementptr i8, ptr %1551, i64 16
  %offset_tbl_ptr.i.i48.i2928 = getelementptr i8, ptr %1551, i64 40
  %hash_coef.i.i49.i2929 = load i64, ptr %hash_coef_ptr.i.i46.i2926, align 4
  %tbl_size.i.i50.i2930 = load i64, ptr %tbl_size_ptr.i.i47.i2927, align 4
  %offset_tbl.i.i51.i2931 = load ptr, ptr %offset_tbl_ptr.i.i48.i2928, align 8
  %product.i.i.i52.i2932 = mul i64 %hash_coef.i.i49.i2929, 4015701072841558310
  %shifted.i.i.i53.i2933 = lshr i64 %product.i.i.i52.i2932, 32
  %xored.i.i.i54.i2934 = xor i64 %shifted.i.i.i53.i2933, %product.i.i.i52.i2932
  %hash.i.i.i55.i2935 = and i64 %xored.i.i.i54.i2934, %tbl_size.i.i50.i2930
  %offset_ptr.i.i56.i2936 = getelementptr i32, ptr %offset_tbl.i.i51.i2931, i64 %hash.i.i.i55.i2935
  %offset.i.i57.i2937 = load i32, ptr %offset_ptr.i.i56.i2936, align 4
  %1563 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1564 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2938 = icmp eq i32 %1561, 100
  br i1 %exitcond.not.i2938, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2947, label %1528

1565:                                             ; preds = %1528
  %1566 = load i32, ptr %108, align 4
  %1567 = add i32 %1566, 1
  %1568 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1567, ptr %108, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2947

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2947: ; preds = %1565, %.cont.i2925
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  br label %._crit_edge.i2078

._crit_edge.i2078:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2947, %1514
  %indvars.iv.next.i2079 = add nuw nsw i64 %indvars.iv.i2076, 1
  %exitcond.not.i2080 = icmp eq i64 %indvars.iv.next.i2079, %wide.trip.count.i2075
  br i1 %exitcond.not.i2080, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2098, label %1514

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2098: ; preds = %._crit_edge.i2116, %._crit_edge.i2078
  %indvars.iv.i2114 = phi i64 [ %indvars.iv.next.i2117, %._crit_edge.i2116 ], [ 0, %._crit_edge.i2078 ]
  %1569 = shl nuw nsw i64 %indvars.iv.i2114, 5
  %1570 = getelementptr i8, ptr %1508, i64 %1569
  %1571 = load ptr, ptr %1570, align 8
  %1572 = icmp ne ptr %1571, @nil_typ
  %1573 = icmp ne ptr %1571, null
  %.not17.i2115 = and i1 %1572, %1573
  br i1 %.not17.i2115, label %1574, label %._crit_edge.i2116

1574:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2098
  %1575 = getelementptr i8, ptr %1570, i64 8
  %1576 = load i64, ptr %1575, align 4
  %.sroa_idx.i2119 = getelementptr i8, ptr %1570, i64 16
  %1577 = load i64, ptr %.sroa_idx.i2119, align 4
  %hash_coef_ptr.i.i6.i2120 = getelementptr i8, ptr %1571, i64 8
  %tbl_size_ptr.i.i7.i2121 = getelementptr i8, ptr %1571, i64 16
  %offset_tbl_ptr.i.i8.i2122 = getelementptr i8, ptr %1571, i64 40
  %1578 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  %hash_coef.i.i21.i2965 = load i64, ptr %hash_coef_ptr.i.i6.i2120, align 4, !noalias !221
  %tbl_size.i.i22.i2966 = load i64, ptr %tbl_size_ptr.i.i7.i2121, align 4, !noalias !221
  %offset_tbl.i.i23.i2967 = load ptr, ptr %offset_tbl_ptr.i.i8.i2122, align 8, !noalias !221
  %product.i.i.i24.i2968 = mul i64 %hash_coef.i.i21.i2965, 4015701072841558310
  %shifted.i.i.i25.i2969 = lshr i64 %product.i.i.i24.i2968, 32
  %xored.i.i.i26.i2970 = xor i64 %shifted.i.i.i25.i2969, %product.i.i.i24.i2968
  %hash.i.i.i27.i2971 = and i64 %xored.i.i.i26.i2970, %tbl_size.i.i22.i2966
  %offset_ptr.i.i28.i2972 = getelementptr i32, ptr %offset_tbl.i.i23.i2967, i64 %hash.i.i.i27.i2971
  %offset.i.i29.i2973 = load i32, ptr %offset_ptr.i.i28.i2972, align 4, !noalias !221
  %1579 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1580 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1581 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1582

1582:                                             ; preds = %.cont.i2996, %1574
  %.0290.i2974 = phi i32 [ 0, %1574 ], [ %1615, %.cont.i2996 ]
  %.074289.i2975 = phi i1 [ true, %1574 ], [ %1616, %.cont.i2996 ]
  %.sroa.0.0288.i2976 = phi ptr [ %1571, %1574 ], [ %1605, %.cont.i2996 ]
  %.sroa.6.0287.i2977.in = phi i64 [ %1576, %1574 ], [ %1607, %.cont.i2996 ]
  %.sroa.12.0286.i2978.in = phi i64 [ %1577, %1574 ], [ %1608, %.cont.i2996 ]
  %.sroa.17.0285.i2979 = phi i32 [ %offset.i.i29.i2973, %1574 ], [ %offset.i.i57.i3008, %.cont.i2996 ]
  %.sroa.12.0286.i2978 = inttoptr i64 %.sroa.12.0286.i2978.in to ptr
  %.sroa.6.0287.i2977 = inttoptr i64 %.sroa.6.0287.i2977.in to ptr
  %1583 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2976, 0
  %1584 = insertvalue { ptr, ptr, ptr, i32 } %1583, ptr %.sroa.6.0287.i2977, 1
  %1585 = insertvalue { ptr, ptr, ptr, i32 } %1584, ptr %.sroa.12.0286.i2978, 2
  %1586 = insertvalue { ptr, ptr, ptr, i32 } %1585, i32 %.sroa.17.0285.i2979, 3
  %1587 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2976)
  %1588 = sext i32 %.sroa.17.0285.i2979 to i64
  %1589 = getelementptr ptr, ptr %.sroa.0.0288.i2976, i64 %1588
  %1590 = getelementptr i8, ptr %1589, i64 64
  %1591 = load ptr, ptr %1590, align 8
  %result.i15.i2980 = call ptr %1591({ ptr, ptr, ptr, i32 } %1586, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1592 = call i32 %result.i15.i2980({ ptr, ptr, ptr, i32 } %1586, { ptr, ptr, ptr, i32 } %1586, ptr nonnull align 8 %2) #53
  %..i2981 = select i1 %.074289.i2975, ptr %12, ptr %14
  %.188.i2982 = select i1 %.074289.i2975, i64 104, i64 112
  %.189.i2983 = select i1 %.074289.i2975, ptr %13, ptr %15
  %.190.i2984 = select i1 %.074289.i2975, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2981, align 8
  %1593 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2981)
  %1594 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2982
  %1595 = load ptr, ptr %1594, align 8
  store ptr @i32_typ, ptr %.189.i2983, align 8
  %result.i14.i2985 = call ptr %1595({ ptr, ptr, ptr, i32 } %123, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2983) #46
  %1596 = call i32 %result.i14.i2985({ ptr, ptr, ptr, i32 } %123, { ptr, ptr, ptr, i32 } %123, ptr nonnull align 8 dereferenceable(8) %..i2981, i32 %1592) #53
  %1597 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1598 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2984
  %1599 = load ptr, ptr %1598, align 8
  %1600 = load ptr, ptr %1599, align 8
  %1601 = call { ptr } %1600(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i2986 = extractvalue { ptr } %1601, 0
  %1602 = sext i32 %1596 to i64
  %1603 = shl nsw i64 %1602, 5
  %1604 = getelementptr i8, ptr %.fca.0.extract55.i2986, i64 %1603
  %1605 = load ptr, ptr %1604, align 8
  %1606 = getelementptr i8, ptr %1604, i64 8
  %1607 = load i64, ptr %1606, align 4
  %.sroa_idx.i2987 = getelementptr i8, ptr %1604, i64 16
  %1608 = load i64, ptr %.sroa_idx.i2987, align 4
  %1609 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1610 = call { ptr } %1600(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i2988 = extractvalue { ptr } %1610, 0
  %1611 = getelementptr i8, ptr %.fca.0.extract52.i2988, i64 %1603
  store ptr %.sroa.0.0288.i2976, ptr %1611, align 8
  %1612 = getelementptr i8, ptr %1611, i64 8
  store i64 %.sroa.6.0287.i2977.in, ptr %1612, align 4
  %.sroa_idx104.i2989 = getelementptr i8, ptr %1611, i64 16
  store i64 %.sroa.12.0286.i2978.in, ptr %.sroa_idx104.i2989, align 4
  %.sroa_idx105.i2990 = getelementptr i8, ptr %1611, i64 24
  store i32 %.sroa.17.0285.i2979, ptr %.sroa_idx105.i2990, align 4
  %1613 = icmp ne ptr %1605, @nil_typ
  %1614 = icmp ne ptr %1605, null
  %.not94.i2991 = and i1 %1613, %1614
  br i1 %.not94.i2991, label %.cont.i2996, label %1619

.cont.i2996:                                      ; preds = %1582
  %1615 = add nuw nsw i32 %.0290.i2974, 1
  %1616 = xor i1 %.074289.i2975, true
  %hash_coef_ptr.i.i46.i2997 = getelementptr i8, ptr %1605, i64 8
  %tbl_size_ptr.i.i47.i2998 = getelementptr i8, ptr %1605, i64 16
  %offset_tbl_ptr.i.i48.i2999 = getelementptr i8, ptr %1605, i64 40
  %hash_coef.i.i49.i3000 = load i64, ptr %hash_coef_ptr.i.i46.i2997, align 4
  %tbl_size.i.i50.i3001 = load i64, ptr %tbl_size_ptr.i.i47.i2998, align 4
  %offset_tbl.i.i51.i3002 = load ptr, ptr %offset_tbl_ptr.i.i48.i2999, align 8
  %product.i.i.i52.i3003 = mul i64 %hash_coef.i.i49.i3000, 4015701072841558310
  %shifted.i.i.i53.i3004 = lshr i64 %product.i.i.i52.i3003, 32
  %xored.i.i.i54.i3005 = xor i64 %shifted.i.i.i53.i3004, %product.i.i.i52.i3003
  %hash.i.i.i55.i3006 = and i64 %xored.i.i.i54.i3005, %tbl_size.i.i50.i3001
  %offset_ptr.i.i56.i3007 = getelementptr i32, ptr %offset_tbl.i.i51.i3002, i64 %hash.i.i.i55.i3006
  %offset.i.i57.i3008 = load i32, ptr %offset_ptr.i.i56.i3007, align 4
  %1617 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1618 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3009 = icmp eq i32 %1615, 100
  br i1 %exitcond.not.i3009, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3018, label %1582

1619:                                             ; preds = %1582
  %1620 = load i32, ptr %108, align 4
  %1621 = add i32 %1620, 1
  %1622 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1621, ptr %108, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3018

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3018: ; preds = %1619, %.cont.i2996
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  br label %._crit_edge.i2116

._crit_edge.i2116:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3018, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2098
  %indvars.iv.next.i2117 = add nuw nsw i64 %indvars.iv.i2114, 1
  %exitcond.not.i2118 = icmp eq i64 %indvars.iv.next.i2117, %wide.trip.count.i2075
  br i1 %exitcond.not.i2118, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2098

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136: ; preds = %._crit_edge.i2116, %1505
  %1623 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %hash_coef.i.i21.i1294 = load i64, ptr %hash_coef_ptr.i.i46.i1232.le, align 4, !noalias !224
  %tbl_size.i.i22.i1295 = load i64, ptr %tbl_size_ptr.i.i47.i1233.le, align 4, !noalias !224
  %offset_tbl.i.i23.i1296 = load ptr, ptr %offset_tbl_ptr.i.i48.i1234.le, align 8, !noalias !224
  %product.i.i.i24.i1297 = mul i64 %hash_coef.i.i21.i1294, 4015701072841558310
  %shifted.i.i.i25.i1298 = lshr i64 %product.i.i.i24.i1297, 32
  %xored.i.i.i26.i1299 = xor i64 %shifted.i.i.i25.i1298, %product.i.i.i24.i1297
  %hash.i.i.i27.i1300 = and i64 %xored.i.i.i26.i1299, %tbl_size.i.i22.i1295
  %offset_ptr.i.i28.i1301 = getelementptr i32, ptr %offset_tbl.i.i23.i1296, i64 %hash.i.i.i27.i1300
  %offset.i.i29.i1302 = load i32, ptr %offset_ptr.i.i28.i1301, align 4, !noalias !224
  %1624 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1625 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1626 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1627

1627:                                             ; preds = %.cont.i1326, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136
  %.0290.i1304 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136 ], [ %1660, %.cont.i1326 ]
  %.074289.i1305 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136 ], [ %1661, %.cont.i1326 ]
  %.sroa.0.0288.i1306 = phi ptr [ %1484, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136 ], [ %1650, %.cont.i1326 ]
  %.sroa.6.0287.i1307.in = phi i64 [ %1486, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136 ], [ %1652, %.cont.i1326 ]
  %.sroa.12.0286.i1308.in = phi i64 [ %1487, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136 ], [ %1653, %.cont.i1326 ]
  %.sroa.17.0285.i1309 = phi i32 [ %offset.i.i29.i1302, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2136 ], [ %offset.i.i57.i1338, %.cont.i1326 ]
  %.sroa.12.0286.i1308 = inttoptr i64 %.sroa.12.0286.i1308.in to ptr
  %.sroa.6.0287.i1307 = inttoptr i64 %.sroa.6.0287.i1307.in to ptr
  %1628 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1306, 0
  %1629 = insertvalue { ptr, ptr, ptr, i32 } %1628, ptr %.sroa.6.0287.i1307, 1
  %1630 = insertvalue { ptr, ptr, ptr, i32 } %1629, ptr %.sroa.12.0286.i1308, 2
  %1631 = insertvalue { ptr, ptr, ptr, i32 } %1630, i32 %.sroa.17.0285.i1309, 3
  %1632 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1306)
  %1633 = sext i32 %.sroa.17.0285.i1309 to i64
  %1634 = getelementptr ptr, ptr %.sroa.0.0288.i1306, i64 %1633
  %1635 = getelementptr i8, ptr %1634, i64 64
  %1636 = load ptr, ptr %1635, align 8
  %result.i15.i1310 = call ptr %1636({ ptr, ptr, ptr, i32 } %1631, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1637 = call i32 %result.i15.i1310({ ptr, ptr, ptr, i32 } %1631, { ptr, ptr, ptr, i32 } %1631, ptr nonnull align 8 %2) #53
  %..i1311 = select i1 %.074289.i1305, ptr %52, ptr %54
  %.188.i1312 = select i1 %.074289.i1305, i64 104, i64 112
  %.189.i1313 = select i1 %.074289.i1305, ptr %53, ptr %55
  %.190.i1314 = select i1 %.074289.i1305, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1311, align 8
  %1638 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1311)
  %1639 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1312
  %1640 = load ptr, ptr %1639, align 8
  store ptr @i32_typ, ptr %.189.i1313, align 8
  %result.i14.i1315 = call ptr %1640({ ptr, ptr, ptr, i32 } %118, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1313) #46
  %1641 = call i32 %result.i14.i1315({ ptr, ptr, ptr, i32 } %118, { ptr, ptr, ptr, i32 } %118, ptr nonnull align 8 dereferenceable(8) %..i1311, i32 %1637) #53
  %1642 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1643 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1314
  %1644 = load ptr, ptr %1643, align 8
  %1645 = load ptr, ptr %1644, align 8
  %1646 = call { ptr } %1645(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i1316 = extractvalue { ptr } %1646, 0
  %1647 = sext i32 %1641 to i64
  %1648 = shl nsw i64 %1647, 5
  %1649 = getelementptr i8, ptr %.fca.0.extract55.i1316, i64 %1648
  %1650 = load ptr, ptr %1649, align 8
  %1651 = getelementptr i8, ptr %1649, i64 8
  %1652 = load i64, ptr %1651, align 4
  %.sroa_idx.i1317 = getelementptr i8, ptr %1649, i64 16
  %1653 = load i64, ptr %.sroa_idx.i1317, align 4
  %1654 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1655 = call { ptr } %1645(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i1318 = extractvalue { ptr } %1655, 0
  %1656 = getelementptr i8, ptr %.fca.0.extract52.i1318, i64 %1648
  store ptr %.sroa.0.0288.i1306, ptr %1656, align 8
  %1657 = getelementptr i8, ptr %1656, i64 8
  store i64 %.sroa.6.0287.i1307.in, ptr %1657, align 4
  %.sroa_idx104.i1319 = getelementptr i8, ptr %1656, i64 16
  store i64 %.sroa.12.0286.i1308.in, ptr %.sroa_idx104.i1319, align 4
  %.sroa_idx105.i1320 = getelementptr i8, ptr %1656, i64 24
  store i32 %.sroa.17.0285.i1309, ptr %.sroa_idx105.i1320, align 4
  %1658 = icmp ne ptr %1650, @nil_typ
  %1659 = icmp ne ptr %1650, null
  %.not94.i1321 = and i1 %1658, %1659
  br i1 %.not94.i1321, label %.cont.i1326, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1348

.cont.i1326:                                      ; preds = %1627
  %1660 = add nuw nsw i32 %.0290.i1304, 1
  %1661 = xor i1 %.074289.i1305, true
  %hash_coef_ptr.i.i46.i1327 = getelementptr i8, ptr %1650, i64 8
  %tbl_size_ptr.i.i47.i1328 = getelementptr i8, ptr %1650, i64 16
  %offset_tbl_ptr.i.i48.i1329 = getelementptr i8, ptr %1650, i64 40
  %hash_coef.i.i49.i1330 = load i64, ptr %hash_coef_ptr.i.i46.i1327, align 4
  %tbl_size.i.i50.i1331 = load i64, ptr %tbl_size_ptr.i.i47.i1328, align 4
  %offset_tbl.i.i51.i1332 = load ptr, ptr %offset_tbl_ptr.i.i48.i1329, align 8
  %product.i.i.i52.i1333 = mul i64 %hash_coef.i.i49.i1330, 4015701072841558310
  %shifted.i.i.i53.i1334 = lshr i64 %product.i.i.i52.i1333, 32
  %xored.i.i.i54.i1335 = xor i64 %shifted.i.i.i53.i1334, %product.i.i.i52.i1333
  %hash.i.i.i55.i1336 = and i64 %xored.i.i.i54.i1335, %tbl_size.i.i50.i1331
  %offset_ptr.i.i56.i1337 = getelementptr i32, ptr %offset_tbl.i.i51.i1332, i64 %hash.i.i.i55.i1336
  %offset.i.i57.i1338 = load i32, ptr %offset_ptr.i.i56.i1337, align 4
  %1662 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1663 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1339 = icmp eq i32 %1660, 100
  br i1 %exitcond.not.i1339, label %1667, label %1627

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1348: ; preds = %1627
  %1664 = load i32, ptr %108, align 4
  %1665 = add i32 %1664, 1
  %1666 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1665, ptr %108, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  br label %CuckooMap_insert_keyK_valueV.exit423

1667:                                             ; preds = %.cont.i1326
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %1668 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1669 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1670 = load ptr, ptr %105, align 8
  %1671 = load ptr, ptr %106, align 8
  %1672 = load i32, ptr %104, align 8
  %1673 = shl i32 %1672, 1
  %spec.select.i1364 = call i32 @llvm.smax.i32(i32 %1673, i32 noundef 16) #40
  store i32 %spec.select.i1364, ptr %104, align 8
  %1674 = zext nneg i32 %spec.select.i1364 to i64
  %1675 = shl nuw nsw i64 %1674, 5
  %result.i5.i1365 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1675) #48
  store ptr %result.i5.i1365, ptr %105, align 8
  %result.i4.i1366 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1675) #48
  store ptr %result.i4.i1366, ptr %106, align 8
  store i32 0, ptr %108, align 4
  %1676 = icmp sgt i32 %1672, 0
  br i1 %1676, label %.lr.ph.i2138, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2174.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2174.thread: ; preds = %1667
  %1677 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit423

.lr.ph.i2138:                                     ; preds = %1667
  %wide.trip.count.i2151 = zext nneg i32 %1672 to i64
  br label %1678

1678:                                             ; preds = %._crit_edge.i2154, %.lr.ph.i2138
  %indvars.iv.i2152 = phi i64 [ 0, %.lr.ph.i2138 ], [ %indvars.iv.next.i2155, %._crit_edge.i2154 ]
  %1679 = shl nuw nsw i64 %indvars.iv.i2152, 5
  %1680 = getelementptr i8, ptr %1670, i64 %1679
  %1681 = load ptr, ptr %1680, align 8
  %1682 = icmp ne ptr %1681, @nil_typ
  %1683 = icmp ne ptr %1681, null
  %.not17.i2153 = and i1 %1682, %1683
  br i1 %.not17.i2153, label %1684, label %._crit_edge.i2154

1684:                                             ; preds = %1678
  %1685 = getelementptr i8, ptr %1680, i64 8
  %1686 = load i64, ptr %1685, align 4
  %.sroa_idx.i2157 = getelementptr i8, ptr %1680, i64 16
  %1687 = load i64, ptr %.sroa_idx.i2157, align 4
  %hash_coef_ptr.i.i6.i2158 = getelementptr i8, ptr %1681, i64 8
  %tbl_size_ptr.i.i7.i2159 = getelementptr i8, ptr %1681, i64 16
  %offset_tbl_ptr.i.i8.i2160 = getelementptr i8, ptr %1681, i64 40
  %1688 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %hash_coef.i.i21.i3036 = load i64, ptr %hash_coef_ptr.i.i6.i2158, align 4, !noalias !227
  %tbl_size.i.i22.i3037 = load i64, ptr %tbl_size_ptr.i.i7.i2159, align 4, !noalias !227
  %offset_tbl.i.i23.i3038 = load ptr, ptr %offset_tbl_ptr.i.i8.i2160, align 8, !noalias !227
  %product.i.i.i24.i3039 = mul i64 %hash_coef.i.i21.i3036, 4015701072841558310
  %shifted.i.i.i25.i3040 = lshr i64 %product.i.i.i24.i3039, 32
  %xored.i.i.i26.i3041 = xor i64 %shifted.i.i.i25.i3040, %product.i.i.i24.i3039
  %hash.i.i.i27.i3042 = and i64 %xored.i.i.i26.i3041, %tbl_size.i.i22.i3037
  %offset_ptr.i.i28.i3043 = getelementptr i32, ptr %offset_tbl.i.i23.i3038, i64 %hash.i.i.i27.i3042
  %offset.i.i29.i3044 = load i32, ptr %offset_ptr.i.i28.i3043, align 4, !noalias !227
  %1689 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1690 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1691 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1692

1692:                                             ; preds = %.cont.i3067, %1684
  %.0290.i3045 = phi i32 [ 0, %1684 ], [ %1725, %.cont.i3067 ]
  %.074289.i3046 = phi i1 [ true, %1684 ], [ %1726, %.cont.i3067 ]
  %.sroa.0.0288.i3047 = phi ptr [ %1681, %1684 ], [ %1715, %.cont.i3067 ]
  %.sroa.6.0287.i3048.in = phi i64 [ %1686, %1684 ], [ %1717, %.cont.i3067 ]
  %.sroa.12.0286.i3049.in = phi i64 [ %1687, %1684 ], [ %1718, %.cont.i3067 ]
  %.sroa.17.0285.i3050 = phi i32 [ %offset.i.i29.i3044, %1684 ], [ %offset.i.i57.i3079, %.cont.i3067 ]
  %.sroa.12.0286.i3049 = inttoptr i64 %.sroa.12.0286.i3049.in to ptr
  %.sroa.6.0287.i3048 = inttoptr i64 %.sroa.6.0287.i3048.in to ptr
  %1693 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3047, 0
  %1694 = insertvalue { ptr, ptr, ptr, i32 } %1693, ptr %.sroa.6.0287.i3048, 1
  %1695 = insertvalue { ptr, ptr, ptr, i32 } %1694, ptr %.sroa.12.0286.i3049, 2
  %1696 = insertvalue { ptr, ptr, ptr, i32 } %1695, i32 %.sroa.17.0285.i3050, 3
  %1697 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3047)
  %1698 = sext i32 %.sroa.17.0285.i3050 to i64
  %1699 = getelementptr ptr, ptr %.sroa.0.0288.i3047, i64 %1698
  %1700 = getelementptr i8, ptr %1699, i64 64
  %1701 = load ptr, ptr %1700, align 8
  %result.i15.i3051 = call ptr %1701({ ptr, ptr, ptr, i32 } %1696, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1702 = call i32 %result.i15.i3051({ ptr, ptr, ptr, i32 } %1696, { ptr, ptr, ptr, i32 } %1696, ptr nonnull align 8 %2) #53
  %..i3052 = select i1 %.074289.i3046, ptr %8, ptr %10
  %.188.i3053 = select i1 %.074289.i3046, i64 104, i64 112
  %.189.i3054 = select i1 %.074289.i3046, ptr %9, ptr %11
  %.190.i3055 = select i1 %.074289.i3046, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3052, align 8
  %1703 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3052)
  %1704 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3053
  %1705 = load ptr, ptr %1704, align 8
  store ptr @i32_typ, ptr %.189.i3054, align 8
  %result.i14.i3056 = call ptr %1705({ ptr, ptr, ptr, i32 } %123, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3054) #46
  %1706 = call i32 %result.i14.i3056({ ptr, ptr, ptr, i32 } %123, { ptr, ptr, ptr, i32 } %123, ptr nonnull align 8 dereferenceable(8) %..i3052, i32 %1702) #53
  %1707 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1708 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3055
  %1709 = load ptr, ptr %1708, align 8
  %1710 = load ptr, ptr %1709, align 8
  %1711 = call { ptr } %1710(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i3057 = extractvalue { ptr } %1711, 0
  %1712 = sext i32 %1706 to i64
  %1713 = shl nsw i64 %1712, 5
  %1714 = getelementptr i8, ptr %.fca.0.extract55.i3057, i64 %1713
  %1715 = load ptr, ptr %1714, align 8
  %1716 = getelementptr i8, ptr %1714, i64 8
  %1717 = load i64, ptr %1716, align 4
  %.sroa_idx.i3058 = getelementptr i8, ptr %1714, i64 16
  %1718 = load i64, ptr %.sroa_idx.i3058, align 4
  %1719 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1720 = call { ptr } %1710(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i3059 = extractvalue { ptr } %1720, 0
  %1721 = getelementptr i8, ptr %.fca.0.extract52.i3059, i64 %1713
  store ptr %.sroa.0.0288.i3047, ptr %1721, align 8
  %1722 = getelementptr i8, ptr %1721, i64 8
  store i64 %.sroa.6.0287.i3048.in, ptr %1722, align 4
  %.sroa_idx104.i3060 = getelementptr i8, ptr %1721, i64 16
  store i64 %.sroa.12.0286.i3049.in, ptr %.sroa_idx104.i3060, align 4
  %.sroa_idx105.i3061 = getelementptr i8, ptr %1721, i64 24
  store i32 %.sroa.17.0285.i3050, ptr %.sroa_idx105.i3061, align 4
  %1723 = icmp ne ptr %1715, @nil_typ
  %1724 = icmp ne ptr %1715, null
  %.not94.i3062 = and i1 %1723, %1724
  br i1 %.not94.i3062, label %.cont.i3067, label %1729

.cont.i3067:                                      ; preds = %1692
  %1725 = add nuw nsw i32 %.0290.i3045, 1
  %1726 = xor i1 %.074289.i3046, true
  %hash_coef_ptr.i.i46.i3068 = getelementptr i8, ptr %1715, i64 8
  %tbl_size_ptr.i.i47.i3069 = getelementptr i8, ptr %1715, i64 16
  %offset_tbl_ptr.i.i48.i3070 = getelementptr i8, ptr %1715, i64 40
  %hash_coef.i.i49.i3071 = load i64, ptr %hash_coef_ptr.i.i46.i3068, align 4
  %tbl_size.i.i50.i3072 = load i64, ptr %tbl_size_ptr.i.i47.i3069, align 4
  %offset_tbl.i.i51.i3073 = load ptr, ptr %offset_tbl_ptr.i.i48.i3070, align 8
  %product.i.i.i52.i3074 = mul i64 %hash_coef.i.i49.i3071, 4015701072841558310
  %shifted.i.i.i53.i3075 = lshr i64 %product.i.i.i52.i3074, 32
  %xored.i.i.i54.i3076 = xor i64 %shifted.i.i.i53.i3075, %product.i.i.i52.i3074
  %hash.i.i.i55.i3077 = and i64 %xored.i.i.i54.i3076, %tbl_size.i.i50.i3072
  %offset_ptr.i.i56.i3078 = getelementptr i32, ptr %offset_tbl.i.i51.i3073, i64 %hash.i.i.i55.i3077
  %offset.i.i57.i3079 = load i32, ptr %offset_ptr.i.i56.i3078, align 4
  %1727 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1728 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3080 = icmp eq i32 %1725, 100
  br i1 %exitcond.not.i3080, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3089, label %1692

1729:                                             ; preds = %1692
  %1730 = load i32, ptr %108, align 4
  %1731 = add i32 %1730, 1
  %1732 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1731, ptr %108, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3089

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3089: ; preds = %1729, %.cont.i3067
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  br label %._crit_edge.i2154

._crit_edge.i2154:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3089, %1678
  %indvars.iv.next.i2155 = add nuw nsw i64 %indvars.iv.i2152, 1
  %exitcond.not.i2156 = icmp eq i64 %indvars.iv.next.i2155, %wide.trip.count.i2151
  br i1 %exitcond.not.i2156, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2174, label %1678

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2174: ; preds = %._crit_edge.i2154
  %1733 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %1734

1734:                                             ; preds = %._crit_edge.i2192, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2174
  %indvars.iv.i2190 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2174 ], [ %indvars.iv.next.i2193, %._crit_edge.i2192 ]
  %1735 = shl nuw nsw i64 %indvars.iv.i2190, 5
  %1736 = getelementptr i8, ptr %1671, i64 %1735
  %1737 = load ptr, ptr %1736, align 8
  %1738 = icmp ne ptr %1737, @nil_typ
  %1739 = icmp ne ptr %1737, null
  %.not17.i2191 = and i1 %1738, %1739
  br i1 %.not17.i2191, label %1740, label %._crit_edge.i2192

1740:                                             ; preds = %1734
  %1741 = getelementptr i8, ptr %1736, i64 8
  %1742 = load i64, ptr %1741, align 4
  %.sroa_idx.i2195 = getelementptr i8, ptr %1736, i64 16
  %1743 = load i64, ptr %.sroa_idx.i2195, align 4
  %hash_coef_ptr.i.i6.i2196 = getelementptr i8, ptr %1737, i64 8
  %tbl_size_ptr.i.i7.i2197 = getelementptr i8, ptr %1737, i64 16
  %offset_tbl_ptr.i.i8.i2198 = getelementptr i8, ptr %1737, i64 40
  %1744 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %hash_coef.i.i21.i3107 = load i64, ptr %hash_coef_ptr.i.i6.i2196, align 4, !noalias !230
  %tbl_size.i.i22.i3108 = load i64, ptr %tbl_size_ptr.i.i7.i2197, align 4, !noalias !230
  %offset_tbl.i.i23.i3109 = load ptr, ptr %offset_tbl_ptr.i.i8.i2198, align 8, !noalias !230
  %product.i.i.i24.i3110 = mul i64 %hash_coef.i.i21.i3107, 4015701072841558310
  %shifted.i.i.i25.i3111 = lshr i64 %product.i.i.i24.i3110, 32
  %xored.i.i.i26.i3112 = xor i64 %shifted.i.i.i25.i3111, %product.i.i.i24.i3110
  %hash.i.i.i27.i3113 = and i64 %xored.i.i.i26.i3112, %tbl_size.i.i22.i3108
  %offset_ptr.i.i28.i3114 = getelementptr i32, ptr %offset_tbl.i.i23.i3109, i64 %hash.i.i.i27.i3113
  %offset.i.i29.i3115 = load i32, ptr %offset_ptr.i.i28.i3114, align 4, !noalias !230
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1746 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1747 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1748

1748:                                             ; preds = %.cont.i3138, %1740
  %.0290.i3116 = phi i32 [ 0, %1740 ], [ %1781, %.cont.i3138 ]
  %.074289.i3117 = phi i1 [ true, %1740 ], [ %1782, %.cont.i3138 ]
  %.sroa.0.0288.i3118 = phi ptr [ %1737, %1740 ], [ %1771, %.cont.i3138 ]
  %.sroa.6.0287.i3119.in = phi i64 [ %1742, %1740 ], [ %1773, %.cont.i3138 ]
  %.sroa.12.0286.i3120.in = phi i64 [ %1743, %1740 ], [ %1774, %.cont.i3138 ]
  %.sroa.17.0285.i3121 = phi i32 [ %offset.i.i29.i3115, %1740 ], [ %offset.i.i57.i3150, %.cont.i3138 ]
  %.sroa.12.0286.i3120 = inttoptr i64 %.sroa.12.0286.i3120.in to ptr
  %.sroa.6.0287.i3119 = inttoptr i64 %.sroa.6.0287.i3119.in to ptr
  %1749 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3118, 0
  %1750 = insertvalue { ptr, ptr, ptr, i32 } %1749, ptr %.sroa.6.0287.i3119, 1
  %1751 = insertvalue { ptr, ptr, ptr, i32 } %1750, ptr %.sroa.12.0286.i3120, 2
  %1752 = insertvalue { ptr, ptr, ptr, i32 } %1751, i32 %.sroa.17.0285.i3121, 3
  %1753 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3118)
  %1754 = sext i32 %.sroa.17.0285.i3121 to i64
  %1755 = getelementptr ptr, ptr %.sroa.0.0288.i3118, i64 %1754
  %1756 = getelementptr i8, ptr %1755, i64 64
  %1757 = load ptr, ptr %1756, align 8
  %result.i15.i3122 = call ptr %1757({ ptr, ptr, ptr, i32 } %1752, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1758 = call i32 %result.i15.i3122({ ptr, ptr, ptr, i32 } %1752, { ptr, ptr, ptr, i32 } %1752, ptr nonnull align 8 %2) #53
  %..i3123 = select i1 %.074289.i3117, ptr %4, ptr %6
  %.188.i3124 = select i1 %.074289.i3117, i64 104, i64 112
  %.189.i3125 = select i1 %.074289.i3117, ptr %5, ptr %7
  %.190.i3126 = select i1 %.074289.i3117, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3123, align 8
  %1759 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3123)
  %1760 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3124
  %1761 = load ptr, ptr %1760, align 8
  store ptr @i32_typ, ptr %.189.i3125, align 8
  %result.i14.i3127 = call ptr %1761({ ptr, ptr, ptr, i32 } %123, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3125) #46
  %1762 = call i32 %result.i14.i3127({ ptr, ptr, ptr, i32 } %123, { ptr, ptr, ptr, i32 } %123, ptr nonnull align 8 dereferenceable(8) %..i3123, i32 %1758) #53
  %1763 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1764 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3126
  %1765 = load ptr, ptr %1764, align 8
  %1766 = load ptr, ptr %1765, align 8
  %1767 = call { ptr } %1766(ptr nonnull %result.i58) #43
  %.fca.0.extract55.i3128 = extractvalue { ptr } %1767, 0
  %1768 = sext i32 %1762 to i64
  %1769 = shl nsw i64 %1768, 5
  %1770 = getelementptr i8, ptr %.fca.0.extract55.i3128, i64 %1769
  %1771 = load ptr, ptr %1770, align 8
  %1772 = getelementptr i8, ptr %1770, i64 8
  %1773 = load i64, ptr %1772, align 4
  %.sroa_idx.i3129 = getelementptr i8, ptr %1770, i64 16
  %1774 = load i64, ptr %.sroa_idx.i3129, align 4
  %1775 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1776 = call { ptr } %1766(ptr nonnull %result.i58) #43
  %.fca.0.extract52.i3130 = extractvalue { ptr } %1776, 0
  %1777 = getelementptr i8, ptr %.fca.0.extract52.i3130, i64 %1769
  store ptr %.sroa.0.0288.i3118, ptr %1777, align 8
  %1778 = getelementptr i8, ptr %1777, i64 8
  store i64 %.sroa.6.0287.i3119.in, ptr %1778, align 4
  %.sroa_idx104.i3131 = getelementptr i8, ptr %1777, i64 16
  store i64 %.sroa.12.0286.i3120.in, ptr %.sroa_idx104.i3131, align 4
  %.sroa_idx105.i3132 = getelementptr i8, ptr %1777, i64 24
  store i32 %.sroa.17.0285.i3121, ptr %.sroa_idx105.i3132, align 4
  %1779 = icmp ne ptr %1771, @nil_typ
  %1780 = icmp ne ptr %1771, null
  %.not94.i3133 = and i1 %1779, %1780
  br i1 %.not94.i3133, label %.cont.i3138, label %1785

.cont.i3138:                                      ; preds = %1748
  %1781 = add nuw nsw i32 %.0290.i3116, 1
  %1782 = xor i1 %.074289.i3117, true
  %hash_coef_ptr.i.i46.i3139 = getelementptr i8, ptr %1771, i64 8
  %tbl_size_ptr.i.i47.i3140 = getelementptr i8, ptr %1771, i64 16
  %offset_tbl_ptr.i.i48.i3141 = getelementptr i8, ptr %1771, i64 40
  %hash_coef.i.i49.i3142 = load i64, ptr %hash_coef_ptr.i.i46.i3139, align 4
  %tbl_size.i.i50.i3143 = load i64, ptr %tbl_size_ptr.i.i47.i3140, align 4
  %offset_tbl.i.i51.i3144 = load ptr, ptr %offset_tbl_ptr.i.i48.i3141, align 8
  %product.i.i.i52.i3145 = mul i64 %hash_coef.i.i49.i3142, 4015701072841558310
  %shifted.i.i.i53.i3146 = lshr i64 %product.i.i.i52.i3145, 32
  %xored.i.i.i54.i3147 = xor i64 %shifted.i.i.i53.i3146, %product.i.i.i52.i3145
  %hash.i.i.i55.i3148 = and i64 %xored.i.i.i54.i3147, %tbl_size.i.i50.i3143
  %offset_ptr.i.i56.i3149 = getelementptr i32, ptr %offset_tbl.i.i51.i3144, i64 %hash.i.i.i55.i3148
  %offset.i.i57.i3150 = load i32, ptr %offset_ptr.i.i56.i3149, align 4
  %1783 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1784 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3151 = icmp eq i32 %1781, 100
  br i1 %exitcond.not.i3151, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3160, label %1748

1785:                                             ; preds = %1748
  %1786 = load i32, ptr %108, align 4
  %1787 = add i32 %1786, 1
  %1788 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1787, ptr %108, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3160

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3160: ; preds = %1785, %.cont.i3138
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  br label %._crit_edge.i2192

._crit_edge.i2192:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3160, %1734
  %indvars.iv.next.i2193 = add nuw nsw i64 %indvars.iv.i2190, 1
  %exitcond.not.i2194 = icmp eq i64 %indvars.iv.next.i2193, %wide.trip.count.i2151
  br i1 %exitcond.not.i2194, label %CuckooMap_insert_keyK_valueV.exit423, label %1734

CuckooMap_insert_keyK_valueV.exit423:             ; preds = %._crit_edge.i2192, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2174.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1348, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1253, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1158, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1099
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1789 = sext i32 %245 to i64
  %1790 = add i64 %.0288206, %1789
  %1791 = add nsw i32 %.0279207, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit423, %CuckooMap_get_keyK.exit
  %_parameterization_i32198 = phi ptr [ @_parameterization_i32, %CuckooMap_insert_keyK_valueV.exit423 ], [ %_parameterization_i32199204, %CuckooMap_get_keyK.exit ]
  %_parameterization_i32 = phi ptr [ @_parameterization_i32, %CuckooMap_insert_keyK_valueV.exit423 ], [ %_parameterization_i32196205, %CuckooMap_get_keyK.exit ]
  %.1289 = phi i64 [ %1790, %CuckooMap_insert_keyK_valueV.exit423 ], [ %.0288206, %CuckooMap_get_keyK.exit ]
  %.1280 = phi i32 [ %1791, %CuckooMap_insert_keyK_valueV.exit423 ], [ %.0279207, %CuckooMap_get_keyK.exit ]
  %1792 = add nuw nsw i32 %.0277208, 1
  %1793 = icmp slt i32 %.1280, %0
  %1794 = icmp slt i32 %1792, %109
  %spec.select = select i1 %1793, i1 %1794, i1 false
  br i1 %spec.select, label %125, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %_parameterization_i32199.lcssa = phi ptr [ %.promoted197, %1 ], [ %_parameterization_i32198, %._crit_edge1 ]
  %_parameterization_i32196.lcssa = phi ptr [ %.promoted, %1 ], [ %_parameterization_i32, %._crit_edge1 ]
  %.0288.lcssa = phi i64 [ 0, %1 ], [ %.1289, %._crit_edge1 ]
  %.0279.lcssa = phi i32 [ 0, %1 ], [ %.1280, %._crit_edge1 ]
  store ptr %_parameterization_i32196.lcssa, ptr %110, align 8
  store ptr %_parameterization_i32199.lcssa, ptr %111, align 8
  %1795 = icmp slt i32 %.0279.lcssa, %0
  br i1 %1795, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1796 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1797 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i.i1611.h2s3415, align 1
  %1798 = getelementptr inbounds i8, ptr %result.i.i1611.h2s3415, i64 29
  store i8 0, ptr %1798, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i.i1611.h2s3415) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1799 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0279.lcssa) #55
  %1800 = load <33 x i8>, ptr @yylhu__unique_keys_for_random_hit_test, align 64
  %1801 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1802 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1803 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <33 x i8> %1800, ptr %result.i.i1626.h2s3413, align 1
  %1804 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1805 = getelementptr inbounds i8, ptr %result.i.i1626.h2s3413, i64 33
  store i8 0, ptr %1805, align 1
  %puts.i590 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(34) %result.i.i1626.h2s3413) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge.lr.ph.i, %._crit_edge3._crit_edge
  %.0287 = phi i32 [ %.0279.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %1806 = call i64 @clock()
  %1807 = load <51 x i8>, ptr @khbst_Error_Nil_returned_during_random_hit_test_for_key_, align 64
  %1808 = icmp sgt i32 %.0287, 0
  br i1 %1808, label %.lr.ph221.preheader, label %._crit_edge.lr.ph.i1667

.lr.ph221.preheader:                              ; preds = %._crit_edge4
  %1809 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %1810 = zext nneg i32 %.0287 to i64
  %1811 = load ptr, ptr %94, align 8
  %1812 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  br label %.lr.ph221

.lr.ph221:                                        ; preds = %._crit_edge5, %.lr.ph221.preheader
  %indvars.iv = phi i64 [ 0, %.lr.ph221.preheader ], [ %indvars.iv.next, %._crit_edge5 ]
  %.0276220 = phi i64 [ 0, %.lr.ph221.preheader ], [ %.1, %._crit_edge5 ]
  %.0282219 = phi i1 [ true, %.lr.ph221.preheader ], [ %.1283, %._crit_edge5 ]
  %1813 = shl i64 %indvars.iv, 2
  %1814 = getelementptr i8, ptr %1811, i64 %1813
  %1815 = load i32, ptr %1814, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %1815 to i160
  %1816 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %1817 = load ptr, ptr %83, align 8
  %1818 = call i32 %1817({ ptr, i160 } %1816) #53
  %1819 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1820 = load i32, ptr %85, align 8
  %1821 = add i32 %1820, -1
  %1822 = and i32 %1821, %1818
  %1823 = load ptr, ptr %86, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1824 = sext i32 %1822 to i64
  %1825 = shl nsw i64 %1824, 5
  %1826 = getelementptr i8, ptr %1823, i64 %1825
  %1827 = load ptr, ptr %1826, align 8
  %1828 = icmp ne ptr %1827, @nil_typ
  %1829 = icmp ne ptr %1827, null
  %.not45.i1412 = and i1 %1828, %1829
  br i1 %.not45.i1412, label %1830, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436.thread

1830:                                             ; preds = %.lr.ph221
  %1831 = getelementptr i8, ptr %1826, i64 8
  %1832 = load i64, ptr %1831, align 4
  %.sroa_idx.i1417 = getelementptr i8, ptr %1826, i64 16
  %1833 = load i64, ptr %.sroa_idx.i1417, align 4
  %1834 = inttoptr i64 %1832 to ptr
  %1835 = inttoptr i64 %1833 to ptr
  %hash_coef_ptr.i.i4.i1418 = getelementptr i8, ptr %1827, i64 8
  %tbl_size_ptr.i.i5.i1419 = getelementptr i8, ptr %1827, i64 16
  %offset_tbl_ptr.i.i6.i1420 = getelementptr i8, ptr %1827, i64 40
  %hash_coef.i.i7.i1421 = load i64, ptr %hash_coef_ptr.i.i4.i1418, align 4, !noalias !233
  %tbl_size.i.i8.i1422 = load i64, ptr %tbl_size_ptr.i.i5.i1419, align 4, !noalias !233
  %offset_tbl.i.i9.i1423 = load ptr, ptr %offset_tbl_ptr.i.i6.i1420, align 8, !noalias !233
  %product.i.i.i10.i1424 = mul i64 %hash_coef.i.i7.i1421, 4015701072841558310
  %shifted.i.i.i11.i1425 = lshr i64 %product.i.i.i10.i1424, 32
  %xored.i.i.i12.i1426 = xor i64 %shifted.i.i.i11.i1425, %product.i.i.i10.i1424
  %hash.i.i.i13.i1427 = and i64 %xored.i.i.i12.i1426, %tbl_size.i.i8.i1422
  %offset_ptr.i.i14.i1428 = getelementptr i32, ptr %offset_tbl.i.i9.i1423, i64 %hash.i.i.i13.i1427
  %offset.i.i15.i1429 = load i32, ptr %offset_ptr.i.i14.i1428, align 4, !noalias !233
  %1836 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1827, 0
  %1837 = insertvalue { ptr, ptr, ptr, i32 } %1836, ptr %1834, 1
  %1838 = insertvalue { ptr, ptr, ptr, i32 } %1837, ptr %1835, 2
  %1839 = insertvalue { ptr, ptr, ptr, i32 } %1838, i32 %offset.i.i15.i1429, 3
  %1840 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1841 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1827) #40
  %1842 = sext i32 %offset.i.i15.i1429 to i64
  %1843 = getelementptr ptr, ptr %1827, i64 %1842
  %1844 = getelementptr i8, ptr %1843, i64 64
  %1845 = load ptr, ptr %1844, align 8
  %result.i2.i = call ptr %1845({ ptr, ptr, ptr, i32 } %1839, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1846 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %1839, { ptr, ptr, ptr, i32 } %1839, ptr nonnull align 8 %2) #53
  %1847 = icmp eq i32 %1846, %1818
  br i1 %1847, label %._crit_edge.i1430, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436.thread

._crit_edge.i1430:                                ; preds = %1830
  %1848 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1849 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1827)
  %1850 = getelementptr i8, ptr %1843, i64 48
  %1851 = load ptr, ptr %1850, align 8
  %result.i1.i1431 = call ptr %1851({ ptr, ptr, ptr, i32 } %1839, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1852 = call { ptr, i160 } %result.i1.i1431({ ptr, ptr, ptr, i32 } %1839, { ptr, ptr, ptr, i32 } %1839, ptr nonnull align 8 %2) #53
  %1853 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1854 = load ptr, ptr %84, align 8
  %1855 = call i1 %1854({ ptr, i160 } %1852, { ptr, i160 } %1816) #53
  br i1 %1855, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436.thread: ; preds = %._crit_edge.i1430, %1830, %.lr.ph221
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1864

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436: ; preds = %._crit_edge.i1430
  %1856 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1857 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1827)
  %1858 = getelementptr i8, ptr %1843, i64 56
  %1859 = load ptr, ptr %1858, align 8
  %result.i.i1433 = call ptr %1859({ ptr, ptr, ptr, i32 } %1839, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1860 = call { ptr, i160 } %result.i.i1433({ ptr, ptr, ptr, i32 } %1839, { ptr, ptr, ptr, i32 } %1839, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1434 = extractvalue { ptr, i160 } %1860, 0
  %.fca.1.extract23.i1435 = extractvalue { ptr, i160 } %1860, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1861 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1862 = icmp ne ptr %.fca.0.extract22.i1434, @nil_typ
  %1863 = icmp ne ptr %.fca.0.extract22.i1434, null
  %.not63.i485 = and i1 %1862, %1863
  %extract.t1545 = trunc i160 %.fca.1.extract23.i1435 to i64
  br i1 %.not63.i485, label %CuckooMap_get_keyK.exit497, label %1864

1864:                                             ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436.thread
  %1865 = add i32 %1818, 2127912214
  %1866 = shl i32 %1818, 12
  %1867 = add i32 %1865, %1866
  %1868 = ashr i32 %1867, 19
  %1869 = xor i32 %1867, %1868
  %1870 = xor i32 %1869, -949894596
  %1871 = add i32 %1870, 374761393
  %1872 = shl i32 %1870, 5
  %1873 = add i32 %1871, %1872
  %1874 = add i32 %1873, -744332180
  %1875 = shl i32 %1873, 9
  %1876 = xor i32 %1874, %1875
  %1877 = add i32 %1876, -42973499
  %1878 = shl i32 %1876, 3
  %1879 = add i32 %1877, %1878
  %1880 = ashr i32 %1879, 16
  %1881 = xor i32 %1879, %1880
  %1882 = xor i32 %1881, -1252372727
  %1883 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1884 = load i32, ptr %85, align 8
  %1885 = add i32 %1884, -1
  %1886 = and i32 %1885, %1882
  %1887 = load ptr, ptr %87, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1888 = sext i32 %1886 to i64
  %1889 = shl nsw i64 %1888, 5
  %1890 = getelementptr i8, ptr %1887, i64 %1889
  %1891 = load ptr, ptr %1890, align 8
  %1892 = icmp ne ptr %1891, @nil_typ
  %1893 = icmp ne ptr %1891, null
  %.not45.i1466 = and i1 %1892, %1893
  br i1 %.not45.i1466, label %1894, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491

1894:                                             ; preds = %1864
  %1895 = getelementptr i8, ptr %1890, i64 8
  %1896 = load i64, ptr %1895, align 4
  %.sroa_idx.i1471 = getelementptr i8, ptr %1890, i64 16
  %1897 = load i64, ptr %.sroa_idx.i1471, align 4
  %1898 = inttoptr i64 %1896 to ptr
  %1899 = inttoptr i64 %1897 to ptr
  %hash_coef_ptr.i.i4.i1472 = getelementptr i8, ptr %1891, i64 8
  %tbl_size_ptr.i.i5.i1473 = getelementptr i8, ptr %1891, i64 16
  %offset_tbl_ptr.i.i6.i1474 = getelementptr i8, ptr %1891, i64 40
  %hash_coef.i.i7.i1475 = load i64, ptr %hash_coef_ptr.i.i4.i1472, align 4, !noalias !236
  %tbl_size.i.i8.i1476 = load i64, ptr %tbl_size_ptr.i.i5.i1473, align 4, !noalias !236
  %offset_tbl.i.i9.i1477 = load ptr, ptr %offset_tbl_ptr.i.i6.i1474, align 8, !noalias !236
  %product.i.i.i10.i1478 = mul i64 %hash_coef.i.i7.i1475, 4015701072841558310
  %shifted.i.i.i11.i1479 = lshr i64 %product.i.i.i10.i1478, 32
  %xored.i.i.i12.i1480 = xor i64 %shifted.i.i.i11.i1479, %product.i.i.i10.i1478
  %hash.i.i.i13.i1481 = and i64 %xored.i.i.i12.i1480, %tbl_size.i.i8.i1476
  %offset_ptr.i.i14.i1482 = getelementptr i32, ptr %offset_tbl.i.i9.i1477, i64 %hash.i.i.i13.i1481
  %offset.i.i15.i1483 = load i32, ptr %offset_ptr.i.i14.i1482, align 4, !noalias !236
  %1900 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1891, 0
  %1901 = insertvalue { ptr, ptr, ptr, i32 } %1900, ptr %1898, 1
  %1902 = insertvalue { ptr, ptr, ptr, i32 } %1901, ptr %1899, 2
  %1903 = insertvalue { ptr, ptr, ptr, i32 } %1902, i32 %offset.i.i15.i1483, 3
  %1904 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1905 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1891) #40
  %1906 = sext i32 %offset.i.i15.i1483 to i64
  %1907 = getelementptr ptr, ptr %1891, i64 %1906
  %1908 = getelementptr i8, ptr %1907, i64 64
  %1909 = load ptr, ptr %1908, align 8
  %result.i2.i1484 = call ptr %1909({ ptr, ptr, ptr, i32 } %1903, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1910 = call i32 %result.i2.i1484({ ptr, ptr, ptr, i32 } %1903, { ptr, ptr, ptr, i32 } %1903, ptr nonnull align 8 %2) #53
  %1911 = icmp eq i32 %1910, %1818
  br i1 %1911, label %._crit_edge.i1485, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491

._crit_edge.i1485:                                ; preds = %1894
  %1912 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1913 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1891)
  %1914 = getelementptr i8, ptr %1907, i64 48
  %1915 = load ptr, ptr %1914, align 8
  %result.i1.i1486 = call ptr %1915({ ptr, ptr, ptr, i32 } %1903, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1916 = call { ptr, i160 } %result.i1.i1486({ ptr, ptr, ptr, i32 } %1903, { ptr, ptr, ptr, i32 } %1903, ptr nonnull align 8 %2) #53
  %1917 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1918 = load ptr, ptr %84, align 8
  %1919 = call i1 %1918({ ptr, i160 } %1916, { ptr, i160 } %1816) #53
  br i1 %1919, label %1920, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491

1920:                                             ; preds = %._crit_edge.i1485
  %1921 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1922 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1891)
  %1923 = getelementptr i8, ptr %1907, i64 56
  %1924 = load ptr, ptr %1923, align 8
  %result.i.i1488 = call ptr %1924({ ptr, ptr, ptr, i32 } %1903, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1925 = call { ptr, i160 } %result.i.i1488({ ptr, ptr, ptr, i32 } %1903, { ptr, ptr, ptr, i32 } %1903, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1489 = extractvalue { ptr, i160 } %1925, 0
  %.fca.1.extract23.i1490 = extractvalue { ptr, i160 } %1925, 1
  %1926 = trunc i160 %.fca.1.extract23.i1490 to i64
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491: ; preds = %1920, %._crit_edge.i1485, %1894, %1864
  %.reg2mem43.sroa.3.0.i1467 = phi i64 [ %1926, %1920 ], [ poison, %._crit_edge.i1485 ], [ poison, %1864 ], [ poison, %1894 ]
  %.reg2mem41.0.i1468 = phi ptr [ %.fca.0.extract22.i1489, %1920 ], [ @nil_typ, %._crit_edge.i1485 ], [ @nil_typ, %1864 ], [ @nil_typ, %1894 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1927 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i490 = icmp eq ptr %.reg2mem41.0.i1468, null
  %1928 = select i1 %.not.i490, ptr @nil_typ, ptr %.reg2mem41.0.i1468
  br label %CuckooMap_get_keyK.exit497

CuckooMap_get_keyK.exit497:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436
  %.not63.i4851544.off0 = phi i64 [ %.reg2mem43.sroa.3.0.i1467, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491 ], [ %extract.t1545, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436 ]
  %.reg2mem56.0.i491 = phi ptr [ %1928, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1491 ], [ %.fca.0.extract22.i1434, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1436 ]
  %1929 = icmp ne ptr %.reg2mem56.0.i491, @nil_typ
  %1930 = icmp ne ptr %.reg2mem56.0.i491, null
  %.not294 = and i1 %1929, %1930
  br i1 %.not294, label %1931, label %._crit_edge.lr.ph.i1647

1931:                                             ; preds = %CuckooMap_get_keyK.exit497
  %sext = shl i64 %.not63.i4851544.off0, 32
  %1932 = ashr exact i64 %sext, 32
  %1933 = add i64 %1932, %.0276220
  br label %._crit_edge5

._crit_edge.lr.ph.i1647:                          ; preds = %CuckooMap_get_keyK.exit497
  %result.i51.h2s3419 = alloca [52 x i8], align 1
  %1934 = getelementptr inbounds i8, ptr %result.i51.h2s3419, i64 51
  store i8 0, ptr %1934, align 1
  store <51 x i8> %1807, ptr %result.i51.h2s3419, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1935 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1936 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %result.i.i1646.h2s3420 = alloca [52 x i8], align 1
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(52) %result.i.i1646.h2s3420, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(52) %result.i51.h2s3419, i64 noundef 51, i1 noundef false)
  %1937 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1938 = getelementptr inbounds i8, ptr %result.i.i1646.h2s3420, i64 51
  store i8 0, ptr %1938, align 1
  %puts.i610 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(52) %result.i.i1646.h2s3420) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1939 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1940 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1815) #55
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge.lr.ph.i1647, %1931
  %.1283 = phi i1 [ %.0282219, %1931 ], [ false, %._crit_edge.lr.ph.i1647 ]
  %.1 = phi i64 [ %1933, %1931 ], [ %.0276220, %._crit_edge.lr.ph.i1647 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %1810
  br i1 %exitcond.not, label %._crit_edge.lr.ph.i1667, label %.lr.ph221

._crit_edge.lr.ph.i1667:                          ; preds = %._crit_edge5, %._crit_edge4
  %.0282.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.1283, %._crit_edge5 ]
  %.0276.lcssa = phi i64 [ 0, %._crit_edge4 ], [ %.1, %._crit_edge5 ]
  %1941 = call i64 @clock()
  %1942 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1944 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i.i1666.h2s3411, align 16
  %1945 = sub i64 %1941, %1806
  %1946 = getelementptr inbounds i8, ptr %result.i.i1666.h2s3411, i64 14
  store i8 0, ptr %1946, align 2
  %puts.i630 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i1666.h2s3411) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i.i.i.h2s3409, align 16
  %1947 = getelementptr inbounds i8, ptr %result.i.i.i.h2s3409, i64 14
  store i8 0, ptr %1947, align 2
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.h2s3409) #53
  %1948 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0287) #55
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i.i304.i.h2s3407, align 16
  %1949 = getelementptr inbounds i8, ptr %result.i.i304.i.h2s3407, i64 14
  store i8 0, ptr %1949, align 2
  %puts.i229.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.h2s3407) #53
  %1950 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1945) #55
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i.i324.i.h2s3405, align 4
  %1951 = getelementptr inbounds i8, ptr %result.i.i324.i.h2s3405, i64 3
  store i8 0, ptr %1951, align 1
  %puts.i249.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.h2s3405) #53
  br i1 %1808, label %._crit_edge.lr.ph.i345.i, label %._crit_edge.lr.ph.i1687

._crit_edge.lr.ph.i345.i:                         ; preds = %._crit_edge.lr.ph.i1667
  %1952 = zext nneg i32 %.0287 to i64
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i.i344.i.h2s3403, align 16
  %1953 = mul i64 %1945, 1000000
  %1954 = sdiv i64 %1953, %1952
  %1955 = getelementptr inbounds i8, ptr %result.i.i344.i.h2s3403, i64 15
  store i8 0, ptr %1955, align 1
  %puts.i269.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.h2s3403) #53
  %1956 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1954) #55
  %1957 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i.i364.i.h2s3401, align 4
  %1958 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1959 = getelementptr inbounds i8, ptr %result.i.i364.i.h2s3401, i64 3
  store i8 0, ptr %1959, align 1
  %puts.i289.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.h2s3401) #53
  br label %._crit_edge.lr.ph.i1687

._crit_edge.lr.ph.i1687:                          ; preds = %._crit_edge.lr.ph.i345.i, %._crit_edge.lr.ph.i1667
  %.not = icmp eq i64 %.0276.lcssa, %.0288.lcssa
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1960 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1961 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i.i1686.h2s3399, align 1
  %spec.select295 = select i1 %.not, i1 %.0282.lcssa, i1 false
  %1962 = getelementptr inbounds i8, ptr %result.i.i1686.h2s3399, i64 18
  store i8 0, ptr %1962, align 1
  %puts.i650 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i1686.h2s3399) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %. = select i1 %spec.select295, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.330 = select i1 %spec.select295, ptr %70, ptr %74
  %.331 = select i1 %spec.select295, ptr %71, ptr %75
  %.332 = select i1 %spec.select295, ptr %72, ptr %76
  %.333 = select i1 %spec.select295, ptr %73, ptr %77
  store ptr @_parameterization_Bufferi8, ptr %.330, align 8
  %.330.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select295, ptr %70, ptr %74
  %.330.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.330.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.330.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.330.sroa.sel342.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select295, ptr %70, ptr %74
  %.330.sroa.sel342.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.330.sroa.sel342.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.330.sroa.sel342.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1963 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.330)
  store ptr @buffer_typ, ptr %.331, align 8
  %.331.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select295, ptr %71, ptr %75
  %.331.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.331.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.331.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.331.sroa.sel337.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select295, ptr %71, ptr %75
  %.331.sroa.sel337.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.331.sroa.sel337.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.331.sroa.sel337.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1964 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.331) #40
  store ptr @_parameterization_String, ptr %.332, align 8
  %1965 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.332)
  %1966 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %.333, align 8
  %1967 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.333) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1968 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1969 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <4 x i8> %., ptr %result.i.i1706.h2s3398, align 4
  %1970 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1971 = getelementptr inbounds i8, ptr %result.i.i1706.h2s3398, i64 4
  store i8 0, ptr %1971, align 4
  %puts.i670 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i1706.h2s3398) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr #18 {
  %2 = alloca {}, align 8
  %result.i.i2074.h2s3821 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i.i2074.h2s3821, align 2
  %result.i.i2054.h2s3822 = alloca [9 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(9) %result.i.i2054.h2s3822, i8 0, i64 9, i1 false)
  %result.i.i2034.h2s3823 = alloca [14 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(14) %result.i.i2034.h2s3823, i8 0, i64 14, i1 false)
  %result.i.i2014.h2s3825 = alloca [5 x i8], align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(5) %result.i.i2014.h2s3825, i8 0, i64 5, i1 false)
  %result.i.i1994.h2s3826 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i.i1994.h2s3826, i8 0, i64 19, i1 false)
  %result.i.i364.i.h2s3828 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i364.i.h2s3828, align 4
  %result.i.i344.i.h2s3830 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i344.i.h2s3830, i8 0, i64 16, i1 false)
  %result.i.i324.i.h2s3832 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i324.i.h2s3832, align 4
  %result.i.i304.i.h2s3834 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i304.i.h2s3834, i8 0, i64 15, i1 false)
  %result.i.i.i.h2s3836 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i.i.h2s3836, i8 0, i64 15, i1 false)
  %result.i.i1974.h2s3838 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i1974.h2s3838, i8 0, i64 16, i1 false)
  %result.i.i1954.h2s3840 = alloca [23 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(23) %result.i.i1954.h2s3840, i8 0, i64 23, i1 false)
  %result.i.i1939.h2s3842 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i.i1939.h2s3842, i8 0, i64 30, i1 false)
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca { ptr }, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca { ptr }, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [1 x ptr], align 8
  %34 = alloca { ptr }, align 8
  %35 = alloca [1 x ptr], align 8
  %36 = alloca { ptr }, align 8
  %37 = alloca [1 x ptr], align 8
  %38 = alloca { ptr }, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %43 = alloca [1 x ptr], align 8
  %44 = alloca { ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca { ptr }, align 8
  %47 = alloca [1 x ptr], align 8
  %48 = alloca { ptr }, align 8
  %49 = alloca [1 x ptr], align 8
  %50 = alloca { ptr }, align 8
  %51 = alloca [1 x ptr], align 8
  %52 = alloca { ptr }, align 8
  %53 = alloca [1 x ptr], align 8
  %54 = alloca { ptr }, align 8
  %55 = alloca [1 x ptr], align 8
  %56 = alloca { ptr }, align 8
  %57 = alloca [1 x ptr], align 8
  %58 = alloca { ptr }, align 8
  %59 = alloca [1 x ptr], align 8
  %60 = alloca { ptr }, align 8
  %61 = alloca [1 x ptr], align 8
  %62 = alloca { ptr }, align 8
  %63 = alloca [1 x ptr], align 8
  %64 = alloca { ptr }, align 8
  %65 = alloca [1 x ptr], align 8
  %66 = alloca { ptr }, align 8
  %oldProtect.i85 = alloca i32, align 4
  %oldProtect.i83 = alloca i32, align 4
  %oldProtect.i81 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0340.sroa.0 = alloca i8, align 8
  %67 = alloca [2 x ptr], align 8
  %68 = alloca [3 x ptr], align 8
  %69 = alloca { ptr, ptr, ptr }, align 8
  %70 = alloca [1 x ptr], align 8
  %71 = alloca { ptr }, align 8
  %72 = alloca [3 x ptr], align 8
  %73 = alloca { ptr, ptr, ptr }, align 8
  %74 = alloca [1 x ptr], align 8
  %75 = alloca { ptr }, align 8
  %result.i79 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i79, align 8
  %76 = getelementptr inbounds i8, ptr %result.i79, i64 8
  store ptr @_parameterization_i32, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %result.i79, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %77, align 8
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i79) #40
  %result.i78 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  %result.i80 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i78, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i78, ptr noalias nofree noundef nonnull readnone @hbaqvtggfm, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i54 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i78) #47
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i78) #40
  %result.i77 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i81) #40
  %result.i82 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i77, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i81) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i81) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i77, ptr noalias nofree noundef nonnull readnone @pvnidioudp, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i53 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i77) #47
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i77) #40
  %81 = getelementptr inbounds i8, ptr %result.i79, i64 48
  store ptr %ret.i54, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i79, i64 56
  store ptr %ret.i53, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i79, i64 40
  store i32 8, ptr %83, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %84 = getelementptr inbounds i8, ptr %result.i79, i64 24
  store ptr %result.i1.i, ptr %84, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %85 = getelementptr inbounds i8, ptr %result.i79, i64 32
  store ptr %result.i.i, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %result.i79, i64 44
  store i32 0, ptr %86, align 4
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  %result.i74 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i74, align 8
  %88 = getelementptr inbounds i8, ptr %result.i74, i64 8
  store ptr @_parameterization_Bool, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i74, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i74) #40
  %result.i73 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i83) #40
  %result.i84 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i73, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i83) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i83) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i73, ptr noalias nofree noundef nonnull readnone @agkclrhtzs, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i52 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i73) #47
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i73) #40
  %result.i72 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i85) #40
  %result.i86 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i72, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i85) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i85) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i72, ptr noalias nofree noundef nonnull readnone @hnbsvmhnda, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i72) #47
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i72) #40
  %93 = getelementptr inbounds i8, ptr %result.i74, i64 48
  store ptr %ret.i52, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i74, i64 56
  store ptr %ret.i, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i74, i64 40
  store i32 8, ptr %95, align 8
  %result.i1.i335 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %96 = getelementptr inbounds i8, ptr %result.i74, i64 24
  store ptr %result.i1.i335, ptr %96, align 8
  %result.i.i336 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %97 = getelementptr inbounds i8, ptr %result.i74, i64 32
  store ptr %result.i.i336, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %99 = getelementptr inbounds i8, ptr %result.i74, i64 44
  store i32 0, ptr %99, align 4
  %100 = mul i32 %0, 10
  %101 = icmp sgt i32 %0, 0
  %102 = icmp sgt i32 %100, 0
  %spec.select263 = and i1 %101, %102
  br i1 %spec.select263, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %105 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i74, 1
  %106 = insertvalue { ptr, ptr, ptr, i32 } %105, ptr undef, 2
  %107 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 10, 3
  %108 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i79, 1
  %109 = insertvalue { ptr, ptr, ptr, i32 } %108, ptr undef, 2
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, i32 10, 3
  %111 = insertvalue { ptr, ptr, ptr, i32 } %108, i32 10, 3
  %112 = insertvalue { ptr, ptr, ptr, i32 } %105, i32 10, 3
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  br label %114

114:                                              ; preds = %._crit_edge1, %.lr.ph
  %result.i76.h2s3845.sroa.0.0 = phi i32 [ 789, %.lr.ph ], [ %117, %._crit_edge1 ]
  %.0375267 = phi i32 [ 0, %.lr.ph ], [ %1772, %._crit_edge1 ]
  %.0378266 = phi i32 [ 0, %.lr.ph ], [ %.1379, %._crit_edge1 ]
  %115 = mul i32 %result.i76.h2s3845.sroa.0.0, 1103515245
  %116 = add i32 %115, 12345
  %117 = and i32 %116, 2147483647
  %.sroa.0364.0.insert.ext = zext nneg i32 %117 to i160
  %118 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0364.0.insert.ext, 1
  %119 = load ptr, ptr %93, align 8
  %120 = call i32 %119({ ptr, i160 } %118) #53
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %122 = load i32, ptr %95, align 8
  %123 = add i32 %122, -1
  %124 = and i32 %123, %120
  %125 = load ptr, ptr %96, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %126 = sext i32 %124 to i64
  %127 = shl nsw i64 %126, 5
  %128 = getelementptr i8, ptr %125, i64 %127
  %129 = load ptr, ptr %128, align 8
  %130 = icmp ne ptr %129, @nil_typ
  %131 = icmp ne ptr %129, null
  %.not45.i = and i1 %130, %131
  br i1 %.not45.i, label %132, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

132:                                              ; preds = %114
  %133 = getelementptr i8, ptr %128, i64 8
  %134 = load i64, ptr %133, align 4
  %.sroa_idx.i = getelementptr i8, ptr %128, i64 16
  %135 = load i64, ptr %.sroa_idx.i, align 4
  %136 = inttoptr i64 %134 to ptr
  %137 = inttoptr i64 %135 to ptr
  %hash_coef_ptr.i.i4.i = getelementptr i8, ptr %129, i64 8
  %tbl_size_ptr.i.i5.i = getelementptr i8, ptr %129, i64 16
  %offset_tbl_ptr.i.i6.i = getelementptr i8, ptr %129, i64 40
  %hash_coef.i.i7.i = load i64, ptr %hash_coef_ptr.i.i4.i, align 4, !noalias !239
  %tbl_size.i.i8.i = load i64, ptr %tbl_size_ptr.i.i5.i, align 4, !noalias !239
  %offset_tbl.i.i9.i = load ptr, ptr %offset_tbl_ptr.i.i6.i, align 8, !noalias !239
  %product.i.i.i10.i = mul i64 %hash_coef.i.i7.i, 4015701072841558310
  %shifted.i.i.i11.i = lshr i64 %product.i.i.i10.i, 32
  %xored.i.i.i12.i = xor i64 %shifted.i.i.i11.i, %product.i.i.i10.i
  %hash.i.i.i13.i = and i64 %xored.i.i.i12.i, %tbl_size.i.i8.i
  %offset_ptr.i.i14.i = getelementptr i32, ptr %offset_tbl.i.i9.i, i64 %hash.i.i.i13.i
  %offset.i.i15.i = load i32, ptr %offset_ptr.i.i14.i, align 4, !noalias !239
  %138 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %129, 0
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, ptr %136, 1
  %140 = insertvalue { ptr, ptr, ptr, i32 } %139, ptr %137, 2
  %141 = insertvalue { ptr, ptr, ptr, i32 } %140, i32 %offset.i.i15.i, 3
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %129) #40
  %144 = sext i32 %offset.i.i15.i to i64
  %145 = getelementptr ptr, ptr %129, i64 %144
  %146 = getelementptr i8, ptr %145, i64 64
  %147 = load ptr, ptr %146, align 8
  %result.i2.i908 = call ptr %147({ ptr, ptr, ptr, i32 } %141, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %148 = call i32 %result.i2.i908({ ptr, ptr, ptr, i32 } %141, { ptr, ptr, ptr, i32 } %141, ptr nonnull align 8 %2) #53
  %149 = icmp eq i32 %148, %120
  br i1 %149, label %._crit_edge.i909, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i909:                                 ; preds = %132
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %129)
  %152 = getelementptr i8, ptr %145, i64 48
  %153 = load ptr, ptr %152, align 8
  %result.i1.i910 = call ptr %153({ ptr, ptr, ptr, i32 } %141, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %154 = call { ptr, i160 } %result.i1.i910({ ptr, ptr, ptr, i32 } %141, { ptr, ptr, ptr, i32 } %141, ptr nonnull align 8 %2) #53
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %156 = load ptr, ptr %94, align 8
  %157 = call i1 %156({ ptr, i160 } %154, { ptr, i160 } %118) #53
  br i1 %157, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i909, %132, %114
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %166

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i909
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %129)
  %160 = getelementptr i8, ptr %145, i64 56
  %161 = load ptr, ptr %160, align 8
  %result.i.i911 = call ptr %161({ ptr, ptr, ptr, i32 } %141, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %162 = call { ptr, i160 } %result.i.i911({ ptr, ptr, ptr, i32 } %141, { ptr, ptr, ptr, i32 } %141, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i = extractvalue { ptr, i160 } %162, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %163 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %164 = icmp ne ptr %.fca.0.extract22.i, @nil_typ
  %165 = icmp ne ptr %.fca.0.extract22.i, null
  %.not63.i = and i1 %164, %165
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %166

166:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %167 = add i32 %120, 2127912214
  %168 = shl i32 %120, 12
  %169 = add i32 %167, %168
  %170 = ashr i32 %169, 19
  %171 = xor i32 %169, %170
  %172 = xor i32 %171, -949894596
  %173 = add i32 %172, 374761393
  %174 = shl i32 %172, 5
  %175 = add i32 %173, %174
  %176 = add i32 %175, -744332180
  %177 = shl i32 %175, 9
  %178 = xor i32 %176, %177
  %179 = add i32 %178, -42973499
  %180 = shl i32 %178, 3
  %181 = add i32 %179, %180
  %182 = ashr i32 %181, 16
  %183 = xor i32 %181, %182
  %184 = xor i32 %183, -1252372727
  %185 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %186 = load i32, ptr %95, align 8
  %187 = add i32 %186, -1
  %188 = and i32 %187, %184
  %189 = load ptr, ptr %97, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %190 = sext i32 %188 to i64
  %191 = shl nsw i64 %190, 5
  %192 = getelementptr i8, ptr %189, i64 %191
  %193 = load ptr, ptr %192, align 8
  %194 = icmp ne ptr %193, @nil_typ
  %195 = icmp ne ptr %193, null
  %.not45.i940 = and i1 %194, %195
  br i1 %.not45.i940, label %196, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit965

196:                                              ; preds = %166
  %197 = getelementptr i8, ptr %192, i64 8
  %198 = load i64, ptr %197, align 4
  %.sroa_idx.i945 = getelementptr i8, ptr %192, i64 16
  %199 = load i64, ptr %.sroa_idx.i945, align 4
  %200 = inttoptr i64 %198 to ptr
  %201 = inttoptr i64 %199 to ptr
  %hash_coef_ptr.i.i4.i946 = getelementptr i8, ptr %193, i64 8
  %tbl_size_ptr.i.i5.i947 = getelementptr i8, ptr %193, i64 16
  %offset_tbl_ptr.i.i6.i948 = getelementptr i8, ptr %193, i64 40
  %hash_coef.i.i7.i949 = load i64, ptr %hash_coef_ptr.i.i4.i946, align 4, !noalias !242
  %tbl_size.i.i8.i950 = load i64, ptr %tbl_size_ptr.i.i5.i947, align 4, !noalias !242
  %offset_tbl.i.i9.i951 = load ptr, ptr %offset_tbl_ptr.i.i6.i948, align 8, !noalias !242
  %product.i.i.i10.i952 = mul i64 %hash_coef.i.i7.i949, 4015701072841558310
  %shifted.i.i.i11.i953 = lshr i64 %product.i.i.i10.i952, 32
  %xored.i.i.i12.i954 = xor i64 %shifted.i.i.i11.i953, %product.i.i.i10.i952
  %hash.i.i.i13.i955 = and i64 %xored.i.i.i12.i954, %tbl_size.i.i8.i950
  %offset_ptr.i.i14.i956 = getelementptr i32, ptr %offset_tbl.i.i9.i951, i64 %hash.i.i.i13.i955
  %offset.i.i15.i957 = load i32, ptr %offset_ptr.i.i14.i956, align 4, !noalias !242
  %202 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %193, 0
  %203 = insertvalue { ptr, ptr, ptr, i32 } %202, ptr %200, 1
  %204 = insertvalue { ptr, ptr, ptr, i32 } %203, ptr %201, 2
  %205 = insertvalue { ptr, ptr, ptr, i32 } %204, i32 %offset.i.i15.i957, 3
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %207 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %193) #40
  %208 = sext i32 %offset.i.i15.i957 to i64
  %209 = getelementptr ptr, ptr %193, i64 %208
  %210 = getelementptr i8, ptr %209, i64 64
  %211 = load ptr, ptr %210, align 8
  %result.i2.i958 = call ptr %211({ ptr, ptr, ptr, i32 } %205, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %212 = call i32 %result.i2.i958({ ptr, ptr, ptr, i32 } %205, { ptr, ptr, ptr, i32 } %205, ptr nonnull align 8 %2) #53
  %213 = icmp eq i32 %212, %120
  br i1 %213, label %._crit_edge.i959, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit965

._crit_edge.i959:                                 ; preds = %196
  %214 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %193)
  %216 = getelementptr i8, ptr %209, i64 48
  %217 = load ptr, ptr %216, align 8
  %result.i1.i960 = call ptr %217({ ptr, ptr, ptr, i32 } %205, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %218 = call { ptr, i160 } %result.i1.i960({ ptr, ptr, ptr, i32 } %205, { ptr, ptr, ptr, i32 } %205, ptr nonnull align 8 %2) #53
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %220 = load ptr, ptr %94, align 8
  %221 = call i1 %220({ ptr, i160 } %218, { ptr, i160 } %118) #53
  br i1 %221, label %222, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit965

222:                                              ; preds = %._crit_edge.i959
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %193)
  %225 = getelementptr i8, ptr %209, i64 56
  %226 = load ptr, ptr %225, align 8
  %result.i.i962 = call ptr %226({ ptr, ptr, ptr, i32 } %205, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %227 = call { ptr, i160 } %result.i.i962({ ptr, ptr, ptr, i32 } %205, { ptr, ptr, ptr, i32 } %205, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i963 = extractvalue { ptr, i160 } %227, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit965

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit965: ; preds = %222, %._crit_edge.i959, %196, %166
  %.reg2mem41.0.i942 = phi ptr [ %.fca.0.extract22.i963, %222 ], [ @nil_typ, %._crit_edge.i959 ], [ @nil_typ, %166 ], [ @nil_typ, %196 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i = icmp eq ptr %.reg2mem41.0.i942, null
  %229 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem41.0.i942
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit965, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.reg2mem56.0.i = phi ptr [ %229, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit965 ], [ %.fca.0.extract22.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %230 = icmp eq ptr %.reg2mem56.0.i, @nil_typ
  %231 = icmp eq ptr %.reg2mem56.0.i, null
  %232 = or i1 %230, %231
  br i1 %232, label %233, label %._crit_edge1

233:                                              ; preds = %CuckooMap_get_keyK.exit
  %234 = add nuw i32 %117, 1
  %.sroa.0347.0.insert.ext = zext i32 %234 to i160
  %235 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0347.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %236 = load ptr, ptr %81, align 8
  %237 = call i32 %236({ ptr, i160 } %118) #53
  %238 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %239 = load i32, ptr %83, align 8
  %240 = add i32 %239, -1
  %241 = and i32 %240, %237
  %242 = load ptr, ptr %84, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %243 = sext i32 %241 to i64
  %244 = shl nsw i64 %243, 5
  %245 = getelementptr i8, ptr %242, i64 %244
  %246 = load ptr, ptr %245, align 8
  %247 = getelementptr i8, ptr %245, i64 8
  %248 = icmp ne ptr %246, @nil_typ
  %249 = icmp ne ptr %246, null
  %.not66.i = and i1 %248, %249
  br i1 %.not66.i, label %250, label %348

250:                                              ; preds = %233
  %251 = load i64, ptr %247, align 4
  %.sroa_idx.i1006 = getelementptr i8, ptr %245, i64 16
  %252 = load i64, ptr %.sroa_idx.i1006, align 4
  %253 = inttoptr i64 %251 to ptr
  %254 = inttoptr i64 %252 to ptr
  %hash_coef_ptr.i.i11.i = getelementptr i8, ptr %246, i64 8
  %tbl_size_ptr.i.i12.i = getelementptr i8, ptr %246, i64 16
  %offset_tbl_ptr.i.i13.i = getelementptr i8, ptr %246, i64 40
  %hash_coef.i.i14.i = load i64, ptr %hash_coef_ptr.i.i11.i, align 4, !noalias !245
  %tbl_size.i.i15.i = load i64, ptr %tbl_size_ptr.i.i12.i, align 4, !noalias !245
  %offset_tbl.i.i16.i = load ptr, ptr %offset_tbl_ptr.i.i13.i, align 8, !noalias !245
  %product.i.i.i17.i = mul i64 %hash_coef.i.i14.i, 4015701072841558310
  %shifted.i.i.i18.i = lshr i64 %product.i.i.i17.i, 32
  %xored.i.i.i19.i = xor i64 %shifted.i.i.i18.i, %product.i.i.i17.i
  %hash.i.i.i20.i = and i64 %xored.i.i.i19.i, %tbl_size.i.i15.i
  %offset_ptr.i.i21.i = getelementptr i32, ptr %offset_tbl.i.i16.i, i64 %hash.i.i.i20.i
  %offset.i.i22.i = load i32, ptr %offset_ptr.i.i21.i, align 4, !noalias !245
  %255 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %246, 0
  %256 = insertvalue { ptr, ptr, ptr, i32 } %255, ptr %253, 1
  %257 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %254, 2
  %258 = insertvalue { ptr, ptr, ptr, i32 } %257, i32 %offset.i.i22.i, 3
  %259 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %260 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %246) #40
  %261 = sext i32 %offset.i.i22.i to i64
  %262 = getelementptr ptr, ptr %246, i64 %261
  %263 = getelementptr i8, ptr %262, i64 64
  %264 = load ptr, ptr %263, align 8
  %result.i8.i1007 = call ptr %264({ ptr, ptr, ptr, i32 } %258, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %265 = call i32 %result.i8.i1007({ ptr, ptr, ptr, i32 } %258, { ptr, ptr, ptr, i32 } %258, ptr nonnull align 8 %2) #53
  %266 = icmp eq i32 %265, %237
  br i1 %266, label %._crit_edge.i1008, label %348

._crit_edge.i1008:                                ; preds = %250
  %267 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %268 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %246)
  %269 = getelementptr i8, ptr %262, i64 48
  %270 = load ptr, ptr %269, align 8
  %result.i7.i = call ptr %270({ ptr, ptr, ptr, i32 } %258, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %271 = call { ptr, i160 } %result.i7.i({ ptr, ptr, ptr, i32 } %258, { ptr, ptr, ptr, i32 } %258, ptr nonnull align 8 %2) #53
  %272 = load ptr, ptr %82, align 8
  %273 = call i1 %272({ ptr, i160 } %271, { ptr, i160 } %118) #53
  br i1 %273, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %348

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1008
  %274 = load ptr, ptr %result.i79, align 8
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %276 = load ptr, ptr %76, align 8
  %277 = load ptr, ptr %274, align 8, !alias.scope !248
  %278 = getelementptr i8, ptr %277, i64 72
  %279 = load ptr, ptr %278, align 8, !alias.scope !248
  %result.i1.i.i = call { i64, i64 } %279(ptr nocapture nofree nonnull readonly align 8 %274) #44, !alias.scope !248
  %280 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %281 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %282 = urem i64 20, %281
  %283 = icmp eq i64 %282, 0
  %284 = sub i64 %281, %282
  %285 = select i1 %283, i64 0, i64 %284
  %286 = add i64 %280, 20
  %287 = add i64 %286, %285
  %288 = load ptr, ptr %276, align 8, !alias.scope !248
  %289 = getelementptr i8, ptr %288, i64 72
  %290 = load ptr, ptr %289, align 8, !alias.scope !248
  %result.i.i.i1009 = call { i64, i64 } %290(ptr nocapture nofree nonnull readonly align 8 %276) #44, !alias.scope !248
  %291 = extractvalue { i64, i64 } %result.i.i.i1009, 0
  %292 = extractvalue { i64, i64 } %result.i.i.i1009, 1
  %293 = call i64 @llvm.umax.i64(i64 %281, i64 %292) #41
  %294 = call i64 @llvm.umax.i64(i64 %293, i64 noundef 8) #41, !range !16
  %295 = urem i64 %287, %292
  %296 = icmp eq i64 %295, 0
  %297 = sub i64 %292, %295
  %298 = select i1 %296, i64 0, i64 %297
  %299 = add i64 %291, %287
  %300 = add i64 %299, %298
  %301 = urem i64 %300, %294
  %302 = icmp eq i64 %301, 0
  %303 = sub i64 %294, %301
  %304 = select i1 %302, i64 0, i64 %303
  %305 = add i64 %304, %300
  %result.i9.i1010 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %305) #48
  store ptr %274, ptr %result.i9.i1010, align 8
  %306 = getelementptr inbounds i8, ptr %result.i9.i1010, i64 8
  store ptr %276, ptr %306, align 8
  %307 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1010)
  %308 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %309 = load ptr, ptr %274, align 8
  %310 = getelementptr i8, ptr %309, i64 72
  %311 = load ptr, ptr %310, align 8
  %result.i.i38.i = call { i64, i64 } %311(ptr nocapture nofree nonnull readonly align 8 %274) #44
  %312 = extractvalue { i64, i64 } %result.i.i38.i, 1
  %313 = urem i64 20, %312
  %314 = icmp eq i64 %313, 0
  %reass.sub3875 = sub i64 %312, %313
  %315 = add i64 %reass.sub3875, 20
  %316 = select i1 %314, i64 20, i64 %315
  %317 = getelementptr i8, ptr %result.i9.i1010, i64 %316
  %318 = getelementptr i8, ptr %309, i64 64
  %319 = load ptr, ptr %318, align 8
  call void %319({ ptr, i160 } %118, ptr nocapture nofree nonnull readonly align 8 %274, ptr nocapture nofree writeonly %317) #45
  %320 = load ptr, ptr %result.i9.i1010, align 8
  %321 = load ptr, ptr %320, align 8
  %322 = getelementptr i8, ptr %321, i64 72
  %323 = load ptr, ptr %322, align 8
  %result.i1.i39.i = call { i64, i64 } %323(ptr nocapture nofree nonnull readonly align 8 %320) #44
  %324 = extractvalue { i64, i64 } %result.i1.i39.i, 0
  %325 = extractvalue { i64, i64 } %result.i1.i39.i, 1
  %326 = urem i64 20, %325
  %327 = icmp eq i64 %326, 0
  %328 = sub i64 %325, %326
  %329 = select i1 %327, i64 0, i64 %328
  %330 = add i64 %324, 20
  %331 = add i64 %330, %329
  %332 = load ptr, ptr %306, align 8
  %333 = load ptr, ptr %332, align 8
  %334 = getelementptr i8, ptr %333, i64 72
  %335 = load ptr, ptr %334, align 8
  %result.i.i40.i = call { i64, i64 } %335(ptr nocapture nofree nonnull readonly align 8 %332) #44
  %336 = extractvalue { i64, i64 } %result.i.i40.i, 1
  %337 = urem i64 %331, %336
  %338 = icmp eq i64 %337, 0
  %339 = sub i64 %336, %337
  %340 = select i1 %338, i64 0, i64 %339
  %341 = getelementptr i8, ptr %result.i9.i1010, i64 %331
  %342 = getelementptr i8, ptr %341, i64 %340
  %343 = getelementptr i8, ptr %333, i64 64
  %344 = load ptr, ptr %343, align 8
  call void %344({ ptr, i160 } %235, ptr nocapture nofree nonnull readonly align 8 %332, ptr nocapture nofree writeonly %342) #45
  %345 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %346 = getelementptr inbounds i8, ptr %result.i9.i1010, i64 16
  store i32 %237, ptr %346, align 8
  store ptr @Entry, ptr %245, align 8
  %347 = ptrtoint ptr %result.i9.i1010 to i64
  store i64 %347, ptr %247, align 4
  %.sroa_idx30.i = getelementptr i8, ptr %245, i64 24
  store i32 10, ptr %.sroa_idx30.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

348:                                              ; preds = %._crit_edge.i1008, %250, %233
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %349 = add i32 %237, 2127912214
  %350 = shl i32 %237, 12
  %351 = add i32 %349, %350
  %352 = ashr i32 %351, 19
  %353 = xor i32 %351, %352
  %354 = xor i32 %353, -949894596
  %355 = add i32 %354, 374761393
  %356 = shl i32 %354, 5
  %357 = add i32 %355, %356
  %358 = add i32 %357, -744332180
  %359 = shl i32 %357, 9
  %360 = xor i32 %358, %359
  %361 = add i32 %360, -42973499
  %362 = shl i32 %360, 3
  %363 = add i32 %361, %362
  %364 = ashr i32 %363, 16
  %365 = xor i32 %363, %364
  %366 = xor i32 %365, -1252372727
  %367 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %368 = load i32, ptr %83, align 8
  %369 = add i32 %368, -1
  %370 = and i32 %369, %366
  %371 = load ptr, ptr %85, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %372 = sext i32 %370 to i64
  %373 = shl nsw i64 %372, 5
  %374 = getelementptr i8, ptr %371, i64 %373
  %375 = load ptr, ptr %374, align 8
  %376 = getelementptr i8, ptr %374, i64 8
  %377 = icmp ne ptr %375, @nil_typ
  %378 = icmp ne ptr %375, null
  %.not66.i1040 = and i1 %377, %378
  br i1 %.not66.i1040, label %379, label %477

379:                                              ; preds = %348
  %380 = load i64, ptr %376, align 4
  %.sroa_idx.i1042 = getelementptr i8, ptr %374, i64 16
  %381 = load i64, ptr %.sroa_idx.i1042, align 4
  %382 = inttoptr i64 %380 to ptr
  %383 = inttoptr i64 %381 to ptr
  %hash_coef_ptr.i.i11.i1043 = getelementptr i8, ptr %375, i64 8
  %tbl_size_ptr.i.i12.i1044 = getelementptr i8, ptr %375, i64 16
  %offset_tbl_ptr.i.i13.i1045 = getelementptr i8, ptr %375, i64 40
  %hash_coef.i.i14.i1046 = load i64, ptr %hash_coef_ptr.i.i11.i1043, align 4, !noalias !251
  %tbl_size.i.i15.i1047 = load i64, ptr %tbl_size_ptr.i.i12.i1044, align 4, !noalias !251
  %offset_tbl.i.i16.i1048 = load ptr, ptr %offset_tbl_ptr.i.i13.i1045, align 8, !noalias !251
  %product.i.i.i17.i1049 = mul i64 %hash_coef.i.i14.i1046, 4015701072841558310
  %shifted.i.i.i18.i1050 = lshr i64 %product.i.i.i17.i1049, 32
  %xored.i.i.i19.i1051 = xor i64 %shifted.i.i.i18.i1050, %product.i.i.i17.i1049
  %hash.i.i.i20.i1052 = and i64 %xored.i.i.i19.i1051, %tbl_size.i.i15.i1047
  %offset_ptr.i.i21.i1053 = getelementptr i32, ptr %offset_tbl.i.i16.i1048, i64 %hash.i.i.i20.i1052
  %offset.i.i22.i1054 = load i32, ptr %offset_ptr.i.i21.i1053, align 4, !noalias !251
  %384 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %375, 0
  %385 = insertvalue { ptr, ptr, ptr, i32 } %384, ptr %382, 1
  %386 = insertvalue { ptr, ptr, ptr, i32 } %385, ptr %383, 2
  %387 = insertvalue { ptr, ptr, ptr, i32 } %386, i32 %offset.i.i22.i1054, 3
  %388 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %389 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %375) #40
  %390 = sext i32 %offset.i.i22.i1054 to i64
  %391 = getelementptr ptr, ptr %375, i64 %390
  %392 = getelementptr i8, ptr %391, i64 64
  %393 = load ptr, ptr %392, align 8
  %result.i8.i1055 = call ptr %393({ ptr, ptr, ptr, i32 } %387, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %394 = call i32 %result.i8.i1055({ ptr, ptr, ptr, i32 } %387, { ptr, ptr, ptr, i32 } %387, ptr nonnull align 8 %2) #53
  %395 = icmp eq i32 %394, %237
  br i1 %395, label %._crit_edge.i1056, label %477

._crit_edge.i1056:                                ; preds = %379
  %396 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %397 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %375)
  %398 = getelementptr i8, ptr %391, i64 48
  %399 = load ptr, ptr %398, align 8
  %result.i7.i1057 = call ptr %399({ ptr, ptr, ptr, i32 } %387, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %400 = call { ptr, i160 } %result.i7.i1057({ ptr, ptr, ptr, i32 } %387, { ptr, ptr, ptr, i32 } %387, ptr nonnull align 8 %2) #53
  %401 = load ptr, ptr %82, align 8
  %402 = call i1 %401({ ptr, i160 } %400, { ptr, i160 } %118) #53
  br i1 %402, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1069, label %477

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1069: ; preds = %._crit_edge.i1056
  %403 = load ptr, ptr %result.i79, align 8
  %404 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %405 = load ptr, ptr %76, align 8
  %406 = load ptr, ptr %403, align 8, !alias.scope !254
  %407 = getelementptr i8, ptr %406, i64 72
  %408 = load ptr, ptr %407, align 8, !alias.scope !254
  %result.i1.i.i1061 = call { i64, i64 } %408(ptr nocapture nofree nonnull readonly align 8 %403) #44, !alias.scope !254
  %409 = extractvalue { i64, i64 } %result.i1.i.i1061, 0
  %410 = extractvalue { i64, i64 } %result.i1.i.i1061, 1
  %411 = urem i64 20, %410
  %412 = icmp eq i64 %411, 0
  %413 = sub i64 %410, %411
  %414 = select i1 %412, i64 0, i64 %413
  %415 = add i64 %409, 20
  %416 = add i64 %415, %414
  %417 = load ptr, ptr %405, align 8, !alias.scope !254
  %418 = getelementptr i8, ptr %417, i64 72
  %419 = load ptr, ptr %418, align 8, !alias.scope !254
  %result.i.i.i1062 = call { i64, i64 } %419(ptr nocapture nofree nonnull readonly align 8 %405) #44, !alias.scope !254
  %420 = extractvalue { i64, i64 } %result.i.i.i1062, 0
  %421 = extractvalue { i64, i64 } %result.i.i.i1062, 1
  %422 = call i64 @llvm.umax.i64(i64 %410, i64 %421) #41
  %423 = call i64 @llvm.umax.i64(i64 %422, i64 noundef 8) #41, !range !16
  %424 = urem i64 %416, %421
  %425 = icmp eq i64 %424, 0
  %426 = sub i64 %421, %424
  %427 = select i1 %425, i64 0, i64 %426
  %428 = add i64 %420, %416
  %429 = add i64 %428, %427
  %430 = urem i64 %429, %423
  %431 = icmp eq i64 %430, 0
  %432 = sub i64 %423, %430
  %433 = select i1 %431, i64 0, i64 %432
  %434 = add i64 %433, %429
  %result.i9.i1063 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %434) #48
  store ptr %403, ptr %result.i9.i1063, align 8
  %435 = getelementptr inbounds i8, ptr %result.i9.i1063, i64 8
  store ptr %405, ptr %435, align 8
  %436 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1063)
  %437 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %438 = load ptr, ptr %403, align 8
  %439 = getelementptr i8, ptr %438, i64 72
  %440 = load ptr, ptr %439, align 8
  %result.i.i38.i1064 = call { i64, i64 } %440(ptr nocapture nofree nonnull readonly align 8 %403) #44
  %441 = extractvalue { i64, i64 } %result.i.i38.i1064, 1
  %442 = urem i64 20, %441
  %443 = icmp eq i64 %442, 0
  %reass.sub3874 = sub i64 %441, %442
  %444 = add i64 %reass.sub3874, 20
  %445 = select i1 %443, i64 20, i64 %444
  %446 = getelementptr i8, ptr %result.i9.i1063, i64 %445
  %447 = getelementptr i8, ptr %438, i64 64
  %448 = load ptr, ptr %447, align 8
  call void %448({ ptr, i160 } %118, ptr nocapture nofree nonnull readonly align 8 %403, ptr nocapture nofree writeonly %446) #45
  %449 = load ptr, ptr %result.i9.i1063, align 8
  %450 = load ptr, ptr %449, align 8
  %451 = getelementptr i8, ptr %450, i64 72
  %452 = load ptr, ptr %451, align 8
  %result.i1.i39.i1066 = call { i64, i64 } %452(ptr nocapture nofree nonnull readonly align 8 %449) #44
  %453 = extractvalue { i64, i64 } %result.i1.i39.i1066, 0
  %454 = extractvalue { i64, i64 } %result.i1.i39.i1066, 1
  %455 = urem i64 20, %454
  %456 = icmp eq i64 %455, 0
  %457 = sub i64 %454, %455
  %458 = select i1 %456, i64 0, i64 %457
  %459 = add i64 %453, 20
  %460 = add i64 %459, %458
  %461 = load ptr, ptr %435, align 8
  %462 = load ptr, ptr %461, align 8
  %463 = getelementptr i8, ptr %462, i64 72
  %464 = load ptr, ptr %463, align 8
  %result.i.i40.i1067 = call { i64, i64 } %464(ptr nocapture nofree nonnull readonly align 8 %461) #44
  %465 = extractvalue { i64, i64 } %result.i.i40.i1067, 1
  %466 = urem i64 %460, %465
  %467 = icmp eq i64 %466, 0
  %468 = sub i64 %465, %466
  %469 = select i1 %467, i64 0, i64 %468
  %470 = getelementptr i8, ptr %result.i9.i1063, i64 %460
  %471 = getelementptr i8, ptr %470, i64 %469
  %472 = getelementptr i8, ptr %462, i64 64
  %473 = load ptr, ptr %472, align 8
  call void %473({ ptr, i160 } %235, ptr nocapture nofree nonnull readonly align 8 %461, ptr nocapture nofree writeonly %471) #45
  %474 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %475 = getelementptr inbounds i8, ptr %result.i9.i1063, i64 16
  store i32 %237, ptr %475, align 8
  store ptr @Entry, ptr %374, align 8
  %476 = ptrtoint ptr %result.i9.i1063 to i64
  store i64 %476, ptr %376, align 4
  %.sroa_idx30.i1068 = getelementptr i8, ptr %374, i64 24
  store i32 10, ptr %.sroa_idx30.i1068, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

477:                                              ; preds = %._crit_edge.i1056, %379, %348
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %478 = load i32, ptr %86, align 4
  %479 = load i32, ptr %83, align 8
  %.not.i388 = icmp slt i32 %478, %479
  br i1 %.not.i388, label %._crit_edge.i, label %480

480:                                              ; preds = %477
  %481 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %482 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %483 = load ptr, ptr %84, align 8
  %484 = load ptr, ptr %85, align 8
  %485 = shl i32 %479, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %485, i32 noundef 16) #40
  store i32 %spec.select.i, ptr %83, align 8
  %486 = zext nneg i32 %spec.select.i to i64
  %487 = shl nuw nsw i64 %486, 5
  %result.i5.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %487) #48
  store ptr %result.i5.i, ptr %84, align 8
  %result.i4.i1084 = call noalias ptr @bump_malloc_wrapper(i64 noundef %487) #48
  store ptr %result.i4.i1084, ptr %85, align 8
  store i32 0, ptr %86, align 4
  %488 = icmp sgt i32 %479, 0
  br i1 %488, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %480
  %wide.trip.count.i = zext nneg i32 %479 to i64
  br label %489

489:                                              ; preds = %._crit_edge.i2169, %.lr.ph.i
  %indvars.iv.i2168 = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i2170, %._crit_edge.i2169 ]
  %490 = shl nuw nsw i64 %indvars.iv.i2168, 5
  %491 = getelementptr i8, ptr %483, i64 %490
  %492 = load ptr, ptr %491, align 8
  %493 = icmp ne ptr %492, @nil_typ
  %494 = icmp ne ptr %492, null
  %.not17.i = and i1 %493, %494
  br i1 %.not17.i, label %495, label %._crit_edge.i2169

495:                                              ; preds = %489
  %496 = getelementptr i8, ptr %491, i64 8
  %497 = load i64, ptr %496, align 4
  %.sroa_idx.i2172 = getelementptr i8, ptr %491, i64 16
  %498 = load i64, ptr %.sroa_idx.i2172, align 4
  %hash_coef_ptr.i.i6.i = getelementptr i8, ptr %492, i64 8
  %tbl_size_ptr.i.i7.i = getelementptr i8, ptr %492, i64 16
  %offset_tbl_ptr.i.i8.i = getelementptr i8, ptr %492, i64 40
  %499 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i6.i, align 4, !noalias !257
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i7.i, align 4, !noalias !257
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i8.i, align 8, !noalias !257
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i29.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !257
  %500 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %502 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %503

503:                                              ; preds = %.cont.i2761, %495
  %.0290.i2743 = phi i32 [ 0, %495 ], [ %536, %.cont.i2761 ]
  %.074289.i2744 = phi i1 [ true, %495 ], [ %537, %.cont.i2761 ]
  %.sroa.0.0288.i2745 = phi ptr [ %492, %495 ], [ %526, %.cont.i2761 ]
  %.sroa.6.0287.i2746.in = phi i64 [ %497, %495 ], [ %528, %.cont.i2761 ]
  %.sroa.12.0286.i2747.in = phi i64 [ %498, %495 ], [ %529, %.cont.i2761 ]
  %.sroa.17.0285.i2748 = phi i32 [ %offset.i.i29.i, %495 ], [ %offset.i.i57.i2773, %.cont.i2761 ]
  %.sroa.12.0286.i2747 = inttoptr i64 %.sroa.12.0286.i2747.in to ptr
  %.sroa.6.0287.i2746 = inttoptr i64 %.sroa.6.0287.i2746.in to ptr
  %504 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2745, 0
  %505 = insertvalue { ptr, ptr, ptr, i32 } %504, ptr %.sroa.6.0287.i2746, 1
  %506 = insertvalue { ptr, ptr, ptr, i32 } %505, ptr %.sroa.12.0286.i2747, 2
  %507 = insertvalue { ptr, ptr, ptr, i32 } %506, i32 %.sroa.17.0285.i2748, 3
  %508 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2745)
  %509 = sext i32 %.sroa.17.0285.i2748 to i64
  %510 = getelementptr ptr, ptr %.sroa.0.0288.i2745, i64 %509
  %511 = getelementptr i8, ptr %510, i64 64
  %512 = load ptr, ptr %511, align 8
  %result.i15.i2749 = call ptr %512({ ptr, ptr, ptr, i32 } %507, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %513 = call i32 %result.i15.i2749({ ptr, ptr, ptr, i32 } %507, { ptr, ptr, ptr, i32 } %507, ptr nonnull align 8 %2) #53
  %..i2750 = select i1 %.074289.i2744, ptr %47, ptr %49
  %.188.i2751 = select i1 %.074289.i2744, i64 104, i64 112
  %.189.i2752 = select i1 %.074289.i2744, ptr %48, ptr %50
  %.190.i2753 = select i1 %.074289.i2744, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2750, align 8
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2750)
  %515 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2751
  %516 = load ptr, ptr %515, align 8
  store ptr @i32_typ, ptr %.189.i2752, align 8
  %result.i14.i2754 = call ptr %516({ ptr, ptr, ptr, i32 } %111, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2752) #46
  %517 = call i32 %result.i14.i2754({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull align 8 dereferenceable(8) %..i2750, i32 %513) #53
  %518 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %519 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2753
  %520 = load ptr, ptr %519, align 8
  %521 = load ptr, ptr %520, align 8
  %522 = call { ptr } %521(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i2755 = extractvalue { ptr } %522, 0
  %523 = sext i32 %517 to i64
  %524 = shl nsw i64 %523, 5
  %525 = getelementptr i8, ptr %.fca.0.extract55.i2755, i64 %524
  %526 = load ptr, ptr %525, align 8
  %527 = getelementptr i8, ptr %525, i64 8
  %528 = load i64, ptr %527, align 4
  %.sroa_idx.i2756 = getelementptr i8, ptr %525, i64 16
  %529 = load i64, ptr %.sroa_idx.i2756, align 4
  %530 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %531 = call { ptr } %521(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i2757 = extractvalue { ptr } %531, 0
  %532 = getelementptr i8, ptr %.fca.0.extract52.i2757, i64 %524
  store ptr %.sroa.0.0288.i2745, ptr %532, align 8
  %533 = getelementptr i8, ptr %532, i64 8
  store i64 %.sroa.6.0287.i2746.in, ptr %533, align 4
  %.sroa_idx104.i2758 = getelementptr i8, ptr %532, i64 16
  store i64 %.sroa.12.0286.i2747.in, ptr %.sroa_idx104.i2758, align 4
  %.sroa_idx105.i2759 = getelementptr i8, ptr %532, i64 24
  store i32 %.sroa.17.0285.i2748, ptr %.sroa_idx105.i2759, align 4
  %534 = icmp ne ptr %526, @nil_typ
  %535 = icmp ne ptr %526, null
  %.not94.i2760 = and i1 %534, %535
  br i1 %.not94.i2760, label %.cont.i2761, label %540

.cont.i2761:                                      ; preds = %503
  %536 = add nuw nsw i32 %.0290.i2743, 1
  %537 = xor i1 %.074289.i2744, true
  %hash_coef_ptr.i.i46.i2762 = getelementptr i8, ptr %526, i64 8
  %tbl_size_ptr.i.i47.i2763 = getelementptr i8, ptr %526, i64 16
  %offset_tbl_ptr.i.i48.i2764 = getelementptr i8, ptr %526, i64 40
  %hash_coef.i.i49.i2765 = load i64, ptr %hash_coef_ptr.i.i46.i2762, align 4
  %tbl_size.i.i50.i2766 = load i64, ptr %tbl_size_ptr.i.i47.i2763, align 4
  %offset_tbl.i.i51.i2767 = load ptr, ptr %offset_tbl_ptr.i.i48.i2764, align 8
  %product.i.i.i52.i2768 = mul i64 %hash_coef.i.i49.i2765, 4015701072841558310
  %shifted.i.i.i53.i2769 = lshr i64 %product.i.i.i52.i2768, 32
  %xored.i.i.i54.i2770 = xor i64 %shifted.i.i.i53.i2769, %product.i.i.i52.i2768
  %hash.i.i.i55.i2771 = and i64 %xored.i.i.i54.i2770, %tbl_size.i.i50.i2766
  %offset_ptr.i.i56.i2772 = getelementptr i32, ptr %offset_tbl.i.i51.i2767, i64 %hash.i.i.i55.i2771
  %offset.i.i57.i2773 = load i32, ptr %offset_ptr.i.i56.i2772, align 4
  %538 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %539 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2774 = icmp eq i32 %536, 100
  br i1 %exitcond.not.i2774, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2776, label %503

540:                                              ; preds = %503
  %541 = load i32, ptr %86, align 4
  %542 = add i32 %541, 1
  %543 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %542, ptr %86, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2776

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2776: ; preds = %540, %.cont.i2761
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  br label %._crit_edge.i2169

._crit_edge.i2169:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2776, %489
  %indvars.iv.next.i2170 = add nuw nsw i64 %indvars.iv.i2168, 1
  %exitcond.not.i2171 = icmp eq i64 %indvars.iv.next.i2170, %wide.trip.count.i
  br i1 %exitcond.not.i2171, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit, label %489

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit: ; preds = %._crit_edge.i2192, %._crit_edge.i2169
  %indvars.iv.i2190 = phi i64 [ %indvars.iv.next.i2193, %._crit_edge.i2192 ], [ 0, %._crit_edge.i2169 ]
  %544 = shl nuw nsw i64 %indvars.iv.i2190, 5
  %545 = getelementptr i8, ptr %484, i64 %544
  %546 = load ptr, ptr %545, align 8
  %547 = icmp ne ptr %546, @nil_typ
  %548 = icmp ne ptr %546, null
  %.not17.i2191 = and i1 %547, %548
  br i1 %.not17.i2191, label %549, label %._crit_edge.i2192

549:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %550 = getelementptr i8, ptr %545, i64 8
  %551 = load i64, ptr %550, align 4
  %.sroa_idx.i2195 = getelementptr i8, ptr %545, i64 16
  %552 = load i64, ptr %.sroa_idx.i2195, align 4
  %hash_coef_ptr.i.i6.i2196 = getelementptr i8, ptr %546, i64 8
  %tbl_size_ptr.i.i7.i2197 = getelementptr i8, ptr %546, i64 16
  %offset_tbl_ptr.i.i8.i2198 = getelementptr i8, ptr %546, i64 40
  %553 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  %hash_coef.i.i21.i2794 = load i64, ptr %hash_coef_ptr.i.i6.i2196, align 4, !noalias !260
  %tbl_size.i.i22.i2795 = load i64, ptr %tbl_size_ptr.i.i7.i2197, align 4, !noalias !260
  %offset_tbl.i.i23.i2796 = load ptr, ptr %offset_tbl_ptr.i.i8.i2198, align 8, !noalias !260
  %product.i.i.i24.i2797 = mul i64 %hash_coef.i.i21.i2794, 4015701072841558310
  %shifted.i.i.i25.i2798 = lshr i64 %product.i.i.i24.i2797, 32
  %xored.i.i.i26.i2799 = xor i64 %shifted.i.i.i25.i2798, %product.i.i.i24.i2797
  %hash.i.i.i27.i2800 = and i64 %xored.i.i.i26.i2799, %tbl_size.i.i22.i2795
  %offset_ptr.i.i28.i2801 = getelementptr i32, ptr %offset_tbl.i.i23.i2796, i64 %hash.i.i.i27.i2800
  %offset.i.i29.i2802 = load i32, ptr %offset_ptr.i.i28.i2801, align 4, !noalias !260
  %554 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %556 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %557

557:                                              ; preds = %.cont.i2825, %549
  %.0290.i2803 = phi i32 [ 0, %549 ], [ %590, %.cont.i2825 ]
  %.074289.i2804 = phi i1 [ true, %549 ], [ %591, %.cont.i2825 ]
  %.sroa.0.0288.i2805 = phi ptr [ %546, %549 ], [ %580, %.cont.i2825 ]
  %.sroa.6.0287.i2806.in = phi i64 [ %551, %549 ], [ %582, %.cont.i2825 ]
  %.sroa.12.0286.i2807.in = phi i64 [ %552, %549 ], [ %583, %.cont.i2825 ]
  %.sroa.17.0285.i2808 = phi i32 [ %offset.i.i29.i2802, %549 ], [ %offset.i.i57.i2837, %.cont.i2825 ]
  %.sroa.12.0286.i2807 = inttoptr i64 %.sroa.12.0286.i2807.in to ptr
  %.sroa.6.0287.i2806 = inttoptr i64 %.sroa.6.0287.i2806.in to ptr
  %558 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2805, 0
  %559 = insertvalue { ptr, ptr, ptr, i32 } %558, ptr %.sroa.6.0287.i2806, 1
  %560 = insertvalue { ptr, ptr, ptr, i32 } %559, ptr %.sroa.12.0286.i2807, 2
  %561 = insertvalue { ptr, ptr, ptr, i32 } %560, i32 %.sroa.17.0285.i2808, 3
  %562 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2805)
  %563 = sext i32 %.sroa.17.0285.i2808 to i64
  %564 = getelementptr ptr, ptr %.sroa.0.0288.i2805, i64 %563
  %565 = getelementptr i8, ptr %564, i64 64
  %566 = load ptr, ptr %565, align 8
  %result.i15.i2809 = call ptr %566({ ptr, ptr, ptr, i32 } %561, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %567 = call i32 %result.i15.i2809({ ptr, ptr, ptr, i32 } %561, { ptr, ptr, ptr, i32 } %561, ptr nonnull align 8 %2) #53
  %..i2810 = select i1 %.074289.i2804, ptr %43, ptr %45
  %.188.i2811 = select i1 %.074289.i2804, i64 104, i64 112
  %.189.i2812 = select i1 %.074289.i2804, ptr %44, ptr %46
  %.190.i2813 = select i1 %.074289.i2804, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2810, align 8
  %568 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2810)
  %569 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2811
  %570 = load ptr, ptr %569, align 8
  store ptr @i32_typ, ptr %.189.i2812, align 8
  %result.i14.i2814 = call ptr %570({ ptr, ptr, ptr, i32 } %111, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2812) #46
  %571 = call i32 %result.i14.i2814({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull align 8 dereferenceable(8) %..i2810, i32 %567) #53
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %573 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2813
  %574 = load ptr, ptr %573, align 8
  %575 = load ptr, ptr %574, align 8
  %576 = call { ptr } %575(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i2815 = extractvalue { ptr } %576, 0
  %577 = sext i32 %571 to i64
  %578 = shl nsw i64 %577, 5
  %579 = getelementptr i8, ptr %.fca.0.extract55.i2815, i64 %578
  %580 = load ptr, ptr %579, align 8
  %581 = getelementptr i8, ptr %579, i64 8
  %582 = load i64, ptr %581, align 4
  %.sroa_idx.i2816 = getelementptr i8, ptr %579, i64 16
  %583 = load i64, ptr %.sroa_idx.i2816, align 4
  %584 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %585 = call { ptr } %575(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i2817 = extractvalue { ptr } %585, 0
  %586 = getelementptr i8, ptr %.fca.0.extract52.i2817, i64 %578
  store ptr %.sroa.0.0288.i2805, ptr %586, align 8
  %587 = getelementptr i8, ptr %586, i64 8
  store i64 %.sroa.6.0287.i2806.in, ptr %587, align 4
  %.sroa_idx104.i2818 = getelementptr i8, ptr %586, i64 16
  store i64 %.sroa.12.0286.i2807.in, ptr %.sroa_idx104.i2818, align 4
  %.sroa_idx105.i2819 = getelementptr i8, ptr %586, i64 24
  store i32 %.sroa.17.0285.i2808, ptr %.sroa_idx105.i2819, align 4
  %588 = icmp ne ptr %580, @nil_typ
  %589 = icmp ne ptr %580, null
  %.not94.i2820 = and i1 %588, %589
  br i1 %.not94.i2820, label %.cont.i2825, label %594

.cont.i2825:                                      ; preds = %557
  %590 = add nuw nsw i32 %.0290.i2803, 1
  %591 = xor i1 %.074289.i2804, true
  %hash_coef_ptr.i.i46.i2826 = getelementptr i8, ptr %580, i64 8
  %tbl_size_ptr.i.i47.i2827 = getelementptr i8, ptr %580, i64 16
  %offset_tbl_ptr.i.i48.i2828 = getelementptr i8, ptr %580, i64 40
  %hash_coef.i.i49.i2829 = load i64, ptr %hash_coef_ptr.i.i46.i2826, align 4
  %tbl_size.i.i50.i2830 = load i64, ptr %tbl_size_ptr.i.i47.i2827, align 4
  %offset_tbl.i.i51.i2831 = load ptr, ptr %offset_tbl_ptr.i.i48.i2828, align 8
  %product.i.i.i52.i2832 = mul i64 %hash_coef.i.i49.i2829, 4015701072841558310
  %shifted.i.i.i53.i2833 = lshr i64 %product.i.i.i52.i2832, 32
  %xored.i.i.i54.i2834 = xor i64 %shifted.i.i.i53.i2833, %product.i.i.i52.i2832
  %hash.i.i.i55.i2835 = and i64 %xored.i.i.i54.i2834, %tbl_size.i.i50.i2830
  %offset_ptr.i.i56.i2836 = getelementptr i32, ptr %offset_tbl.i.i51.i2831, i64 %hash.i.i.i55.i2835
  %offset.i.i57.i2837 = load i32, ptr %offset_ptr.i.i56.i2836, align 4
  %592 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %593 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2838 = icmp eq i32 %590, 100
  br i1 %exitcond.not.i2838, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847, label %557

594:                                              ; preds = %557
  %595 = load i32, ptr %86, align 4
  %596 = add i32 %595, 1
  %597 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %596, ptr %86, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847: ; preds = %594, %.cont.i2825
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  br label %._crit_edge.i2192

._crit_edge.i2192:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %indvars.iv.next.i2193 = add nuw nsw i64 %indvars.iv.i2190, 1
  %exitcond.not.i2194 = icmp eq i64 %indvars.iv.next.i2193, %wide.trip.count.i
  br i1 %exitcond.not.i2194, label %._crit_edge.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit

._crit_edge.i:                                    ; preds = %._crit_edge.i2192, %480, %477
  %598 = load ptr, ptr %result.i79, align 8
  %599 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %600 = load ptr, ptr %76, align 8
  %601 = load ptr, ptr %598, align 8
  %602 = getelementptr i8, ptr %601, i64 72
  %603 = load ptr, ptr %602, align 8
  %result.i1.i.i391 = call { i64, i64 } %603(ptr nocapture nofree nonnull readonly align 8 %598) #44
  %604 = extractvalue { i64, i64 } %result.i1.i.i391, 0
  %605 = extractvalue { i64, i64 } %result.i1.i.i391, 1
  %606 = urem i64 20, %605
  %607 = icmp eq i64 %606, 0
  %608 = sub i64 %605, %606
  %609 = select i1 %607, i64 0, i64 %608
  %610 = add i64 %604, 20
  %611 = add i64 %610, %609
  %612 = load ptr, ptr %600, align 8
  %613 = getelementptr i8, ptr %612, i64 72
  %614 = load ptr, ptr %613, align 8
  %result.i.i.i392 = call { i64, i64 } %614(ptr nocapture nofree nonnull readonly align 8 %600) #44
  %615 = extractvalue { i64, i64 } %result.i.i.i392, 0
  %616 = extractvalue { i64, i64 } %result.i.i.i392, 1
  %617 = call i64 @llvm.umax.i64(i64 %605, i64 %616) #41
  %618 = call i64 @llvm.umax.i64(i64 %617, i64 noundef 8) #41, !range !16
  %619 = urem i64 %611, %616
  %620 = icmp eq i64 %619, 0
  %621 = sub i64 %616, %619
  %622 = select i1 %620, i64 0, i64 %621
  %623 = add i64 %615, %611
  %624 = add i64 %623, %622
  %625 = urem i64 %624, %618
  %626 = icmp eq i64 %625, 0
  %627 = sub i64 %618, %625
  %628 = select i1 %626, i64 0, i64 %627
  %629 = add i64 %628, %624
  %result.i22.i393 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %629) #48
  store ptr %598, ptr %result.i22.i393, align 8
  %630 = getelementptr inbounds i8, ptr %result.i22.i393, i64 8
  store ptr %600, ptr %630, align 8
  %631 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i393)
  %632 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %633 = load ptr, ptr %598, align 8
  %634 = getelementptr i8, ptr %633, i64 72
  %635 = load ptr, ptr %634, align 8
  %result.i.i127.i = call { i64, i64 } %635(ptr nocapture nofree nonnull readonly align 8 %598) #44
  %636 = extractvalue { i64, i64 } %result.i.i127.i, 1
  %637 = urem i64 20, %636
  %638 = icmp eq i64 %637, 0
  %reass.sub3873 = sub i64 %636, %637
  %639 = add i64 %reass.sub3873, 20
  %640 = select i1 %638, i64 20, i64 %639
  %641 = getelementptr i8, ptr %result.i22.i393, i64 %640
  %642 = getelementptr i8, ptr %633, i64 64
  %643 = load ptr, ptr %642, align 8
  call void %643({ ptr, i160 } %118, ptr nocapture nofree nonnull readonly align 8 %598, ptr nocapture nofree writeonly %641) #45
  %644 = load ptr, ptr %result.i22.i393, align 8
  %645 = load ptr, ptr %644, align 8
  %646 = getelementptr i8, ptr %645, i64 72
  %647 = load ptr, ptr %646, align 8
  %result.i1.i128.i = call { i64, i64 } %647(ptr nocapture nofree nonnull readonly align 8 %644) #44
  %648 = extractvalue { i64, i64 } %result.i1.i128.i, 0
  %649 = extractvalue { i64, i64 } %result.i1.i128.i, 1
  %650 = urem i64 20, %649
  %651 = icmp eq i64 %650, 0
  %652 = sub i64 %649, %650
  %653 = select i1 %651, i64 0, i64 %652
  %654 = add i64 %648, 20
  %655 = add i64 %654, %653
  %656 = load ptr, ptr %630, align 8
  %657 = load ptr, ptr %656, align 8
  %658 = getelementptr i8, ptr %657, i64 72
  %659 = load ptr, ptr %658, align 8
  %result.i.i129.i = call { i64, i64 } %659(ptr nocapture nofree nonnull readonly align 8 %656) #44
  %660 = extractvalue { i64, i64 } %result.i.i129.i, 1
  %661 = urem i64 %655, %660
  %662 = icmp eq i64 %661, 0
  %663 = sub i64 %660, %661
  %664 = select i1 %662, i64 0, i64 %663
  %665 = getelementptr i8, ptr %result.i22.i393, i64 %655
  %666 = getelementptr i8, ptr %665, i64 %664
  %667 = getelementptr i8, ptr %657, i64 64
  %668 = load ptr, ptr %667, align 8
  call void %668({ ptr, i160 } %235, ptr nocapture nofree nonnull readonly align 8 %656, ptr nocapture nofree writeonly %666) #45
  %669 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %670 = getelementptr inbounds i8, ptr %result.i22.i393, i64 16
  store i32 %237, ptr %670, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %674

674:                                              ; preds = %.cont.i, %._crit_edge.i
  %.0290.i = phi i32 [ 0, %._crit_edge.i ], [ %709, %.cont.i ]
  %.074289.i = phi i1 [ true, %._crit_edge.i ], [ %710, %.cont.i ]
  %.sroa.0.0288.i = phi ptr [ @Entry, %._crit_edge.i ], [ %697, %.cont.i ]
  %.sroa.6.0287.i = phi ptr [ %result.i22.i393, %._crit_edge.i ], [ %711, %.cont.i ]
  %.sroa.12.0286.i = phi ptr [ undef, %._crit_edge.i ], [ %712, %.cont.i ]
  %.sroa.17.0285.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i57.i, %.cont.i ]
  %675 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i, 0
  %676 = insertvalue { ptr, ptr, ptr, i32 } %675, ptr %.sroa.6.0287.i, 1
  %677 = insertvalue { ptr, ptr, ptr, i32 } %676, ptr %.sroa.12.0286.i, 2
  %678 = insertvalue { ptr, ptr, ptr, i32 } %677, i32 %.sroa.17.0285.i, 3
  %679 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i)
  %680 = sext i32 %.sroa.17.0285.i to i64
  %681 = getelementptr ptr, ptr %.sroa.0.0288.i, i64 %680
  %682 = getelementptr i8, ptr %681, i64 64
  %683 = load ptr, ptr %682, align 8
  %result.i15.i = call ptr %683({ ptr, ptr, ptr, i32 } %678, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %684 = call i32 %result.i15.i({ ptr, ptr, ptr, i32 } %678, { ptr, ptr, ptr, i32 } %678, ptr nonnull align 8 %2) #53
  %..i = select i1 %.074289.i, ptr %63, ptr %65
  %.188.i = select i1 %.074289.i, i64 104, i64 112
  %.189.i = select i1 %.074289.i, ptr %64, ptr %66
  %.190.i = select i1 %.074289.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i, align 8
  %685 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i)
  %686 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i
  %687 = load ptr, ptr %686, align 8
  store ptr @i32_typ, ptr %.189.i, align 8
  %result.i14.i = call ptr %687({ ptr, ptr, ptr, i32 } %110, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i) #46
  %688 = call i32 %result.i14.i({ ptr, ptr, ptr, i32 } %110, { ptr, ptr, ptr, i32 } %110, ptr nonnull align 8 dereferenceable(8) %..i, i32 %684) #53
  %689 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %690 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i
  %691 = load ptr, ptr %690, align 8
  %692 = load ptr, ptr %691, align 8
  %693 = call { ptr } %692(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i = extractvalue { ptr } %693, 0
  %694 = sext i32 %688 to i64
  %695 = shl nsw i64 %694, 5
  %696 = getelementptr i8, ptr %.fca.0.extract55.i, i64 %695
  %697 = load ptr, ptr %696, align 8
  %698 = getelementptr i8, ptr %696, i64 8
  %699 = load i64, ptr %698, align 4
  %.sroa_idx.i1103 = getelementptr i8, ptr %696, i64 16
  %700 = load i64, ptr %.sroa_idx.i1103, align 4
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %702 = call { ptr } %692(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i = extractvalue { ptr } %702, 0
  %703 = getelementptr i8, ptr %.fca.0.extract52.i, i64 %695
  store ptr %.sroa.0.0288.i, ptr %703, align 8
  %704 = getelementptr i8, ptr %703, i64 8
  %705 = ptrtoint ptr %.sroa.6.0287.i to i64
  %706 = ptrtoint ptr %.sroa.12.0286.i to i64
  store i64 %705, ptr %704, align 4
  %.sroa_idx104.i = getelementptr i8, ptr %703, i64 16
  store i64 %706, ptr %.sroa_idx104.i, align 4
  %.sroa_idx105.i = getelementptr i8, ptr %703, i64 24
  store i32 %.sroa.17.0285.i, ptr %.sroa_idx105.i, align 4
  %707 = icmp ne ptr %697, @nil_typ
  %708 = icmp ne ptr %697, null
  %.not94.i = and i1 %707, %708
  br i1 %.not94.i, label %.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

.cont.i:                                          ; preds = %674
  %709 = add nuw nsw i32 %.0290.i, 1
  %710 = xor i1 %.074289.i, true
  %711 = inttoptr i64 %699 to ptr
  %712 = inttoptr i64 %700 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %697, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %697, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %697, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4
  %713 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %714 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i = icmp eq i32 %709, 100
  br i1 %exitcond.not.i, label %718, label %674

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %674
  %715 = load i32, ptr %86, align 4
  %716 = add i32 %715, 1
  %717 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %716, ptr %86, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  br label %CuckooMap_insert_keyK_valueV.exit

718:                                              ; preds = %.cont.i
  %hash_coef_ptr.i.i46.i.le = getelementptr i8, ptr %697, i64 8
  %tbl_size_ptr.i.i47.i.le = getelementptr i8, ptr %697, i64 16
  %offset_tbl_ptr.i.i48.i.le = getelementptr i8, ptr %697, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  %719 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %720 = load ptr, ptr %84, align 8
  %721 = load ptr, ptr %85, align 8
  %722 = load i32, ptr %83, align 8
  %723 = shl i32 %722, 1
  %spec.select.i1120 = call i32 @llvm.smax.i32(i32 %723, i32 noundef 16) #40
  store i32 %spec.select.i1120, ptr %83, align 8
  %724 = zext nneg i32 %spec.select.i1120 to i64
  %725 = shl nuw nsw i64 %724, 5
  %result.i5.i1121 = call noalias ptr @bump_malloc_wrapper(i64 noundef %725) #48
  store ptr %result.i5.i1121, ptr %84, align 8
  %result.i4.i1122 = call noalias ptr @bump_malloc_wrapper(i64 noundef %725) #48
  store ptr %result.i4.i1122, ptr %85, align 8
  store i32 0, ptr %86, align 4
  %726 = icmp sgt i32 %722, 0
  br i1 %726, label %.lr.ph.i2214, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2250.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2250.thread: ; preds = %718
  %727 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288

.lr.ph.i2214:                                     ; preds = %718
  %wide.trip.count.i2227 = zext nneg i32 %722 to i64
  br label %728

728:                                              ; preds = %._crit_edge.i2230, %.lr.ph.i2214
  %indvars.iv.i2228 = phi i64 [ 0, %.lr.ph.i2214 ], [ %indvars.iv.next.i2231, %._crit_edge.i2230 ]
  %729 = shl nuw nsw i64 %indvars.iv.i2228, 5
  %730 = getelementptr i8, ptr %720, i64 %729
  %731 = load ptr, ptr %730, align 8
  %732 = icmp ne ptr %731, @nil_typ
  %733 = icmp ne ptr %731, null
  %.not17.i2229 = and i1 %732, %733
  br i1 %.not17.i2229, label %734, label %._crit_edge.i2230

734:                                              ; preds = %728
  %735 = getelementptr i8, ptr %730, i64 8
  %736 = load i64, ptr %735, align 4
  %.sroa_idx.i2233 = getelementptr i8, ptr %730, i64 16
  %737 = load i64, ptr %.sroa_idx.i2233, align 4
  %hash_coef_ptr.i.i6.i2234 = getelementptr i8, ptr %731, i64 8
  %tbl_size_ptr.i.i7.i2235 = getelementptr i8, ptr %731, i64 16
  %offset_tbl_ptr.i.i8.i2236 = getelementptr i8, ptr %731, i64 40
  %738 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  %hash_coef.i.i21.i2865 = load i64, ptr %hash_coef_ptr.i.i6.i2234, align 4, !noalias !263
  %tbl_size.i.i22.i2866 = load i64, ptr %tbl_size_ptr.i.i7.i2235, align 4, !noalias !263
  %offset_tbl.i.i23.i2867 = load ptr, ptr %offset_tbl_ptr.i.i8.i2236, align 8, !noalias !263
  %product.i.i.i24.i2868 = mul i64 %hash_coef.i.i21.i2865, 4015701072841558310
  %shifted.i.i.i25.i2869 = lshr i64 %product.i.i.i24.i2868, 32
  %xored.i.i.i26.i2870 = xor i64 %shifted.i.i.i25.i2869, %product.i.i.i24.i2868
  %hash.i.i.i27.i2871 = and i64 %xored.i.i.i26.i2870, %tbl_size.i.i22.i2866
  %offset_ptr.i.i28.i2872 = getelementptr i32, ptr %offset_tbl.i.i23.i2867, i64 %hash.i.i.i27.i2871
  %offset.i.i29.i2873 = load i32, ptr %offset_ptr.i.i28.i2872, align 4, !noalias !263
  %739 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %740 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %742

742:                                              ; preds = %.cont.i2896, %734
  %.0290.i2874 = phi i32 [ 0, %734 ], [ %775, %.cont.i2896 ]
  %.074289.i2875 = phi i1 [ true, %734 ], [ %776, %.cont.i2896 ]
  %.sroa.0.0288.i2876 = phi ptr [ %731, %734 ], [ %765, %.cont.i2896 ]
  %.sroa.6.0287.i2877.in = phi i64 [ %736, %734 ], [ %767, %.cont.i2896 ]
  %.sroa.12.0286.i2878.in = phi i64 [ %737, %734 ], [ %768, %.cont.i2896 ]
  %.sroa.17.0285.i2879 = phi i32 [ %offset.i.i29.i2873, %734 ], [ %offset.i.i57.i2908, %.cont.i2896 ]
  %.sroa.12.0286.i2878 = inttoptr i64 %.sroa.12.0286.i2878.in to ptr
  %.sroa.6.0287.i2877 = inttoptr i64 %.sroa.6.0287.i2877.in to ptr
  %743 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2876, 0
  %744 = insertvalue { ptr, ptr, ptr, i32 } %743, ptr %.sroa.6.0287.i2877, 1
  %745 = insertvalue { ptr, ptr, ptr, i32 } %744, ptr %.sroa.12.0286.i2878, 2
  %746 = insertvalue { ptr, ptr, ptr, i32 } %745, i32 %.sroa.17.0285.i2879, 3
  %747 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2876)
  %748 = sext i32 %.sroa.17.0285.i2879 to i64
  %749 = getelementptr ptr, ptr %.sroa.0.0288.i2876, i64 %748
  %750 = getelementptr i8, ptr %749, i64 64
  %751 = load ptr, ptr %750, align 8
  %result.i15.i2880 = call ptr %751({ ptr, ptr, ptr, i32 } %746, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %752 = call i32 %result.i15.i2880({ ptr, ptr, ptr, i32 } %746, { ptr, ptr, ptr, i32 } %746, ptr nonnull align 8 %2) #53
  %..i2881 = select i1 %.074289.i2875, ptr %39, ptr %41
  %.188.i2882 = select i1 %.074289.i2875, i64 104, i64 112
  %.189.i2883 = select i1 %.074289.i2875, ptr %40, ptr %42
  %.190.i2884 = select i1 %.074289.i2875, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2881, align 8
  %753 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2881)
  %754 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2882
  %755 = load ptr, ptr %754, align 8
  store ptr @i32_typ, ptr %.189.i2883, align 8
  %result.i14.i2885 = call ptr %755({ ptr, ptr, ptr, i32 } %111, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2883) #46
  %756 = call i32 %result.i14.i2885({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull align 8 dereferenceable(8) %..i2881, i32 %752) #53
  %757 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %758 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2884
  %759 = load ptr, ptr %758, align 8
  %760 = load ptr, ptr %759, align 8
  %761 = call { ptr } %760(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i2886 = extractvalue { ptr } %761, 0
  %762 = sext i32 %756 to i64
  %763 = shl nsw i64 %762, 5
  %764 = getelementptr i8, ptr %.fca.0.extract55.i2886, i64 %763
  %765 = load ptr, ptr %764, align 8
  %766 = getelementptr i8, ptr %764, i64 8
  %767 = load i64, ptr %766, align 4
  %.sroa_idx.i2887 = getelementptr i8, ptr %764, i64 16
  %768 = load i64, ptr %.sroa_idx.i2887, align 4
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %770 = call { ptr } %760(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i2888 = extractvalue { ptr } %770, 0
  %771 = getelementptr i8, ptr %.fca.0.extract52.i2888, i64 %763
  store ptr %.sroa.0.0288.i2876, ptr %771, align 8
  %772 = getelementptr i8, ptr %771, i64 8
  store i64 %.sroa.6.0287.i2877.in, ptr %772, align 4
  %.sroa_idx104.i2889 = getelementptr i8, ptr %771, i64 16
  store i64 %.sroa.12.0286.i2878.in, ptr %.sroa_idx104.i2889, align 4
  %.sroa_idx105.i2890 = getelementptr i8, ptr %771, i64 24
  store i32 %.sroa.17.0285.i2879, ptr %.sroa_idx105.i2890, align 4
  %773 = icmp ne ptr %765, @nil_typ
  %774 = icmp ne ptr %765, null
  %.not94.i2891 = and i1 %773, %774
  br i1 %.not94.i2891, label %.cont.i2896, label %779

.cont.i2896:                                      ; preds = %742
  %775 = add nuw nsw i32 %.0290.i2874, 1
  %776 = xor i1 %.074289.i2875, true
  %hash_coef_ptr.i.i46.i2897 = getelementptr i8, ptr %765, i64 8
  %tbl_size_ptr.i.i47.i2898 = getelementptr i8, ptr %765, i64 16
  %offset_tbl_ptr.i.i48.i2899 = getelementptr i8, ptr %765, i64 40
  %hash_coef.i.i49.i2900 = load i64, ptr %hash_coef_ptr.i.i46.i2897, align 4
  %tbl_size.i.i50.i2901 = load i64, ptr %tbl_size_ptr.i.i47.i2898, align 4
  %offset_tbl.i.i51.i2902 = load ptr, ptr %offset_tbl_ptr.i.i48.i2899, align 8
  %product.i.i.i52.i2903 = mul i64 %hash_coef.i.i49.i2900, 4015701072841558310
  %shifted.i.i.i53.i2904 = lshr i64 %product.i.i.i52.i2903, 32
  %xored.i.i.i54.i2905 = xor i64 %shifted.i.i.i53.i2904, %product.i.i.i52.i2903
  %hash.i.i.i55.i2906 = and i64 %xored.i.i.i54.i2905, %tbl_size.i.i50.i2901
  %offset_ptr.i.i56.i2907 = getelementptr i32, ptr %offset_tbl.i.i51.i2902, i64 %hash.i.i.i55.i2906
  %offset.i.i57.i2908 = load i32, ptr %offset_ptr.i.i56.i2907, align 4
  %777 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %778 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2909 = icmp eq i32 %775, 100
  br i1 %exitcond.not.i2909, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918, label %742

779:                                              ; preds = %742
  %780 = load i32, ptr %86, align 4
  %781 = add i32 %780, 1
  %782 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %781, ptr %86, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918: ; preds = %779, %.cont.i2896
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  br label %._crit_edge.i2230

._crit_edge.i2230:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918, %728
  %indvars.iv.next.i2231 = add nuw nsw i64 %indvars.iv.i2228, 1
  %exitcond.not.i2232 = icmp eq i64 %indvars.iv.next.i2231, %wide.trip.count.i2227
  br i1 %exitcond.not.i2232, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2250, label %728

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2250: ; preds = %._crit_edge.i2230
  %783 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %784

784:                                              ; preds = %._crit_edge.i2268, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2250
  %indvars.iv.i2266 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2250 ], [ %indvars.iv.next.i2269, %._crit_edge.i2268 ]
  %785 = shl nuw nsw i64 %indvars.iv.i2266, 5
  %786 = getelementptr i8, ptr %721, i64 %785
  %787 = load ptr, ptr %786, align 8
  %788 = icmp ne ptr %787, @nil_typ
  %789 = icmp ne ptr %787, null
  %.not17.i2267 = and i1 %788, %789
  br i1 %.not17.i2267, label %790, label %._crit_edge.i2268

790:                                              ; preds = %784
  %791 = getelementptr i8, ptr %786, i64 8
  %792 = load i64, ptr %791, align 4
  %.sroa_idx.i2271 = getelementptr i8, ptr %786, i64 16
  %793 = load i64, ptr %.sroa_idx.i2271, align 4
  %hash_coef_ptr.i.i6.i2272 = getelementptr i8, ptr %787, i64 8
  %tbl_size_ptr.i.i7.i2273 = getelementptr i8, ptr %787, i64 16
  %offset_tbl_ptr.i.i8.i2274 = getelementptr i8, ptr %787, i64 40
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  %hash_coef.i.i21.i2936 = load i64, ptr %hash_coef_ptr.i.i6.i2272, align 4, !noalias !266
  %tbl_size.i.i22.i2937 = load i64, ptr %tbl_size_ptr.i.i7.i2273, align 4, !noalias !266
  %offset_tbl.i.i23.i2938 = load ptr, ptr %offset_tbl_ptr.i.i8.i2274, align 8, !noalias !266
  %product.i.i.i24.i2939 = mul i64 %hash_coef.i.i21.i2936, 4015701072841558310
  %shifted.i.i.i25.i2940 = lshr i64 %product.i.i.i24.i2939, 32
  %xored.i.i.i26.i2941 = xor i64 %shifted.i.i.i25.i2940, %product.i.i.i24.i2939
  %hash.i.i.i27.i2942 = and i64 %xored.i.i.i26.i2941, %tbl_size.i.i22.i2937
  %offset_ptr.i.i28.i2943 = getelementptr i32, ptr %offset_tbl.i.i23.i2938, i64 %hash.i.i.i27.i2942
  %offset.i.i29.i2944 = load i32, ptr %offset_ptr.i.i28.i2943, align 4, !noalias !266
  %795 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %796 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %797 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %798

798:                                              ; preds = %.cont.i2967, %790
  %.0290.i2945 = phi i32 [ 0, %790 ], [ %831, %.cont.i2967 ]
  %.074289.i2946 = phi i1 [ true, %790 ], [ %832, %.cont.i2967 ]
  %.sroa.0.0288.i2947 = phi ptr [ %787, %790 ], [ %821, %.cont.i2967 ]
  %.sroa.6.0287.i2948.in = phi i64 [ %792, %790 ], [ %823, %.cont.i2967 ]
  %.sroa.12.0286.i2949.in = phi i64 [ %793, %790 ], [ %824, %.cont.i2967 ]
  %.sroa.17.0285.i2950 = phi i32 [ %offset.i.i29.i2944, %790 ], [ %offset.i.i57.i2979, %.cont.i2967 ]
  %.sroa.12.0286.i2949 = inttoptr i64 %.sroa.12.0286.i2949.in to ptr
  %.sroa.6.0287.i2948 = inttoptr i64 %.sroa.6.0287.i2948.in to ptr
  %799 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2947, 0
  %800 = insertvalue { ptr, ptr, ptr, i32 } %799, ptr %.sroa.6.0287.i2948, 1
  %801 = insertvalue { ptr, ptr, ptr, i32 } %800, ptr %.sroa.12.0286.i2949, 2
  %802 = insertvalue { ptr, ptr, ptr, i32 } %801, i32 %.sroa.17.0285.i2950, 3
  %803 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2947)
  %804 = sext i32 %.sroa.17.0285.i2950 to i64
  %805 = getelementptr ptr, ptr %.sroa.0.0288.i2947, i64 %804
  %806 = getelementptr i8, ptr %805, i64 64
  %807 = load ptr, ptr %806, align 8
  %result.i15.i2951 = call ptr %807({ ptr, ptr, ptr, i32 } %802, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %808 = call i32 %result.i15.i2951({ ptr, ptr, ptr, i32 } %802, { ptr, ptr, ptr, i32 } %802, ptr nonnull align 8 %2) #53
  %..i2952 = select i1 %.074289.i2946, ptr %35, ptr %37
  %.188.i2953 = select i1 %.074289.i2946, i64 104, i64 112
  %.189.i2954 = select i1 %.074289.i2946, ptr %36, ptr %38
  %.190.i2955 = select i1 %.074289.i2946, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2952, align 8
  %809 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2952)
  %810 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2953
  %811 = load ptr, ptr %810, align 8
  store ptr @i32_typ, ptr %.189.i2954, align 8
  %result.i14.i2956 = call ptr %811({ ptr, ptr, ptr, i32 } %111, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2954) #46
  %812 = call i32 %result.i14.i2956({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull align 8 dereferenceable(8) %..i2952, i32 %808) #53
  %813 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %814 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2955
  %815 = load ptr, ptr %814, align 8
  %816 = load ptr, ptr %815, align 8
  %817 = call { ptr } %816(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i2957 = extractvalue { ptr } %817, 0
  %818 = sext i32 %812 to i64
  %819 = shl nsw i64 %818, 5
  %820 = getelementptr i8, ptr %.fca.0.extract55.i2957, i64 %819
  %821 = load ptr, ptr %820, align 8
  %822 = getelementptr i8, ptr %820, i64 8
  %823 = load i64, ptr %822, align 4
  %.sroa_idx.i2958 = getelementptr i8, ptr %820, i64 16
  %824 = load i64, ptr %.sroa_idx.i2958, align 4
  %825 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %826 = call { ptr } %816(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i2959 = extractvalue { ptr } %826, 0
  %827 = getelementptr i8, ptr %.fca.0.extract52.i2959, i64 %819
  store ptr %.sroa.0.0288.i2947, ptr %827, align 8
  %828 = getelementptr i8, ptr %827, i64 8
  store i64 %.sroa.6.0287.i2948.in, ptr %828, align 4
  %.sroa_idx104.i2960 = getelementptr i8, ptr %827, i64 16
  store i64 %.sroa.12.0286.i2949.in, ptr %.sroa_idx104.i2960, align 4
  %.sroa_idx105.i2961 = getelementptr i8, ptr %827, i64 24
  store i32 %.sroa.17.0285.i2950, ptr %.sroa_idx105.i2961, align 4
  %829 = icmp ne ptr %821, @nil_typ
  %830 = icmp ne ptr %821, null
  %.not94.i2962 = and i1 %829, %830
  br i1 %.not94.i2962, label %.cont.i2967, label %835

.cont.i2967:                                      ; preds = %798
  %831 = add nuw nsw i32 %.0290.i2945, 1
  %832 = xor i1 %.074289.i2946, true
  %hash_coef_ptr.i.i46.i2968 = getelementptr i8, ptr %821, i64 8
  %tbl_size_ptr.i.i47.i2969 = getelementptr i8, ptr %821, i64 16
  %offset_tbl_ptr.i.i48.i2970 = getelementptr i8, ptr %821, i64 40
  %hash_coef.i.i49.i2971 = load i64, ptr %hash_coef_ptr.i.i46.i2968, align 4
  %tbl_size.i.i50.i2972 = load i64, ptr %tbl_size_ptr.i.i47.i2969, align 4
  %offset_tbl.i.i51.i2973 = load ptr, ptr %offset_tbl_ptr.i.i48.i2970, align 8
  %product.i.i.i52.i2974 = mul i64 %hash_coef.i.i49.i2971, 4015701072841558310
  %shifted.i.i.i53.i2975 = lshr i64 %product.i.i.i52.i2974, 32
  %xored.i.i.i54.i2976 = xor i64 %shifted.i.i.i53.i2975, %product.i.i.i52.i2974
  %hash.i.i.i55.i2977 = and i64 %xored.i.i.i54.i2976, %tbl_size.i.i50.i2972
  %offset_ptr.i.i56.i2978 = getelementptr i32, ptr %offset_tbl.i.i51.i2973, i64 %hash.i.i.i55.i2977
  %offset.i.i57.i2979 = load i32, ptr %offset_ptr.i.i56.i2978, align 4
  %833 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %834 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2980 = icmp eq i32 %831, 100
  br i1 %exitcond.not.i2980, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989, label %798

835:                                              ; preds = %798
  %836 = load i32, ptr %86, align 4
  %837 = add i32 %836, 1
  %838 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %837, ptr %86, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989: ; preds = %835, %.cont.i2967
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  br label %._crit_edge.i2268

._crit_edge.i2268:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989, %784
  %indvars.iv.next.i2269 = add nuw nsw i64 %indvars.iv.i2266, 1
  %exitcond.not.i2270 = icmp eq i64 %indvars.iv.next.i2269, %wide.trip.count.i2227
  br i1 %exitcond.not.i2270, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288, label %784

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288: ; preds = %._crit_edge.i2268, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2250.thread
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  %hash_coef.i.i21.i1145 = load i64, ptr %hash_coef_ptr.i.i46.i.le, align 4, !noalias !269
  %tbl_size.i.i22.i1146 = load i64, ptr %tbl_size_ptr.i.i47.i.le, align 4, !noalias !269
  %offset_tbl.i.i23.i1147 = load ptr, ptr %offset_tbl_ptr.i.i48.i.le, align 8, !noalias !269
  %product.i.i.i24.i1148 = mul i64 %hash_coef.i.i21.i1145, 4015701072841558310
  %shifted.i.i.i25.i1149 = lshr i64 %product.i.i.i24.i1148, 32
  %xored.i.i.i26.i1150 = xor i64 %shifted.i.i.i25.i1149, %product.i.i.i24.i1148
  %hash.i.i.i27.i1151 = and i64 %xored.i.i.i26.i1150, %tbl_size.i.i22.i1146
  %offset_ptr.i.i28.i1152 = getelementptr i32, ptr %offset_tbl.i.i23.i1147, i64 %hash.i.i.i27.i1151
  %offset.i.i29.i1153 = load i32, ptr %offset_ptr.i.i28.i1152, align 4, !noalias !269
  %839 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %840 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %841 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %842

842:                                              ; preds = %.cont.i1177, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288
  %.0290.i1155 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288 ], [ %875, %.cont.i1177 ]
  %.074289.i1156 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288 ], [ %876, %.cont.i1177 ]
  %.sroa.0.0288.i1157 = phi ptr [ %697, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288 ], [ %865, %.cont.i1177 ]
  %.sroa.6.0287.i1158.in = phi i64 [ %699, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288 ], [ %867, %.cont.i1177 ]
  %.sroa.12.0286.i1159.in = phi i64 [ %700, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288 ], [ %868, %.cont.i1177 ]
  %.sroa.17.0285.i1160 = phi i32 [ %offset.i.i29.i1153, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2288 ], [ %offset.i.i57.i1189, %.cont.i1177 ]
  %.sroa.12.0286.i1159 = inttoptr i64 %.sroa.12.0286.i1159.in to ptr
  %.sroa.6.0287.i1158 = inttoptr i64 %.sroa.6.0287.i1158.in to ptr
  %843 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1157, 0
  %844 = insertvalue { ptr, ptr, ptr, i32 } %843, ptr %.sroa.6.0287.i1158, 1
  %845 = insertvalue { ptr, ptr, ptr, i32 } %844, ptr %.sroa.12.0286.i1159, 2
  %846 = insertvalue { ptr, ptr, ptr, i32 } %845, i32 %.sroa.17.0285.i1160, 3
  %847 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1157)
  %848 = sext i32 %.sroa.17.0285.i1160 to i64
  %849 = getelementptr ptr, ptr %.sroa.0.0288.i1157, i64 %848
  %850 = getelementptr i8, ptr %849, i64 64
  %851 = load ptr, ptr %850, align 8
  %result.i15.i1161 = call ptr %851({ ptr, ptr, ptr, i32 } %846, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %852 = call i32 %result.i15.i1161({ ptr, ptr, ptr, i32 } %846, { ptr, ptr, ptr, i32 } %846, ptr nonnull align 8 %2) #53
  %..i1162 = select i1 %.074289.i1156, ptr %59, ptr %61
  %.188.i1163 = select i1 %.074289.i1156, i64 104, i64 112
  %.189.i1164 = select i1 %.074289.i1156, ptr %60, ptr %62
  %.190.i1165 = select i1 %.074289.i1156, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1162, align 8
  %853 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1162)
  %854 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1163
  %855 = load ptr, ptr %854, align 8
  store ptr @i32_typ, ptr %.189.i1164, align 8
  %result.i14.i1166 = call ptr %855({ ptr, ptr, ptr, i32 } %110, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1164) #46
  %856 = call i32 %result.i14.i1166({ ptr, ptr, ptr, i32 } %110, { ptr, ptr, ptr, i32 } %110, ptr nonnull align 8 dereferenceable(8) %..i1162, i32 %852) #53
  %857 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %858 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1165
  %859 = load ptr, ptr %858, align 8
  %860 = load ptr, ptr %859, align 8
  %861 = call { ptr } %860(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i1167 = extractvalue { ptr } %861, 0
  %862 = sext i32 %856 to i64
  %863 = shl nsw i64 %862, 5
  %864 = getelementptr i8, ptr %.fca.0.extract55.i1167, i64 %863
  %865 = load ptr, ptr %864, align 8
  %866 = getelementptr i8, ptr %864, i64 8
  %867 = load i64, ptr %866, align 4
  %.sroa_idx.i1168 = getelementptr i8, ptr %864, i64 16
  %868 = load i64, ptr %.sroa_idx.i1168, align 4
  %869 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %870 = call { ptr } %860(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i1169 = extractvalue { ptr } %870, 0
  %871 = getelementptr i8, ptr %.fca.0.extract52.i1169, i64 %863
  store ptr %.sroa.0.0288.i1157, ptr %871, align 8
  %872 = getelementptr i8, ptr %871, i64 8
  store i64 %.sroa.6.0287.i1158.in, ptr %872, align 4
  %.sroa_idx104.i1170 = getelementptr i8, ptr %871, i64 16
  store i64 %.sroa.12.0286.i1159.in, ptr %.sroa_idx104.i1170, align 4
  %.sroa_idx105.i1171 = getelementptr i8, ptr %871, i64 24
  store i32 %.sroa.17.0285.i1160, ptr %.sroa_idx105.i1171, align 4
  %873 = icmp ne ptr %865, @nil_typ
  %874 = icmp ne ptr %865, null
  %.not94.i1172 = and i1 %873, %874
  br i1 %.not94.i1172, label %.cont.i1177, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1199

.cont.i1177:                                      ; preds = %842
  %875 = add nuw nsw i32 %.0290.i1155, 1
  %876 = xor i1 %.074289.i1156, true
  %hash_coef_ptr.i.i46.i1178 = getelementptr i8, ptr %865, i64 8
  %tbl_size_ptr.i.i47.i1179 = getelementptr i8, ptr %865, i64 16
  %offset_tbl_ptr.i.i48.i1180 = getelementptr i8, ptr %865, i64 40
  %hash_coef.i.i49.i1181 = load i64, ptr %hash_coef_ptr.i.i46.i1178, align 4
  %tbl_size.i.i50.i1182 = load i64, ptr %tbl_size_ptr.i.i47.i1179, align 4
  %offset_tbl.i.i51.i1183 = load ptr, ptr %offset_tbl_ptr.i.i48.i1180, align 8
  %product.i.i.i52.i1184 = mul i64 %hash_coef.i.i49.i1181, 4015701072841558310
  %shifted.i.i.i53.i1185 = lshr i64 %product.i.i.i52.i1184, 32
  %xored.i.i.i54.i1186 = xor i64 %shifted.i.i.i53.i1185, %product.i.i.i52.i1184
  %hash.i.i.i55.i1187 = and i64 %xored.i.i.i54.i1186, %tbl_size.i.i50.i1182
  %offset_ptr.i.i56.i1188 = getelementptr i32, ptr %offset_tbl.i.i51.i1183, i64 %hash.i.i.i55.i1187
  %offset.i.i57.i1189 = load i32, ptr %offset_ptr.i.i56.i1188, align 4
  %877 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %878 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1190 = icmp eq i32 %875, 100
  br i1 %exitcond.not.i1190, label %882, label %842

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1199: ; preds = %842
  %879 = load i32, ptr %86, align 4
  %880 = add i32 %879, 1
  %881 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %880, ptr %86, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  br label %CuckooMap_insert_keyK_valueV.exit

882:                                              ; preds = %.cont.i1177
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  %883 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %884 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %885 = load ptr, ptr %84, align 8
  %886 = load ptr, ptr %85, align 8
  %887 = load i32, ptr %83, align 8
  %888 = shl i32 %887, 1
  %spec.select.i1215 = call i32 @llvm.smax.i32(i32 %888, i32 noundef 16) #40
  store i32 %spec.select.i1215, ptr %83, align 8
  %889 = zext nneg i32 %spec.select.i1215 to i64
  %890 = shl nuw nsw i64 %889, 5
  %result.i5.i1216 = call noalias ptr @bump_malloc_wrapper(i64 noundef %890) #48
  store ptr %result.i5.i1216, ptr %84, align 8
  %result.i4.i1217 = call noalias ptr @bump_malloc_wrapper(i64 noundef %890) #48
  store ptr %result.i4.i1217, ptr %85, align 8
  store i32 0, ptr %86, align 4
  %891 = icmp sgt i32 %887, 0
  br i1 %891, label %.lr.ph.i2290, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2326.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2326.thread: ; preds = %882
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i2290:                                     ; preds = %882
  %wide.trip.count.i2303 = zext nneg i32 %887 to i64
  br label %893

893:                                              ; preds = %._crit_edge.i2306, %.lr.ph.i2290
  %indvars.iv.i2304 = phi i64 [ 0, %.lr.ph.i2290 ], [ %indvars.iv.next.i2307, %._crit_edge.i2306 ]
  %894 = shl nuw nsw i64 %indvars.iv.i2304, 5
  %895 = getelementptr i8, ptr %885, i64 %894
  %896 = load ptr, ptr %895, align 8
  %897 = icmp ne ptr %896, @nil_typ
  %898 = icmp ne ptr %896, null
  %.not17.i2305 = and i1 %897, %898
  br i1 %.not17.i2305, label %899, label %._crit_edge.i2306

899:                                              ; preds = %893
  %900 = getelementptr i8, ptr %895, i64 8
  %901 = load i64, ptr %900, align 4
  %.sroa_idx.i2309 = getelementptr i8, ptr %895, i64 16
  %902 = load i64, ptr %.sroa_idx.i2309, align 4
  %hash_coef_ptr.i.i6.i2310 = getelementptr i8, ptr %896, i64 8
  %tbl_size_ptr.i.i7.i2311 = getelementptr i8, ptr %896, i64 16
  %offset_tbl_ptr.i.i8.i2312 = getelementptr i8, ptr %896, i64 40
  %903 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %hash_coef.i.i21.i3007 = load i64, ptr %hash_coef_ptr.i.i6.i2310, align 4, !noalias !272
  %tbl_size.i.i22.i3008 = load i64, ptr %tbl_size_ptr.i.i7.i2311, align 4, !noalias !272
  %offset_tbl.i.i23.i3009 = load ptr, ptr %offset_tbl_ptr.i.i8.i2312, align 8, !noalias !272
  %product.i.i.i24.i3010 = mul i64 %hash_coef.i.i21.i3007, 4015701072841558310
  %shifted.i.i.i25.i3011 = lshr i64 %product.i.i.i24.i3010, 32
  %xored.i.i.i26.i3012 = xor i64 %shifted.i.i.i25.i3011, %product.i.i.i24.i3010
  %hash.i.i.i27.i3013 = and i64 %xored.i.i.i26.i3012, %tbl_size.i.i22.i3008
  %offset_ptr.i.i28.i3014 = getelementptr i32, ptr %offset_tbl.i.i23.i3009, i64 %hash.i.i.i27.i3013
  %offset.i.i29.i3015 = load i32, ptr %offset_ptr.i.i28.i3014, align 4, !noalias !272
  %904 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %905 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %906 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %907

907:                                              ; preds = %.cont.i3038, %899
  %.0290.i3016 = phi i32 [ 0, %899 ], [ %940, %.cont.i3038 ]
  %.074289.i3017 = phi i1 [ true, %899 ], [ %941, %.cont.i3038 ]
  %.sroa.0.0288.i3018 = phi ptr [ %896, %899 ], [ %930, %.cont.i3038 ]
  %.sroa.6.0287.i3019.in = phi i64 [ %901, %899 ], [ %932, %.cont.i3038 ]
  %.sroa.12.0286.i3020.in = phi i64 [ %902, %899 ], [ %933, %.cont.i3038 ]
  %.sroa.17.0285.i3021 = phi i32 [ %offset.i.i29.i3015, %899 ], [ %offset.i.i57.i3050, %.cont.i3038 ]
  %.sroa.12.0286.i3020 = inttoptr i64 %.sroa.12.0286.i3020.in to ptr
  %.sroa.6.0287.i3019 = inttoptr i64 %.sroa.6.0287.i3019.in to ptr
  %908 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3018, 0
  %909 = insertvalue { ptr, ptr, ptr, i32 } %908, ptr %.sroa.6.0287.i3019, 1
  %910 = insertvalue { ptr, ptr, ptr, i32 } %909, ptr %.sroa.12.0286.i3020, 2
  %911 = insertvalue { ptr, ptr, ptr, i32 } %910, i32 %.sroa.17.0285.i3021, 3
  %912 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3018)
  %913 = sext i32 %.sroa.17.0285.i3021 to i64
  %914 = getelementptr ptr, ptr %.sroa.0.0288.i3018, i64 %913
  %915 = getelementptr i8, ptr %914, i64 64
  %916 = load ptr, ptr %915, align 8
  %result.i15.i3022 = call ptr %916({ ptr, ptr, ptr, i32 } %911, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %917 = call i32 %result.i15.i3022({ ptr, ptr, ptr, i32 } %911, { ptr, ptr, ptr, i32 } %911, ptr nonnull align 8 %2) #53
  %..i3023 = select i1 %.074289.i3017, ptr %31, ptr %33
  %.188.i3024 = select i1 %.074289.i3017, i64 104, i64 112
  %.189.i3025 = select i1 %.074289.i3017, ptr %32, ptr %34
  %.190.i3026 = select i1 %.074289.i3017, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3023, align 8
  %918 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3023)
  %919 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3024
  %920 = load ptr, ptr %919, align 8
  store ptr @i32_typ, ptr %.189.i3025, align 8
  %result.i14.i3027 = call ptr %920({ ptr, ptr, ptr, i32 } %111, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3025) #46
  %921 = call i32 %result.i14.i3027({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull align 8 dereferenceable(8) %..i3023, i32 %917) #53
  %922 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %923 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3026
  %924 = load ptr, ptr %923, align 8
  %925 = load ptr, ptr %924, align 8
  %926 = call { ptr } %925(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i3028 = extractvalue { ptr } %926, 0
  %927 = sext i32 %921 to i64
  %928 = shl nsw i64 %927, 5
  %929 = getelementptr i8, ptr %.fca.0.extract55.i3028, i64 %928
  %930 = load ptr, ptr %929, align 8
  %931 = getelementptr i8, ptr %929, i64 8
  %932 = load i64, ptr %931, align 4
  %.sroa_idx.i3029 = getelementptr i8, ptr %929, i64 16
  %933 = load i64, ptr %.sroa_idx.i3029, align 4
  %934 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %935 = call { ptr } %925(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i3030 = extractvalue { ptr } %935, 0
  %936 = getelementptr i8, ptr %.fca.0.extract52.i3030, i64 %928
  store ptr %.sroa.0.0288.i3018, ptr %936, align 8
  %937 = getelementptr i8, ptr %936, i64 8
  store i64 %.sroa.6.0287.i3019.in, ptr %937, align 4
  %.sroa_idx104.i3031 = getelementptr i8, ptr %936, i64 16
  store i64 %.sroa.12.0286.i3020.in, ptr %.sroa_idx104.i3031, align 4
  %.sroa_idx105.i3032 = getelementptr i8, ptr %936, i64 24
  store i32 %.sroa.17.0285.i3021, ptr %.sroa_idx105.i3032, align 4
  %938 = icmp ne ptr %930, @nil_typ
  %939 = icmp ne ptr %930, null
  %.not94.i3033 = and i1 %938, %939
  br i1 %.not94.i3033, label %.cont.i3038, label %944

.cont.i3038:                                      ; preds = %907
  %940 = add nuw nsw i32 %.0290.i3016, 1
  %941 = xor i1 %.074289.i3017, true
  %hash_coef_ptr.i.i46.i3039 = getelementptr i8, ptr %930, i64 8
  %tbl_size_ptr.i.i47.i3040 = getelementptr i8, ptr %930, i64 16
  %offset_tbl_ptr.i.i48.i3041 = getelementptr i8, ptr %930, i64 40
  %hash_coef.i.i49.i3042 = load i64, ptr %hash_coef_ptr.i.i46.i3039, align 4
  %tbl_size.i.i50.i3043 = load i64, ptr %tbl_size_ptr.i.i47.i3040, align 4
  %offset_tbl.i.i51.i3044 = load ptr, ptr %offset_tbl_ptr.i.i48.i3041, align 8
  %product.i.i.i52.i3045 = mul i64 %hash_coef.i.i49.i3042, 4015701072841558310
  %shifted.i.i.i53.i3046 = lshr i64 %product.i.i.i52.i3045, 32
  %xored.i.i.i54.i3047 = xor i64 %shifted.i.i.i53.i3046, %product.i.i.i52.i3045
  %hash.i.i.i55.i3048 = and i64 %xored.i.i.i54.i3047, %tbl_size.i.i50.i3043
  %offset_ptr.i.i56.i3049 = getelementptr i32, ptr %offset_tbl.i.i51.i3044, i64 %hash.i.i.i55.i3048
  %offset.i.i57.i3050 = load i32, ptr %offset_ptr.i.i56.i3049, align 4
  %942 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3051 = icmp eq i32 %940, 100
  br i1 %exitcond.not.i3051, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060, label %907

944:                                              ; preds = %907
  %945 = load i32, ptr %86, align 4
  %946 = add i32 %945, 1
  %947 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %946, ptr %86, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060: ; preds = %944, %.cont.i3038
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  br label %._crit_edge.i2306

._crit_edge.i2306:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060, %893
  %indvars.iv.next.i2307 = add nuw nsw i64 %indvars.iv.i2304, 1
  %exitcond.not.i2308 = icmp eq i64 %indvars.iv.next.i2307, %wide.trip.count.i2303
  br i1 %exitcond.not.i2308, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2326, label %893

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2326: ; preds = %._crit_edge.i2306
  %948 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %949

949:                                              ; preds = %._crit_edge.i2344, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2326
  %indvars.iv.i2342 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2326 ], [ %indvars.iv.next.i2345, %._crit_edge.i2344 ]
  %950 = shl nuw nsw i64 %indvars.iv.i2342, 5
  %951 = getelementptr i8, ptr %886, i64 %950
  %952 = load ptr, ptr %951, align 8
  %953 = icmp ne ptr %952, @nil_typ
  %954 = icmp ne ptr %952, null
  %.not17.i2343 = and i1 %953, %954
  br i1 %.not17.i2343, label %955, label %._crit_edge.i2344

955:                                              ; preds = %949
  %956 = getelementptr i8, ptr %951, i64 8
  %957 = load i64, ptr %956, align 4
  %.sroa_idx.i2347 = getelementptr i8, ptr %951, i64 16
  %958 = load i64, ptr %.sroa_idx.i2347, align 4
  %hash_coef_ptr.i.i6.i2348 = getelementptr i8, ptr %952, i64 8
  %tbl_size_ptr.i.i7.i2349 = getelementptr i8, ptr %952, i64 16
  %offset_tbl_ptr.i.i8.i2350 = getelementptr i8, ptr %952, i64 40
  %959 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %hash_coef.i.i21.i3078 = load i64, ptr %hash_coef_ptr.i.i6.i2348, align 4, !noalias !275
  %tbl_size.i.i22.i3079 = load i64, ptr %tbl_size_ptr.i.i7.i2349, align 4, !noalias !275
  %offset_tbl.i.i23.i3080 = load ptr, ptr %offset_tbl_ptr.i.i8.i2350, align 8, !noalias !275
  %product.i.i.i24.i3081 = mul i64 %hash_coef.i.i21.i3078, 4015701072841558310
  %shifted.i.i.i25.i3082 = lshr i64 %product.i.i.i24.i3081, 32
  %xored.i.i.i26.i3083 = xor i64 %shifted.i.i.i25.i3082, %product.i.i.i24.i3081
  %hash.i.i.i27.i3084 = and i64 %xored.i.i.i26.i3083, %tbl_size.i.i22.i3079
  %offset_ptr.i.i28.i3085 = getelementptr i32, ptr %offset_tbl.i.i23.i3080, i64 %hash.i.i.i27.i3084
  %offset.i.i29.i3086 = load i32, ptr %offset_ptr.i.i28.i3085, align 4, !noalias !275
  %960 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %961 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %962 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %963

963:                                              ; preds = %.cont.i3109, %955
  %.0290.i3087 = phi i32 [ 0, %955 ], [ %996, %.cont.i3109 ]
  %.074289.i3088 = phi i1 [ true, %955 ], [ %997, %.cont.i3109 ]
  %.sroa.0.0288.i3089 = phi ptr [ %952, %955 ], [ %986, %.cont.i3109 ]
  %.sroa.6.0287.i3090.in = phi i64 [ %957, %955 ], [ %988, %.cont.i3109 ]
  %.sroa.12.0286.i3091.in = phi i64 [ %958, %955 ], [ %989, %.cont.i3109 ]
  %.sroa.17.0285.i3092 = phi i32 [ %offset.i.i29.i3086, %955 ], [ %offset.i.i57.i3121, %.cont.i3109 ]
  %.sroa.12.0286.i3091 = inttoptr i64 %.sroa.12.0286.i3091.in to ptr
  %.sroa.6.0287.i3090 = inttoptr i64 %.sroa.6.0287.i3090.in to ptr
  %964 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3089, 0
  %965 = insertvalue { ptr, ptr, ptr, i32 } %964, ptr %.sroa.6.0287.i3090, 1
  %966 = insertvalue { ptr, ptr, ptr, i32 } %965, ptr %.sroa.12.0286.i3091, 2
  %967 = insertvalue { ptr, ptr, ptr, i32 } %966, i32 %.sroa.17.0285.i3092, 3
  %968 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3089)
  %969 = sext i32 %.sroa.17.0285.i3092 to i64
  %970 = getelementptr ptr, ptr %.sroa.0.0288.i3089, i64 %969
  %971 = getelementptr i8, ptr %970, i64 64
  %972 = load ptr, ptr %971, align 8
  %result.i15.i3093 = call ptr %972({ ptr, ptr, ptr, i32 } %967, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %973 = call i32 %result.i15.i3093({ ptr, ptr, ptr, i32 } %967, { ptr, ptr, ptr, i32 } %967, ptr nonnull align 8 %2) #53
  %..i3094 = select i1 %.074289.i3088, ptr %27, ptr %29
  %.188.i3095 = select i1 %.074289.i3088, i64 104, i64 112
  %.189.i3096 = select i1 %.074289.i3088, ptr %28, ptr %30
  %.190.i3097 = select i1 %.074289.i3088, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3094, align 8
  %974 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3094)
  %975 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3095
  %976 = load ptr, ptr %975, align 8
  store ptr @i32_typ, ptr %.189.i3096, align 8
  %result.i14.i3098 = call ptr %976({ ptr, ptr, ptr, i32 } %111, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3096) #46
  %977 = call i32 %result.i14.i3098({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull align 8 dereferenceable(8) %..i3094, i32 %973) #53
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %979 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3097
  %980 = load ptr, ptr %979, align 8
  %981 = load ptr, ptr %980, align 8
  %982 = call { ptr } %981(ptr nonnull %result.i79) #43
  %.fca.0.extract55.i3099 = extractvalue { ptr } %982, 0
  %983 = sext i32 %977 to i64
  %984 = shl nsw i64 %983, 5
  %985 = getelementptr i8, ptr %.fca.0.extract55.i3099, i64 %984
  %986 = load ptr, ptr %985, align 8
  %987 = getelementptr i8, ptr %985, i64 8
  %988 = load i64, ptr %987, align 4
  %.sroa_idx.i3100 = getelementptr i8, ptr %985, i64 16
  %989 = load i64, ptr %.sroa_idx.i3100, align 4
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %991 = call { ptr } %981(ptr nonnull %result.i79) #43
  %.fca.0.extract52.i3101 = extractvalue { ptr } %991, 0
  %992 = getelementptr i8, ptr %.fca.0.extract52.i3101, i64 %984
  store ptr %.sroa.0.0288.i3089, ptr %992, align 8
  %993 = getelementptr i8, ptr %992, i64 8
  store i64 %.sroa.6.0287.i3090.in, ptr %993, align 4
  %.sroa_idx104.i3102 = getelementptr i8, ptr %992, i64 16
  store i64 %.sroa.12.0286.i3091.in, ptr %.sroa_idx104.i3102, align 4
  %.sroa_idx105.i3103 = getelementptr i8, ptr %992, i64 24
  store i32 %.sroa.17.0285.i3092, ptr %.sroa_idx105.i3103, align 4
  %994 = icmp ne ptr %986, @nil_typ
  %995 = icmp ne ptr %986, null
  %.not94.i3104 = and i1 %994, %995
  br i1 %.not94.i3104, label %.cont.i3109, label %1000

.cont.i3109:                                      ; preds = %963
  %996 = add nuw nsw i32 %.0290.i3087, 1
  %997 = xor i1 %.074289.i3088, true
  %hash_coef_ptr.i.i46.i3110 = getelementptr i8, ptr %986, i64 8
  %tbl_size_ptr.i.i47.i3111 = getelementptr i8, ptr %986, i64 16
  %offset_tbl_ptr.i.i48.i3112 = getelementptr i8, ptr %986, i64 40
  %hash_coef.i.i49.i3113 = load i64, ptr %hash_coef_ptr.i.i46.i3110, align 4
  %tbl_size.i.i50.i3114 = load i64, ptr %tbl_size_ptr.i.i47.i3111, align 4
  %offset_tbl.i.i51.i3115 = load ptr, ptr %offset_tbl_ptr.i.i48.i3112, align 8
  %product.i.i.i52.i3116 = mul i64 %hash_coef.i.i49.i3113, 4015701072841558310
  %shifted.i.i.i53.i3117 = lshr i64 %product.i.i.i52.i3116, 32
  %xored.i.i.i54.i3118 = xor i64 %shifted.i.i.i53.i3117, %product.i.i.i52.i3116
  %hash.i.i.i55.i3119 = and i64 %xored.i.i.i54.i3118, %tbl_size.i.i50.i3114
  %offset_ptr.i.i56.i3120 = getelementptr i32, ptr %offset_tbl.i.i51.i3115, i64 %hash.i.i.i55.i3119
  %offset.i.i57.i3121 = load i32, ptr %offset_ptr.i.i56.i3120, align 4
  %998 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %999 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3122 = icmp eq i32 %996, 100
  br i1 %exitcond.not.i3122, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131, label %963

1000:                                             ; preds = %963
  %1001 = load i32, ptr %86, align 4
  %1002 = add i32 %1001, 1
  %1003 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1002, ptr %86, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131: ; preds = %1000, %.cont.i3109
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  br label %._crit_edge.i2344

._crit_edge.i2344:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131, %949
  %indvars.iv.next.i2345 = add nuw nsw i64 %indvars.iv.i2342, 1
  %exitcond.not.i2346 = icmp eq i64 %indvars.iv.next.i2345, %wide.trip.count.i2303
  br i1 %exitcond.not.i2346, label %CuckooMap_insert_keyK_valueV.exit, label %949

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i2344, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2326.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1199, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1069, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store i1 true, ptr %.sroa.0340.sroa.0, align 8
  %.sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.0. = load i8, ptr %.sroa.0340.sroa.0, align 8
  %.sroa.0340.0.insert.ext = zext i8 %.sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.0. to i160
  %1004 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0340.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1005 = load ptr, ptr %93, align 8
  %1006 = call i32 %1005({ ptr, i160 } %118) #53
  %1007 = load i32, ptr %95, align 8
  %1008 = add i32 %1007, -1
  %1009 = and i32 %1008, %1006
  %1010 = load ptr, ptr %96, align 8
  %1011 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1012 = sext i32 %1009 to i64
  %1013 = shl nsw i64 %1012, 5
  %1014 = getelementptr i8, ptr %1010, i64 %1013
  %1015 = load ptr, ptr %1014, align 8
  %1016 = getelementptr i8, ptr %1014, i64 8
  %1017 = icmp ne ptr %1015, @nil_typ
  %1018 = icmp ne ptr %1015, null
  %.not66.i1263 = and i1 %1017, %1018
  br i1 %.not66.i1263, label %1019, label %1117

1019:                                             ; preds = %CuckooMap_insert_keyK_valueV.exit
  %1020 = load i64, ptr %1016, align 4
  %.sroa_idx.i1265 = getelementptr i8, ptr %1014, i64 16
  %1021 = load i64, ptr %.sroa_idx.i1265, align 4
  %1022 = inttoptr i64 %1020 to ptr
  %1023 = inttoptr i64 %1021 to ptr
  %hash_coef_ptr.i.i11.i1266 = getelementptr i8, ptr %1015, i64 8
  %tbl_size_ptr.i.i12.i1267 = getelementptr i8, ptr %1015, i64 16
  %offset_tbl_ptr.i.i13.i1268 = getelementptr i8, ptr %1015, i64 40
  %hash_coef.i.i14.i1269 = load i64, ptr %hash_coef_ptr.i.i11.i1266, align 4, !noalias !278
  %tbl_size.i.i15.i1270 = load i64, ptr %tbl_size_ptr.i.i12.i1267, align 4, !noalias !278
  %offset_tbl.i.i16.i1271 = load ptr, ptr %offset_tbl_ptr.i.i13.i1268, align 8, !noalias !278
  %product.i.i.i17.i1272 = mul i64 %hash_coef.i.i14.i1269, 4015701072841558310
  %shifted.i.i.i18.i1273 = lshr i64 %product.i.i.i17.i1272, 32
  %xored.i.i.i19.i1274 = xor i64 %shifted.i.i.i18.i1273, %product.i.i.i17.i1272
  %hash.i.i.i20.i1275 = and i64 %xored.i.i.i19.i1274, %tbl_size.i.i15.i1270
  %offset_ptr.i.i21.i1276 = getelementptr i32, ptr %offset_tbl.i.i16.i1271, i64 %hash.i.i.i20.i1275
  %offset.i.i22.i1277 = load i32, ptr %offset_ptr.i.i21.i1276, align 4, !noalias !278
  %1024 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1015, 0
  %1025 = insertvalue { ptr, ptr, ptr, i32 } %1024, ptr %1022, 1
  %1026 = insertvalue { ptr, ptr, ptr, i32 } %1025, ptr %1023, 2
  %1027 = insertvalue { ptr, ptr, ptr, i32 } %1026, i32 %offset.i.i22.i1277, 3
  %1028 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1029 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1015) #40
  %1030 = sext i32 %offset.i.i22.i1277 to i64
  %1031 = getelementptr ptr, ptr %1015, i64 %1030
  %1032 = getelementptr i8, ptr %1031, i64 64
  %1033 = load ptr, ptr %1032, align 8
  %result.i8.i1278 = call ptr %1033({ ptr, ptr, ptr, i32 } %1027, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1034 = call i32 %result.i8.i1278({ ptr, ptr, ptr, i32 } %1027, { ptr, ptr, ptr, i32 } %1027, ptr nonnull align 8 %2) #53
  %1035 = icmp eq i32 %1034, %1006
  br i1 %1035, label %._crit_edge.i1279, label %1117

._crit_edge.i1279:                                ; preds = %1019
  %1036 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1037 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1015)
  %1038 = getelementptr i8, ptr %1031, i64 48
  %1039 = load ptr, ptr %1038, align 8
  %result.i7.i1280 = call ptr %1039({ ptr, ptr, ptr, i32 } %1027, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1040 = call { ptr, i160 } %result.i7.i1280({ ptr, ptr, ptr, i32 } %1027, { ptr, ptr, ptr, i32 } %1027, ptr nonnull align 8 %2) #53
  %1041 = load ptr, ptr %94, align 8
  %1042 = call i1 %1041({ ptr, i160 } %1040, { ptr, i160 } %118) #53
  br i1 %1042, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1292, label %1117

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1292: ; preds = %._crit_edge.i1279
  %1043 = load ptr, ptr %result.i74, align 8
  %1044 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1045 = load ptr, ptr %88, align 8
  %1046 = load ptr, ptr %1043, align 8, !alias.scope !281
  %1047 = getelementptr i8, ptr %1046, i64 72
  %1048 = load ptr, ptr %1047, align 8, !alias.scope !281
  %result.i1.i.i1284 = call { i64, i64 } %1048(ptr nocapture nofree nonnull readonly align 8 %1043) #44, !alias.scope !281
  %1049 = extractvalue { i64, i64 } %result.i1.i.i1284, 0
  %1050 = extractvalue { i64, i64 } %result.i1.i.i1284, 1
  %1051 = urem i64 20, %1050
  %1052 = icmp eq i64 %1051, 0
  %1053 = sub i64 %1050, %1051
  %1054 = select i1 %1052, i64 0, i64 %1053
  %1055 = add i64 %1049, 20
  %1056 = add i64 %1055, %1054
  %1057 = load ptr, ptr %1045, align 8, !alias.scope !281
  %1058 = getelementptr i8, ptr %1057, i64 72
  %1059 = load ptr, ptr %1058, align 8, !alias.scope !281
  %result.i.i.i1285 = call { i64, i64 } %1059(ptr nocapture nofree nonnull readonly align 8 %1045) #44, !alias.scope !281
  %1060 = extractvalue { i64, i64 } %result.i.i.i1285, 0
  %1061 = extractvalue { i64, i64 } %result.i.i.i1285, 1
  %1062 = call i64 @llvm.umax.i64(i64 %1050, i64 %1061) #41
  %1063 = call i64 @llvm.umax.i64(i64 %1062, i64 noundef 8) #41, !range !16
  %1064 = urem i64 %1056, %1061
  %1065 = icmp eq i64 %1064, 0
  %1066 = sub i64 %1061, %1064
  %1067 = select i1 %1065, i64 0, i64 %1066
  %1068 = add i64 %1060, %1056
  %1069 = add i64 %1068, %1067
  %1070 = urem i64 %1069, %1063
  %1071 = icmp eq i64 %1070, 0
  %1072 = sub i64 %1063, %1070
  %1073 = select i1 %1071, i64 0, i64 %1072
  %1074 = add i64 %1073, %1069
  %result.i9.i1286 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1074) #48
  store ptr %1043, ptr %result.i9.i1286, align 8
  %1075 = getelementptr inbounds i8, ptr %result.i9.i1286, i64 8
  store ptr %1045, ptr %1075, align 8
  %1076 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1286)
  %1077 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1078 = load ptr, ptr %1043, align 8
  %1079 = getelementptr i8, ptr %1078, i64 72
  %1080 = load ptr, ptr %1079, align 8
  %result.i.i38.i1287 = call { i64, i64 } %1080(ptr nocapture nofree nonnull readonly align 8 %1043) #44
  %1081 = extractvalue { i64, i64 } %result.i.i38.i1287, 1
  %1082 = urem i64 20, %1081
  %1083 = icmp eq i64 %1082, 0
  %reass.sub3877 = sub i64 %1081, %1082
  %1084 = add i64 %reass.sub3877, 20
  %1085 = select i1 %1083, i64 20, i64 %1084
  %1086 = getelementptr i8, ptr %result.i9.i1286, i64 %1085
  %1087 = getelementptr i8, ptr %1078, i64 64
  %1088 = load ptr, ptr %1087, align 8
  call void %1088({ ptr, i160 } %118, ptr nocapture nofree nonnull readonly align 8 %1043, ptr nocapture nofree writeonly %1086) #45
  %1089 = load ptr, ptr %result.i9.i1286, align 8
  %1090 = load ptr, ptr %1089, align 8
  %1091 = getelementptr i8, ptr %1090, i64 72
  %1092 = load ptr, ptr %1091, align 8
  %result.i1.i39.i1289 = call { i64, i64 } %1092(ptr nocapture nofree nonnull readonly align 8 %1089) #44
  %1093 = extractvalue { i64, i64 } %result.i1.i39.i1289, 0
  %1094 = extractvalue { i64, i64 } %result.i1.i39.i1289, 1
  %1095 = urem i64 20, %1094
  %1096 = icmp eq i64 %1095, 0
  %1097 = sub i64 %1094, %1095
  %1098 = select i1 %1096, i64 0, i64 %1097
  %1099 = add i64 %1093, 20
  %1100 = add i64 %1099, %1098
  %1101 = load ptr, ptr %1075, align 8
  %1102 = load ptr, ptr %1101, align 8
  %1103 = getelementptr i8, ptr %1102, i64 72
  %1104 = load ptr, ptr %1103, align 8
  %result.i.i40.i1290 = call { i64, i64 } %1104(ptr nocapture nofree nonnull readonly align 8 %1101) #44
  %1105 = extractvalue { i64, i64 } %result.i.i40.i1290, 1
  %1106 = urem i64 %1100, %1105
  %1107 = icmp eq i64 %1106, 0
  %1108 = sub i64 %1105, %1106
  %1109 = select i1 %1107, i64 0, i64 %1108
  %1110 = getelementptr i8, ptr %result.i9.i1286, i64 %1100
  %1111 = getelementptr i8, ptr %1110, i64 %1109
  %1112 = getelementptr i8, ptr %1102, i64 64
  %1113 = load ptr, ptr %1112, align 8
  call void %1113({ ptr, i160 } %1004, ptr nocapture nofree nonnull readonly align 8 %1101, ptr nocapture nofree writeonly %1111) #45
  %1114 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1115 = getelementptr inbounds i8, ptr %result.i9.i1286, i64 16
  store i32 %1006, ptr %1115, align 8
  store ptr @Entry, ptr %1014, align 8
  %1116 = ptrtoint ptr %result.i9.i1286 to i64
  store i64 %1116, ptr %1016, align 4
  %.sroa_idx30.i1291 = getelementptr i8, ptr %1014, i64 24
  store i32 10, ptr %.sroa_idx30.i1291, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit465

1117:                                             ; preds = %._crit_edge.i1279, %1019, %CuckooMap_insert_keyK_valueV.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1118 = add i32 %1006, 2127912214
  %1119 = shl i32 %1006, 12
  %1120 = add i32 %1118, %1119
  %1121 = ashr i32 %1120, 19
  %1122 = xor i32 %1120, %1121
  %1123 = xor i32 %1122, -949894596
  %1124 = add i32 %1123, 374761393
  %1125 = shl i32 %1123, 5
  %1126 = add i32 %1124, %1125
  %1127 = add i32 %1126, -744332180
  %1128 = shl i32 %1126, 9
  %1129 = xor i32 %1127, %1128
  %1130 = add i32 %1129, -42973499
  %1131 = shl i32 %1129, 3
  %1132 = add i32 %1130, %1131
  %1133 = ashr i32 %1132, 16
  %1134 = xor i32 %1132, %1133
  %1135 = xor i32 %1134, -1252372727
  %1136 = load i32, ptr %95, align 8
  %1137 = add i32 %1136, -1
  %1138 = and i32 %1137, %1135
  %1139 = load ptr, ptr %97, align 8
  %1140 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1141 = sext i32 %1138 to i64
  %1142 = shl nsw i64 %1141, 5
  %1143 = getelementptr i8, ptr %1139, i64 %1142
  %1144 = load ptr, ptr %1143, align 8
  %1145 = getelementptr i8, ptr %1143, i64 8
  %1146 = icmp ne ptr %1144, @nil_typ
  %1147 = icmp ne ptr %1144, null
  %.not66.i1322 = and i1 %1146, %1147
  br i1 %.not66.i1322, label %1148, label %1246

1148:                                             ; preds = %1117
  %1149 = load i64, ptr %1145, align 4
  %.sroa_idx.i1324 = getelementptr i8, ptr %1143, i64 16
  %1150 = load i64, ptr %.sroa_idx.i1324, align 4
  %1151 = inttoptr i64 %1149 to ptr
  %1152 = inttoptr i64 %1150 to ptr
  %hash_coef_ptr.i.i11.i1325 = getelementptr i8, ptr %1144, i64 8
  %tbl_size_ptr.i.i12.i1326 = getelementptr i8, ptr %1144, i64 16
  %offset_tbl_ptr.i.i13.i1327 = getelementptr i8, ptr %1144, i64 40
  %hash_coef.i.i14.i1328 = load i64, ptr %hash_coef_ptr.i.i11.i1325, align 4, !noalias !284
  %tbl_size.i.i15.i1329 = load i64, ptr %tbl_size_ptr.i.i12.i1326, align 4, !noalias !284
  %offset_tbl.i.i16.i1330 = load ptr, ptr %offset_tbl_ptr.i.i13.i1327, align 8, !noalias !284
  %product.i.i.i17.i1331 = mul i64 %hash_coef.i.i14.i1328, 4015701072841558310
  %shifted.i.i.i18.i1332 = lshr i64 %product.i.i.i17.i1331, 32
  %xored.i.i.i19.i1333 = xor i64 %shifted.i.i.i18.i1332, %product.i.i.i17.i1331
  %hash.i.i.i20.i1334 = and i64 %xored.i.i.i19.i1333, %tbl_size.i.i15.i1329
  %offset_ptr.i.i21.i1335 = getelementptr i32, ptr %offset_tbl.i.i16.i1330, i64 %hash.i.i.i20.i1334
  %offset.i.i22.i1336 = load i32, ptr %offset_ptr.i.i21.i1335, align 4, !noalias !284
  %1153 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1144, 0
  %1154 = insertvalue { ptr, ptr, ptr, i32 } %1153, ptr %1151, 1
  %1155 = insertvalue { ptr, ptr, ptr, i32 } %1154, ptr %1152, 2
  %1156 = insertvalue { ptr, ptr, ptr, i32 } %1155, i32 %offset.i.i22.i1336, 3
  %1157 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1158 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1144) #40
  %1159 = sext i32 %offset.i.i22.i1336 to i64
  %1160 = getelementptr ptr, ptr %1144, i64 %1159
  %1161 = getelementptr i8, ptr %1160, i64 64
  %1162 = load ptr, ptr %1161, align 8
  %result.i8.i1337 = call ptr %1162({ ptr, ptr, ptr, i32 } %1156, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1163 = call i32 %result.i8.i1337({ ptr, ptr, ptr, i32 } %1156, { ptr, ptr, ptr, i32 } %1156, ptr nonnull align 8 %2) #53
  %1164 = icmp eq i32 %1163, %1006
  br i1 %1164, label %._crit_edge.i1338, label %1246

._crit_edge.i1338:                                ; preds = %1148
  %1165 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1166 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1144)
  %1167 = getelementptr i8, ptr %1160, i64 48
  %1168 = load ptr, ptr %1167, align 8
  %result.i7.i1339 = call ptr %1168({ ptr, ptr, ptr, i32 } %1156, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1169 = call { ptr, i160 } %result.i7.i1339({ ptr, ptr, ptr, i32 } %1156, { ptr, ptr, ptr, i32 } %1156, ptr nonnull align 8 %2) #53
  %1170 = load ptr, ptr %94, align 8
  %1171 = call i1 %1170({ ptr, i160 } %1169, { ptr, i160 } %118) #53
  br i1 %1171, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1351, label %1246

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1351: ; preds = %._crit_edge.i1338
  %1172 = load ptr, ptr %result.i74, align 8
  %1173 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1174 = load ptr, ptr %88, align 8
  %1175 = load ptr, ptr %1172, align 8, !alias.scope !287
  %1176 = getelementptr i8, ptr %1175, i64 72
  %1177 = load ptr, ptr %1176, align 8, !alias.scope !287
  %result.i1.i.i1343 = call { i64, i64 } %1177(ptr nocapture nofree nonnull readonly align 8 %1172) #44, !alias.scope !287
  %1178 = extractvalue { i64, i64 } %result.i1.i.i1343, 0
  %1179 = extractvalue { i64, i64 } %result.i1.i.i1343, 1
  %1180 = urem i64 20, %1179
  %1181 = icmp eq i64 %1180, 0
  %1182 = sub i64 %1179, %1180
  %1183 = select i1 %1181, i64 0, i64 %1182
  %1184 = add i64 %1178, 20
  %1185 = add i64 %1184, %1183
  %1186 = load ptr, ptr %1174, align 8, !alias.scope !287
  %1187 = getelementptr i8, ptr %1186, i64 72
  %1188 = load ptr, ptr %1187, align 8, !alias.scope !287
  %result.i.i.i1344 = call { i64, i64 } %1188(ptr nocapture nofree nonnull readonly align 8 %1174) #44, !alias.scope !287
  %1189 = extractvalue { i64, i64 } %result.i.i.i1344, 0
  %1190 = extractvalue { i64, i64 } %result.i.i.i1344, 1
  %1191 = call i64 @llvm.umax.i64(i64 %1179, i64 %1190) #41
  %1192 = call i64 @llvm.umax.i64(i64 %1191, i64 noundef 8) #41, !range !16
  %1193 = urem i64 %1185, %1190
  %1194 = icmp eq i64 %1193, 0
  %1195 = sub i64 %1190, %1193
  %1196 = select i1 %1194, i64 0, i64 %1195
  %1197 = add i64 %1189, %1185
  %1198 = add i64 %1197, %1196
  %1199 = urem i64 %1198, %1192
  %1200 = icmp eq i64 %1199, 0
  %1201 = sub i64 %1192, %1199
  %1202 = select i1 %1200, i64 0, i64 %1201
  %1203 = add i64 %1202, %1198
  %result.i9.i1345 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1203) #48
  store ptr %1172, ptr %result.i9.i1345, align 8
  %1204 = getelementptr inbounds i8, ptr %result.i9.i1345, i64 8
  store ptr %1174, ptr %1204, align 8
  %1205 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1345)
  %1206 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1207 = load ptr, ptr %1172, align 8
  %1208 = getelementptr i8, ptr %1207, i64 72
  %1209 = load ptr, ptr %1208, align 8
  %result.i.i38.i1346 = call { i64, i64 } %1209(ptr nocapture nofree nonnull readonly align 8 %1172) #44
  %1210 = extractvalue { i64, i64 } %result.i.i38.i1346, 1
  %1211 = urem i64 20, %1210
  %1212 = icmp eq i64 %1211, 0
  %reass.sub3876 = sub i64 %1210, %1211
  %1213 = add i64 %reass.sub3876, 20
  %1214 = select i1 %1212, i64 20, i64 %1213
  %1215 = getelementptr i8, ptr %result.i9.i1345, i64 %1214
  %1216 = getelementptr i8, ptr %1207, i64 64
  %1217 = load ptr, ptr %1216, align 8
  call void %1217({ ptr, i160 } %118, ptr nocapture nofree nonnull readonly align 8 %1172, ptr nocapture nofree writeonly %1215) #45
  %1218 = load ptr, ptr %result.i9.i1345, align 8
  %1219 = load ptr, ptr %1218, align 8
  %1220 = getelementptr i8, ptr %1219, i64 72
  %1221 = load ptr, ptr %1220, align 8
  %result.i1.i39.i1348 = call { i64, i64 } %1221(ptr nocapture nofree nonnull readonly align 8 %1218) #44
  %1222 = extractvalue { i64, i64 } %result.i1.i39.i1348, 0
  %1223 = extractvalue { i64, i64 } %result.i1.i39.i1348, 1
  %1224 = urem i64 20, %1223
  %1225 = icmp eq i64 %1224, 0
  %1226 = sub i64 %1223, %1224
  %1227 = select i1 %1225, i64 0, i64 %1226
  %1228 = add i64 %1222, 20
  %1229 = add i64 %1228, %1227
  %1230 = load ptr, ptr %1204, align 8
  %1231 = load ptr, ptr %1230, align 8
  %1232 = getelementptr i8, ptr %1231, i64 72
  %1233 = load ptr, ptr %1232, align 8
  %result.i.i40.i1349 = call { i64, i64 } %1233(ptr nocapture nofree nonnull readonly align 8 %1230) #44
  %1234 = extractvalue { i64, i64 } %result.i.i40.i1349, 1
  %1235 = urem i64 %1229, %1234
  %1236 = icmp eq i64 %1235, 0
  %1237 = sub i64 %1234, %1235
  %1238 = select i1 %1236, i64 0, i64 %1237
  %1239 = getelementptr i8, ptr %result.i9.i1345, i64 %1229
  %1240 = getelementptr i8, ptr %1239, i64 %1238
  %1241 = getelementptr i8, ptr %1231, i64 64
  %1242 = load ptr, ptr %1241, align 8
  call void %1242({ ptr, i160 } %1004, ptr nocapture nofree nonnull readonly align 8 %1230, ptr nocapture nofree writeonly %1240) #45
  %1243 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1244 = getelementptr inbounds i8, ptr %result.i9.i1345, i64 16
  store i32 %1006, ptr %1244, align 8
  store ptr @Entry, ptr %1143, align 8
  %1245 = ptrtoint ptr %result.i9.i1345 to i64
  store i64 %1245, ptr %1145, align 4
  %.sroa_idx30.i1350 = getelementptr i8, ptr %1143, i64 24
  store i32 10, ptr %.sroa_idx30.i1350, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit465

1246:                                             ; preds = %._crit_edge.i1338, %1148, %1117
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1247 = load i32, ptr %99, align 4
  %1248 = load i32, ptr %95, align 8
  %.not.i423 = icmp slt i32 %1247, %1248
  br i1 %.not.i423, label %._crit_edge.i425, label %1249

1249:                                             ; preds = %1246
  %1250 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1251 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1252 = load ptr, ptr %96, align 8
  %1253 = load ptr, ptr %97, align 8
  %1254 = shl i32 %1248, 1
  %spec.select.i1367 = call i32 @llvm.smax.i32(i32 %1254, i32 noundef 16) #40
  store i32 %spec.select.i1367, ptr %95, align 8
  %1255 = zext nneg i32 %spec.select.i1367 to i64
  %1256 = shl nuw nsw i64 %1255, 5
  %result.i5.i1368 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1256) #48
  store ptr %result.i5.i1368, ptr %96, align 8
  %result.i4.i1369 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1256) #48
  store ptr %result.i4.i1369, ptr %97, align 8
  store i32 0, ptr %99, align 4
  %1257 = icmp sgt i32 %1248, 0
  br i1 %1257, label %.lr.ph.i2366, label %._crit_edge.i425

.lr.ph.i2366:                                     ; preds = %1249
  %wide.trip.count.i2379 = zext nneg i32 %1248 to i64
  br label %1258

1258:                                             ; preds = %._crit_edge.i2382, %.lr.ph.i2366
  %indvars.iv.i2380 = phi i64 [ 0, %.lr.ph.i2366 ], [ %indvars.iv.next.i2383, %._crit_edge.i2382 ]
  %1259 = shl nuw nsw i64 %indvars.iv.i2380, 5
  %1260 = getelementptr i8, ptr %1252, i64 %1259
  %1261 = load ptr, ptr %1260, align 8
  %1262 = icmp ne ptr %1261, @nil_typ
  %1263 = icmp ne ptr %1261, null
  %.not17.i2381 = and i1 %1262, %1263
  br i1 %.not17.i2381, label %1264, label %._crit_edge.i2382

1264:                                             ; preds = %1258
  %1265 = getelementptr i8, ptr %1260, i64 8
  %1266 = load i64, ptr %1265, align 4
  %.sroa_idx.i2385 = getelementptr i8, ptr %1260, i64 16
  %1267 = load i64, ptr %.sroa_idx.i2385, align 4
  %hash_coef_ptr.i.i6.i2386 = getelementptr i8, ptr %1261, i64 8
  %tbl_size_ptr.i.i7.i2387 = getelementptr i8, ptr %1261, i64 16
  %offset_tbl_ptr.i.i8.i2388 = getelementptr i8, ptr %1261, i64 40
  %1268 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %hash_coef.i.i21.i3149 = load i64, ptr %hash_coef_ptr.i.i6.i2386, align 4, !noalias !290
  %tbl_size.i.i22.i3150 = load i64, ptr %tbl_size_ptr.i.i7.i2387, align 4, !noalias !290
  %offset_tbl.i.i23.i3151 = load ptr, ptr %offset_tbl_ptr.i.i8.i2388, align 8, !noalias !290
  %product.i.i.i24.i3152 = mul i64 %hash_coef.i.i21.i3149, 4015701072841558310
  %shifted.i.i.i25.i3153 = lshr i64 %product.i.i.i24.i3152, 32
  %xored.i.i.i26.i3154 = xor i64 %shifted.i.i.i25.i3153, %product.i.i.i24.i3152
  %hash.i.i.i27.i3155 = and i64 %xored.i.i.i26.i3154, %tbl_size.i.i22.i3150
  %offset_ptr.i.i28.i3156 = getelementptr i32, ptr %offset_tbl.i.i23.i3151, i64 %hash.i.i.i27.i3155
  %offset.i.i29.i3157 = load i32, ptr %offset_ptr.i.i28.i3156, align 4, !noalias !290
  %1269 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1272

1272:                                             ; preds = %.cont.i3180, %1264
  %.0290.i3158 = phi i32 [ 0, %1264 ], [ %1305, %.cont.i3180 ]
  %.074289.i3159 = phi i1 [ true, %1264 ], [ %1306, %.cont.i3180 ]
  %.sroa.0.0288.i3160 = phi ptr [ %1261, %1264 ], [ %1295, %.cont.i3180 ]
  %.sroa.6.0287.i3161.in = phi i64 [ %1266, %1264 ], [ %1297, %.cont.i3180 ]
  %.sroa.12.0286.i3162.in = phi i64 [ %1267, %1264 ], [ %1298, %.cont.i3180 ]
  %.sroa.17.0285.i3163 = phi i32 [ %offset.i.i29.i3157, %1264 ], [ %offset.i.i57.i3192, %.cont.i3180 ]
  %.sroa.12.0286.i3162 = inttoptr i64 %.sroa.12.0286.i3162.in to ptr
  %.sroa.6.0287.i3161 = inttoptr i64 %.sroa.6.0287.i3161.in to ptr
  %1273 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3160, 0
  %1274 = insertvalue { ptr, ptr, ptr, i32 } %1273, ptr %.sroa.6.0287.i3161, 1
  %1275 = insertvalue { ptr, ptr, ptr, i32 } %1274, ptr %.sroa.12.0286.i3162, 2
  %1276 = insertvalue { ptr, ptr, ptr, i32 } %1275, i32 %.sroa.17.0285.i3163, 3
  %1277 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3160)
  %1278 = sext i32 %.sroa.17.0285.i3163 to i64
  %1279 = getelementptr ptr, ptr %.sroa.0.0288.i3160, i64 %1278
  %1280 = getelementptr i8, ptr %1279, i64 64
  %1281 = load ptr, ptr %1280, align 8
  %result.i15.i3164 = call ptr %1281({ ptr, ptr, ptr, i32 } %1276, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1282 = call i32 %result.i15.i3164({ ptr, ptr, ptr, i32 } %1276, { ptr, ptr, ptr, i32 } %1276, ptr nonnull align 8 %2) #53
  %..i3165 = select i1 %.074289.i3159, ptr %23, ptr %25
  %.188.i3166 = select i1 %.074289.i3159, i64 104, i64 112
  %.189.i3167 = select i1 %.074289.i3159, ptr %24, ptr %26
  %.190.i3168 = select i1 %.074289.i3159, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3165, align 8
  %1283 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3165)
  %1284 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3166
  %1285 = load ptr, ptr %1284, align 8
  store ptr @i32_typ, ptr %.189.i3167, align 8
  %result.i14.i3169 = call ptr %1285({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3167) #46
  %1286 = call i32 %result.i14.i3169({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 dereferenceable(8) %..i3165, i32 %1282) #53
  %1287 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1288 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3168
  %1289 = load ptr, ptr %1288, align 8
  %1290 = load ptr, ptr %1289, align 8
  %1291 = call { ptr } %1290(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i3170 = extractvalue { ptr } %1291, 0
  %1292 = sext i32 %1286 to i64
  %1293 = shl nsw i64 %1292, 5
  %1294 = getelementptr i8, ptr %.fca.0.extract55.i3170, i64 %1293
  %1295 = load ptr, ptr %1294, align 8
  %1296 = getelementptr i8, ptr %1294, i64 8
  %1297 = load i64, ptr %1296, align 4
  %.sroa_idx.i3171 = getelementptr i8, ptr %1294, i64 16
  %1298 = load i64, ptr %.sroa_idx.i3171, align 4
  %1299 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1300 = call { ptr } %1290(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i3172 = extractvalue { ptr } %1300, 0
  %1301 = getelementptr i8, ptr %.fca.0.extract52.i3172, i64 %1293
  store ptr %.sroa.0.0288.i3160, ptr %1301, align 8
  %1302 = getelementptr i8, ptr %1301, i64 8
  store i64 %.sroa.6.0287.i3161.in, ptr %1302, align 4
  %.sroa_idx104.i3173 = getelementptr i8, ptr %1301, i64 16
  store i64 %.sroa.12.0286.i3162.in, ptr %.sroa_idx104.i3173, align 4
  %.sroa_idx105.i3174 = getelementptr i8, ptr %1301, i64 24
  store i32 %.sroa.17.0285.i3163, ptr %.sroa_idx105.i3174, align 4
  %1303 = icmp ne ptr %1295, @nil_typ
  %1304 = icmp ne ptr %1295, null
  %.not94.i3175 = and i1 %1303, %1304
  br i1 %.not94.i3175, label %.cont.i3180, label %1309

.cont.i3180:                                      ; preds = %1272
  %1305 = add nuw nsw i32 %.0290.i3158, 1
  %1306 = xor i1 %.074289.i3159, true
  %hash_coef_ptr.i.i46.i3181 = getelementptr i8, ptr %1295, i64 8
  %tbl_size_ptr.i.i47.i3182 = getelementptr i8, ptr %1295, i64 16
  %offset_tbl_ptr.i.i48.i3183 = getelementptr i8, ptr %1295, i64 40
  %hash_coef.i.i49.i3184 = load i64, ptr %hash_coef_ptr.i.i46.i3181, align 4
  %tbl_size.i.i50.i3185 = load i64, ptr %tbl_size_ptr.i.i47.i3182, align 4
  %offset_tbl.i.i51.i3186 = load ptr, ptr %offset_tbl_ptr.i.i48.i3183, align 8
  %product.i.i.i52.i3187 = mul i64 %hash_coef.i.i49.i3184, 4015701072841558310
  %shifted.i.i.i53.i3188 = lshr i64 %product.i.i.i52.i3187, 32
  %xored.i.i.i54.i3189 = xor i64 %shifted.i.i.i53.i3188, %product.i.i.i52.i3187
  %hash.i.i.i55.i3190 = and i64 %xored.i.i.i54.i3189, %tbl_size.i.i50.i3185
  %offset_ptr.i.i56.i3191 = getelementptr i32, ptr %offset_tbl.i.i51.i3186, i64 %hash.i.i.i55.i3190
  %offset.i.i57.i3192 = load i32, ptr %offset_ptr.i.i56.i3191, align 4
  %1307 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1308 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3193 = icmp eq i32 %1305, 100
  br i1 %exitcond.not.i3193, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202, label %1272

1309:                                             ; preds = %1272
  %1310 = load i32, ptr %99, align 4
  %1311 = add i32 %1310, 1
  %1312 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1311, ptr %99, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202: ; preds = %1309, %.cont.i3180
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  br label %._crit_edge.i2382

._crit_edge.i2382:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202, %1258
  %indvars.iv.next.i2383 = add nuw nsw i64 %indvars.iv.i2380, 1
  %exitcond.not.i2384 = icmp eq i64 %indvars.iv.next.i2383, %wide.trip.count.i2379
  br i1 %exitcond.not.i2384, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2402, label %1258

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2402: ; preds = %._crit_edge.i2420, %._crit_edge.i2382
  %indvars.iv.i2418 = phi i64 [ %indvars.iv.next.i2421, %._crit_edge.i2420 ], [ 0, %._crit_edge.i2382 ]
  %1313 = shl nuw nsw i64 %indvars.iv.i2418, 5
  %1314 = getelementptr i8, ptr %1253, i64 %1313
  %1315 = load ptr, ptr %1314, align 8
  %1316 = icmp ne ptr %1315, @nil_typ
  %1317 = icmp ne ptr %1315, null
  %.not17.i2419 = and i1 %1316, %1317
  br i1 %.not17.i2419, label %1318, label %._crit_edge.i2420

1318:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2402
  %1319 = getelementptr i8, ptr %1314, i64 8
  %1320 = load i64, ptr %1319, align 4
  %.sroa_idx.i2423 = getelementptr i8, ptr %1314, i64 16
  %1321 = load i64, ptr %.sroa_idx.i2423, align 4
  %hash_coef_ptr.i.i6.i2424 = getelementptr i8, ptr %1315, i64 8
  %tbl_size_ptr.i.i7.i2425 = getelementptr i8, ptr %1315, i64 16
  %offset_tbl_ptr.i.i8.i2426 = getelementptr i8, ptr %1315, i64 40
  %1322 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  %hash_coef.i.i21.i3220 = load i64, ptr %hash_coef_ptr.i.i6.i2424, align 4, !noalias !293
  %tbl_size.i.i22.i3221 = load i64, ptr %tbl_size_ptr.i.i7.i2425, align 4, !noalias !293
  %offset_tbl.i.i23.i3222 = load ptr, ptr %offset_tbl_ptr.i.i8.i2426, align 8, !noalias !293
  %product.i.i.i24.i3223 = mul i64 %hash_coef.i.i21.i3220, 4015701072841558310
  %shifted.i.i.i25.i3224 = lshr i64 %product.i.i.i24.i3223, 32
  %xored.i.i.i26.i3225 = xor i64 %shifted.i.i.i25.i3224, %product.i.i.i24.i3223
  %hash.i.i.i27.i3226 = and i64 %xored.i.i.i26.i3225, %tbl_size.i.i22.i3221
  %offset_ptr.i.i28.i3227 = getelementptr i32, ptr %offset_tbl.i.i23.i3222, i64 %hash.i.i.i27.i3226
  %offset.i.i29.i3228 = load i32, ptr %offset_ptr.i.i28.i3227, align 4, !noalias !293
  %1323 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1324 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1325 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1326

1326:                                             ; preds = %.cont.i3251, %1318
  %.0290.i3229 = phi i32 [ 0, %1318 ], [ %1359, %.cont.i3251 ]
  %.074289.i3230 = phi i1 [ true, %1318 ], [ %1360, %.cont.i3251 ]
  %.sroa.0.0288.i3231 = phi ptr [ %1315, %1318 ], [ %1349, %.cont.i3251 ]
  %.sroa.6.0287.i3232.in = phi i64 [ %1320, %1318 ], [ %1351, %.cont.i3251 ]
  %.sroa.12.0286.i3233.in = phi i64 [ %1321, %1318 ], [ %1352, %.cont.i3251 ]
  %.sroa.17.0285.i3234 = phi i32 [ %offset.i.i29.i3228, %1318 ], [ %offset.i.i57.i3263, %.cont.i3251 ]
  %.sroa.12.0286.i3233 = inttoptr i64 %.sroa.12.0286.i3233.in to ptr
  %.sroa.6.0287.i3232 = inttoptr i64 %.sroa.6.0287.i3232.in to ptr
  %1327 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3231, 0
  %1328 = insertvalue { ptr, ptr, ptr, i32 } %1327, ptr %.sroa.6.0287.i3232, 1
  %1329 = insertvalue { ptr, ptr, ptr, i32 } %1328, ptr %.sroa.12.0286.i3233, 2
  %1330 = insertvalue { ptr, ptr, ptr, i32 } %1329, i32 %.sroa.17.0285.i3234, 3
  %1331 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3231)
  %1332 = sext i32 %.sroa.17.0285.i3234 to i64
  %1333 = getelementptr ptr, ptr %.sroa.0.0288.i3231, i64 %1332
  %1334 = getelementptr i8, ptr %1333, i64 64
  %1335 = load ptr, ptr %1334, align 8
  %result.i15.i3235 = call ptr %1335({ ptr, ptr, ptr, i32 } %1330, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1336 = call i32 %result.i15.i3235({ ptr, ptr, ptr, i32 } %1330, { ptr, ptr, ptr, i32 } %1330, ptr nonnull align 8 %2) #53
  %..i3236 = select i1 %.074289.i3230, ptr %19, ptr %21
  %.188.i3237 = select i1 %.074289.i3230, i64 104, i64 112
  %.189.i3238 = select i1 %.074289.i3230, ptr %20, ptr %22
  %.190.i3239 = select i1 %.074289.i3230, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3236, align 8
  %1337 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3236)
  %1338 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3237
  %1339 = load ptr, ptr %1338, align 8
  store ptr @i32_typ, ptr %.189.i3238, align 8
  %result.i14.i3240 = call ptr %1339({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3238) #46
  %1340 = call i32 %result.i14.i3240({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 dereferenceable(8) %..i3236, i32 %1336) #53
  %1341 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1342 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3239
  %1343 = load ptr, ptr %1342, align 8
  %1344 = load ptr, ptr %1343, align 8
  %1345 = call { ptr } %1344(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i3241 = extractvalue { ptr } %1345, 0
  %1346 = sext i32 %1340 to i64
  %1347 = shl nsw i64 %1346, 5
  %1348 = getelementptr i8, ptr %.fca.0.extract55.i3241, i64 %1347
  %1349 = load ptr, ptr %1348, align 8
  %1350 = getelementptr i8, ptr %1348, i64 8
  %1351 = load i64, ptr %1350, align 4
  %.sroa_idx.i3242 = getelementptr i8, ptr %1348, i64 16
  %1352 = load i64, ptr %.sroa_idx.i3242, align 4
  %1353 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1354 = call { ptr } %1344(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i3243 = extractvalue { ptr } %1354, 0
  %1355 = getelementptr i8, ptr %.fca.0.extract52.i3243, i64 %1347
  store ptr %.sroa.0.0288.i3231, ptr %1355, align 8
  %1356 = getelementptr i8, ptr %1355, i64 8
  store i64 %.sroa.6.0287.i3232.in, ptr %1356, align 4
  %.sroa_idx104.i3244 = getelementptr i8, ptr %1355, i64 16
  store i64 %.sroa.12.0286.i3233.in, ptr %.sroa_idx104.i3244, align 4
  %.sroa_idx105.i3245 = getelementptr i8, ptr %1355, i64 24
  store i32 %.sroa.17.0285.i3234, ptr %.sroa_idx105.i3245, align 4
  %1357 = icmp ne ptr %1349, @nil_typ
  %1358 = icmp ne ptr %1349, null
  %.not94.i3246 = and i1 %1357, %1358
  br i1 %.not94.i3246, label %.cont.i3251, label %1363

.cont.i3251:                                      ; preds = %1326
  %1359 = add nuw nsw i32 %.0290.i3229, 1
  %1360 = xor i1 %.074289.i3230, true
  %hash_coef_ptr.i.i46.i3252 = getelementptr i8, ptr %1349, i64 8
  %tbl_size_ptr.i.i47.i3253 = getelementptr i8, ptr %1349, i64 16
  %offset_tbl_ptr.i.i48.i3254 = getelementptr i8, ptr %1349, i64 40
  %hash_coef.i.i49.i3255 = load i64, ptr %hash_coef_ptr.i.i46.i3252, align 4
  %tbl_size.i.i50.i3256 = load i64, ptr %tbl_size_ptr.i.i47.i3253, align 4
  %offset_tbl.i.i51.i3257 = load ptr, ptr %offset_tbl_ptr.i.i48.i3254, align 8
  %product.i.i.i52.i3258 = mul i64 %hash_coef.i.i49.i3255, 4015701072841558310
  %shifted.i.i.i53.i3259 = lshr i64 %product.i.i.i52.i3258, 32
  %xored.i.i.i54.i3260 = xor i64 %shifted.i.i.i53.i3259, %product.i.i.i52.i3258
  %hash.i.i.i55.i3261 = and i64 %xored.i.i.i54.i3260, %tbl_size.i.i50.i3256
  %offset_ptr.i.i56.i3262 = getelementptr i32, ptr %offset_tbl.i.i51.i3257, i64 %hash.i.i.i55.i3261
  %offset.i.i57.i3263 = load i32, ptr %offset_ptr.i.i56.i3262, align 4
  %1361 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1362 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3264 = icmp eq i32 %1359, 100
  br i1 %exitcond.not.i3264, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273, label %1326

1363:                                             ; preds = %1326
  %1364 = load i32, ptr %99, align 4
  %1365 = add i32 %1364, 1
  %1366 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1365, ptr %99, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273: ; preds = %1363, %.cont.i3251
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  br label %._crit_edge.i2420

._crit_edge.i2420:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2402
  %indvars.iv.next.i2421 = add nuw nsw i64 %indvars.iv.i2418, 1
  %exitcond.not.i2422 = icmp eq i64 %indvars.iv.next.i2421, %wide.trip.count.i2379
  br i1 %exitcond.not.i2422, label %._crit_edge.i425, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2402

._crit_edge.i425:                                 ; preds = %._crit_edge.i2420, %1249, %1246
  %1367 = load ptr, ptr %result.i74, align 8
  %1368 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1369 = load ptr, ptr %88, align 8
  %1370 = load ptr, ptr %1367, align 8
  %1371 = getelementptr i8, ptr %1370, i64 72
  %1372 = load ptr, ptr %1371, align 8
  %result.i1.i.i428 = call { i64, i64 } %1372(ptr nocapture nofree nonnull readonly align 8 %1367) #44
  %1373 = extractvalue { i64, i64 } %result.i1.i.i428, 0
  %1374 = extractvalue { i64, i64 } %result.i1.i.i428, 1
  %1375 = urem i64 20, %1374
  %1376 = icmp eq i64 %1375, 0
  %1377 = sub i64 %1374, %1375
  %1378 = select i1 %1376, i64 0, i64 %1377
  %1379 = add i64 %1373, 20
  %1380 = add i64 %1379, %1378
  %1381 = load ptr, ptr %1369, align 8
  %1382 = getelementptr i8, ptr %1381, i64 72
  %1383 = load ptr, ptr %1382, align 8
  %result.i.i.i429 = call { i64, i64 } %1383(ptr nocapture nofree nonnull readonly align 8 %1369) #44
  %1384 = extractvalue { i64, i64 } %result.i.i.i429, 0
  %1385 = extractvalue { i64, i64 } %result.i.i.i429, 1
  %1386 = call i64 @llvm.umax.i64(i64 %1374, i64 %1385) #41
  %1387 = call i64 @llvm.umax.i64(i64 %1386, i64 noundef 8) #41, !range !16
  %1388 = urem i64 %1380, %1385
  %1389 = icmp eq i64 %1388, 0
  %1390 = sub i64 %1385, %1388
  %1391 = select i1 %1389, i64 0, i64 %1390
  %1392 = add i64 %1384, %1380
  %1393 = add i64 %1392, %1391
  %1394 = urem i64 %1393, %1387
  %1395 = icmp eq i64 %1394, 0
  %1396 = sub i64 %1387, %1394
  %1397 = select i1 %1395, i64 0, i64 %1396
  %1398 = add i64 %1397, %1393
  %result.i22.i430 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1398) #48
  store ptr %1367, ptr %result.i22.i430, align 8
  %1399 = getelementptr inbounds i8, ptr %result.i22.i430, i64 8
  store ptr %1369, ptr %1399, align 8
  %1400 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i430)
  %1401 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1402 = load ptr, ptr %1367, align 8
  %1403 = getelementptr i8, ptr %1402, i64 72
  %1404 = load ptr, ptr %1403, align 8
  %result.i.i127.i431 = call { i64, i64 } %1404(ptr nocapture nofree nonnull readonly align 8 %1367) #44
  %1405 = extractvalue { i64, i64 } %result.i.i127.i431, 1
  %1406 = urem i64 20, %1405
  %1407 = icmp eq i64 %1406, 0
  %reass.sub = sub i64 %1405, %1406
  %1408 = add i64 %reass.sub, 20
  %1409 = select i1 %1407, i64 20, i64 %1408
  %1410 = getelementptr i8, ptr %result.i22.i430, i64 %1409
  %1411 = getelementptr i8, ptr %1402, i64 64
  %1412 = load ptr, ptr %1411, align 8
  call void %1412({ ptr, i160 } %118, ptr nocapture nofree nonnull readonly align 8 %1367, ptr nocapture nofree writeonly %1410) #45
  %1413 = load ptr, ptr %result.i22.i430, align 8
  %1414 = load ptr, ptr %1413, align 8
  %1415 = getelementptr i8, ptr %1414, i64 72
  %1416 = load ptr, ptr %1415, align 8
  %result.i1.i128.i433 = call { i64, i64 } %1416(ptr nocapture nofree nonnull readonly align 8 %1413) #44
  %1417 = extractvalue { i64, i64 } %result.i1.i128.i433, 0
  %1418 = extractvalue { i64, i64 } %result.i1.i128.i433, 1
  %1419 = urem i64 20, %1418
  %1420 = icmp eq i64 %1419, 0
  %1421 = sub i64 %1418, %1419
  %1422 = select i1 %1420, i64 0, i64 %1421
  %1423 = add i64 %1417, 20
  %1424 = add i64 %1423, %1422
  %1425 = load ptr, ptr %1399, align 8
  %1426 = load ptr, ptr %1425, align 8
  %1427 = getelementptr i8, ptr %1426, i64 72
  %1428 = load ptr, ptr %1427, align 8
  %result.i.i129.i434 = call { i64, i64 } %1428(ptr nocapture nofree nonnull readonly align 8 %1425) #44
  %1429 = extractvalue { i64, i64 } %result.i.i129.i434, 1
  %1430 = urem i64 %1424, %1429
  %1431 = icmp eq i64 %1430, 0
  %1432 = sub i64 %1429, %1430
  %1433 = select i1 %1431, i64 0, i64 %1432
  %1434 = getelementptr i8, ptr %result.i22.i430, i64 %1424
  %1435 = getelementptr i8, ptr %1434, i64 %1433
  %1436 = getelementptr i8, ptr %1426, i64 64
  %1437 = load ptr, ptr %1436, align 8
  call void %1437({ ptr, i160 } %1004, ptr nocapture nofree nonnull readonly align 8 %1425, ptr nocapture nofree writeonly %1435) #45
  %1438 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1439 = getelementptr inbounds i8, ptr %result.i22.i430, i64 16
  store i32 %1006, ptr %1439, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  %1440 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1441 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1442 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1443

1443:                                             ; preds = %.cont.i1424, %._crit_edge.i425
  %.0290.i1402 = phi i32 [ 0, %._crit_edge.i425 ], [ %1478, %.cont.i1424 ]
  %.074289.i1403 = phi i1 [ true, %._crit_edge.i425 ], [ %1479, %.cont.i1424 ]
  %.sroa.0.0288.i1404 = phi ptr [ @Entry, %._crit_edge.i425 ], [ %1466, %.cont.i1424 ]
  %.sroa.6.0287.i1405 = phi ptr [ %result.i22.i430, %._crit_edge.i425 ], [ %1480, %.cont.i1424 ]
  %.sroa.12.0286.i1406 = phi ptr [ undef, %._crit_edge.i425 ], [ %1481, %.cont.i1424 ]
  %.sroa.17.0285.i1407 = phi i32 [ 10, %._crit_edge.i425 ], [ %offset.i.i57.i1436, %.cont.i1424 ]
  %1444 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1404, 0
  %1445 = insertvalue { ptr, ptr, ptr, i32 } %1444, ptr %.sroa.6.0287.i1405, 1
  %1446 = insertvalue { ptr, ptr, ptr, i32 } %1445, ptr %.sroa.12.0286.i1406, 2
  %1447 = insertvalue { ptr, ptr, ptr, i32 } %1446, i32 %.sroa.17.0285.i1407, 3
  %1448 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1404)
  %1449 = sext i32 %.sroa.17.0285.i1407 to i64
  %1450 = getelementptr ptr, ptr %.sroa.0.0288.i1404, i64 %1449
  %1451 = getelementptr i8, ptr %1450, i64 64
  %1452 = load ptr, ptr %1451, align 8
  %result.i15.i1408 = call ptr %1452({ ptr, ptr, ptr, i32 } %1447, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1453 = call i32 %result.i15.i1408({ ptr, ptr, ptr, i32 } %1447, { ptr, ptr, ptr, i32 } %1447, ptr nonnull align 8 %2) #53
  %..i1409 = select i1 %.074289.i1403, ptr %55, ptr %57
  %.188.i1410 = select i1 %.074289.i1403, i64 104, i64 112
  %.189.i1411 = select i1 %.074289.i1403, ptr %56, ptr %58
  %.190.i1412 = select i1 %.074289.i1403, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1409, align 8
  %1454 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1409)
  %1455 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1410
  %1456 = load ptr, ptr %1455, align 8
  store ptr @i32_typ, ptr %.189.i1411, align 8
  %result.i14.i1413 = call ptr %1456({ ptr, ptr, ptr, i32 } %107, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1411) #46
  %1457 = call i32 %result.i14.i1413({ ptr, ptr, ptr, i32 } %107, { ptr, ptr, ptr, i32 } %107, ptr nonnull align 8 dereferenceable(8) %..i1409, i32 %1453) #53
  %1458 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1459 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1412
  %1460 = load ptr, ptr %1459, align 8
  %1461 = load ptr, ptr %1460, align 8
  %1462 = call { ptr } %1461(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i1414 = extractvalue { ptr } %1462, 0
  %1463 = sext i32 %1457 to i64
  %1464 = shl nsw i64 %1463, 5
  %1465 = getelementptr i8, ptr %.fca.0.extract55.i1414, i64 %1464
  %1466 = load ptr, ptr %1465, align 8
  %1467 = getelementptr i8, ptr %1465, i64 8
  %1468 = load i64, ptr %1467, align 4
  %.sroa_idx.i1415 = getelementptr i8, ptr %1465, i64 16
  %1469 = load i64, ptr %.sroa_idx.i1415, align 4
  %1470 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1471 = call { ptr } %1461(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i1416 = extractvalue { ptr } %1471, 0
  %1472 = getelementptr i8, ptr %.fca.0.extract52.i1416, i64 %1464
  store ptr %.sroa.0.0288.i1404, ptr %1472, align 8
  %1473 = getelementptr i8, ptr %1472, i64 8
  %1474 = ptrtoint ptr %.sroa.6.0287.i1405 to i64
  %1475 = ptrtoint ptr %.sroa.12.0286.i1406 to i64
  store i64 %1474, ptr %1473, align 4
  %.sroa_idx104.i1417 = getelementptr i8, ptr %1472, i64 16
  store i64 %1475, ptr %.sroa_idx104.i1417, align 4
  %.sroa_idx105.i1418 = getelementptr i8, ptr %1472, i64 24
  store i32 %.sroa.17.0285.i1407, ptr %.sroa_idx105.i1418, align 4
  %1476 = icmp ne ptr %1466, @nil_typ
  %1477 = icmp ne ptr %1466, null
  %.not94.i1419 = and i1 %1476, %1477
  br i1 %.not94.i1419, label %.cont.i1424, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1446

.cont.i1424:                                      ; preds = %1443
  %1478 = add nuw nsw i32 %.0290.i1402, 1
  %1479 = xor i1 %.074289.i1403, true
  %1480 = inttoptr i64 %1468 to ptr
  %1481 = inttoptr i64 %1469 to ptr
  %hash_coef_ptr.i.i46.i1425 = getelementptr i8, ptr %1466, i64 8
  %tbl_size_ptr.i.i47.i1426 = getelementptr i8, ptr %1466, i64 16
  %offset_tbl_ptr.i.i48.i1427 = getelementptr i8, ptr %1466, i64 40
  %hash_coef.i.i49.i1428 = load i64, ptr %hash_coef_ptr.i.i46.i1425, align 4
  %tbl_size.i.i50.i1429 = load i64, ptr %tbl_size_ptr.i.i47.i1426, align 4
  %offset_tbl.i.i51.i1430 = load ptr, ptr %offset_tbl_ptr.i.i48.i1427, align 8
  %product.i.i.i52.i1431 = mul i64 %hash_coef.i.i49.i1428, 4015701072841558310
  %shifted.i.i.i53.i1432 = lshr i64 %product.i.i.i52.i1431, 32
  %xored.i.i.i54.i1433 = xor i64 %shifted.i.i.i53.i1432, %product.i.i.i52.i1431
  %hash.i.i.i55.i1434 = and i64 %xored.i.i.i54.i1433, %tbl_size.i.i50.i1429
  %offset_ptr.i.i56.i1435 = getelementptr i32, ptr %offset_tbl.i.i51.i1430, i64 %hash.i.i.i55.i1434
  %offset.i.i57.i1436 = load i32, ptr %offset_ptr.i.i56.i1435, align 4
  %1482 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1483 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1437 = icmp eq i32 %1478, 100
  br i1 %exitcond.not.i1437, label %1487, label %1443

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1446: ; preds = %1443
  %1484 = load i32, ptr %99, align 4
  %1485 = add i32 %1484, 1
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1485, ptr %99, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  br label %CuckooMap_insert_keyK_valueV.exit465

1487:                                             ; preds = %.cont.i1424
  %hash_coef_ptr.i.i46.i1425.le = getelementptr i8, ptr %1466, i64 8
  %tbl_size_ptr.i.i47.i1426.le = getelementptr i8, ptr %1466, i64 16
  %offset_tbl_ptr.i.i48.i1427.le = getelementptr i8, ptr %1466, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  %1488 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1489 = load ptr, ptr %96, align 8
  %1490 = load ptr, ptr %97, align 8
  %1491 = load i32, ptr %95, align 8
  %1492 = shl i32 %1491, 1
  %spec.select.i1462 = call i32 @llvm.smax.i32(i32 %1492, i32 noundef 16) #40
  store i32 %spec.select.i1462, ptr %95, align 8
  %1493 = zext nneg i32 %spec.select.i1462 to i64
  %1494 = shl nuw nsw i64 %1493, 5
  %result.i5.i1463 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1494) #48
  store ptr %result.i5.i1463, ptr %96, align 8
  %result.i4.i1464 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1494) #48
  store ptr %result.i4.i1464, ptr %97, align 8
  store i32 0, ptr %99, align 4
  %1495 = icmp sgt i32 %1491, 0
  br i1 %1495, label %.lr.ph.i2442, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516

.lr.ph.i2442:                                     ; preds = %1487
  %wide.trip.count.i2455 = zext nneg i32 %1491 to i64
  br label %1496

1496:                                             ; preds = %._crit_edge.i2458, %.lr.ph.i2442
  %indvars.iv.i2456 = phi i64 [ 0, %.lr.ph.i2442 ], [ %indvars.iv.next.i2459, %._crit_edge.i2458 ]
  %1497 = shl nuw nsw i64 %indvars.iv.i2456, 5
  %1498 = getelementptr i8, ptr %1489, i64 %1497
  %1499 = load ptr, ptr %1498, align 8
  %1500 = icmp ne ptr %1499, @nil_typ
  %1501 = icmp ne ptr %1499, null
  %.not17.i2457 = and i1 %1500, %1501
  br i1 %.not17.i2457, label %1502, label %._crit_edge.i2458

1502:                                             ; preds = %1496
  %1503 = getelementptr i8, ptr %1498, i64 8
  %1504 = load i64, ptr %1503, align 4
  %.sroa_idx.i2461 = getelementptr i8, ptr %1498, i64 16
  %1505 = load i64, ptr %.sroa_idx.i2461, align 4
  %hash_coef_ptr.i.i6.i2462 = getelementptr i8, ptr %1499, i64 8
  %tbl_size_ptr.i.i7.i2463 = getelementptr i8, ptr %1499, i64 16
  %offset_tbl_ptr.i.i8.i2464 = getelementptr i8, ptr %1499, i64 40
  %1506 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  %hash_coef.i.i21.i3291 = load i64, ptr %hash_coef_ptr.i.i6.i2462, align 4, !noalias !296
  %tbl_size.i.i22.i3292 = load i64, ptr %tbl_size_ptr.i.i7.i2463, align 4, !noalias !296
  %offset_tbl.i.i23.i3293 = load ptr, ptr %offset_tbl_ptr.i.i8.i2464, align 8, !noalias !296
  %product.i.i.i24.i3294 = mul i64 %hash_coef.i.i21.i3291, 4015701072841558310
  %shifted.i.i.i25.i3295 = lshr i64 %product.i.i.i24.i3294, 32
  %xored.i.i.i26.i3296 = xor i64 %shifted.i.i.i25.i3295, %product.i.i.i24.i3294
  %hash.i.i.i27.i3297 = and i64 %xored.i.i.i26.i3296, %tbl_size.i.i22.i3292
  %offset_ptr.i.i28.i3298 = getelementptr i32, ptr %offset_tbl.i.i23.i3293, i64 %hash.i.i.i27.i3297
  %offset.i.i29.i3299 = load i32, ptr %offset_ptr.i.i28.i3298, align 4, !noalias !296
  %1507 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1508 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1509 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1510

1510:                                             ; preds = %.cont.i3322, %1502
  %.0290.i3300 = phi i32 [ 0, %1502 ], [ %1543, %.cont.i3322 ]
  %.074289.i3301 = phi i1 [ true, %1502 ], [ %1544, %.cont.i3322 ]
  %.sroa.0.0288.i3302 = phi ptr [ %1499, %1502 ], [ %1533, %.cont.i3322 ]
  %.sroa.6.0287.i3303.in = phi i64 [ %1504, %1502 ], [ %1535, %.cont.i3322 ]
  %.sroa.12.0286.i3304.in = phi i64 [ %1505, %1502 ], [ %1536, %.cont.i3322 ]
  %.sroa.17.0285.i3305 = phi i32 [ %offset.i.i29.i3299, %1502 ], [ %offset.i.i57.i3334, %.cont.i3322 ]
  %.sroa.12.0286.i3304 = inttoptr i64 %.sroa.12.0286.i3304.in to ptr
  %.sroa.6.0287.i3303 = inttoptr i64 %.sroa.6.0287.i3303.in to ptr
  %1511 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3302, 0
  %1512 = insertvalue { ptr, ptr, ptr, i32 } %1511, ptr %.sroa.6.0287.i3303, 1
  %1513 = insertvalue { ptr, ptr, ptr, i32 } %1512, ptr %.sroa.12.0286.i3304, 2
  %1514 = insertvalue { ptr, ptr, ptr, i32 } %1513, i32 %.sroa.17.0285.i3305, 3
  %1515 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3302)
  %1516 = sext i32 %.sroa.17.0285.i3305 to i64
  %1517 = getelementptr ptr, ptr %.sroa.0.0288.i3302, i64 %1516
  %1518 = getelementptr i8, ptr %1517, i64 64
  %1519 = load ptr, ptr %1518, align 8
  %result.i15.i3306 = call ptr %1519({ ptr, ptr, ptr, i32 } %1514, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1520 = call i32 %result.i15.i3306({ ptr, ptr, ptr, i32 } %1514, { ptr, ptr, ptr, i32 } %1514, ptr nonnull align 8 %2) #53
  %..i3307 = select i1 %.074289.i3301, ptr %15, ptr %17
  %.188.i3308 = select i1 %.074289.i3301, i64 104, i64 112
  %.189.i3309 = select i1 %.074289.i3301, ptr %16, ptr %18
  %.190.i3310 = select i1 %.074289.i3301, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3307, align 8
  %1521 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3307)
  %1522 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3308
  %1523 = load ptr, ptr %1522, align 8
  store ptr @i32_typ, ptr %.189.i3309, align 8
  %result.i14.i3311 = call ptr %1523({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3309) #46
  %1524 = call i32 %result.i14.i3311({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 dereferenceable(8) %..i3307, i32 %1520) #53
  %1525 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1526 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3310
  %1527 = load ptr, ptr %1526, align 8
  %1528 = load ptr, ptr %1527, align 8
  %1529 = call { ptr } %1528(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i3312 = extractvalue { ptr } %1529, 0
  %1530 = sext i32 %1524 to i64
  %1531 = shl nsw i64 %1530, 5
  %1532 = getelementptr i8, ptr %.fca.0.extract55.i3312, i64 %1531
  %1533 = load ptr, ptr %1532, align 8
  %1534 = getelementptr i8, ptr %1532, i64 8
  %1535 = load i64, ptr %1534, align 4
  %.sroa_idx.i3313 = getelementptr i8, ptr %1532, i64 16
  %1536 = load i64, ptr %.sroa_idx.i3313, align 4
  %1537 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1538 = call { ptr } %1528(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i3314 = extractvalue { ptr } %1538, 0
  %1539 = getelementptr i8, ptr %.fca.0.extract52.i3314, i64 %1531
  store ptr %.sroa.0.0288.i3302, ptr %1539, align 8
  %1540 = getelementptr i8, ptr %1539, i64 8
  store i64 %.sroa.6.0287.i3303.in, ptr %1540, align 4
  %.sroa_idx104.i3315 = getelementptr i8, ptr %1539, i64 16
  store i64 %.sroa.12.0286.i3304.in, ptr %.sroa_idx104.i3315, align 4
  %.sroa_idx105.i3316 = getelementptr i8, ptr %1539, i64 24
  store i32 %.sroa.17.0285.i3305, ptr %.sroa_idx105.i3316, align 4
  %1541 = icmp ne ptr %1533, @nil_typ
  %1542 = icmp ne ptr %1533, null
  %.not94.i3317 = and i1 %1541, %1542
  br i1 %.not94.i3317, label %.cont.i3322, label %1547

.cont.i3322:                                      ; preds = %1510
  %1543 = add nuw nsw i32 %.0290.i3300, 1
  %1544 = xor i1 %.074289.i3301, true
  %hash_coef_ptr.i.i46.i3323 = getelementptr i8, ptr %1533, i64 8
  %tbl_size_ptr.i.i47.i3324 = getelementptr i8, ptr %1533, i64 16
  %offset_tbl_ptr.i.i48.i3325 = getelementptr i8, ptr %1533, i64 40
  %hash_coef.i.i49.i3326 = load i64, ptr %hash_coef_ptr.i.i46.i3323, align 4
  %tbl_size.i.i50.i3327 = load i64, ptr %tbl_size_ptr.i.i47.i3324, align 4
  %offset_tbl.i.i51.i3328 = load ptr, ptr %offset_tbl_ptr.i.i48.i3325, align 8
  %product.i.i.i52.i3329 = mul i64 %hash_coef.i.i49.i3326, 4015701072841558310
  %shifted.i.i.i53.i3330 = lshr i64 %product.i.i.i52.i3329, 32
  %xored.i.i.i54.i3331 = xor i64 %shifted.i.i.i53.i3330, %product.i.i.i52.i3329
  %hash.i.i.i55.i3332 = and i64 %xored.i.i.i54.i3331, %tbl_size.i.i50.i3327
  %offset_ptr.i.i56.i3333 = getelementptr i32, ptr %offset_tbl.i.i51.i3328, i64 %hash.i.i.i55.i3332
  %offset.i.i57.i3334 = load i32, ptr %offset_ptr.i.i56.i3333, align 4
  %1545 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1546 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3335 = icmp eq i32 %1543, 100
  br i1 %exitcond.not.i3335, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344, label %1510

1547:                                             ; preds = %1510
  %1548 = load i32, ptr %99, align 4
  %1549 = add i32 %1548, 1
  %1550 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1549, ptr %99, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344: ; preds = %1547, %.cont.i3322
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  br label %._crit_edge.i2458

._crit_edge.i2458:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344, %1496
  %indvars.iv.next.i2459 = add nuw nsw i64 %indvars.iv.i2456, 1
  %exitcond.not.i2460 = icmp eq i64 %indvars.iv.next.i2459, %wide.trip.count.i2455
  br i1 %exitcond.not.i2460, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2478, label %1496

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2478: ; preds = %._crit_edge.i2496, %._crit_edge.i2458
  %indvars.iv.i2494 = phi i64 [ %indvars.iv.next.i2497, %._crit_edge.i2496 ], [ 0, %._crit_edge.i2458 ]
  %1551 = shl nuw nsw i64 %indvars.iv.i2494, 5
  %1552 = getelementptr i8, ptr %1490, i64 %1551
  %1553 = load ptr, ptr %1552, align 8
  %1554 = icmp ne ptr %1553, @nil_typ
  %1555 = icmp ne ptr %1553, null
  %.not17.i2495 = and i1 %1554, %1555
  br i1 %.not17.i2495, label %1556, label %._crit_edge.i2496

1556:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2478
  %1557 = getelementptr i8, ptr %1552, i64 8
  %1558 = load i64, ptr %1557, align 4
  %.sroa_idx.i2499 = getelementptr i8, ptr %1552, i64 16
  %1559 = load i64, ptr %.sroa_idx.i2499, align 4
  %hash_coef_ptr.i.i6.i2500 = getelementptr i8, ptr %1553, i64 8
  %tbl_size_ptr.i.i7.i2501 = getelementptr i8, ptr %1553, i64 16
  %offset_tbl_ptr.i.i8.i2502 = getelementptr i8, ptr %1553, i64 40
  %1560 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %hash_coef.i.i21.i3362 = load i64, ptr %hash_coef_ptr.i.i6.i2500, align 4, !noalias !299
  %tbl_size.i.i22.i3363 = load i64, ptr %tbl_size_ptr.i.i7.i2501, align 4, !noalias !299
  %offset_tbl.i.i23.i3364 = load ptr, ptr %offset_tbl_ptr.i.i8.i2502, align 8, !noalias !299
  %product.i.i.i24.i3365 = mul i64 %hash_coef.i.i21.i3362, 4015701072841558310
  %shifted.i.i.i25.i3366 = lshr i64 %product.i.i.i24.i3365, 32
  %xored.i.i.i26.i3367 = xor i64 %shifted.i.i.i25.i3366, %product.i.i.i24.i3365
  %hash.i.i.i27.i3368 = and i64 %xored.i.i.i26.i3367, %tbl_size.i.i22.i3363
  %offset_ptr.i.i28.i3369 = getelementptr i32, ptr %offset_tbl.i.i23.i3364, i64 %hash.i.i.i27.i3368
  %offset.i.i29.i3370 = load i32, ptr %offset_ptr.i.i28.i3369, align 4, !noalias !299
  %1561 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1562 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1563 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1564

1564:                                             ; preds = %.cont.i3393, %1556
  %.0290.i3371 = phi i32 [ 0, %1556 ], [ %1597, %.cont.i3393 ]
  %.074289.i3372 = phi i1 [ true, %1556 ], [ %1598, %.cont.i3393 ]
  %.sroa.0.0288.i3373 = phi ptr [ %1553, %1556 ], [ %1587, %.cont.i3393 ]
  %.sroa.6.0287.i3374.in = phi i64 [ %1558, %1556 ], [ %1589, %.cont.i3393 ]
  %.sroa.12.0286.i3375.in = phi i64 [ %1559, %1556 ], [ %1590, %.cont.i3393 ]
  %.sroa.17.0285.i3376 = phi i32 [ %offset.i.i29.i3370, %1556 ], [ %offset.i.i57.i3405, %.cont.i3393 ]
  %.sroa.12.0286.i3375 = inttoptr i64 %.sroa.12.0286.i3375.in to ptr
  %.sroa.6.0287.i3374 = inttoptr i64 %.sroa.6.0287.i3374.in to ptr
  %1565 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3373, 0
  %1566 = insertvalue { ptr, ptr, ptr, i32 } %1565, ptr %.sroa.6.0287.i3374, 1
  %1567 = insertvalue { ptr, ptr, ptr, i32 } %1566, ptr %.sroa.12.0286.i3375, 2
  %1568 = insertvalue { ptr, ptr, ptr, i32 } %1567, i32 %.sroa.17.0285.i3376, 3
  %1569 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3373)
  %1570 = sext i32 %.sroa.17.0285.i3376 to i64
  %1571 = getelementptr ptr, ptr %.sroa.0.0288.i3373, i64 %1570
  %1572 = getelementptr i8, ptr %1571, i64 64
  %1573 = load ptr, ptr %1572, align 8
  %result.i15.i3377 = call ptr %1573({ ptr, ptr, ptr, i32 } %1568, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1574 = call i32 %result.i15.i3377({ ptr, ptr, ptr, i32 } %1568, { ptr, ptr, ptr, i32 } %1568, ptr nonnull align 8 %2) #53
  %..i3378 = select i1 %.074289.i3372, ptr %11, ptr %13
  %.188.i3379 = select i1 %.074289.i3372, i64 104, i64 112
  %.189.i3380 = select i1 %.074289.i3372, ptr %12, ptr %14
  %.190.i3381 = select i1 %.074289.i3372, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3378, align 8
  %1575 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3378)
  %1576 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3379
  %1577 = load ptr, ptr %1576, align 8
  store ptr @i32_typ, ptr %.189.i3380, align 8
  %result.i14.i3382 = call ptr %1577({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3380) #46
  %1578 = call i32 %result.i14.i3382({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 dereferenceable(8) %..i3378, i32 %1574) #53
  %1579 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1580 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3381
  %1581 = load ptr, ptr %1580, align 8
  %1582 = load ptr, ptr %1581, align 8
  %1583 = call { ptr } %1582(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i3383 = extractvalue { ptr } %1583, 0
  %1584 = sext i32 %1578 to i64
  %1585 = shl nsw i64 %1584, 5
  %1586 = getelementptr i8, ptr %.fca.0.extract55.i3383, i64 %1585
  %1587 = load ptr, ptr %1586, align 8
  %1588 = getelementptr i8, ptr %1586, i64 8
  %1589 = load i64, ptr %1588, align 4
  %.sroa_idx.i3384 = getelementptr i8, ptr %1586, i64 16
  %1590 = load i64, ptr %.sroa_idx.i3384, align 4
  %1591 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1592 = call { ptr } %1582(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i3385 = extractvalue { ptr } %1592, 0
  %1593 = getelementptr i8, ptr %.fca.0.extract52.i3385, i64 %1585
  store ptr %.sroa.0.0288.i3373, ptr %1593, align 8
  %1594 = getelementptr i8, ptr %1593, i64 8
  store i64 %.sroa.6.0287.i3374.in, ptr %1594, align 4
  %.sroa_idx104.i3386 = getelementptr i8, ptr %1593, i64 16
  store i64 %.sroa.12.0286.i3375.in, ptr %.sroa_idx104.i3386, align 4
  %.sroa_idx105.i3387 = getelementptr i8, ptr %1593, i64 24
  store i32 %.sroa.17.0285.i3376, ptr %.sroa_idx105.i3387, align 4
  %1595 = icmp ne ptr %1587, @nil_typ
  %1596 = icmp ne ptr %1587, null
  %.not94.i3388 = and i1 %1595, %1596
  br i1 %.not94.i3388, label %.cont.i3393, label %1601

.cont.i3393:                                      ; preds = %1564
  %1597 = add nuw nsw i32 %.0290.i3371, 1
  %1598 = xor i1 %.074289.i3372, true
  %hash_coef_ptr.i.i46.i3394 = getelementptr i8, ptr %1587, i64 8
  %tbl_size_ptr.i.i47.i3395 = getelementptr i8, ptr %1587, i64 16
  %offset_tbl_ptr.i.i48.i3396 = getelementptr i8, ptr %1587, i64 40
  %hash_coef.i.i49.i3397 = load i64, ptr %hash_coef_ptr.i.i46.i3394, align 4
  %tbl_size.i.i50.i3398 = load i64, ptr %tbl_size_ptr.i.i47.i3395, align 4
  %offset_tbl.i.i51.i3399 = load ptr, ptr %offset_tbl_ptr.i.i48.i3396, align 8
  %product.i.i.i52.i3400 = mul i64 %hash_coef.i.i49.i3397, 4015701072841558310
  %shifted.i.i.i53.i3401 = lshr i64 %product.i.i.i52.i3400, 32
  %xored.i.i.i54.i3402 = xor i64 %shifted.i.i.i53.i3401, %product.i.i.i52.i3400
  %hash.i.i.i55.i3403 = and i64 %xored.i.i.i54.i3402, %tbl_size.i.i50.i3398
  %offset_ptr.i.i56.i3404 = getelementptr i32, ptr %offset_tbl.i.i51.i3399, i64 %hash.i.i.i55.i3403
  %offset.i.i57.i3405 = load i32, ptr %offset_ptr.i.i56.i3404, align 4
  %1599 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1600 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3406 = icmp eq i32 %1597, 100
  br i1 %exitcond.not.i3406, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415, label %1564

1601:                                             ; preds = %1564
  %1602 = load i32, ptr %99, align 4
  %1603 = add i32 %1602, 1
  %1604 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1603, ptr %99, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415: ; preds = %1601, %.cont.i3393
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  br label %._crit_edge.i2496

._crit_edge.i2496:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2478
  %indvars.iv.next.i2497 = add nuw nsw i64 %indvars.iv.i2494, 1
  %exitcond.not.i2498 = icmp eq i64 %indvars.iv.next.i2497, %wide.trip.count.i2455
  br i1 %exitcond.not.i2498, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2478

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516: ; preds = %._crit_edge.i2496, %1487
  %1605 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  %hash_coef.i.i21.i1487 = load i64, ptr %hash_coef_ptr.i.i46.i1425.le, align 4, !noalias !302
  %tbl_size.i.i22.i1488 = load i64, ptr %tbl_size_ptr.i.i47.i1426.le, align 4, !noalias !302
  %offset_tbl.i.i23.i1489 = load ptr, ptr %offset_tbl_ptr.i.i48.i1427.le, align 8, !noalias !302
  %product.i.i.i24.i1490 = mul i64 %hash_coef.i.i21.i1487, 4015701072841558310
  %shifted.i.i.i25.i1491 = lshr i64 %product.i.i.i24.i1490, 32
  %xored.i.i.i26.i1492 = xor i64 %shifted.i.i.i25.i1491, %product.i.i.i24.i1490
  %hash.i.i.i27.i1493 = and i64 %xored.i.i.i26.i1492, %tbl_size.i.i22.i1488
  %offset_ptr.i.i28.i1494 = getelementptr i32, ptr %offset_tbl.i.i23.i1489, i64 %hash.i.i.i27.i1493
  %offset.i.i29.i1495 = load i32, ptr %offset_ptr.i.i28.i1494, align 4, !noalias !302
  %1606 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1607 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1608 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1609

1609:                                             ; preds = %.cont.i1519, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516
  %.0290.i1497 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516 ], [ %1642, %.cont.i1519 ]
  %.074289.i1498 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516 ], [ %1643, %.cont.i1519 ]
  %.sroa.0.0288.i1499 = phi ptr [ %1466, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516 ], [ %1632, %.cont.i1519 ]
  %.sroa.6.0287.i1500.in = phi i64 [ %1468, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516 ], [ %1634, %.cont.i1519 ]
  %.sroa.12.0286.i1501.in = phi i64 [ %1469, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516 ], [ %1635, %.cont.i1519 ]
  %.sroa.17.0285.i1502 = phi i32 [ %offset.i.i29.i1495, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2516 ], [ %offset.i.i57.i1531, %.cont.i1519 ]
  %.sroa.12.0286.i1501 = inttoptr i64 %.sroa.12.0286.i1501.in to ptr
  %.sroa.6.0287.i1500 = inttoptr i64 %.sroa.6.0287.i1500.in to ptr
  %1610 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1499, 0
  %1611 = insertvalue { ptr, ptr, ptr, i32 } %1610, ptr %.sroa.6.0287.i1500, 1
  %1612 = insertvalue { ptr, ptr, ptr, i32 } %1611, ptr %.sroa.12.0286.i1501, 2
  %1613 = insertvalue { ptr, ptr, ptr, i32 } %1612, i32 %.sroa.17.0285.i1502, 3
  %1614 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1499)
  %1615 = sext i32 %.sroa.17.0285.i1502 to i64
  %1616 = getelementptr ptr, ptr %.sroa.0.0288.i1499, i64 %1615
  %1617 = getelementptr i8, ptr %1616, i64 64
  %1618 = load ptr, ptr %1617, align 8
  %result.i15.i1503 = call ptr %1618({ ptr, ptr, ptr, i32 } %1613, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1619 = call i32 %result.i15.i1503({ ptr, ptr, ptr, i32 } %1613, { ptr, ptr, ptr, i32 } %1613, ptr nonnull align 8 %2) #53
  %..i1504 = select i1 %.074289.i1498, ptr %51, ptr %53
  %.188.i1505 = select i1 %.074289.i1498, i64 104, i64 112
  %.189.i1506 = select i1 %.074289.i1498, ptr %52, ptr %54
  %.190.i1507 = select i1 %.074289.i1498, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1504, align 8
  %1620 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1504)
  %1621 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1505
  %1622 = load ptr, ptr %1621, align 8
  store ptr @i32_typ, ptr %.189.i1506, align 8
  %result.i14.i1508 = call ptr %1622({ ptr, ptr, ptr, i32 } %107, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1506) #46
  %1623 = call i32 %result.i14.i1508({ ptr, ptr, ptr, i32 } %107, { ptr, ptr, ptr, i32 } %107, ptr nonnull align 8 dereferenceable(8) %..i1504, i32 %1619) #53
  %1624 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1625 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1507
  %1626 = load ptr, ptr %1625, align 8
  %1627 = load ptr, ptr %1626, align 8
  %1628 = call { ptr } %1627(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i1509 = extractvalue { ptr } %1628, 0
  %1629 = sext i32 %1623 to i64
  %1630 = shl nsw i64 %1629, 5
  %1631 = getelementptr i8, ptr %.fca.0.extract55.i1509, i64 %1630
  %1632 = load ptr, ptr %1631, align 8
  %1633 = getelementptr i8, ptr %1631, i64 8
  %1634 = load i64, ptr %1633, align 4
  %.sroa_idx.i1510 = getelementptr i8, ptr %1631, i64 16
  %1635 = load i64, ptr %.sroa_idx.i1510, align 4
  %1636 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1637 = call { ptr } %1627(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i1511 = extractvalue { ptr } %1637, 0
  %1638 = getelementptr i8, ptr %.fca.0.extract52.i1511, i64 %1630
  store ptr %.sroa.0.0288.i1499, ptr %1638, align 8
  %1639 = getelementptr i8, ptr %1638, i64 8
  store i64 %.sroa.6.0287.i1500.in, ptr %1639, align 4
  %.sroa_idx104.i1512 = getelementptr i8, ptr %1638, i64 16
  store i64 %.sroa.12.0286.i1501.in, ptr %.sroa_idx104.i1512, align 4
  %.sroa_idx105.i1513 = getelementptr i8, ptr %1638, i64 24
  store i32 %.sroa.17.0285.i1502, ptr %.sroa_idx105.i1513, align 4
  %1640 = icmp ne ptr %1632, @nil_typ
  %1641 = icmp ne ptr %1632, null
  %.not94.i1514 = and i1 %1640, %1641
  br i1 %.not94.i1514, label %.cont.i1519, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1541

.cont.i1519:                                      ; preds = %1609
  %1642 = add nuw nsw i32 %.0290.i1497, 1
  %1643 = xor i1 %.074289.i1498, true
  %hash_coef_ptr.i.i46.i1520 = getelementptr i8, ptr %1632, i64 8
  %tbl_size_ptr.i.i47.i1521 = getelementptr i8, ptr %1632, i64 16
  %offset_tbl_ptr.i.i48.i1522 = getelementptr i8, ptr %1632, i64 40
  %hash_coef.i.i49.i1523 = load i64, ptr %hash_coef_ptr.i.i46.i1520, align 4
  %tbl_size.i.i50.i1524 = load i64, ptr %tbl_size_ptr.i.i47.i1521, align 4
  %offset_tbl.i.i51.i1525 = load ptr, ptr %offset_tbl_ptr.i.i48.i1522, align 8
  %product.i.i.i52.i1526 = mul i64 %hash_coef.i.i49.i1523, 4015701072841558310
  %shifted.i.i.i53.i1527 = lshr i64 %product.i.i.i52.i1526, 32
  %xored.i.i.i54.i1528 = xor i64 %shifted.i.i.i53.i1527, %product.i.i.i52.i1526
  %hash.i.i.i55.i1529 = and i64 %xored.i.i.i54.i1528, %tbl_size.i.i50.i1524
  %offset_ptr.i.i56.i1530 = getelementptr i32, ptr %offset_tbl.i.i51.i1525, i64 %hash.i.i.i55.i1529
  %offset.i.i57.i1531 = load i32, ptr %offset_ptr.i.i56.i1530, align 4
  %1644 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1645 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1532 = icmp eq i32 %1642, 100
  br i1 %exitcond.not.i1532, label %1649, label %1609

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1541: ; preds = %1609
  %1646 = load i32, ptr %99, align 4
  %1647 = add i32 %1646, 1
  %1648 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1647, ptr %99, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  br label %CuckooMap_insert_keyK_valueV.exit465

1649:                                             ; preds = %.cont.i1519
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  %1650 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1651 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1652 = load ptr, ptr %96, align 8
  %1653 = load ptr, ptr %97, align 8
  %1654 = load i32, ptr %95, align 8
  %1655 = shl i32 %1654, 1
  %spec.select.i1557 = call i32 @llvm.smax.i32(i32 %1655, i32 noundef 16) #40
  store i32 %spec.select.i1557, ptr %95, align 8
  %1656 = zext nneg i32 %spec.select.i1557 to i64
  %1657 = shl nuw nsw i64 %1656, 5
  %result.i5.i1558 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1657) #48
  store ptr %result.i5.i1558, ptr %96, align 8
  %result.i4.i1559 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1657) #48
  store ptr %result.i4.i1559, ptr %97, align 8
  store i32 0, ptr %99, align 4
  %1658 = icmp sgt i32 %1654, 0
  br i1 %1658, label %.lr.ph.i2518, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2554.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2554.thread: ; preds = %1649
  %1659 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit465

.lr.ph.i2518:                                     ; preds = %1649
  %wide.trip.count.i2531 = zext nneg i32 %1654 to i64
  br label %1660

1660:                                             ; preds = %._crit_edge.i2534, %.lr.ph.i2518
  %indvars.iv.i2532 = phi i64 [ 0, %.lr.ph.i2518 ], [ %indvars.iv.next.i2535, %._crit_edge.i2534 ]
  %1661 = shl nuw nsw i64 %indvars.iv.i2532, 5
  %1662 = getelementptr i8, ptr %1652, i64 %1661
  %1663 = load ptr, ptr %1662, align 8
  %1664 = icmp ne ptr %1663, @nil_typ
  %1665 = icmp ne ptr %1663, null
  %.not17.i2533 = and i1 %1664, %1665
  br i1 %.not17.i2533, label %1666, label %._crit_edge.i2534

1666:                                             ; preds = %1660
  %1667 = getelementptr i8, ptr %1662, i64 8
  %1668 = load i64, ptr %1667, align 4
  %.sroa_idx.i2537 = getelementptr i8, ptr %1662, i64 16
  %1669 = load i64, ptr %.sroa_idx.i2537, align 4
  %hash_coef_ptr.i.i6.i2538 = getelementptr i8, ptr %1663, i64 8
  %tbl_size_ptr.i.i7.i2539 = getelementptr i8, ptr %1663, i64 16
  %offset_tbl_ptr.i.i8.i2540 = getelementptr i8, ptr %1663, i64 40
  %1670 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  %hash_coef.i.i21.i3433 = load i64, ptr %hash_coef_ptr.i.i6.i2538, align 4, !noalias !305
  %tbl_size.i.i22.i3434 = load i64, ptr %tbl_size_ptr.i.i7.i2539, align 4, !noalias !305
  %offset_tbl.i.i23.i3435 = load ptr, ptr %offset_tbl_ptr.i.i8.i2540, align 8, !noalias !305
  %product.i.i.i24.i3436 = mul i64 %hash_coef.i.i21.i3433, 4015701072841558310
  %shifted.i.i.i25.i3437 = lshr i64 %product.i.i.i24.i3436, 32
  %xored.i.i.i26.i3438 = xor i64 %shifted.i.i.i25.i3437, %product.i.i.i24.i3436
  %hash.i.i.i27.i3439 = and i64 %xored.i.i.i26.i3438, %tbl_size.i.i22.i3434
  %offset_ptr.i.i28.i3440 = getelementptr i32, ptr %offset_tbl.i.i23.i3435, i64 %hash.i.i.i27.i3439
  %offset.i.i29.i3441 = load i32, ptr %offset_ptr.i.i28.i3440, align 4, !noalias !305
  %1671 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1674

1674:                                             ; preds = %.cont.i3464, %1666
  %.0290.i3442 = phi i32 [ 0, %1666 ], [ %1707, %.cont.i3464 ]
  %.074289.i3443 = phi i1 [ true, %1666 ], [ %1708, %.cont.i3464 ]
  %.sroa.0.0288.i3444 = phi ptr [ %1663, %1666 ], [ %1697, %.cont.i3464 ]
  %.sroa.6.0287.i3445.in = phi i64 [ %1668, %1666 ], [ %1699, %.cont.i3464 ]
  %.sroa.12.0286.i3446.in = phi i64 [ %1669, %1666 ], [ %1700, %.cont.i3464 ]
  %.sroa.17.0285.i3447 = phi i32 [ %offset.i.i29.i3441, %1666 ], [ %offset.i.i57.i3476, %.cont.i3464 ]
  %.sroa.12.0286.i3446 = inttoptr i64 %.sroa.12.0286.i3446.in to ptr
  %.sroa.6.0287.i3445 = inttoptr i64 %.sroa.6.0287.i3445.in to ptr
  %1675 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3444, 0
  %1676 = insertvalue { ptr, ptr, ptr, i32 } %1675, ptr %.sroa.6.0287.i3445, 1
  %1677 = insertvalue { ptr, ptr, ptr, i32 } %1676, ptr %.sroa.12.0286.i3446, 2
  %1678 = insertvalue { ptr, ptr, ptr, i32 } %1677, i32 %.sroa.17.0285.i3447, 3
  %1679 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3444)
  %1680 = sext i32 %.sroa.17.0285.i3447 to i64
  %1681 = getelementptr ptr, ptr %.sroa.0.0288.i3444, i64 %1680
  %1682 = getelementptr i8, ptr %1681, i64 64
  %1683 = load ptr, ptr %1682, align 8
  %result.i15.i3448 = call ptr %1683({ ptr, ptr, ptr, i32 } %1678, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1684 = call i32 %result.i15.i3448({ ptr, ptr, ptr, i32 } %1678, { ptr, ptr, ptr, i32 } %1678, ptr nonnull align 8 %2) #53
  %..i3449 = select i1 %.074289.i3443, ptr %7, ptr %9
  %.188.i3450 = select i1 %.074289.i3443, i64 104, i64 112
  %.189.i3451 = select i1 %.074289.i3443, ptr %8, ptr %10
  %.190.i3452 = select i1 %.074289.i3443, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3449, align 8
  %1685 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3449)
  %1686 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3450
  %1687 = load ptr, ptr %1686, align 8
  store ptr @i32_typ, ptr %.189.i3451, align 8
  %result.i14.i3453 = call ptr %1687({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3451) #46
  %1688 = call i32 %result.i14.i3453({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 dereferenceable(8) %..i3449, i32 %1684) #53
  %1689 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1690 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3452
  %1691 = load ptr, ptr %1690, align 8
  %1692 = load ptr, ptr %1691, align 8
  %1693 = call { ptr } %1692(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i3454 = extractvalue { ptr } %1693, 0
  %1694 = sext i32 %1688 to i64
  %1695 = shl nsw i64 %1694, 5
  %1696 = getelementptr i8, ptr %.fca.0.extract55.i3454, i64 %1695
  %1697 = load ptr, ptr %1696, align 8
  %1698 = getelementptr i8, ptr %1696, i64 8
  %1699 = load i64, ptr %1698, align 4
  %.sroa_idx.i3455 = getelementptr i8, ptr %1696, i64 16
  %1700 = load i64, ptr %.sroa_idx.i3455, align 4
  %1701 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1702 = call { ptr } %1692(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i3456 = extractvalue { ptr } %1702, 0
  %1703 = getelementptr i8, ptr %.fca.0.extract52.i3456, i64 %1695
  store ptr %.sroa.0.0288.i3444, ptr %1703, align 8
  %1704 = getelementptr i8, ptr %1703, i64 8
  store i64 %.sroa.6.0287.i3445.in, ptr %1704, align 4
  %.sroa_idx104.i3457 = getelementptr i8, ptr %1703, i64 16
  store i64 %.sroa.12.0286.i3446.in, ptr %.sroa_idx104.i3457, align 4
  %.sroa_idx105.i3458 = getelementptr i8, ptr %1703, i64 24
  store i32 %.sroa.17.0285.i3447, ptr %.sroa_idx105.i3458, align 4
  %1705 = icmp ne ptr %1697, @nil_typ
  %1706 = icmp ne ptr %1697, null
  %.not94.i3459 = and i1 %1705, %1706
  br i1 %.not94.i3459, label %.cont.i3464, label %1711

.cont.i3464:                                      ; preds = %1674
  %1707 = add nuw nsw i32 %.0290.i3442, 1
  %1708 = xor i1 %.074289.i3443, true
  %hash_coef_ptr.i.i46.i3465 = getelementptr i8, ptr %1697, i64 8
  %tbl_size_ptr.i.i47.i3466 = getelementptr i8, ptr %1697, i64 16
  %offset_tbl_ptr.i.i48.i3467 = getelementptr i8, ptr %1697, i64 40
  %hash_coef.i.i49.i3468 = load i64, ptr %hash_coef_ptr.i.i46.i3465, align 4
  %tbl_size.i.i50.i3469 = load i64, ptr %tbl_size_ptr.i.i47.i3466, align 4
  %offset_tbl.i.i51.i3470 = load ptr, ptr %offset_tbl_ptr.i.i48.i3467, align 8
  %product.i.i.i52.i3471 = mul i64 %hash_coef.i.i49.i3468, 4015701072841558310
  %shifted.i.i.i53.i3472 = lshr i64 %product.i.i.i52.i3471, 32
  %xored.i.i.i54.i3473 = xor i64 %shifted.i.i.i53.i3472, %product.i.i.i52.i3471
  %hash.i.i.i55.i3474 = and i64 %xored.i.i.i54.i3473, %tbl_size.i.i50.i3469
  %offset_ptr.i.i56.i3475 = getelementptr i32, ptr %offset_tbl.i.i51.i3470, i64 %hash.i.i.i55.i3474
  %offset.i.i57.i3476 = load i32, ptr %offset_ptr.i.i56.i3475, align 4
  %1709 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1710 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3477 = icmp eq i32 %1707, 100
  br i1 %exitcond.not.i3477, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486, label %1674

1711:                                             ; preds = %1674
  %1712 = load i32, ptr %99, align 4
  %1713 = add i32 %1712, 1
  %1714 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1713, ptr %99, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486: ; preds = %1711, %.cont.i3464
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  br label %._crit_edge.i2534

._crit_edge.i2534:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486, %1660
  %indvars.iv.next.i2535 = add nuw nsw i64 %indvars.iv.i2532, 1
  %exitcond.not.i2536 = icmp eq i64 %indvars.iv.next.i2535, %wide.trip.count.i2531
  br i1 %exitcond.not.i2536, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2554, label %1660

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2554: ; preds = %._crit_edge.i2534
  %1715 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %1716

1716:                                             ; preds = %._crit_edge.i2572, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2554
  %indvars.iv.i2570 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2554 ], [ %indvars.iv.next.i2573, %._crit_edge.i2572 ]
  %1717 = shl nuw nsw i64 %indvars.iv.i2570, 5
  %1718 = getelementptr i8, ptr %1653, i64 %1717
  %1719 = load ptr, ptr %1718, align 8
  %1720 = icmp ne ptr %1719, @nil_typ
  %1721 = icmp ne ptr %1719, null
  %.not17.i2571 = and i1 %1720, %1721
  br i1 %.not17.i2571, label %1722, label %._crit_edge.i2572

1722:                                             ; preds = %1716
  %1723 = getelementptr i8, ptr %1718, i64 8
  %1724 = load i64, ptr %1723, align 4
  %.sroa_idx.i2575 = getelementptr i8, ptr %1718, i64 16
  %1725 = load i64, ptr %.sroa_idx.i2575, align 4
  %hash_coef_ptr.i.i6.i2576 = getelementptr i8, ptr %1719, i64 8
  %tbl_size_ptr.i.i7.i2577 = getelementptr i8, ptr %1719, i64 16
  %offset_tbl_ptr.i.i8.i2578 = getelementptr i8, ptr %1719, i64 40
  %1726 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %hash_coef.i.i21.i3504 = load i64, ptr %hash_coef_ptr.i.i6.i2576, align 4, !noalias !308
  %tbl_size.i.i22.i3505 = load i64, ptr %tbl_size_ptr.i.i7.i2577, align 4, !noalias !308
  %offset_tbl.i.i23.i3506 = load ptr, ptr %offset_tbl_ptr.i.i8.i2578, align 8, !noalias !308
  %product.i.i.i24.i3507 = mul i64 %hash_coef.i.i21.i3504, 4015701072841558310
  %shifted.i.i.i25.i3508 = lshr i64 %product.i.i.i24.i3507, 32
  %xored.i.i.i26.i3509 = xor i64 %shifted.i.i.i25.i3508, %product.i.i.i24.i3507
  %hash.i.i.i27.i3510 = and i64 %xored.i.i.i26.i3509, %tbl_size.i.i22.i3505
  %offset_ptr.i.i28.i3511 = getelementptr i32, ptr %offset_tbl.i.i23.i3506, i64 %hash.i.i.i27.i3510
  %offset.i.i29.i3512 = load i32, ptr %offset_ptr.i.i28.i3511, align 4, !noalias !308
  %1727 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1728 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1729 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1730

1730:                                             ; preds = %.cont.i3535, %1722
  %.0290.i3513 = phi i32 [ 0, %1722 ], [ %1763, %.cont.i3535 ]
  %.074289.i3514 = phi i1 [ true, %1722 ], [ %1764, %.cont.i3535 ]
  %.sroa.0.0288.i3515 = phi ptr [ %1719, %1722 ], [ %1753, %.cont.i3535 ]
  %.sroa.6.0287.i3516.in = phi i64 [ %1724, %1722 ], [ %1755, %.cont.i3535 ]
  %.sroa.12.0286.i3517.in = phi i64 [ %1725, %1722 ], [ %1756, %.cont.i3535 ]
  %.sroa.17.0285.i3518 = phi i32 [ %offset.i.i29.i3512, %1722 ], [ %offset.i.i57.i3547, %.cont.i3535 ]
  %.sroa.12.0286.i3517 = inttoptr i64 %.sroa.12.0286.i3517.in to ptr
  %.sroa.6.0287.i3516 = inttoptr i64 %.sroa.6.0287.i3516.in to ptr
  %1731 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3515, 0
  %1732 = insertvalue { ptr, ptr, ptr, i32 } %1731, ptr %.sroa.6.0287.i3516, 1
  %1733 = insertvalue { ptr, ptr, ptr, i32 } %1732, ptr %.sroa.12.0286.i3517, 2
  %1734 = insertvalue { ptr, ptr, ptr, i32 } %1733, i32 %.sroa.17.0285.i3518, 3
  %1735 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3515)
  %1736 = sext i32 %.sroa.17.0285.i3518 to i64
  %1737 = getelementptr ptr, ptr %.sroa.0.0288.i3515, i64 %1736
  %1738 = getelementptr i8, ptr %1737, i64 64
  %1739 = load ptr, ptr %1738, align 8
  %result.i15.i3519 = call ptr %1739({ ptr, ptr, ptr, i32 } %1734, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1740 = call i32 %result.i15.i3519({ ptr, ptr, ptr, i32 } %1734, { ptr, ptr, ptr, i32 } %1734, ptr nonnull align 8 %2) #53
  %..i3520 = select i1 %.074289.i3514, ptr %3, ptr %5
  %.188.i3521 = select i1 %.074289.i3514, i64 104, i64 112
  %.189.i3522 = select i1 %.074289.i3514, ptr %4, ptr %6
  %.190.i3523 = select i1 %.074289.i3514, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3520, align 8
  %1741 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3520)
  %1742 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3521
  %1743 = load ptr, ptr %1742, align 8
  store ptr @i32_typ, ptr %.189.i3522, align 8
  %result.i14.i3524 = call ptr %1743({ ptr, ptr, ptr, i32 } %112, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3522) #46
  %1744 = call i32 %result.i14.i3524({ ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %112, ptr nonnull align 8 dereferenceable(8) %..i3520, i32 %1740) #53
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1746 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3523
  %1747 = load ptr, ptr %1746, align 8
  %1748 = load ptr, ptr %1747, align 8
  %1749 = call { ptr } %1748(ptr nonnull %result.i74) #43
  %.fca.0.extract55.i3525 = extractvalue { ptr } %1749, 0
  %1750 = sext i32 %1744 to i64
  %1751 = shl nsw i64 %1750, 5
  %1752 = getelementptr i8, ptr %.fca.0.extract55.i3525, i64 %1751
  %1753 = load ptr, ptr %1752, align 8
  %1754 = getelementptr i8, ptr %1752, i64 8
  %1755 = load i64, ptr %1754, align 4
  %.sroa_idx.i3526 = getelementptr i8, ptr %1752, i64 16
  %1756 = load i64, ptr %.sroa_idx.i3526, align 4
  %1757 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1758 = call { ptr } %1748(ptr nonnull %result.i74) #43
  %.fca.0.extract52.i3527 = extractvalue { ptr } %1758, 0
  %1759 = getelementptr i8, ptr %.fca.0.extract52.i3527, i64 %1751
  store ptr %.sroa.0.0288.i3515, ptr %1759, align 8
  %1760 = getelementptr i8, ptr %1759, i64 8
  store i64 %.sroa.6.0287.i3516.in, ptr %1760, align 4
  %.sroa_idx104.i3528 = getelementptr i8, ptr %1759, i64 16
  store i64 %.sroa.12.0286.i3517.in, ptr %.sroa_idx104.i3528, align 4
  %.sroa_idx105.i3529 = getelementptr i8, ptr %1759, i64 24
  store i32 %.sroa.17.0285.i3518, ptr %.sroa_idx105.i3529, align 4
  %1761 = icmp ne ptr %1753, @nil_typ
  %1762 = icmp ne ptr %1753, null
  %.not94.i3530 = and i1 %1761, %1762
  br i1 %.not94.i3530, label %.cont.i3535, label %1767

.cont.i3535:                                      ; preds = %1730
  %1763 = add nuw nsw i32 %.0290.i3513, 1
  %1764 = xor i1 %.074289.i3514, true
  %hash_coef_ptr.i.i46.i3536 = getelementptr i8, ptr %1753, i64 8
  %tbl_size_ptr.i.i47.i3537 = getelementptr i8, ptr %1753, i64 16
  %offset_tbl_ptr.i.i48.i3538 = getelementptr i8, ptr %1753, i64 40
  %hash_coef.i.i49.i3539 = load i64, ptr %hash_coef_ptr.i.i46.i3536, align 4
  %tbl_size.i.i50.i3540 = load i64, ptr %tbl_size_ptr.i.i47.i3537, align 4
  %offset_tbl.i.i51.i3541 = load ptr, ptr %offset_tbl_ptr.i.i48.i3538, align 8
  %product.i.i.i52.i3542 = mul i64 %hash_coef.i.i49.i3539, 4015701072841558310
  %shifted.i.i.i53.i3543 = lshr i64 %product.i.i.i52.i3542, 32
  %xored.i.i.i54.i3544 = xor i64 %shifted.i.i.i53.i3543, %product.i.i.i52.i3542
  %hash.i.i.i55.i3545 = and i64 %xored.i.i.i54.i3544, %tbl_size.i.i50.i3540
  %offset_ptr.i.i56.i3546 = getelementptr i32, ptr %offset_tbl.i.i51.i3541, i64 %hash.i.i.i55.i3545
  %offset.i.i57.i3547 = load i32, ptr %offset_ptr.i.i56.i3546, align 4
  %1765 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1766 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3548 = icmp eq i32 %1763, 100
  br i1 %exitcond.not.i3548, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557, label %1730

1767:                                             ; preds = %1730
  %1768 = load i32, ptr %99, align 4
  %1769 = add i32 %1768, 1
  %1770 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1769, ptr %99, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557: ; preds = %1767, %.cont.i3535
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  br label %._crit_edge.i2572

._crit_edge.i2572:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557, %1716
  %indvars.iv.next.i2573 = add nuw nsw i64 %indvars.iv.i2570, 1
  %exitcond.not.i2574 = icmp eq i64 %indvars.iv.next.i2573, %wide.trip.count.i2531
  br i1 %exitcond.not.i2574, label %CuckooMap_insert_keyK_valueV.exit465, label %1716

CuckooMap_insert_keyK_valueV.exit465:             ; preds = %._crit_edge.i2572, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2554.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1541, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1446, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1351, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1292
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1771 = add nsw i32 %.0378266, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit465, %CuckooMap_get_keyK.exit
  %.1379 = phi i32 [ %1771, %CuckooMap_insert_keyK_valueV.exit465 ], [ %.0378266, %CuckooMap_get_keyK.exit ]
  %1772 = add nuw nsw i32 %.0375267, 1
  %1773 = icmp slt i32 %.1379, %0
  %1774 = icmp slt i32 %1772, %100
  %spec.select = select i1 %1773, i1 %1774, i1 false
  br i1 %spec.select, label %114, label %._crit_edge3._crit_edge.loopexit

._crit_edge3._crit_edge.loopexit:                 ; preds = %._crit_edge1
  %.phi.trans.insert = getelementptr inbounds i8, ptr %67, i64 8
  %.promoted269.pre = load ptr, ptr %.phi.trans.insert, align 8
  br label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge3._crit_edge.loopexit, %1
  %.promoted269 = phi ptr [ undef, %1 ], [ %.promoted269.pre, %._crit_edge3._crit_edge.loopexit ]
  %1775 = sext i32 %0 to i64
  %1776 = shl nsw i64 %1775, 2
  %result.i2.i482 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1776) #48
  %1777 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #40
  %1778 = mul i32 %0, 20
  %1779 = getelementptr inbounds i8, ptr %67, i64 8
  %1780 = icmp sgt i32 %1778, 0
  %spec.select401272 = and i1 %101, %1780
  br i1 %spec.select401272, label %.lr.ph276, label %._crit_edge7._crit_edge

.lr.ph276:                                        ; preds = %._crit_edge3._crit_edge
  %1781 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1782 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1783 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  br label %1784

1784:                                             ; preds = %._crit_edge5, %.lr.ph276
  %1785 = phi i32 [ 987, %.lr.ph276 ], [ %1788, %._crit_edge5 ]
  %.0374275 = phi i32 [ 0, %.lr.ph276 ], [ %.1, %._crit_edge5 ]
  %.2377274 = phi i32 [ 0, %.lr.ph276 ], [ %1911, %._crit_edge5 ]
  %_parameterization_i32271273 = phi ptr [ %.promoted269, %.lr.ph276 ], [ %_parameterization_i32270, %._crit_edge5 ]
  %1786 = mul i32 %1785, 1103515245
  %1787 = add i32 %1786, 12345
  %1788 = and i32 %1787, 2147483647
  %.sroa.0302.0.insert.ext = zext nneg i32 %1788 to i160
  %1789 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0302.0.insert.ext, 1
  %1790 = load ptr, ptr %93, align 8
  %1791 = call i32 %1790({ ptr, i160 } %1789) #53
  %1792 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1793 = load i32, ptr %95, align 8
  %1794 = add i32 %1793, -1
  %1795 = and i32 %1794, %1791
  %1796 = load ptr, ptr %96, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1797 = sext i32 %1795 to i64
  %1798 = shl nsw i64 %1797, 5
  %1799 = getelementptr i8, ptr %1796, i64 %1798
  %1800 = load ptr, ptr %1799, align 8
  %1801 = icmp ne ptr %1800, @nil_typ
  %1802 = icmp ne ptr %1800, null
  %.not45.i1605 = and i1 %1801, %1802
  br i1 %.not45.i1605, label %1803, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630.thread

1803:                                             ; preds = %1784
  %1804 = getelementptr i8, ptr %1799, i64 8
  %1805 = load i64, ptr %1804, align 4
  %.sroa_idx.i1610 = getelementptr i8, ptr %1799, i64 16
  %1806 = load i64, ptr %.sroa_idx.i1610, align 4
  %1807 = inttoptr i64 %1805 to ptr
  %1808 = inttoptr i64 %1806 to ptr
  %hash_coef_ptr.i.i4.i1611 = getelementptr i8, ptr %1800, i64 8
  %tbl_size_ptr.i.i5.i1612 = getelementptr i8, ptr %1800, i64 16
  %offset_tbl_ptr.i.i6.i1613 = getelementptr i8, ptr %1800, i64 40
  %hash_coef.i.i7.i1614 = load i64, ptr %hash_coef_ptr.i.i4.i1611, align 4, !noalias !311
  %tbl_size.i.i8.i1615 = load i64, ptr %tbl_size_ptr.i.i5.i1612, align 4, !noalias !311
  %offset_tbl.i.i9.i1616 = load ptr, ptr %offset_tbl_ptr.i.i6.i1613, align 8, !noalias !311
  %product.i.i.i10.i1617 = mul i64 %hash_coef.i.i7.i1614, 4015701072841558310
  %shifted.i.i.i11.i1618 = lshr i64 %product.i.i.i10.i1617, 32
  %xored.i.i.i12.i1619 = xor i64 %shifted.i.i.i11.i1618, %product.i.i.i10.i1617
  %hash.i.i.i13.i1620 = and i64 %xored.i.i.i12.i1619, %tbl_size.i.i8.i1615
  %offset_ptr.i.i14.i1621 = getelementptr i32, ptr %offset_tbl.i.i9.i1616, i64 %hash.i.i.i13.i1620
  %offset.i.i15.i1622 = load i32, ptr %offset_ptr.i.i14.i1621, align 4, !noalias !311
  %1809 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1800, 0
  %1810 = insertvalue { ptr, ptr, ptr, i32 } %1809, ptr %1807, 1
  %1811 = insertvalue { ptr, ptr, ptr, i32 } %1810, ptr %1808, 2
  %1812 = insertvalue { ptr, ptr, ptr, i32 } %1811, i32 %offset.i.i15.i1622, 3
  %1813 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1814 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1800) #40
  %1815 = sext i32 %offset.i.i15.i1622 to i64
  %1816 = getelementptr ptr, ptr %1800, i64 %1815
  %1817 = getelementptr i8, ptr %1816, i64 64
  %1818 = load ptr, ptr %1817, align 8
  %result.i2.i1623 = call ptr %1818({ ptr, ptr, ptr, i32 } %1812, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1819 = call i32 %result.i2.i1623({ ptr, ptr, ptr, i32 } %1812, { ptr, ptr, ptr, i32 } %1812, ptr nonnull align 8 %2) #53
  %1820 = icmp eq i32 %1819, %1791
  br i1 %1820, label %._crit_edge.i1624, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630.thread

._crit_edge.i1624:                                ; preds = %1803
  %1821 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1822 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1800)
  %1823 = getelementptr i8, ptr %1816, i64 48
  %1824 = load ptr, ptr %1823, align 8
  %result.i1.i1625 = call ptr %1824({ ptr, ptr, ptr, i32 } %1812, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1825 = call { ptr, i160 } %result.i1.i1625({ ptr, ptr, ptr, i32 } %1812, { ptr, ptr, ptr, i32 } %1812, ptr nonnull align 8 %2) #53
  %1826 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1827 = load ptr, ptr %94, align 8
  %1828 = call i1 %1827({ ptr, i160 } %1825, { ptr, i160 } %1789) #53
  br i1 %1828, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630.thread: ; preds = %._crit_edge.i1624, %1803, %1784
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1837

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630: ; preds = %._crit_edge.i1624
  %1829 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1830 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1800)
  %1831 = getelementptr i8, ptr %1816, i64 56
  %1832 = load ptr, ptr %1831, align 8
  %result.i.i1627 = call ptr %1832({ ptr, ptr, ptr, i32 } %1812, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1833 = call { ptr, i160 } %result.i.i1627({ ptr, ptr, ptr, i32 } %1812, { ptr, ptr, ptr, i32 } %1812, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1628 = extractvalue { ptr, i160 } %1833, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1834 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1835 = icmp ne ptr %.fca.0.extract22.i1628, @nil_typ
  %1836 = icmp ne ptr %.fca.0.extract22.i1628, null
  %.not63.i518 = and i1 %1835, %1836
  br i1 %.not63.i518, label %CuckooMap_get_keyK.exit532, label %1837

1837:                                             ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630.thread
  %1838 = add i32 %1791, 2127912214
  %1839 = shl i32 %1791, 12
  %1840 = add i32 %1838, %1839
  %1841 = ashr i32 %1840, 19
  %1842 = xor i32 %1840, %1841
  %1843 = xor i32 %1842, -949894596
  %1844 = add i32 %1843, 374761393
  %1845 = shl i32 %1843, 5
  %1846 = add i32 %1844, %1845
  %1847 = add i32 %1846, -744332180
  %1848 = shl i32 %1846, 9
  %1849 = xor i32 %1847, %1848
  %1850 = add i32 %1849, -42973499
  %1851 = shl i32 %1849, 3
  %1852 = add i32 %1850, %1851
  %1853 = ashr i32 %1852, 16
  %1854 = xor i32 %1852, %1853
  %1855 = xor i32 %1854, -1252372727
  %1856 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1857 = load i32, ptr %95, align 8
  %1858 = add i32 %1857, -1
  %1859 = and i32 %1858, %1855
  %1860 = load ptr, ptr %97, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1861 = sext i32 %1859 to i64
  %1862 = shl nsw i64 %1861, 5
  %1863 = getelementptr i8, ptr %1860, i64 %1862
  %1864 = load ptr, ptr %1863, align 8
  %1865 = icmp ne ptr %1864, @nil_typ
  %1866 = icmp ne ptr %1864, null
  %.not45.i1660 = and i1 %1865, %1866
  br i1 %.not45.i1660, label %1867, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1685

1867:                                             ; preds = %1837
  %1868 = getelementptr i8, ptr %1863, i64 8
  %1869 = load i64, ptr %1868, align 4
  %.sroa_idx.i1665 = getelementptr i8, ptr %1863, i64 16
  %1870 = load i64, ptr %.sroa_idx.i1665, align 4
  %1871 = inttoptr i64 %1869 to ptr
  %1872 = inttoptr i64 %1870 to ptr
  %hash_coef_ptr.i.i4.i1666 = getelementptr i8, ptr %1864, i64 8
  %tbl_size_ptr.i.i5.i1667 = getelementptr i8, ptr %1864, i64 16
  %offset_tbl_ptr.i.i6.i1668 = getelementptr i8, ptr %1864, i64 40
  %hash_coef.i.i7.i1669 = load i64, ptr %hash_coef_ptr.i.i4.i1666, align 4, !noalias !314
  %tbl_size.i.i8.i1670 = load i64, ptr %tbl_size_ptr.i.i5.i1667, align 4, !noalias !314
  %offset_tbl.i.i9.i1671 = load ptr, ptr %offset_tbl_ptr.i.i6.i1668, align 8, !noalias !314
  %product.i.i.i10.i1672 = mul i64 %hash_coef.i.i7.i1669, 4015701072841558310
  %shifted.i.i.i11.i1673 = lshr i64 %product.i.i.i10.i1672, 32
  %xored.i.i.i12.i1674 = xor i64 %shifted.i.i.i11.i1673, %product.i.i.i10.i1672
  %hash.i.i.i13.i1675 = and i64 %xored.i.i.i12.i1674, %tbl_size.i.i8.i1670
  %offset_ptr.i.i14.i1676 = getelementptr i32, ptr %offset_tbl.i.i9.i1671, i64 %hash.i.i.i13.i1675
  %offset.i.i15.i1677 = load i32, ptr %offset_ptr.i.i14.i1676, align 4, !noalias !314
  %1873 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1864, 0
  %1874 = insertvalue { ptr, ptr, ptr, i32 } %1873, ptr %1871, 1
  %1875 = insertvalue { ptr, ptr, ptr, i32 } %1874, ptr %1872, 2
  %1876 = insertvalue { ptr, ptr, ptr, i32 } %1875, i32 %offset.i.i15.i1677, 3
  %1877 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1878 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1864) #40
  %1879 = sext i32 %offset.i.i15.i1677 to i64
  %1880 = getelementptr ptr, ptr %1864, i64 %1879
  %1881 = getelementptr i8, ptr %1880, i64 64
  %1882 = load ptr, ptr %1881, align 8
  %result.i2.i1678 = call ptr %1882({ ptr, ptr, ptr, i32 } %1876, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1883 = call i32 %result.i2.i1678({ ptr, ptr, ptr, i32 } %1876, { ptr, ptr, ptr, i32 } %1876, ptr nonnull align 8 %2) #53
  %1884 = icmp eq i32 %1883, %1791
  br i1 %1884, label %._crit_edge.i1679, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1685

._crit_edge.i1679:                                ; preds = %1867
  %1885 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1886 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1864)
  %1887 = getelementptr i8, ptr %1880, i64 48
  %1888 = load ptr, ptr %1887, align 8
  %result.i1.i1680 = call ptr %1888({ ptr, ptr, ptr, i32 } %1876, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1889 = call { ptr, i160 } %result.i1.i1680({ ptr, ptr, ptr, i32 } %1876, { ptr, ptr, ptr, i32 } %1876, ptr nonnull align 8 %2) #53
  %1890 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1891 = load ptr, ptr %94, align 8
  %1892 = call i1 %1891({ ptr, i160 } %1889, { ptr, i160 } %1789) #53
  br i1 %1892, label %1893, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1685

1893:                                             ; preds = %._crit_edge.i1679
  %1894 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1895 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1864)
  %1896 = getelementptr i8, ptr %1880, i64 56
  %1897 = load ptr, ptr %1896, align 8
  %result.i.i1682 = call ptr %1897({ ptr, ptr, ptr, i32 } %1876, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1898 = call { ptr, i160 } %result.i.i1682({ ptr, ptr, ptr, i32 } %1876, { ptr, ptr, ptr, i32 } %1876, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1683 = extractvalue { ptr, i160 } %1898, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1685

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1685: ; preds = %1893, %._crit_edge.i1679, %1867, %1837
  %.reg2mem41.0.i1662 = phi ptr [ %.fca.0.extract22.i1683, %1893 ], [ @nil_typ, %._crit_edge.i1679 ], [ @nil_typ, %1837 ], [ @nil_typ, %1867 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1899 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i525 = icmp eq ptr %.reg2mem41.0.i1662, null
  %1900 = select i1 %.not.i525, ptr @nil_typ, ptr %.reg2mem41.0.i1662
  br label %CuckooMap_get_keyK.exit532

CuckooMap_get_keyK.exit532:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1685, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630
  %.reg2mem56.0.i526 = phi ptr [ %1900, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1685 ], [ %.fca.0.extract22.i1628, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1630 ]
  %1901 = icmp eq ptr %.reg2mem56.0.i526, @nil_typ
  %1902 = icmp eq ptr %.reg2mem56.0.i526, null
  %1903 = or i1 %1901, %1902
  br i1 %1903, label %1904, label %._crit_edge5

1904:                                             ; preds = %CuckooMap_get_keyK.exit532
  store ptr @_parameterization_i32, ptr %67, align 8
  %1905 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %67)
  %1906 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %1907 = sext i32 %.0374275 to i64
  %1908 = shl nsw i64 %1907, 2
  %1909 = getelementptr i8, ptr %result.i2.i482, i64 %1908
  store i32 %1788, ptr %1909, align 1
  %1910 = add nsw i32 %.0374275, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %1904, %CuckooMap_get_keyK.exit532
  %_parameterization_i32270 = phi ptr [ @_parameterization_i32, %1904 ], [ %_parameterization_i32271273, %CuckooMap_get_keyK.exit532 ]
  %.1 = phi i32 [ %1910, %1904 ], [ %.0374275, %CuckooMap_get_keyK.exit532 ]
  %1911 = add nuw nsw i32 %.2377274, 1
  %1912 = icmp slt i32 %.1, %0
  %1913 = icmp slt i32 %1911, %1778
  %spec.select401 = select i1 %1912, i1 %1913, i1 false
  br i1 %spec.select401, label %1784, label %._crit_edge7._crit_edge

._crit_edge7._crit_edge:                          ; preds = %._crit_edge5, %._crit_edge3._crit_edge
  %_parameterization_i32271.lcssa = phi ptr [ %.promoted269, %._crit_edge3._crit_edge ], [ %_parameterization_i32270, %._crit_edge5 ]
  %.0374.lcssa = phi i32 [ 0, %._crit_edge3._crit_edge ], [ %.1, %._crit_edge5 ]
  store ptr %_parameterization_i32271.lcssa, ptr %1779, align 8
  %1914 = icmp slt i32 %.0374.lcssa, %0
  br i1 %1914, label %._crit_edge.lr.ph.i, label %._crit_edge8

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge7._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1915 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1916 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i.i1939.h2s3842, align 1
  %1917 = getelementptr inbounds i8, ptr %result.i.i1939.h2s3842, i64 29
  store i8 0, ptr %1917, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i.i1939.h2s3842) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1918 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0374.lcssa) #55
  %1919 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1920 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1921 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <22 x i8> <i8 32, i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %result.i.i1954.h2s3840, align 1
  %1922 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1923 = getelementptr inbounds i8, ptr %result.i.i1954.h2s3840, i64 22
  store i8 0, ptr %1923, align 1
  %puts.i743 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(23) %result.i.i1954.h2s3840) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge.lr.ph.i, %._crit_edge7._crit_edge
  %.0397 = phi i32 [ %.0374.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge7._crit_edge ]
  %1924 = call i64 @clock()
  %1925 = icmp sgt i32 %.0397, 0
  br i1 %1925, label %._crit_edge9.preheader, label %2052

._crit_edge9.preheader:                           ; preds = %._crit_edge8
  %1926 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %1927 = zext nneg i32 %.0397 to i64
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %CuckooMap_get_keyK.exit621, %._crit_edge9.preheader
  %indvars.iv = phi i64 [ 0, %._crit_edge9.preheader ], [ %indvars.iv.next, %CuckooMap_get_keyK.exit621 ]
  %.0382281 = phi i32 [ 0, %._crit_edge9.preheader ], [ %.2384, %CuckooMap_get_keyK.exit621 ]
  %.0385280 = phi i32 [ 0, %._crit_edge9.preheader ], [ %.2387, %CuckooMap_get_keyK.exit621 ]
  %1928 = shl i64 %indvars.iv, 2
  %1929 = getelementptr i8, ptr %result.i2.i482, i64 %1928
  %1930 = load i32, ptr %1929, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %1930 to i160
  %1931 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %1932 = load ptr, ptr %81, align 8
  %1933 = call i32 %1932({ ptr, i160 } %1931) #53
  %1934 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1935 = load i32, ptr %83, align 8
  %1936 = add i32 %1935, -1
  %1937 = and i32 %1936, %1933
  %1938 = load ptr, ptr %84, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1939 = sext i32 %1937 to i64
  %1940 = shl nsw i64 %1939, 5
  %1941 = getelementptr i8, ptr %1938, i64 %1940
  %1942 = load ptr, ptr %1941, align 8
  %1943 = icmp ne ptr %1942, @nil_typ
  %1944 = icmp ne ptr %1942, null
  %.not45.i1727 = and i1 %1943, %1944
  br i1 %.not45.i1727, label %1945, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751.thread

1945:                                             ; preds = %._crit_edge9
  %1946 = getelementptr i8, ptr %1941, i64 8
  %1947 = load i64, ptr %1946, align 4
  %.sroa_idx.i1732 = getelementptr i8, ptr %1941, i64 16
  %1948 = load i64, ptr %.sroa_idx.i1732, align 4
  %1949 = inttoptr i64 %1947 to ptr
  %1950 = inttoptr i64 %1948 to ptr
  %hash_coef_ptr.i.i4.i1733 = getelementptr i8, ptr %1942, i64 8
  %tbl_size_ptr.i.i5.i1734 = getelementptr i8, ptr %1942, i64 16
  %offset_tbl_ptr.i.i6.i1735 = getelementptr i8, ptr %1942, i64 40
  %hash_coef.i.i7.i1736 = load i64, ptr %hash_coef_ptr.i.i4.i1733, align 4, !noalias !317
  %tbl_size.i.i8.i1737 = load i64, ptr %tbl_size_ptr.i.i5.i1734, align 4, !noalias !317
  %offset_tbl.i.i9.i1738 = load ptr, ptr %offset_tbl_ptr.i.i6.i1735, align 8, !noalias !317
  %product.i.i.i10.i1739 = mul i64 %hash_coef.i.i7.i1736, 4015701072841558310
  %shifted.i.i.i11.i1740 = lshr i64 %product.i.i.i10.i1739, 32
  %xored.i.i.i12.i1741 = xor i64 %shifted.i.i.i11.i1740, %product.i.i.i10.i1739
  %hash.i.i.i13.i1742 = and i64 %xored.i.i.i12.i1741, %tbl_size.i.i8.i1737
  %offset_ptr.i.i14.i1743 = getelementptr i32, ptr %offset_tbl.i.i9.i1738, i64 %hash.i.i.i13.i1742
  %offset.i.i15.i1744 = load i32, ptr %offset_ptr.i.i14.i1743, align 4, !noalias !317
  %1951 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1942, 0
  %1952 = insertvalue { ptr, ptr, ptr, i32 } %1951, ptr %1949, 1
  %1953 = insertvalue { ptr, ptr, ptr, i32 } %1952, ptr %1950, 2
  %1954 = insertvalue { ptr, ptr, ptr, i32 } %1953, i32 %offset.i.i15.i1744, 3
  %1955 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1956 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1942) #40
  %1957 = sext i32 %offset.i.i15.i1744 to i64
  %1958 = getelementptr ptr, ptr %1942, i64 %1957
  %1959 = getelementptr i8, ptr %1958, i64 64
  %1960 = load ptr, ptr %1959, align 8
  %result.i2.i = call ptr %1960({ ptr, ptr, ptr, i32 } %1954, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1961 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %1954, { ptr, ptr, ptr, i32 } %1954, ptr nonnull align 8 %2) #53
  %1962 = icmp eq i32 %1961, %1933
  br i1 %1962, label %._crit_edge.i1745, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751.thread

._crit_edge.i1745:                                ; preds = %1945
  %1963 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1964 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1942)
  %1965 = getelementptr i8, ptr %1958, i64 48
  %1966 = load ptr, ptr %1965, align 8
  %result.i1.i1746 = call ptr %1966({ ptr, ptr, ptr, i32 } %1954, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1967 = call { ptr, i160 } %result.i1.i1746({ ptr, ptr, ptr, i32 } %1954, { ptr, ptr, ptr, i32 } %1954, ptr nonnull align 8 %2) #53
  %1968 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1969 = load ptr, ptr %82, align 8
  %1970 = call i1 %1969({ ptr, i160 } %1967, { ptr, i160 } %1931) #53
  br i1 %1970, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751.thread: ; preds = %._crit_edge.i1745, %1945, %._crit_edge9
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1979

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751: ; preds = %._crit_edge.i1745
  %1971 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1972 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1942)
  %1973 = getelementptr i8, ptr %1958, i64 56
  %1974 = load ptr, ptr %1973, align 8
  %result.i.i1748 = call ptr %1974({ ptr, ptr, ptr, i32 } %1954, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1975 = call { ptr, i160 } %result.i.i1748({ ptr, ptr, ptr, i32 } %1954, { ptr, ptr, ptr, i32 } %1954, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1749 = extractvalue { ptr, i160 } %1975, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1976 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1977 = icmp ne ptr %.fca.0.extract22.i1749, @nil_typ
  %1978 = icmp ne ptr %.fca.0.extract22.i1749, null
  %.not63.i609 = and i1 %1977, %1978
  br i1 %.not63.i609, label %CuckooMap_get_keyK.exit621, label %1979

1979:                                             ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751.thread
  %1980 = add i32 %1933, 2127912214
  %1981 = shl i32 %1933, 12
  %1982 = add i32 %1980, %1981
  %1983 = ashr i32 %1982, 19
  %1984 = xor i32 %1982, %1983
  %1985 = xor i32 %1984, -949894596
  %1986 = add i32 %1985, 374761393
  %1987 = shl i32 %1985, 5
  %1988 = add i32 %1986, %1987
  %1989 = add i32 %1988, -744332180
  %1990 = shl i32 %1988, 9
  %1991 = xor i32 %1989, %1990
  %1992 = add i32 %1991, -42973499
  %1993 = shl i32 %1991, 3
  %1994 = add i32 %1992, %1993
  %1995 = ashr i32 %1994, 16
  %1996 = xor i32 %1994, %1995
  %1997 = xor i32 %1996, -1252372727
  %1998 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1999 = load i32, ptr %83, align 8
  %2000 = add i32 %1999, -1
  %2001 = and i32 %2000, %1997
  %2002 = load ptr, ptr %85, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2003 = sext i32 %2001 to i64
  %2004 = shl nsw i64 %2003, 5
  %2005 = getelementptr i8, ptr %2002, i64 %2004
  %2006 = load ptr, ptr %2005, align 8
  %2007 = icmp ne ptr %2006, @nil_typ
  %2008 = icmp ne ptr %2006, null
  %.not45.i1781 = and i1 %2007, %2008
  br i1 %.not45.i1781, label %2009, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1806

2009:                                             ; preds = %1979
  %2010 = getelementptr i8, ptr %2005, i64 8
  %2011 = load i64, ptr %2010, align 4
  %.sroa_idx.i1786 = getelementptr i8, ptr %2005, i64 16
  %2012 = load i64, ptr %.sroa_idx.i1786, align 4
  %2013 = inttoptr i64 %2011 to ptr
  %2014 = inttoptr i64 %2012 to ptr
  %hash_coef_ptr.i.i4.i1787 = getelementptr i8, ptr %2006, i64 8
  %tbl_size_ptr.i.i5.i1788 = getelementptr i8, ptr %2006, i64 16
  %offset_tbl_ptr.i.i6.i1789 = getelementptr i8, ptr %2006, i64 40
  %hash_coef.i.i7.i1790 = load i64, ptr %hash_coef_ptr.i.i4.i1787, align 4, !noalias !320
  %tbl_size.i.i8.i1791 = load i64, ptr %tbl_size_ptr.i.i5.i1788, align 4, !noalias !320
  %offset_tbl.i.i9.i1792 = load ptr, ptr %offset_tbl_ptr.i.i6.i1789, align 8, !noalias !320
  %product.i.i.i10.i1793 = mul i64 %hash_coef.i.i7.i1790, 4015701072841558310
  %shifted.i.i.i11.i1794 = lshr i64 %product.i.i.i10.i1793, 32
  %xored.i.i.i12.i1795 = xor i64 %shifted.i.i.i11.i1794, %product.i.i.i10.i1793
  %hash.i.i.i13.i1796 = and i64 %xored.i.i.i12.i1795, %tbl_size.i.i8.i1791
  %offset_ptr.i.i14.i1797 = getelementptr i32, ptr %offset_tbl.i.i9.i1792, i64 %hash.i.i.i13.i1796
  %offset.i.i15.i1798 = load i32, ptr %offset_ptr.i.i14.i1797, align 4, !noalias !320
  %2015 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2006, 0
  %2016 = insertvalue { ptr, ptr, ptr, i32 } %2015, ptr %2013, 1
  %2017 = insertvalue { ptr, ptr, ptr, i32 } %2016, ptr %2014, 2
  %2018 = insertvalue { ptr, ptr, ptr, i32 } %2017, i32 %offset.i.i15.i1798, 3
  %2019 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2020 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %2006) #40
  %2021 = sext i32 %offset.i.i15.i1798 to i64
  %2022 = getelementptr ptr, ptr %2006, i64 %2021
  %2023 = getelementptr i8, ptr %2022, i64 64
  %2024 = load ptr, ptr %2023, align 8
  %result.i2.i1799 = call ptr %2024({ ptr, ptr, ptr, i32 } %2018, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2025 = call i32 %result.i2.i1799({ ptr, ptr, ptr, i32 } %2018, { ptr, ptr, ptr, i32 } %2018, ptr nonnull align 8 %2) #53
  %2026 = icmp eq i32 %2025, %1933
  br i1 %2026, label %._crit_edge.i1800, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1806

._crit_edge.i1800:                                ; preds = %2009
  %2027 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2028 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %2006)
  %2029 = getelementptr i8, ptr %2022, i64 48
  %2030 = load ptr, ptr %2029, align 8
  %result.i1.i1801 = call ptr %2030({ ptr, ptr, ptr, i32 } %2018, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2031 = call { ptr, i160 } %result.i1.i1801({ ptr, ptr, ptr, i32 } %2018, { ptr, ptr, ptr, i32 } %2018, ptr nonnull align 8 %2) #53
  %2032 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %2033 = load ptr, ptr %82, align 8
  %2034 = call i1 %2033({ ptr, i160 } %2031, { ptr, i160 } %1931) #53
  br i1 %2034, label %2035, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1806

2035:                                             ; preds = %._crit_edge.i1800
  %2036 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2037 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %2006)
  %2038 = getelementptr i8, ptr %2022, i64 56
  %2039 = load ptr, ptr %2038, align 8
  %result.i.i1803 = call ptr %2039({ ptr, ptr, ptr, i32 } %2018, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2040 = call { ptr, i160 } %result.i.i1803({ ptr, ptr, ptr, i32 } %2018, { ptr, ptr, ptr, i32 } %2018, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1804 = extractvalue { ptr, i160 } %2040, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1806

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1806: ; preds = %2035, %._crit_edge.i1800, %2009, %1979
  %.reg2mem41.0.i1783 = phi ptr [ %.fca.0.extract22.i1804, %2035 ], [ @nil_typ, %._crit_edge.i1800 ], [ @nil_typ, %1979 ], [ @nil_typ, %2009 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2041 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i614 = icmp eq ptr %.reg2mem41.0.i1783, null
  %2042 = select i1 %.not.i614, ptr @nil_typ, ptr %.reg2mem41.0.i1783
  br label %CuckooMap_get_keyK.exit621

CuckooMap_get_keyK.exit621:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1806, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751
  %.reg2mem56.0.i615 = phi ptr [ %2042, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1806 ], [ %.fca.0.extract22.i1749, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1751 ]
  %2043 = icmp eq ptr %.reg2mem56.0.i615, @nil_typ
  %2044 = icmp eq ptr %.reg2mem56.0.i615, null
  %2045 = or i1 %2043, %2044
  %.0382..0385 = select i1 %2045, i32 %.0382281, i32 %.0385280
  %2046 = add i32 %.0382..0385, 1
  %.2387 = select i1 %2045, i32 %.0385280, i32 %2046
  %.2384 = select i1 %2045, i32 %2046, i32 %.0382281
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %1927
  br i1 %exitcond.not, label %2047, label %._crit_edge9

2047:                                             ; preds = %CuckooMap_get_keyK.exit621
  %2048 = call i64 @clock()
  %2049 = mul i32 %.2387, 100
  %2050 = sdiv i32 %2049, %.0397
  %2051 = icmp slt i32 %2050, 5
  br label %._crit_edge.lr.ph.i1975

2052:                                             ; preds = %._crit_edge8
  %2053 = call i64 @clock()
  br label %._crit_edge.lr.ph.i1975

._crit_edge.lr.ph.i1975:                          ; preds = %2052, %2047
  %2054 = phi i64 [ %2048, %2047 ], [ %2053, %2052 ]
  %.0382.lcssa295 = phi i32 [ %.2384, %2047 ], [ 0, %2052 ]
  %.0385.lcssa294 = phi i32 [ %.2387, %2047 ], [ 0, %2052 ]
  %.reg2mem27.0.in = phi i1 [ %2051, %2047 ], [ true, %2052 ]
  %2055 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2056 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2057 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %result.i.i1974.h2s3838, align 16
  %2058 = sub i64 %2054, %1924
  %2059 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %2060 = getelementptr inbounds i8, ptr %result.i.i1974.h2s3838, i64 15
  store i8 0, ptr %2060, align 1
  %puts.i763 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i1974.h2s3838) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i.i.i.h2s3836, align 16
  %2061 = getelementptr inbounds i8, ptr %result.i.i.i.h2s3836, i64 14
  store i8 0, ptr %2061, align 2
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.h2s3836) #53
  %2062 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0397) #55
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i.i304.i.h2s3834, align 16
  %2063 = getelementptr inbounds i8, ptr %result.i.i304.i.h2s3834, i64 14
  store i8 0, ptr %2063, align 2
  %puts.i229.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.h2s3834) #53
  %2064 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2058) #55
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i.i324.i.h2s3832, align 4
  %2065 = getelementptr inbounds i8, ptr %result.i.i324.i.h2s3832, i64 3
  store i8 0, ptr %2065, align 1
  %puts.i249.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.h2s3832) #53
  br i1 %1925, label %._crit_edge.lr.ph.i345.i, label %._crit_edge.lr.ph.i1995

._crit_edge.lr.ph.i345.i:                         ; preds = %._crit_edge.lr.ph.i1975
  %2066 = zext nneg i32 %.0397 to i64
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i.i344.i.h2s3830, align 16
  %2067 = mul i64 %2058, 1000000
  %2068 = sdiv i64 %2067, %2066
  %2069 = getelementptr inbounds i8, ptr %result.i.i344.i.h2s3830, i64 15
  store i8 0, ptr %2069, align 1
  %puts.i269.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.h2s3830) #53
  %2070 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2068) #55
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i.i364.i.h2s3828, align 4
  %2071 = getelementptr inbounds i8, ptr %result.i.i364.i.h2s3828, i64 3
  store i8 0, ptr %2071, align 1
  %puts.i289.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.h2s3828) #53
  br label %._crit_edge.lr.ph.i1995

._crit_edge.lr.ph.i1995:                          ; preds = %._crit_edge.lr.ph.i345.i, %._crit_edge.lr.ph.i1975
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2072 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2073 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i.i1994.h2s3826, align 1
  %2074 = getelementptr inbounds i8, ptr %result.i.i1994.h2s3826, i64 18
  store i8 0, ptr %2074, align 1
  %puts.i783 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i1994.h2s3826) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %. = select i1 %.reg2mem27.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.436 = select i1 %.reg2mem27.0.in, ptr %68, ptr %72
  %.437 = select i1 %.reg2mem27.0.in, ptr %69, ptr %73
  %.438 = select i1 %.reg2mem27.0.in, ptr %70, ptr %74
  %.439 = select i1 %.reg2mem27.0.in, ptr %71, ptr %75
  store ptr @_parameterization_Bufferi8, ptr %.436, align 8
  %.436.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem27.0.in, ptr %68, ptr %72
  %.436.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.436.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.436.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.436.sroa.sel448.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem27.0.in, ptr %68, ptr %72
  %.436.sroa.sel448.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.436.sroa.sel448.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.436.sroa.sel448.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %2075 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.436)
  store ptr @buffer_typ, ptr %.437, align 8
  %.437.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem27.0.in, ptr %69, ptr %73
  %.437.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.437.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.437.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.437.sroa.sel443.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem27.0.in, ptr %69, ptr %73
  %.437.sroa.sel443.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.437.sroa.sel443.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.437.sroa.sel443.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %2076 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.437) #40
  store ptr @_parameterization_String, ptr %.438, align 8
  %2077 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.438)
  store ptr @String, ptr %.439, align 8
  %2078 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.439) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2079 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2080 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <4 x i8> %., ptr %result.i.i2014.h2s3825, align 4
  %2081 = getelementptr inbounds i8, ptr %result.i.i2014.h2s3825, i64 4
  store i8 0, ptr %2081, align 4
  %puts.i803 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i2014.h2s3825) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2082 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2083 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <13 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %result.i.i2034.h2s3823, align 16
  %2084 = getelementptr inbounds i8, ptr %result.i.i2034.h2s3823, i64 13
  store i8 0, ptr %2084, align 1
  %puts.i823 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(14) %result.i.i2034.h2s3823) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2085 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0382.lcssa295) #55
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2086 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2087 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store i64 2322295501682647084, ptr %result.i.i2054.h2s3822, align 8
  %2088 = getelementptr inbounds i8, ptr %result.i.i2054.h2s3822, i64 8
  store i8 0, ptr %2088, align 8
  %puts.i843 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(9) %result.i.i2054.h2s3822) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2089 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0385.lcssa294) #55
  %2090 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2091 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2092 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store i8 41, ptr %result.i.i2074.h2s3821, align 2
  %2093 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %2094 = getelementptr inbounds i8, ptr %result.i.i2074.h2s3821, i64 1
  store i8 0, ptr %2094, align 1
  %puts.i863 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i.i2074.h2s3821) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr #18 {
  %2 = alloca {}, align 8
  %result.i.i2167.h2s3868 = alloca [2 x i8], align 2
  store i16 0, ptr %result.i.i2167.h2s3868, align 2
  %result.i.i2147.h2s3869 = alloca [21 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(21) %result.i.i2147.h2s3869, i8 0, i64 21, i1 false)
  %result.i.i2127.h2s3871 = alloca [5 x i8], align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(5) %result.i.i2127.h2s3871, i8 0, i64 5, i1 false)
  %result.i.i2107.h2s3872 = alloca [19 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(19) %result.i.i2107.h2s3872, i8 0, i64 19, i1 false)
  %result.i.i364.i.h2s3874 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i364.i.h2s3874, align 4
  %result.i.i344.i.h2s3876 = alloca [16 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %result.i.i344.i.h2s3876, i8 0, i64 16, i1 false)
  %result.i.i324.i.h2s3878 = alloca [4 x i8], align 4
  store i32 0, ptr %result.i.i324.i.h2s3878, align 4
  %result.i.i304.i.h2s3880 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i304.i.h2s3880, i8 0, i64 15, i1 false)
  %result.i.i.i.h2s3882 = alloca [15 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(15) %result.i.i.i.h2s3882, i8 0, i64 15, i1 false)
  %result.i.i2087.h2s3884 = alloca [14 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(14) %result.i.i2087.h2s3884, i8 0, i64 14, i1 false)
  %result.i.i2027.h2s3886 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i.i2027.h2s3886, i8 0, i64 30, i1 false)
  %result.i.i2012.h2s3888 = alloca [30 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(30) %result.i.i2012.h2s3888, i8 0, i64 30, i1 false)
  %result.i79.h2s3890 = alloca [24 x i8], align 8
  %3 = getelementptr inbounds i8, ptr %result.i79.h2s3890, i64 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %3, i8 0, i64 16, i1 false)
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca { ptr }, align 8
  %20 = alloca [1 x ptr], align 8
  %21 = alloca { ptr }, align 8
  %22 = alloca [1 x ptr], align 8
  %23 = alloca { ptr }, align 8
  %24 = alloca [1 x ptr], align 8
  %25 = alloca { ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca { ptr }, align 8
  %28 = alloca [1 x ptr], align 8
  %29 = alloca { ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca { ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca { ptr }, align 8
  %36 = alloca [1 x ptr], align 8
  %37 = alloca { ptr }, align 8
  %38 = alloca [1 x ptr], align 8
  %39 = alloca { ptr }, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca { ptr }, align 8
  %42 = alloca [1 x ptr], align 8
  %43 = alloca { ptr }, align 8
  %44 = alloca [1 x ptr], align 8
  %45 = alloca { ptr }, align 8
  %46 = alloca [1 x ptr], align 8
  %47 = alloca { ptr }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca [1 x ptr], align 8
  %53 = alloca { ptr }, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca [1 x ptr], align 8
  %59 = alloca { ptr }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [1 x ptr], align 8
  %63 = alloca { ptr }, align 8
  %64 = alloca [1 x ptr], align 8
  %65 = alloca { ptr }, align 8
  %66 = alloca [1 x ptr], align 8
  %67 = alloca { ptr }, align 8
  %oldProtect.i89 = alloca i32, align 4
  %oldProtect.i87 = alloca i32, align 4
  %oldProtect.i85 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %68 = alloca [2 x ptr], align 8
  %69 = alloca [2 x ptr], align 8
  %.sroa.0335.sroa.0 = alloca i8, align 8
  %70 = alloca [2 x ptr], align 8
  %71 = alloca [3 x ptr], align 8
  %72 = alloca [3 x ptr], align 8
  %73 = alloca [3 x ptr], align 8
  %74 = alloca { ptr, ptr, ptr }, align 8
  %75 = alloca [1 x ptr], align 8
  %76 = alloca { ptr }, align 8
  %77 = alloca [3 x ptr], align 8
  %78 = alloca { ptr, ptr, ptr }, align 8
  %79 = alloca [1 x ptr], align 8
  %80 = alloca { ptr }, align 8
  %result.i83 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i83, align 8
  %81 = getelementptr inbounds i8, ptr %result.i83, i64 8
  store ptr @_parameterization_i32, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i83, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i83) #40
  %result.i82 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  %result.i84 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i82, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i82, ptr noalias nofree noundef nonnull readnone @nivqqmixpq, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i57 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i82) #47
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i82) #40
  %result.i81 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i85) #40
  %result.i86 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i81, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i85) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i85) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i81, ptr noalias nofree noundef nonnull readnone @ytebrvjgff, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i56 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i81) #47
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i81) #40
  %86 = getelementptr inbounds i8, ptr %result.i83, i64 48
  store ptr %ret.i57, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i83, i64 56
  store ptr %ret.i56, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i83, i64 40
  store i32 8, ptr %88, align 8
  %result.i1.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %89 = getelementptr inbounds i8, ptr %result.i83, i64 24
  store ptr %result.i1.i, ptr %89, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %90 = getelementptr inbounds i8, ptr %result.i83, i64 32
  store ptr %result.i.i, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i83, i64 44
  store i32 0, ptr %91, align 4
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  store ptr @_parameterization_i32, ptr %result.i79.h2s3890, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i79.h2s3890) #40
  %94 = getelementptr inbounds i8, ptr %result.i79.h2s3890, i64 20
  store i32 %0, ptr %94, align 4
  %95 = sext i32 %0 to i64
  %96 = shl nsw i64 %95, 2
  %result.i2.i371 = call noalias ptr @bump_malloc_wrapper(i64 noundef %96) #48
  %97 = getelementptr inbounds i8, ptr %result.i79.h2s3890, i64 8
  store ptr %result.i2.i371, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #40
  %99 = getelementptr inbounds i8, ptr %result.i79.h2s3890, i64 16
  store i32 0, ptr %99, align 8
  %result.i78 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i78, align 8
  %100 = getelementptr inbounds i8, ptr %result.i78, i64 8
  store ptr @_parameterization_Bool, ptr %100, align 8
  %101 = getelementptr inbounds i8, ptr %result.i78, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %101, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i78) #40
  %result.i77 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i87) #40
  %result.i88 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i77, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i87) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i87) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i77, ptr noalias nofree noundef nonnull readnone @axlhmwbuwo, ptr noalias nofree noundef nonnull readnone @i32_hasher) #40
  %ret.i55 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i77) #47
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i77) #40
  %result.i76 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i89) #40
  %result.i90 = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i76, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i89) #57
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i89) #40
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i76, ptr noalias nofree noundef nonnull readnone @sxmbvaaqjx, ptr noalias nofree noundef nonnull readnone @i32_eq) #40
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i76) #47
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i76) #40
  %105 = getelementptr inbounds i8, ptr %result.i78, i64 48
  store ptr %ret.i55, ptr %105, align 8
  %106 = getelementptr inbounds i8, ptr %result.i78, i64 56
  store ptr %ret.i, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %result.i78, i64 40
  store i32 8, ptr %107, align 8
  %result.i1.i385 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %108 = getelementptr inbounds i8, ptr %result.i78, i64 24
  store ptr %result.i1.i385, ptr %108, align 8
  %result.i.i386 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %109 = getelementptr inbounds i8, ptr %result.i78, i64 32
  store ptr %result.i.i386, ptr %109, align 8
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %111 = getelementptr inbounds i8, ptr %result.i78, i64 44
  store i32 0, ptr %111, align 4
  %112 = mul i32 %0, 10
  %113 = getelementptr inbounds i8, ptr %68, i64 8
  %114 = getelementptr inbounds i8, ptr %69, i64 8
  %115 = getelementptr inbounds i8, ptr %70, i64 8
  %.promoted = load ptr, ptr %113, align 8
  %.promoted292 = load ptr, ptr %114, align 8
  %.promoted295 = load ptr, ptr %115, align 8
  %116 = icmp sgt i32 %0, 0
  %117 = icmp sgt i32 %112, 0
  %spec.select297 = and i1 %116, %117
  br i1 %spec.select297, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %120 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i78, 1
  %121 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr undef, 2
  %122 = insertvalue { ptr, ptr, ptr, i32 } %121, i32 10, 3
  %123 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i83, 1
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr undef, 2
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 10, 3
  %126 = insertvalue { ptr, ptr, ptr, i32 } %123, i32 10, 3
  %127 = insertvalue { ptr, ptr, ptr, i32 } %120, i32 10, 3
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG) #40
  br label %129

129:                                              ; preds = %._crit_edge1, %.lr.ph
  %result.i80.h2s3891.sroa.0.0 = phi i32 [ 101112, %.lr.ph ], [ %132, %._crit_edge1 ]
  %.0374302 = phi i32 [ 0, %.lr.ph ], [ %1795, %._crit_edge1 ]
  %.0376301 = phi i32 [ 0, %.lr.ph ], [ %.1377, %._crit_edge1 ]
  %_parameterization_i32291300 = phi ptr [ %.promoted, %.lr.ph ], [ %_parameterization_i32, %._crit_edge1 ]
  %_parameterization_i32294299 = phi ptr [ %.promoted292, %.lr.ph ], [ %_parameterization_i32293, %._crit_edge1 ]
  %_parameterization_Bool296298 = phi ptr [ %.promoted295, %.lr.ph ], [ %_parameterization_Bool, %._crit_edge1 ]
  %130 = mul i32 %result.i80.h2s3891.sroa.0.0, 1103515245
  %131 = add i32 %130, 12345
  %132 = and i32 %131, 2147483647
  %.sroa.0362.0.insert.ext = zext nneg i32 %132 to i160
  %133 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0362.0.insert.ext, 1
  %134 = load ptr, ptr %105, align 8
  %135 = call i32 %134({ ptr, i160 } %133) #53
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %137 = load i32, ptr %107, align 8
  %138 = add i32 %137, -1
  %139 = and i32 %138, %135
  %140 = load ptr, ptr %108, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %141 = sext i32 %139 to i64
  %142 = shl nsw i64 %141, 5
  %143 = getelementptr i8, ptr %140, i64 %142
  %144 = load ptr, ptr %143, align 8
  %145 = icmp ne ptr %144, @nil_typ
  %146 = icmp ne ptr %144, null
  %.not45.i = and i1 %145, %146
  br i1 %.not45.i, label %147, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

147:                                              ; preds = %129
  %148 = getelementptr i8, ptr %143, i64 8
  %149 = load i64, ptr %148, align 4
  %.sroa_idx.i = getelementptr i8, ptr %143, i64 16
  %150 = load i64, ptr %.sroa_idx.i, align 4
  %151 = inttoptr i64 %149 to ptr
  %152 = inttoptr i64 %150 to ptr
  %hash_coef_ptr.i.i4.i = getelementptr i8, ptr %144, i64 8
  %tbl_size_ptr.i.i5.i = getelementptr i8, ptr %144, i64 16
  %offset_tbl_ptr.i.i6.i = getelementptr i8, ptr %144, i64 40
  %hash_coef.i.i7.i = load i64, ptr %hash_coef_ptr.i.i4.i, align 4, !noalias !323
  %tbl_size.i.i8.i = load i64, ptr %tbl_size_ptr.i.i5.i, align 4, !noalias !323
  %offset_tbl.i.i9.i = load ptr, ptr %offset_tbl_ptr.i.i6.i, align 8, !noalias !323
  %product.i.i.i10.i = mul i64 %hash_coef.i.i7.i, 4015701072841558310
  %shifted.i.i.i11.i = lshr i64 %product.i.i.i10.i, 32
  %xored.i.i.i12.i = xor i64 %shifted.i.i.i11.i, %product.i.i.i10.i
  %hash.i.i.i13.i = and i64 %xored.i.i.i12.i, %tbl_size.i.i8.i
  %offset_ptr.i.i14.i = getelementptr i32, ptr %offset_tbl.i.i9.i, i64 %hash.i.i.i13.i
  %offset.i.i15.i = load i32, ptr %offset_ptr.i.i14.i, align 4, !noalias !323
  %153 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %144, 0
  %154 = insertvalue { ptr, ptr, ptr, i32 } %153, ptr %151, 1
  %155 = insertvalue { ptr, ptr, ptr, i32 } %154, ptr %152, 2
  %156 = insertvalue { ptr, ptr, ptr, i32 } %155, i32 %offset.i.i15.i, 3
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %144) #40
  %159 = sext i32 %offset.i.i15.i to i64
  %160 = getelementptr ptr, ptr %144, i64 %159
  %161 = getelementptr i8, ptr %160, i64 64
  %162 = load ptr, ptr %161, align 8
  %result.i2.i991 = call ptr %162({ ptr, ptr, ptr, i32 } %156, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %163 = call i32 %result.i2.i991({ ptr, ptr, ptr, i32 } %156, { ptr, ptr, ptr, i32 } %156, ptr nonnull align 8 %2) #53
  %164 = icmp eq i32 %163, %135
  br i1 %164, label %._crit_edge.i992, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i992:                                 ; preds = %147
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %144)
  %167 = getelementptr i8, ptr %160, i64 48
  %168 = load ptr, ptr %167, align 8
  %result.i1.i993 = call ptr %168({ ptr, ptr, ptr, i32 } %156, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %169 = call { ptr, i160 } %result.i1.i993({ ptr, ptr, ptr, i32 } %156, { ptr, ptr, ptr, i32 } %156, ptr nonnull align 8 %2) #53
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %171 = load ptr, ptr %106, align 8
  %172 = call i1 %171({ ptr, i160 } %169, { ptr, i160 } %133) #53
  br i1 %172, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i992, %147, %129
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %181

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i992
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %144)
  %175 = getelementptr i8, ptr %160, i64 56
  %176 = load ptr, ptr %175, align 8
  %result.i.i994 = call ptr %176({ ptr, ptr, ptr, i32 } %156, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %177 = call { ptr, i160 } %result.i.i994({ ptr, ptr, ptr, i32 } %156, { ptr, ptr, ptr, i32 } %156, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i = extractvalue { ptr, i160 } %177, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %179 = icmp ne ptr %.fca.0.extract22.i, @nil_typ
  %180 = icmp ne ptr %.fca.0.extract22.i, null
  %.not63.i = and i1 %179, %180
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %181

181:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %182 = add i32 %135, 2127912214
  %183 = shl i32 %135, 12
  %184 = add i32 %182, %183
  %185 = ashr i32 %184, 19
  %186 = xor i32 %184, %185
  %187 = xor i32 %186, -949894596
  %188 = add i32 %187, 374761393
  %189 = shl i32 %187, 5
  %190 = add i32 %188, %189
  %191 = add i32 %190, -744332180
  %192 = shl i32 %190, 9
  %193 = xor i32 %191, %192
  %194 = add i32 %193, -42973499
  %195 = shl i32 %193, 3
  %196 = add i32 %194, %195
  %197 = ashr i32 %196, 16
  %198 = xor i32 %196, %197
  %199 = xor i32 %198, -1252372727
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %201 = load i32, ptr %107, align 8
  %202 = add i32 %201, -1
  %203 = and i32 %202, %199
  %204 = load ptr, ptr %109, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %205 = sext i32 %203 to i64
  %206 = shl nsw i64 %205, 5
  %207 = getelementptr i8, ptr %204, i64 %206
  %208 = load ptr, ptr %207, align 8
  %209 = icmp ne ptr %208, @nil_typ
  %210 = icmp ne ptr %208, null
  %.not45.i1023 = and i1 %209, %210
  br i1 %.not45.i1023, label %211, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1048

211:                                              ; preds = %181
  %212 = getelementptr i8, ptr %207, i64 8
  %213 = load i64, ptr %212, align 4
  %.sroa_idx.i1028 = getelementptr i8, ptr %207, i64 16
  %214 = load i64, ptr %.sroa_idx.i1028, align 4
  %215 = inttoptr i64 %213 to ptr
  %216 = inttoptr i64 %214 to ptr
  %hash_coef_ptr.i.i4.i1029 = getelementptr i8, ptr %208, i64 8
  %tbl_size_ptr.i.i5.i1030 = getelementptr i8, ptr %208, i64 16
  %offset_tbl_ptr.i.i6.i1031 = getelementptr i8, ptr %208, i64 40
  %hash_coef.i.i7.i1032 = load i64, ptr %hash_coef_ptr.i.i4.i1029, align 4, !noalias !326
  %tbl_size.i.i8.i1033 = load i64, ptr %tbl_size_ptr.i.i5.i1030, align 4, !noalias !326
  %offset_tbl.i.i9.i1034 = load ptr, ptr %offset_tbl_ptr.i.i6.i1031, align 8, !noalias !326
  %product.i.i.i10.i1035 = mul i64 %hash_coef.i.i7.i1032, 4015701072841558310
  %shifted.i.i.i11.i1036 = lshr i64 %product.i.i.i10.i1035, 32
  %xored.i.i.i12.i1037 = xor i64 %shifted.i.i.i11.i1036, %product.i.i.i10.i1035
  %hash.i.i.i13.i1038 = and i64 %xored.i.i.i12.i1037, %tbl_size.i.i8.i1033
  %offset_ptr.i.i14.i1039 = getelementptr i32, ptr %offset_tbl.i.i9.i1034, i64 %hash.i.i.i13.i1038
  %offset.i.i15.i1040 = load i32, ptr %offset_ptr.i.i14.i1039, align 4, !noalias !326
  %217 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %208, 0
  %218 = insertvalue { ptr, ptr, ptr, i32 } %217, ptr %215, 1
  %219 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %216, 2
  %220 = insertvalue { ptr, ptr, ptr, i32 } %219, i32 %offset.i.i15.i1040, 3
  %221 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %208) #40
  %223 = sext i32 %offset.i.i15.i1040 to i64
  %224 = getelementptr ptr, ptr %208, i64 %223
  %225 = getelementptr i8, ptr %224, i64 64
  %226 = load ptr, ptr %225, align 8
  %result.i2.i1041 = call ptr %226({ ptr, ptr, ptr, i32 } %220, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %227 = call i32 %result.i2.i1041({ ptr, ptr, ptr, i32 } %220, { ptr, ptr, ptr, i32 } %220, ptr nonnull align 8 %2) #53
  %228 = icmp eq i32 %227, %135
  br i1 %228, label %._crit_edge.i1042, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1048

._crit_edge.i1042:                                ; preds = %211
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %208)
  %231 = getelementptr i8, ptr %224, i64 48
  %232 = load ptr, ptr %231, align 8
  %result.i1.i1043 = call ptr %232({ ptr, ptr, ptr, i32 } %220, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %233 = call { ptr, i160 } %result.i1.i1043({ ptr, ptr, ptr, i32 } %220, { ptr, ptr, ptr, i32 } %220, ptr nonnull align 8 %2) #53
  %234 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %235 = load ptr, ptr %106, align 8
  %236 = call i1 %235({ ptr, i160 } %233, { ptr, i160 } %133) #53
  br i1 %236, label %237, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1048

237:                                              ; preds = %._crit_edge.i1042
  %238 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %239 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %208)
  %240 = getelementptr i8, ptr %224, i64 56
  %241 = load ptr, ptr %240, align 8
  %result.i.i1045 = call ptr %241({ ptr, ptr, ptr, i32 } %220, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %242 = call { ptr, i160 } %result.i.i1045({ ptr, ptr, ptr, i32 } %220, { ptr, ptr, ptr, i32 } %220, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1046 = extractvalue { ptr, i160 } %242, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1048

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1048: ; preds = %237, %._crit_edge.i1042, %211, %181
  %.reg2mem41.0.i1025 = phi ptr [ %.fca.0.extract22.i1046, %237 ], [ @nil_typ, %._crit_edge.i1042 ], [ @nil_typ, %181 ], [ @nil_typ, %211 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %243 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i = icmp eq ptr %.reg2mem41.0.i1025, null
  %244 = select i1 %.not.i, ptr @nil_typ, ptr %.reg2mem41.0.i1025
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1048, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.reg2mem56.0.i = phi ptr [ %244, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1048 ], [ %.fca.0.extract22.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %245 = icmp eq ptr %.reg2mem56.0.i, @nil_typ
  %246 = icmp eq ptr %.reg2mem56.0.i, null
  %247 = or i1 %245, %246
  br i1 %247, label %248, label %._crit_edge1

248:                                              ; preds = %CuckooMap_get_keyK.exit
  %249 = add nuw i32 %132, 1
  %.sroa.0345.0.insert.ext = zext i32 %249 to i160
  %250 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0345.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %68, align 8
  %251 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %68)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %252 = load ptr, ptr %86, align 8
  %253 = call i32 %252({ ptr, i160 } %133) #53
  %254 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %255 = load i32, ptr %88, align 8
  %256 = add i32 %255, -1
  %257 = and i32 %256, %253
  %258 = load ptr, ptr %89, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %259 = sext i32 %257 to i64
  %260 = shl nsw i64 %259, 5
  %261 = getelementptr i8, ptr %258, i64 %260
  %262 = load ptr, ptr %261, align 8
  %263 = getelementptr i8, ptr %261, i64 8
  %264 = icmp ne ptr %262, @nil_typ
  %265 = icmp ne ptr %262, null
  %.not66.i = and i1 %264, %265
  br i1 %.not66.i, label %266, label %364

266:                                              ; preds = %248
  %267 = load i64, ptr %263, align 4
  %.sroa_idx.i1089 = getelementptr i8, ptr %261, i64 16
  %268 = load i64, ptr %.sroa_idx.i1089, align 4
  %269 = inttoptr i64 %267 to ptr
  %270 = inttoptr i64 %268 to ptr
  %hash_coef_ptr.i.i11.i = getelementptr i8, ptr %262, i64 8
  %tbl_size_ptr.i.i12.i = getelementptr i8, ptr %262, i64 16
  %offset_tbl_ptr.i.i13.i = getelementptr i8, ptr %262, i64 40
  %hash_coef.i.i14.i = load i64, ptr %hash_coef_ptr.i.i11.i, align 4, !noalias !329
  %tbl_size.i.i15.i = load i64, ptr %tbl_size_ptr.i.i12.i, align 4, !noalias !329
  %offset_tbl.i.i16.i = load ptr, ptr %offset_tbl_ptr.i.i13.i, align 8, !noalias !329
  %product.i.i.i17.i = mul i64 %hash_coef.i.i14.i, 4015701072841558310
  %shifted.i.i.i18.i = lshr i64 %product.i.i.i17.i, 32
  %xored.i.i.i19.i = xor i64 %shifted.i.i.i18.i, %product.i.i.i17.i
  %hash.i.i.i20.i = and i64 %xored.i.i.i19.i, %tbl_size.i.i15.i
  %offset_ptr.i.i21.i = getelementptr i32, ptr %offset_tbl.i.i16.i, i64 %hash.i.i.i20.i
  %offset.i.i22.i = load i32, ptr %offset_ptr.i.i21.i, align 4, !noalias !329
  %271 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %262, 0
  %272 = insertvalue { ptr, ptr, ptr, i32 } %271, ptr %269, 1
  %273 = insertvalue { ptr, ptr, ptr, i32 } %272, ptr %270, 2
  %274 = insertvalue { ptr, ptr, ptr, i32 } %273, i32 %offset.i.i22.i, 3
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %262) #40
  %277 = sext i32 %offset.i.i22.i to i64
  %278 = getelementptr ptr, ptr %262, i64 %277
  %279 = getelementptr i8, ptr %278, i64 64
  %280 = load ptr, ptr %279, align 8
  %result.i8.i1090 = call ptr %280({ ptr, ptr, ptr, i32 } %274, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %281 = call i32 %result.i8.i1090({ ptr, ptr, ptr, i32 } %274, { ptr, ptr, ptr, i32 } %274, ptr nonnull align 8 %2) #53
  %282 = icmp eq i32 %281, %253
  br i1 %282, label %._crit_edge.i1091, label %364

._crit_edge.i1091:                                ; preds = %266
  %283 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %284 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %262)
  %285 = getelementptr i8, ptr %278, i64 48
  %286 = load ptr, ptr %285, align 8
  %result.i7.i = call ptr %286({ ptr, ptr, ptr, i32 } %274, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %287 = call { ptr, i160 } %result.i7.i({ ptr, ptr, ptr, i32 } %274, { ptr, ptr, ptr, i32 } %274, ptr nonnull align 8 %2) #53
  %288 = load ptr, ptr %87, align 8
  %289 = call i1 %288({ ptr, i160 } %287, { ptr, i160 } %133) #53
  br i1 %289, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %364

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1091
  %290 = load ptr, ptr %result.i83, align 8
  %291 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %292 = load ptr, ptr %81, align 8
  %293 = load ptr, ptr %290, align 8, !alias.scope !332
  %294 = getelementptr i8, ptr %293, i64 72
  %295 = load ptr, ptr %294, align 8, !alias.scope !332
  %result.i1.i.i = call { i64, i64 } %295(ptr nocapture nofree nonnull readonly align 8 %290) #44, !alias.scope !332
  %296 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %297 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %298 = urem i64 20, %297
  %299 = icmp eq i64 %298, 0
  %300 = sub i64 %297, %298
  %301 = select i1 %299, i64 0, i64 %300
  %302 = add i64 %296, 20
  %303 = add i64 %302, %301
  %304 = load ptr, ptr %292, align 8, !alias.scope !332
  %305 = getelementptr i8, ptr %304, i64 72
  %306 = load ptr, ptr %305, align 8, !alias.scope !332
  %result.i.i.i1092 = call { i64, i64 } %306(ptr nocapture nofree nonnull readonly align 8 %292) #44, !alias.scope !332
  %307 = extractvalue { i64, i64 } %result.i.i.i1092, 0
  %308 = extractvalue { i64, i64 } %result.i.i.i1092, 1
  %309 = call i64 @llvm.umax.i64(i64 %297, i64 %308) #41
  %310 = call i64 @llvm.umax.i64(i64 %309, i64 noundef 8) #41, !range !16
  %311 = urem i64 %303, %308
  %312 = icmp eq i64 %311, 0
  %313 = sub i64 %308, %311
  %314 = select i1 %312, i64 0, i64 %313
  %315 = add i64 %307, %303
  %316 = add i64 %315, %314
  %317 = urem i64 %316, %310
  %318 = icmp eq i64 %317, 0
  %319 = sub i64 %310, %317
  %320 = select i1 %318, i64 0, i64 %319
  %321 = add i64 %320, %316
  %result.i9.i1093 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %321) #48
  store ptr %290, ptr %result.i9.i1093, align 8
  %322 = getelementptr inbounds i8, ptr %result.i9.i1093, i64 8
  store ptr %292, ptr %322, align 8
  %323 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1093)
  %324 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %325 = load ptr, ptr %290, align 8
  %326 = getelementptr i8, ptr %325, i64 72
  %327 = load ptr, ptr %326, align 8
  %result.i.i38.i = call { i64, i64 } %327(ptr nocapture nofree nonnull readonly align 8 %290) #44
  %328 = extractvalue { i64, i64 } %result.i.i38.i, 1
  %329 = urem i64 20, %328
  %330 = icmp eq i64 %329, 0
  %reass.sub3925 = sub i64 %328, %329
  %331 = add i64 %reass.sub3925, 20
  %332 = select i1 %330, i64 20, i64 %331
  %333 = getelementptr i8, ptr %result.i9.i1093, i64 %332
  %334 = getelementptr i8, ptr %325, i64 64
  %335 = load ptr, ptr %334, align 8
  call void %335({ ptr, i160 } %133, ptr nocapture nofree nonnull readonly align 8 %290, ptr nocapture nofree writeonly %333) #45
  %336 = load ptr, ptr %result.i9.i1093, align 8
  %337 = load ptr, ptr %336, align 8
  %338 = getelementptr i8, ptr %337, i64 72
  %339 = load ptr, ptr %338, align 8
  %result.i1.i39.i = call { i64, i64 } %339(ptr nocapture nofree nonnull readonly align 8 %336) #44
  %340 = extractvalue { i64, i64 } %result.i1.i39.i, 0
  %341 = extractvalue { i64, i64 } %result.i1.i39.i, 1
  %342 = urem i64 20, %341
  %343 = icmp eq i64 %342, 0
  %344 = sub i64 %341, %342
  %345 = select i1 %343, i64 0, i64 %344
  %346 = add i64 %340, 20
  %347 = add i64 %346, %345
  %348 = load ptr, ptr %322, align 8
  %349 = load ptr, ptr %348, align 8
  %350 = getelementptr i8, ptr %349, i64 72
  %351 = load ptr, ptr %350, align 8
  %result.i.i40.i = call { i64, i64 } %351(ptr nocapture nofree nonnull readonly align 8 %348) #44
  %352 = extractvalue { i64, i64 } %result.i.i40.i, 1
  %353 = urem i64 %347, %352
  %354 = icmp eq i64 %353, 0
  %355 = sub i64 %352, %353
  %356 = select i1 %354, i64 0, i64 %355
  %357 = getelementptr i8, ptr %result.i9.i1093, i64 %347
  %358 = getelementptr i8, ptr %357, i64 %356
  %359 = getelementptr i8, ptr %349, i64 64
  %360 = load ptr, ptr %359, align 8
  call void %360({ ptr, i160 } %250, ptr nocapture nofree nonnull readonly align 8 %348, ptr nocapture nofree writeonly %358) #45
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %362 = getelementptr inbounds i8, ptr %result.i9.i1093, i64 16
  store i32 %253, ptr %362, align 8
  store ptr @Entry, ptr %261, align 8
  %363 = ptrtoint ptr %result.i9.i1093 to i64
  store i64 %363, ptr %263, align 4
  %.sroa_idx30.i = getelementptr i8, ptr %261, i64 24
  store i32 10, ptr %.sroa_idx30.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

364:                                              ; preds = %._crit_edge.i1091, %266, %248
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %365 = add i32 %253, 2127912214
  %366 = shl i32 %253, 12
  %367 = add i32 %365, %366
  %368 = ashr i32 %367, 19
  %369 = xor i32 %367, %368
  %370 = xor i32 %369, -949894596
  %371 = add i32 %370, 374761393
  %372 = shl i32 %370, 5
  %373 = add i32 %371, %372
  %374 = add i32 %373, -744332180
  %375 = shl i32 %373, 9
  %376 = xor i32 %374, %375
  %377 = add i32 %376, -42973499
  %378 = shl i32 %376, 3
  %379 = add i32 %377, %378
  %380 = ashr i32 %379, 16
  %381 = xor i32 %379, %380
  %382 = xor i32 %381, -1252372727
  %383 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %384 = load i32, ptr %88, align 8
  %385 = add i32 %384, -1
  %386 = and i32 %385, %382
  %387 = load ptr, ptr %90, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %388 = sext i32 %386 to i64
  %389 = shl nsw i64 %388, 5
  %390 = getelementptr i8, ptr %387, i64 %389
  %391 = load ptr, ptr %390, align 8
  %392 = getelementptr i8, ptr %390, i64 8
  %393 = icmp ne ptr %391, @nil_typ
  %394 = icmp ne ptr %391, null
  %.not66.i1123 = and i1 %393, %394
  br i1 %.not66.i1123, label %395, label %493

395:                                              ; preds = %364
  %396 = load i64, ptr %392, align 4
  %.sroa_idx.i1125 = getelementptr i8, ptr %390, i64 16
  %397 = load i64, ptr %.sroa_idx.i1125, align 4
  %398 = inttoptr i64 %396 to ptr
  %399 = inttoptr i64 %397 to ptr
  %hash_coef_ptr.i.i11.i1126 = getelementptr i8, ptr %391, i64 8
  %tbl_size_ptr.i.i12.i1127 = getelementptr i8, ptr %391, i64 16
  %offset_tbl_ptr.i.i13.i1128 = getelementptr i8, ptr %391, i64 40
  %hash_coef.i.i14.i1129 = load i64, ptr %hash_coef_ptr.i.i11.i1126, align 4, !noalias !335
  %tbl_size.i.i15.i1130 = load i64, ptr %tbl_size_ptr.i.i12.i1127, align 4, !noalias !335
  %offset_tbl.i.i16.i1131 = load ptr, ptr %offset_tbl_ptr.i.i13.i1128, align 8, !noalias !335
  %product.i.i.i17.i1132 = mul i64 %hash_coef.i.i14.i1129, 4015701072841558310
  %shifted.i.i.i18.i1133 = lshr i64 %product.i.i.i17.i1132, 32
  %xored.i.i.i19.i1134 = xor i64 %shifted.i.i.i18.i1133, %product.i.i.i17.i1132
  %hash.i.i.i20.i1135 = and i64 %xored.i.i.i19.i1134, %tbl_size.i.i15.i1130
  %offset_ptr.i.i21.i1136 = getelementptr i32, ptr %offset_tbl.i.i16.i1131, i64 %hash.i.i.i20.i1135
  %offset.i.i22.i1137 = load i32, ptr %offset_ptr.i.i21.i1136, align 4, !noalias !335
  %400 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %391, 0
  %401 = insertvalue { ptr, ptr, ptr, i32 } %400, ptr %398, 1
  %402 = insertvalue { ptr, ptr, ptr, i32 } %401, ptr %399, 2
  %403 = insertvalue { ptr, ptr, ptr, i32 } %402, i32 %offset.i.i22.i1137, 3
  %404 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %405 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %391) #40
  %406 = sext i32 %offset.i.i22.i1137 to i64
  %407 = getelementptr ptr, ptr %391, i64 %406
  %408 = getelementptr i8, ptr %407, i64 64
  %409 = load ptr, ptr %408, align 8
  %result.i8.i1138 = call ptr %409({ ptr, ptr, ptr, i32 } %403, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %410 = call i32 %result.i8.i1138({ ptr, ptr, ptr, i32 } %403, { ptr, ptr, ptr, i32 } %403, ptr nonnull align 8 %2) #53
  %411 = icmp eq i32 %410, %253
  br i1 %411, label %._crit_edge.i1139, label %493

._crit_edge.i1139:                                ; preds = %395
  %412 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %413 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %391)
  %414 = getelementptr i8, ptr %407, i64 48
  %415 = load ptr, ptr %414, align 8
  %result.i7.i1140 = call ptr %415({ ptr, ptr, ptr, i32 } %403, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %416 = call { ptr, i160 } %result.i7.i1140({ ptr, ptr, ptr, i32 } %403, { ptr, ptr, ptr, i32 } %403, ptr nonnull align 8 %2) #53
  %417 = load ptr, ptr %87, align 8
  %418 = call i1 %417({ ptr, i160 } %416, { ptr, i160 } %133) #53
  br i1 %418, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1152, label %493

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1152: ; preds = %._crit_edge.i1139
  %419 = load ptr, ptr %result.i83, align 8
  %420 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %421 = load ptr, ptr %81, align 8
  %422 = load ptr, ptr %419, align 8, !alias.scope !338
  %423 = getelementptr i8, ptr %422, i64 72
  %424 = load ptr, ptr %423, align 8, !alias.scope !338
  %result.i1.i.i1144 = call { i64, i64 } %424(ptr nocapture nofree nonnull readonly align 8 %419) #44, !alias.scope !338
  %425 = extractvalue { i64, i64 } %result.i1.i.i1144, 0
  %426 = extractvalue { i64, i64 } %result.i1.i.i1144, 1
  %427 = urem i64 20, %426
  %428 = icmp eq i64 %427, 0
  %429 = sub i64 %426, %427
  %430 = select i1 %428, i64 0, i64 %429
  %431 = add i64 %425, 20
  %432 = add i64 %431, %430
  %433 = load ptr, ptr %421, align 8, !alias.scope !338
  %434 = getelementptr i8, ptr %433, i64 72
  %435 = load ptr, ptr %434, align 8, !alias.scope !338
  %result.i.i.i1145 = call { i64, i64 } %435(ptr nocapture nofree nonnull readonly align 8 %421) #44, !alias.scope !338
  %436 = extractvalue { i64, i64 } %result.i.i.i1145, 0
  %437 = extractvalue { i64, i64 } %result.i.i.i1145, 1
  %438 = call i64 @llvm.umax.i64(i64 %426, i64 %437) #41
  %439 = call i64 @llvm.umax.i64(i64 %438, i64 noundef 8) #41, !range !16
  %440 = urem i64 %432, %437
  %441 = icmp eq i64 %440, 0
  %442 = sub i64 %437, %440
  %443 = select i1 %441, i64 0, i64 %442
  %444 = add i64 %436, %432
  %445 = add i64 %444, %443
  %446 = urem i64 %445, %439
  %447 = icmp eq i64 %446, 0
  %448 = sub i64 %439, %446
  %449 = select i1 %447, i64 0, i64 %448
  %450 = add i64 %449, %445
  %result.i9.i1146 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %450) #48
  store ptr %419, ptr %result.i9.i1146, align 8
  %451 = getelementptr inbounds i8, ptr %result.i9.i1146, i64 8
  store ptr %421, ptr %451, align 8
  %452 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1146)
  %453 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %454 = load ptr, ptr %419, align 8
  %455 = getelementptr i8, ptr %454, i64 72
  %456 = load ptr, ptr %455, align 8
  %result.i.i38.i1147 = call { i64, i64 } %456(ptr nocapture nofree nonnull readonly align 8 %419) #44
  %457 = extractvalue { i64, i64 } %result.i.i38.i1147, 1
  %458 = urem i64 20, %457
  %459 = icmp eq i64 %458, 0
  %reass.sub3924 = sub i64 %457, %458
  %460 = add i64 %reass.sub3924, 20
  %461 = select i1 %459, i64 20, i64 %460
  %462 = getelementptr i8, ptr %result.i9.i1146, i64 %461
  %463 = getelementptr i8, ptr %454, i64 64
  %464 = load ptr, ptr %463, align 8
  call void %464({ ptr, i160 } %133, ptr nocapture nofree nonnull readonly align 8 %419, ptr nocapture nofree writeonly %462) #45
  %465 = load ptr, ptr %result.i9.i1146, align 8
  %466 = load ptr, ptr %465, align 8
  %467 = getelementptr i8, ptr %466, i64 72
  %468 = load ptr, ptr %467, align 8
  %result.i1.i39.i1149 = call { i64, i64 } %468(ptr nocapture nofree nonnull readonly align 8 %465) #44
  %469 = extractvalue { i64, i64 } %result.i1.i39.i1149, 0
  %470 = extractvalue { i64, i64 } %result.i1.i39.i1149, 1
  %471 = urem i64 20, %470
  %472 = icmp eq i64 %471, 0
  %473 = sub i64 %470, %471
  %474 = select i1 %472, i64 0, i64 %473
  %475 = add i64 %469, 20
  %476 = add i64 %475, %474
  %477 = load ptr, ptr %451, align 8
  %478 = load ptr, ptr %477, align 8
  %479 = getelementptr i8, ptr %478, i64 72
  %480 = load ptr, ptr %479, align 8
  %result.i.i40.i1150 = call { i64, i64 } %480(ptr nocapture nofree nonnull readonly align 8 %477) #44
  %481 = extractvalue { i64, i64 } %result.i.i40.i1150, 1
  %482 = urem i64 %476, %481
  %483 = icmp eq i64 %482, 0
  %484 = sub i64 %481, %482
  %485 = select i1 %483, i64 0, i64 %484
  %486 = getelementptr i8, ptr %result.i9.i1146, i64 %476
  %487 = getelementptr i8, ptr %486, i64 %485
  %488 = getelementptr i8, ptr %478, i64 64
  %489 = load ptr, ptr %488, align 8
  call void %489({ ptr, i160 } %250, ptr nocapture nofree nonnull readonly align 8 %477, ptr nocapture nofree writeonly %487) #45
  %490 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %491 = getelementptr inbounds i8, ptr %result.i9.i1146, i64 16
  store i32 %253, ptr %491, align 8
  store ptr @Entry, ptr %390, align 8
  %492 = ptrtoint ptr %result.i9.i1146 to i64
  store i64 %492, ptr %392, align 4
  %.sroa_idx30.i1151 = getelementptr i8, ptr %390, i64 24
  store i32 10, ptr %.sroa_idx30.i1151, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit

493:                                              ; preds = %._crit_edge.i1139, %395, %364
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %494 = load i32, ptr %91, align 4
  %495 = load i32, ptr %88, align 8
  %.not.i438 = icmp slt i32 %494, %495
  br i1 %.not.i438, label %._crit_edge.i, label %496

496:                                              ; preds = %493
  %497 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %498 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %499 = load ptr, ptr %89, align 8
  %500 = load ptr, ptr %90, align 8
  %501 = shl i32 %495, 1
  %spec.select.i = call i32 @llvm.smax.i32(i32 %501, i32 noundef 16) #40
  store i32 %spec.select.i, ptr %88, align 8
  %502 = zext nneg i32 %spec.select.i to i64
  %503 = shl nuw nsw i64 %502, 5
  %result.i5.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %503) #48
  store ptr %result.i5.i, ptr %89, align 8
  %result.i4.i1167 = call noalias ptr @bump_malloc_wrapper(i64 noundef %503) #48
  store ptr %result.i4.i1167, ptr %90, align 8
  store i32 0, ptr %91, align 4
  %504 = icmp sgt i32 %495, 0
  br i1 %504, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %496
  %wide.trip.count.i = zext nneg i32 %495 to i64
  br label %505

505:                                              ; preds = %._crit_edge.i2256, %.lr.ph.i
  %indvars.iv.i2255 = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i2257, %._crit_edge.i2256 ]
  %506 = shl nuw nsw i64 %indvars.iv.i2255, 5
  %507 = getelementptr i8, ptr %499, i64 %506
  %508 = load ptr, ptr %507, align 8
  %509 = icmp ne ptr %508, @nil_typ
  %510 = icmp ne ptr %508, null
  %.not17.i = and i1 %509, %510
  br i1 %.not17.i, label %511, label %._crit_edge.i2256

511:                                              ; preds = %505
  %512 = getelementptr i8, ptr %507, i64 8
  %513 = load i64, ptr %512, align 4
  %.sroa_idx.i2259 = getelementptr i8, ptr %507, i64 16
  %514 = load i64, ptr %.sroa_idx.i2259, align 4
  %hash_coef_ptr.i.i6.i = getelementptr i8, ptr %508, i64 8
  %tbl_size_ptr.i.i7.i = getelementptr i8, ptr %508, i64 16
  %offset_tbl_ptr.i.i8.i = getelementptr i8, ptr %508, i64 40
  %515 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i6.i, align 4, !noalias !341
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i7.i, align 4, !noalias !341
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i8.i, align 8, !noalias !341
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i29.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !341
  %516 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %517 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %518 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %519

519:                                              ; preds = %.cont.i2832, %511
  %.0290.i2814 = phi i32 [ 0, %511 ], [ %552, %.cont.i2832 ]
  %.074289.i2815 = phi i1 [ true, %511 ], [ %553, %.cont.i2832 ]
  %.sroa.0.0288.i2816 = phi ptr [ %508, %511 ], [ %542, %.cont.i2832 ]
  %.sroa.6.0287.i2817.in = phi i64 [ %513, %511 ], [ %544, %.cont.i2832 ]
  %.sroa.12.0286.i2818.in = phi i64 [ %514, %511 ], [ %545, %.cont.i2832 ]
  %.sroa.17.0285.i2819 = phi i32 [ %offset.i.i29.i, %511 ], [ %offset.i.i57.i2844, %.cont.i2832 ]
  %.sroa.12.0286.i2818 = inttoptr i64 %.sroa.12.0286.i2818.in to ptr
  %.sroa.6.0287.i2817 = inttoptr i64 %.sroa.6.0287.i2817.in to ptr
  %520 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2816, 0
  %521 = insertvalue { ptr, ptr, ptr, i32 } %520, ptr %.sroa.6.0287.i2817, 1
  %522 = insertvalue { ptr, ptr, ptr, i32 } %521, ptr %.sroa.12.0286.i2818, 2
  %523 = insertvalue { ptr, ptr, ptr, i32 } %522, i32 %.sroa.17.0285.i2819, 3
  %524 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2816)
  %525 = sext i32 %.sroa.17.0285.i2819 to i64
  %526 = getelementptr ptr, ptr %.sroa.0.0288.i2816, i64 %525
  %527 = getelementptr i8, ptr %526, i64 64
  %528 = load ptr, ptr %527, align 8
  %result.i15.i2820 = call ptr %528({ ptr, ptr, ptr, i32 } %523, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %529 = call i32 %result.i15.i2820({ ptr, ptr, ptr, i32 } %523, { ptr, ptr, ptr, i32 } %523, ptr nonnull align 8 %2) #53
  %..i2821 = select i1 %.074289.i2815, ptr %48, ptr %50
  %.188.i2822 = select i1 %.074289.i2815, i64 104, i64 112
  %.189.i2823 = select i1 %.074289.i2815, ptr %49, ptr %51
  %.190.i2824 = select i1 %.074289.i2815, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2821, align 8
  %530 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2821)
  %531 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2822
  %532 = load ptr, ptr %531, align 8
  store ptr @i32_typ, ptr %.189.i2823, align 8
  %result.i14.i2825 = call ptr %532({ ptr, ptr, ptr, i32 } %126, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2823) #46
  %533 = call i32 %result.i14.i2825({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull align 8 dereferenceable(8) %..i2821, i32 %529) #53
  %534 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %535 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2824
  %536 = load ptr, ptr %535, align 8
  %537 = load ptr, ptr %536, align 8
  %538 = call { ptr } %537(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i2826 = extractvalue { ptr } %538, 0
  %539 = sext i32 %533 to i64
  %540 = shl nsw i64 %539, 5
  %541 = getelementptr i8, ptr %.fca.0.extract55.i2826, i64 %540
  %542 = load ptr, ptr %541, align 8
  %543 = getelementptr i8, ptr %541, i64 8
  %544 = load i64, ptr %543, align 4
  %.sroa_idx.i2827 = getelementptr i8, ptr %541, i64 16
  %545 = load i64, ptr %.sroa_idx.i2827, align 4
  %546 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %547 = call { ptr } %537(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i2828 = extractvalue { ptr } %547, 0
  %548 = getelementptr i8, ptr %.fca.0.extract52.i2828, i64 %540
  store ptr %.sroa.0.0288.i2816, ptr %548, align 8
  %549 = getelementptr i8, ptr %548, i64 8
  store i64 %.sroa.6.0287.i2817.in, ptr %549, align 4
  %.sroa_idx104.i2829 = getelementptr i8, ptr %548, i64 16
  store i64 %.sroa.12.0286.i2818.in, ptr %.sroa_idx104.i2829, align 4
  %.sroa_idx105.i2830 = getelementptr i8, ptr %548, i64 24
  store i32 %.sroa.17.0285.i2819, ptr %.sroa_idx105.i2830, align 4
  %550 = icmp ne ptr %542, @nil_typ
  %551 = icmp ne ptr %542, null
  %.not94.i2831 = and i1 %550, %551
  br i1 %.not94.i2831, label %.cont.i2832, label %556

.cont.i2832:                                      ; preds = %519
  %552 = add nuw nsw i32 %.0290.i2814, 1
  %553 = xor i1 %.074289.i2815, true
  %hash_coef_ptr.i.i46.i2833 = getelementptr i8, ptr %542, i64 8
  %tbl_size_ptr.i.i47.i2834 = getelementptr i8, ptr %542, i64 16
  %offset_tbl_ptr.i.i48.i2835 = getelementptr i8, ptr %542, i64 40
  %hash_coef.i.i49.i2836 = load i64, ptr %hash_coef_ptr.i.i46.i2833, align 4
  %tbl_size.i.i50.i2837 = load i64, ptr %tbl_size_ptr.i.i47.i2834, align 4
  %offset_tbl.i.i51.i2838 = load ptr, ptr %offset_tbl_ptr.i.i48.i2835, align 8
  %product.i.i.i52.i2839 = mul i64 %hash_coef.i.i49.i2836, 4015701072841558310
  %shifted.i.i.i53.i2840 = lshr i64 %product.i.i.i52.i2839, 32
  %xored.i.i.i54.i2841 = xor i64 %shifted.i.i.i53.i2840, %product.i.i.i52.i2839
  %hash.i.i.i55.i2842 = and i64 %xored.i.i.i54.i2841, %tbl_size.i.i50.i2837
  %offset_ptr.i.i56.i2843 = getelementptr i32, ptr %offset_tbl.i.i51.i2838, i64 %hash.i.i.i55.i2842
  %offset.i.i57.i2844 = load i32, ptr %offset_ptr.i.i56.i2843, align 4
  %554 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2845 = icmp eq i32 %552, 100
  br i1 %exitcond.not.i2845, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847, label %519

556:                                              ; preds = %519
  %557 = load i32, ptr %91, align 4
  %558 = add i32 %557, 1
  %559 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %558, ptr %91, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847: ; preds = %556, %.cont.i2832
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  br label %._crit_edge.i2256

._crit_edge.i2256:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2847, %505
  %indvars.iv.next.i2257 = add nuw nsw i64 %indvars.iv.i2255, 1
  %exitcond.not.i2258 = icmp eq i64 %indvars.iv.next.i2257, %wide.trip.count.i
  br i1 %exitcond.not.i2258, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit, label %505

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit: ; preds = %._crit_edge.i2279, %._crit_edge.i2256
  %indvars.iv.i2277 = phi i64 [ %indvars.iv.next.i2280, %._crit_edge.i2279 ], [ 0, %._crit_edge.i2256 ]
  %560 = shl nuw nsw i64 %indvars.iv.i2277, 5
  %561 = getelementptr i8, ptr %500, i64 %560
  %562 = load ptr, ptr %561, align 8
  %563 = icmp ne ptr %562, @nil_typ
  %564 = icmp ne ptr %562, null
  %.not17.i2278 = and i1 %563, %564
  br i1 %.not17.i2278, label %565, label %._crit_edge.i2279

565:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %566 = getelementptr i8, ptr %561, i64 8
  %567 = load i64, ptr %566, align 4
  %.sroa_idx.i2282 = getelementptr i8, ptr %561, i64 16
  %568 = load i64, ptr %.sroa_idx.i2282, align 4
  %hash_coef_ptr.i.i6.i2283 = getelementptr i8, ptr %562, i64 8
  %tbl_size_ptr.i.i7.i2284 = getelementptr i8, ptr %562, i64 16
  %offset_tbl_ptr.i.i8.i2285 = getelementptr i8, ptr %562, i64 40
  %569 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  %hash_coef.i.i21.i2865 = load i64, ptr %hash_coef_ptr.i.i6.i2283, align 4, !noalias !344
  %tbl_size.i.i22.i2866 = load i64, ptr %tbl_size_ptr.i.i7.i2284, align 4, !noalias !344
  %offset_tbl.i.i23.i2867 = load ptr, ptr %offset_tbl_ptr.i.i8.i2285, align 8, !noalias !344
  %product.i.i.i24.i2868 = mul i64 %hash_coef.i.i21.i2865, 4015701072841558310
  %shifted.i.i.i25.i2869 = lshr i64 %product.i.i.i24.i2868, 32
  %xored.i.i.i26.i2870 = xor i64 %shifted.i.i.i25.i2869, %product.i.i.i24.i2868
  %hash.i.i.i27.i2871 = and i64 %xored.i.i.i26.i2870, %tbl_size.i.i22.i2866
  %offset_ptr.i.i28.i2872 = getelementptr i32, ptr %offset_tbl.i.i23.i2867, i64 %hash.i.i.i27.i2871
  %offset.i.i29.i2873 = load i32, ptr %offset_ptr.i.i28.i2872, align 4, !noalias !344
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %571 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %573

573:                                              ; preds = %.cont.i2896, %565
  %.0290.i2874 = phi i32 [ 0, %565 ], [ %606, %.cont.i2896 ]
  %.074289.i2875 = phi i1 [ true, %565 ], [ %607, %.cont.i2896 ]
  %.sroa.0.0288.i2876 = phi ptr [ %562, %565 ], [ %596, %.cont.i2896 ]
  %.sroa.6.0287.i2877.in = phi i64 [ %567, %565 ], [ %598, %.cont.i2896 ]
  %.sroa.12.0286.i2878.in = phi i64 [ %568, %565 ], [ %599, %.cont.i2896 ]
  %.sroa.17.0285.i2879 = phi i32 [ %offset.i.i29.i2873, %565 ], [ %offset.i.i57.i2908, %.cont.i2896 ]
  %.sroa.12.0286.i2878 = inttoptr i64 %.sroa.12.0286.i2878.in to ptr
  %.sroa.6.0287.i2877 = inttoptr i64 %.sroa.6.0287.i2877.in to ptr
  %574 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2876, 0
  %575 = insertvalue { ptr, ptr, ptr, i32 } %574, ptr %.sroa.6.0287.i2877, 1
  %576 = insertvalue { ptr, ptr, ptr, i32 } %575, ptr %.sroa.12.0286.i2878, 2
  %577 = insertvalue { ptr, ptr, ptr, i32 } %576, i32 %.sroa.17.0285.i2879, 3
  %578 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2876)
  %579 = sext i32 %.sroa.17.0285.i2879 to i64
  %580 = getelementptr ptr, ptr %.sroa.0.0288.i2876, i64 %579
  %581 = getelementptr i8, ptr %580, i64 64
  %582 = load ptr, ptr %581, align 8
  %result.i15.i2880 = call ptr %582({ ptr, ptr, ptr, i32 } %577, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %583 = call i32 %result.i15.i2880({ ptr, ptr, ptr, i32 } %577, { ptr, ptr, ptr, i32 } %577, ptr nonnull align 8 %2) #53
  %..i2881 = select i1 %.074289.i2875, ptr %44, ptr %46
  %.188.i2882 = select i1 %.074289.i2875, i64 104, i64 112
  %.189.i2883 = select i1 %.074289.i2875, ptr %45, ptr %47
  %.190.i2884 = select i1 %.074289.i2875, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2881, align 8
  %584 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2881)
  %585 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2882
  %586 = load ptr, ptr %585, align 8
  store ptr @i32_typ, ptr %.189.i2883, align 8
  %result.i14.i2885 = call ptr %586({ ptr, ptr, ptr, i32 } %126, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2883) #46
  %587 = call i32 %result.i14.i2885({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull align 8 dereferenceable(8) %..i2881, i32 %583) #53
  %588 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %589 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2884
  %590 = load ptr, ptr %589, align 8
  %591 = load ptr, ptr %590, align 8
  %592 = call { ptr } %591(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i2886 = extractvalue { ptr } %592, 0
  %593 = sext i32 %587 to i64
  %594 = shl nsw i64 %593, 5
  %595 = getelementptr i8, ptr %.fca.0.extract55.i2886, i64 %594
  %596 = load ptr, ptr %595, align 8
  %597 = getelementptr i8, ptr %595, i64 8
  %598 = load i64, ptr %597, align 4
  %.sroa_idx.i2887 = getelementptr i8, ptr %595, i64 16
  %599 = load i64, ptr %.sroa_idx.i2887, align 4
  %600 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %601 = call { ptr } %591(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i2888 = extractvalue { ptr } %601, 0
  %602 = getelementptr i8, ptr %.fca.0.extract52.i2888, i64 %594
  store ptr %.sroa.0.0288.i2876, ptr %602, align 8
  %603 = getelementptr i8, ptr %602, i64 8
  store i64 %.sroa.6.0287.i2877.in, ptr %603, align 4
  %.sroa_idx104.i2889 = getelementptr i8, ptr %602, i64 16
  store i64 %.sroa.12.0286.i2878.in, ptr %.sroa_idx104.i2889, align 4
  %.sroa_idx105.i2890 = getelementptr i8, ptr %602, i64 24
  store i32 %.sroa.17.0285.i2879, ptr %.sroa_idx105.i2890, align 4
  %604 = icmp ne ptr %596, @nil_typ
  %605 = icmp ne ptr %596, null
  %.not94.i2891 = and i1 %604, %605
  br i1 %.not94.i2891, label %.cont.i2896, label %610

.cont.i2896:                                      ; preds = %573
  %606 = add nuw nsw i32 %.0290.i2874, 1
  %607 = xor i1 %.074289.i2875, true
  %hash_coef_ptr.i.i46.i2897 = getelementptr i8, ptr %596, i64 8
  %tbl_size_ptr.i.i47.i2898 = getelementptr i8, ptr %596, i64 16
  %offset_tbl_ptr.i.i48.i2899 = getelementptr i8, ptr %596, i64 40
  %hash_coef.i.i49.i2900 = load i64, ptr %hash_coef_ptr.i.i46.i2897, align 4
  %tbl_size.i.i50.i2901 = load i64, ptr %tbl_size_ptr.i.i47.i2898, align 4
  %offset_tbl.i.i51.i2902 = load ptr, ptr %offset_tbl_ptr.i.i48.i2899, align 8
  %product.i.i.i52.i2903 = mul i64 %hash_coef.i.i49.i2900, 4015701072841558310
  %shifted.i.i.i53.i2904 = lshr i64 %product.i.i.i52.i2903, 32
  %xored.i.i.i54.i2905 = xor i64 %shifted.i.i.i53.i2904, %product.i.i.i52.i2903
  %hash.i.i.i55.i2906 = and i64 %xored.i.i.i54.i2905, %tbl_size.i.i50.i2901
  %offset_ptr.i.i56.i2907 = getelementptr i32, ptr %offset_tbl.i.i51.i2902, i64 %hash.i.i.i55.i2906
  %offset.i.i57.i2908 = load i32, ptr %offset_ptr.i.i56.i2907, align 4
  %608 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %609 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2909 = icmp eq i32 %606, 100
  br i1 %exitcond.not.i2909, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918, label %573

610:                                              ; preds = %573
  %611 = load i32, ptr %91, align 4
  %612 = add i32 %611, 1
  %613 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %612, ptr %91, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918: ; preds = %610, %.cont.i2896
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  br label %._crit_edge.i2279

._crit_edge.i2279:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2918, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit
  %indvars.iv.next.i2280 = add nuw nsw i64 %indvars.iv.i2277, 1
  %exitcond.not.i2281 = icmp eq i64 %indvars.iv.next.i2280, %wide.trip.count.i
  br i1 %exitcond.not.i2281, label %._crit_edge.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit

._crit_edge.i:                                    ; preds = %._crit_edge.i2279, %496, %493
  %614 = load ptr, ptr %result.i83, align 8
  %615 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %616 = load ptr, ptr %81, align 8
  %617 = load ptr, ptr %614, align 8
  %618 = getelementptr i8, ptr %617, i64 72
  %619 = load ptr, ptr %618, align 8
  %result.i1.i.i441 = call { i64, i64 } %619(ptr nocapture nofree nonnull readonly align 8 %614) #44
  %620 = extractvalue { i64, i64 } %result.i1.i.i441, 0
  %621 = extractvalue { i64, i64 } %result.i1.i.i441, 1
  %622 = urem i64 20, %621
  %623 = icmp eq i64 %622, 0
  %624 = sub i64 %621, %622
  %625 = select i1 %623, i64 0, i64 %624
  %626 = add i64 %620, 20
  %627 = add i64 %626, %625
  %628 = load ptr, ptr %616, align 8
  %629 = getelementptr i8, ptr %628, i64 72
  %630 = load ptr, ptr %629, align 8
  %result.i.i.i442 = call { i64, i64 } %630(ptr nocapture nofree nonnull readonly align 8 %616) #44
  %631 = extractvalue { i64, i64 } %result.i.i.i442, 0
  %632 = extractvalue { i64, i64 } %result.i.i.i442, 1
  %633 = call i64 @llvm.umax.i64(i64 %621, i64 %632) #41
  %634 = call i64 @llvm.umax.i64(i64 %633, i64 noundef 8) #41, !range !16
  %635 = urem i64 %627, %632
  %636 = icmp eq i64 %635, 0
  %637 = sub i64 %632, %635
  %638 = select i1 %636, i64 0, i64 %637
  %639 = add i64 %631, %627
  %640 = add i64 %639, %638
  %641 = urem i64 %640, %634
  %642 = icmp eq i64 %641, 0
  %643 = sub i64 %634, %641
  %644 = select i1 %642, i64 0, i64 %643
  %645 = add i64 %644, %640
  %result.i22.i443 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %645) #48
  store ptr %614, ptr %result.i22.i443, align 8
  %646 = getelementptr inbounds i8, ptr %result.i22.i443, i64 8
  store ptr %616, ptr %646, align 8
  %647 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i443)
  %648 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %649 = load ptr, ptr %614, align 8
  %650 = getelementptr i8, ptr %649, i64 72
  %651 = load ptr, ptr %650, align 8
  %result.i.i127.i = call { i64, i64 } %651(ptr nocapture nofree nonnull readonly align 8 %614) #44
  %652 = extractvalue { i64, i64 } %result.i.i127.i, 1
  %653 = urem i64 20, %652
  %654 = icmp eq i64 %653, 0
  %reass.sub3923 = sub i64 %652, %653
  %655 = add i64 %reass.sub3923, 20
  %656 = select i1 %654, i64 20, i64 %655
  %657 = getelementptr i8, ptr %result.i22.i443, i64 %656
  %658 = getelementptr i8, ptr %649, i64 64
  %659 = load ptr, ptr %658, align 8
  call void %659({ ptr, i160 } %133, ptr nocapture nofree nonnull readonly align 8 %614, ptr nocapture nofree writeonly %657) #45
  %660 = load ptr, ptr %result.i22.i443, align 8
  %661 = load ptr, ptr %660, align 8
  %662 = getelementptr i8, ptr %661, i64 72
  %663 = load ptr, ptr %662, align 8
  %result.i1.i128.i = call { i64, i64 } %663(ptr nocapture nofree nonnull readonly align 8 %660) #44
  %664 = extractvalue { i64, i64 } %result.i1.i128.i, 0
  %665 = extractvalue { i64, i64 } %result.i1.i128.i, 1
  %666 = urem i64 20, %665
  %667 = icmp eq i64 %666, 0
  %668 = sub i64 %665, %666
  %669 = select i1 %667, i64 0, i64 %668
  %670 = add i64 %664, 20
  %671 = add i64 %670, %669
  %672 = load ptr, ptr %646, align 8
  %673 = load ptr, ptr %672, align 8
  %674 = getelementptr i8, ptr %673, i64 72
  %675 = load ptr, ptr %674, align 8
  %result.i.i129.i = call { i64, i64 } %675(ptr nocapture nofree nonnull readonly align 8 %672) #44
  %676 = extractvalue { i64, i64 } %result.i.i129.i, 1
  %677 = urem i64 %671, %676
  %678 = icmp eq i64 %677, 0
  %679 = sub i64 %676, %677
  %680 = select i1 %678, i64 0, i64 %679
  %681 = getelementptr i8, ptr %result.i22.i443, i64 %671
  %682 = getelementptr i8, ptr %681, i64 %680
  %683 = getelementptr i8, ptr %673, i64 64
  %684 = load ptr, ptr %683, align 8
  call void %684({ ptr, i160 } %250, ptr nocapture nofree nonnull readonly align 8 %672, ptr nocapture nofree writeonly %682) #45
  %685 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %686 = getelementptr inbounds i8, ptr %result.i22.i443, i64 16
  store i32 %253, ptr %686, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %687 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %688 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %689 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %690

690:                                              ; preds = %.cont.i, %._crit_edge.i
  %.0290.i = phi i32 [ 0, %._crit_edge.i ], [ %725, %.cont.i ]
  %.074289.i = phi i1 [ true, %._crit_edge.i ], [ %726, %.cont.i ]
  %.sroa.0.0288.i = phi ptr [ @Entry, %._crit_edge.i ], [ %713, %.cont.i ]
  %.sroa.6.0287.i = phi ptr [ %result.i22.i443, %._crit_edge.i ], [ %727, %.cont.i ]
  %.sroa.12.0286.i = phi ptr [ undef, %._crit_edge.i ], [ %728, %.cont.i ]
  %.sroa.17.0285.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i57.i, %.cont.i ]
  %691 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i, 0
  %692 = insertvalue { ptr, ptr, ptr, i32 } %691, ptr %.sroa.6.0287.i, 1
  %693 = insertvalue { ptr, ptr, ptr, i32 } %692, ptr %.sroa.12.0286.i, 2
  %694 = insertvalue { ptr, ptr, ptr, i32 } %693, i32 %.sroa.17.0285.i, 3
  %695 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i)
  %696 = sext i32 %.sroa.17.0285.i to i64
  %697 = getelementptr ptr, ptr %.sroa.0.0288.i, i64 %696
  %698 = getelementptr i8, ptr %697, i64 64
  %699 = load ptr, ptr %698, align 8
  %result.i15.i = call ptr %699({ ptr, ptr, ptr, i32 } %694, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %700 = call i32 %result.i15.i({ ptr, ptr, ptr, i32 } %694, { ptr, ptr, ptr, i32 } %694, ptr nonnull align 8 %2) #53
  %..i = select i1 %.074289.i, ptr %64, ptr %66
  %.188.i = select i1 %.074289.i, i64 104, i64 112
  %.189.i = select i1 %.074289.i, ptr %65, ptr %67
  %.190.i = select i1 %.074289.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i, align 8
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i)
  %702 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i
  %703 = load ptr, ptr %702, align 8
  store ptr @i32_typ, ptr %.189.i, align 8
  %result.i14.i = call ptr %703({ ptr, ptr, ptr, i32 } %125, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i) #46
  %704 = call i32 %result.i14.i({ ptr, ptr, ptr, i32 } %125, { ptr, ptr, ptr, i32 } %125, ptr nonnull align 8 dereferenceable(8) %..i, i32 %700) #53
  %705 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %706 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i
  %707 = load ptr, ptr %706, align 8
  %708 = load ptr, ptr %707, align 8
  %709 = call { ptr } %708(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i = extractvalue { ptr } %709, 0
  %710 = sext i32 %704 to i64
  %711 = shl nsw i64 %710, 5
  %712 = getelementptr i8, ptr %.fca.0.extract55.i, i64 %711
  %713 = load ptr, ptr %712, align 8
  %714 = getelementptr i8, ptr %712, i64 8
  %715 = load i64, ptr %714, align 4
  %.sroa_idx.i1186 = getelementptr i8, ptr %712, i64 16
  %716 = load i64, ptr %.sroa_idx.i1186, align 4
  %717 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %718 = call { ptr } %708(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i = extractvalue { ptr } %718, 0
  %719 = getelementptr i8, ptr %.fca.0.extract52.i, i64 %711
  store ptr %.sroa.0.0288.i, ptr %719, align 8
  %720 = getelementptr i8, ptr %719, i64 8
  %721 = ptrtoint ptr %.sroa.6.0287.i to i64
  %722 = ptrtoint ptr %.sroa.12.0286.i to i64
  store i64 %721, ptr %720, align 4
  %.sroa_idx104.i = getelementptr i8, ptr %719, i64 16
  store i64 %722, ptr %.sroa_idx104.i, align 4
  %.sroa_idx105.i = getelementptr i8, ptr %719, i64 24
  store i32 %.sroa.17.0285.i, ptr %.sroa_idx105.i, align 4
  %723 = icmp ne ptr %713, @nil_typ
  %724 = icmp ne ptr %713, null
  %.not94.i = and i1 %723, %724
  br i1 %.not94.i, label %.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

.cont.i:                                          ; preds = %690
  %725 = add nuw nsw i32 %.0290.i, 1
  %726 = xor i1 %.074289.i, true
  %727 = inttoptr i64 %715 to ptr
  %728 = inttoptr i64 %716 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %713, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %713, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %713, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %730 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i = icmp eq i32 %725, 100
  br i1 %exitcond.not.i, label %734, label %690

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %690
  %731 = load i32, ptr %91, align 4
  %732 = add i32 %731, 1
  %733 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %732, ptr %91, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  br label %CuckooMap_insert_keyK_valueV.exit

734:                                              ; preds = %.cont.i
  %hash_coef_ptr.i.i46.i.le = getelementptr i8, ptr %713, i64 8
  %tbl_size_ptr.i.i47.i.le = getelementptr i8, ptr %713, i64 16
  %offset_tbl_ptr.i.i48.i.le = getelementptr i8, ptr %713, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %735 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %736 = load ptr, ptr %89, align 8
  %737 = load ptr, ptr %90, align 8
  %738 = load i32, ptr %88, align 8
  %739 = shl i32 %738, 1
  %spec.select.i1203 = call i32 @llvm.smax.i32(i32 %739, i32 noundef 16) #40
  store i32 %spec.select.i1203, ptr %88, align 8
  %740 = zext nneg i32 %spec.select.i1203 to i64
  %741 = shl nuw nsw i64 %740, 5
  %result.i5.i1204 = call noalias ptr @bump_malloc_wrapper(i64 noundef %741) #48
  store ptr %result.i5.i1204, ptr %89, align 8
  %result.i4.i1205 = call noalias ptr @bump_malloc_wrapper(i64 noundef %741) #48
  store ptr %result.i4.i1205, ptr %90, align 8
  store i32 0, ptr %91, align 4
  %742 = icmp sgt i32 %738, 0
  br i1 %742, label %.lr.ph.i2301, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2337.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2337.thread: ; preds = %734
  %743 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375

.lr.ph.i2301:                                     ; preds = %734
  %wide.trip.count.i2314 = zext nneg i32 %738 to i64
  br label %744

744:                                              ; preds = %._crit_edge.i2317, %.lr.ph.i2301
  %indvars.iv.i2315 = phi i64 [ 0, %.lr.ph.i2301 ], [ %indvars.iv.next.i2318, %._crit_edge.i2317 ]
  %745 = shl nuw nsw i64 %indvars.iv.i2315, 5
  %746 = getelementptr i8, ptr %736, i64 %745
  %747 = load ptr, ptr %746, align 8
  %748 = icmp ne ptr %747, @nil_typ
  %749 = icmp ne ptr %747, null
  %.not17.i2316 = and i1 %748, %749
  br i1 %.not17.i2316, label %750, label %._crit_edge.i2317

750:                                              ; preds = %744
  %751 = getelementptr i8, ptr %746, i64 8
  %752 = load i64, ptr %751, align 4
  %.sroa_idx.i2320 = getelementptr i8, ptr %746, i64 16
  %753 = load i64, ptr %.sroa_idx.i2320, align 4
  %hash_coef_ptr.i.i6.i2321 = getelementptr i8, ptr %747, i64 8
  %tbl_size_ptr.i.i7.i2322 = getelementptr i8, ptr %747, i64 16
  %offset_tbl_ptr.i.i8.i2323 = getelementptr i8, ptr %747, i64 40
  %754 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  %hash_coef.i.i21.i2936 = load i64, ptr %hash_coef_ptr.i.i6.i2321, align 4, !noalias !347
  %tbl_size.i.i22.i2937 = load i64, ptr %tbl_size_ptr.i.i7.i2322, align 4, !noalias !347
  %offset_tbl.i.i23.i2938 = load ptr, ptr %offset_tbl_ptr.i.i8.i2323, align 8, !noalias !347
  %product.i.i.i24.i2939 = mul i64 %hash_coef.i.i21.i2936, 4015701072841558310
  %shifted.i.i.i25.i2940 = lshr i64 %product.i.i.i24.i2939, 32
  %xored.i.i.i26.i2941 = xor i64 %shifted.i.i.i25.i2940, %product.i.i.i24.i2939
  %hash.i.i.i27.i2942 = and i64 %xored.i.i.i26.i2941, %tbl_size.i.i22.i2937
  %offset_ptr.i.i28.i2943 = getelementptr i32, ptr %offset_tbl.i.i23.i2938, i64 %hash.i.i.i27.i2942
  %offset.i.i29.i2944 = load i32, ptr %offset_ptr.i.i28.i2943, align 4, !noalias !347
  %755 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %756 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %757 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %758

758:                                              ; preds = %.cont.i2967, %750
  %.0290.i2945 = phi i32 [ 0, %750 ], [ %791, %.cont.i2967 ]
  %.074289.i2946 = phi i1 [ true, %750 ], [ %792, %.cont.i2967 ]
  %.sroa.0.0288.i2947 = phi ptr [ %747, %750 ], [ %781, %.cont.i2967 ]
  %.sroa.6.0287.i2948.in = phi i64 [ %752, %750 ], [ %783, %.cont.i2967 ]
  %.sroa.12.0286.i2949.in = phi i64 [ %753, %750 ], [ %784, %.cont.i2967 ]
  %.sroa.17.0285.i2950 = phi i32 [ %offset.i.i29.i2944, %750 ], [ %offset.i.i57.i2979, %.cont.i2967 ]
  %.sroa.12.0286.i2949 = inttoptr i64 %.sroa.12.0286.i2949.in to ptr
  %.sroa.6.0287.i2948 = inttoptr i64 %.sroa.6.0287.i2948.in to ptr
  %759 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i2947, 0
  %760 = insertvalue { ptr, ptr, ptr, i32 } %759, ptr %.sroa.6.0287.i2948, 1
  %761 = insertvalue { ptr, ptr, ptr, i32 } %760, ptr %.sroa.12.0286.i2949, 2
  %762 = insertvalue { ptr, ptr, ptr, i32 } %761, i32 %.sroa.17.0285.i2950, 3
  %763 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i2947)
  %764 = sext i32 %.sroa.17.0285.i2950 to i64
  %765 = getelementptr ptr, ptr %.sroa.0.0288.i2947, i64 %764
  %766 = getelementptr i8, ptr %765, i64 64
  %767 = load ptr, ptr %766, align 8
  %result.i15.i2951 = call ptr %767({ ptr, ptr, ptr, i32 } %762, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %768 = call i32 %result.i15.i2951({ ptr, ptr, ptr, i32 } %762, { ptr, ptr, ptr, i32 } %762, ptr nonnull align 8 %2) #53
  %..i2952 = select i1 %.074289.i2946, ptr %40, ptr %42
  %.188.i2953 = select i1 %.074289.i2946, i64 104, i64 112
  %.189.i2954 = select i1 %.074289.i2946, ptr %41, ptr %43
  %.190.i2955 = select i1 %.074289.i2946, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i2952, align 8
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i2952)
  %770 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i2953
  %771 = load ptr, ptr %770, align 8
  store ptr @i32_typ, ptr %.189.i2954, align 8
  %result.i14.i2956 = call ptr %771({ ptr, ptr, ptr, i32 } %126, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i2954) #46
  %772 = call i32 %result.i14.i2956({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull align 8 dereferenceable(8) %..i2952, i32 %768) #53
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %774 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i2955
  %775 = load ptr, ptr %774, align 8
  %776 = load ptr, ptr %775, align 8
  %777 = call { ptr } %776(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i2957 = extractvalue { ptr } %777, 0
  %778 = sext i32 %772 to i64
  %779 = shl nsw i64 %778, 5
  %780 = getelementptr i8, ptr %.fca.0.extract55.i2957, i64 %779
  %781 = load ptr, ptr %780, align 8
  %782 = getelementptr i8, ptr %780, i64 8
  %783 = load i64, ptr %782, align 4
  %.sroa_idx.i2958 = getelementptr i8, ptr %780, i64 16
  %784 = load i64, ptr %.sroa_idx.i2958, align 4
  %785 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %786 = call { ptr } %776(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i2959 = extractvalue { ptr } %786, 0
  %787 = getelementptr i8, ptr %.fca.0.extract52.i2959, i64 %779
  store ptr %.sroa.0.0288.i2947, ptr %787, align 8
  %788 = getelementptr i8, ptr %787, i64 8
  store i64 %.sroa.6.0287.i2948.in, ptr %788, align 4
  %.sroa_idx104.i2960 = getelementptr i8, ptr %787, i64 16
  store i64 %.sroa.12.0286.i2949.in, ptr %.sroa_idx104.i2960, align 4
  %.sroa_idx105.i2961 = getelementptr i8, ptr %787, i64 24
  store i32 %.sroa.17.0285.i2950, ptr %.sroa_idx105.i2961, align 4
  %789 = icmp ne ptr %781, @nil_typ
  %790 = icmp ne ptr %781, null
  %.not94.i2962 = and i1 %789, %790
  br i1 %.not94.i2962, label %.cont.i2967, label %795

.cont.i2967:                                      ; preds = %758
  %791 = add nuw nsw i32 %.0290.i2945, 1
  %792 = xor i1 %.074289.i2946, true
  %hash_coef_ptr.i.i46.i2968 = getelementptr i8, ptr %781, i64 8
  %tbl_size_ptr.i.i47.i2969 = getelementptr i8, ptr %781, i64 16
  %offset_tbl_ptr.i.i48.i2970 = getelementptr i8, ptr %781, i64 40
  %hash_coef.i.i49.i2971 = load i64, ptr %hash_coef_ptr.i.i46.i2968, align 4
  %tbl_size.i.i50.i2972 = load i64, ptr %tbl_size_ptr.i.i47.i2969, align 4
  %offset_tbl.i.i51.i2973 = load ptr, ptr %offset_tbl_ptr.i.i48.i2970, align 8
  %product.i.i.i52.i2974 = mul i64 %hash_coef.i.i49.i2971, 4015701072841558310
  %shifted.i.i.i53.i2975 = lshr i64 %product.i.i.i52.i2974, 32
  %xored.i.i.i54.i2976 = xor i64 %shifted.i.i.i53.i2975, %product.i.i.i52.i2974
  %hash.i.i.i55.i2977 = and i64 %xored.i.i.i54.i2976, %tbl_size.i.i50.i2972
  %offset_ptr.i.i56.i2978 = getelementptr i32, ptr %offset_tbl.i.i51.i2973, i64 %hash.i.i.i55.i2977
  %offset.i.i57.i2979 = load i32, ptr %offset_ptr.i.i56.i2978, align 4
  %793 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i2980 = icmp eq i32 %791, 100
  br i1 %exitcond.not.i2980, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989, label %758

795:                                              ; preds = %758
  %796 = load i32, ptr %91, align 4
  %797 = add i32 %796, 1
  %798 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %797, ptr %91, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989: ; preds = %795, %.cont.i2967
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  br label %._crit_edge.i2317

._crit_edge.i2317:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2989, %744
  %indvars.iv.next.i2318 = add nuw nsw i64 %indvars.iv.i2315, 1
  %exitcond.not.i2319 = icmp eq i64 %indvars.iv.next.i2318, %wide.trip.count.i2314
  br i1 %exitcond.not.i2319, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2337, label %744

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2337: ; preds = %._crit_edge.i2317
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %800

800:                                              ; preds = %._crit_edge.i2355, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2337
  %indvars.iv.i2353 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2337 ], [ %indvars.iv.next.i2356, %._crit_edge.i2355 ]
  %801 = shl nuw nsw i64 %indvars.iv.i2353, 5
  %802 = getelementptr i8, ptr %737, i64 %801
  %803 = load ptr, ptr %802, align 8
  %804 = icmp ne ptr %803, @nil_typ
  %805 = icmp ne ptr %803, null
  %.not17.i2354 = and i1 %804, %805
  br i1 %.not17.i2354, label %806, label %._crit_edge.i2355

806:                                              ; preds = %800
  %807 = getelementptr i8, ptr %802, i64 8
  %808 = load i64, ptr %807, align 4
  %.sroa_idx.i2358 = getelementptr i8, ptr %802, i64 16
  %809 = load i64, ptr %.sroa_idx.i2358, align 4
  %hash_coef_ptr.i.i6.i2359 = getelementptr i8, ptr %803, i64 8
  %tbl_size_ptr.i.i7.i2360 = getelementptr i8, ptr %803, i64 16
  %offset_tbl_ptr.i.i8.i2361 = getelementptr i8, ptr %803, i64 40
  %810 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  %hash_coef.i.i21.i3007 = load i64, ptr %hash_coef_ptr.i.i6.i2359, align 4, !noalias !350
  %tbl_size.i.i22.i3008 = load i64, ptr %tbl_size_ptr.i.i7.i2360, align 4, !noalias !350
  %offset_tbl.i.i23.i3009 = load ptr, ptr %offset_tbl_ptr.i.i8.i2361, align 8, !noalias !350
  %product.i.i.i24.i3010 = mul i64 %hash_coef.i.i21.i3007, 4015701072841558310
  %shifted.i.i.i25.i3011 = lshr i64 %product.i.i.i24.i3010, 32
  %xored.i.i.i26.i3012 = xor i64 %shifted.i.i.i25.i3011, %product.i.i.i24.i3010
  %hash.i.i.i27.i3013 = and i64 %xored.i.i.i26.i3012, %tbl_size.i.i22.i3008
  %offset_ptr.i.i28.i3014 = getelementptr i32, ptr %offset_tbl.i.i23.i3009, i64 %hash.i.i.i27.i3013
  %offset.i.i29.i3015 = load i32, ptr %offset_ptr.i.i28.i3014, align 4, !noalias !350
  %811 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %812 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %813 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %814

814:                                              ; preds = %.cont.i3038, %806
  %.0290.i3016 = phi i32 [ 0, %806 ], [ %847, %.cont.i3038 ]
  %.074289.i3017 = phi i1 [ true, %806 ], [ %848, %.cont.i3038 ]
  %.sroa.0.0288.i3018 = phi ptr [ %803, %806 ], [ %837, %.cont.i3038 ]
  %.sroa.6.0287.i3019.in = phi i64 [ %808, %806 ], [ %839, %.cont.i3038 ]
  %.sroa.12.0286.i3020.in = phi i64 [ %809, %806 ], [ %840, %.cont.i3038 ]
  %.sroa.17.0285.i3021 = phi i32 [ %offset.i.i29.i3015, %806 ], [ %offset.i.i57.i3050, %.cont.i3038 ]
  %.sroa.12.0286.i3020 = inttoptr i64 %.sroa.12.0286.i3020.in to ptr
  %.sroa.6.0287.i3019 = inttoptr i64 %.sroa.6.0287.i3019.in to ptr
  %815 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3018, 0
  %816 = insertvalue { ptr, ptr, ptr, i32 } %815, ptr %.sroa.6.0287.i3019, 1
  %817 = insertvalue { ptr, ptr, ptr, i32 } %816, ptr %.sroa.12.0286.i3020, 2
  %818 = insertvalue { ptr, ptr, ptr, i32 } %817, i32 %.sroa.17.0285.i3021, 3
  %819 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3018)
  %820 = sext i32 %.sroa.17.0285.i3021 to i64
  %821 = getelementptr ptr, ptr %.sroa.0.0288.i3018, i64 %820
  %822 = getelementptr i8, ptr %821, i64 64
  %823 = load ptr, ptr %822, align 8
  %result.i15.i3022 = call ptr %823({ ptr, ptr, ptr, i32 } %818, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %824 = call i32 %result.i15.i3022({ ptr, ptr, ptr, i32 } %818, { ptr, ptr, ptr, i32 } %818, ptr nonnull align 8 %2) #53
  %..i3023 = select i1 %.074289.i3017, ptr %36, ptr %38
  %.188.i3024 = select i1 %.074289.i3017, i64 104, i64 112
  %.189.i3025 = select i1 %.074289.i3017, ptr %37, ptr %39
  %.190.i3026 = select i1 %.074289.i3017, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3023, align 8
  %825 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3023)
  %826 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3024
  %827 = load ptr, ptr %826, align 8
  store ptr @i32_typ, ptr %.189.i3025, align 8
  %result.i14.i3027 = call ptr %827({ ptr, ptr, ptr, i32 } %126, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3025) #46
  %828 = call i32 %result.i14.i3027({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull align 8 dereferenceable(8) %..i3023, i32 %824) #53
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %830 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3026
  %831 = load ptr, ptr %830, align 8
  %832 = load ptr, ptr %831, align 8
  %833 = call { ptr } %832(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i3028 = extractvalue { ptr } %833, 0
  %834 = sext i32 %828 to i64
  %835 = shl nsw i64 %834, 5
  %836 = getelementptr i8, ptr %.fca.0.extract55.i3028, i64 %835
  %837 = load ptr, ptr %836, align 8
  %838 = getelementptr i8, ptr %836, i64 8
  %839 = load i64, ptr %838, align 4
  %.sroa_idx.i3029 = getelementptr i8, ptr %836, i64 16
  %840 = load i64, ptr %.sroa_idx.i3029, align 4
  %841 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %842 = call { ptr } %832(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i3030 = extractvalue { ptr } %842, 0
  %843 = getelementptr i8, ptr %.fca.0.extract52.i3030, i64 %835
  store ptr %.sroa.0.0288.i3018, ptr %843, align 8
  %844 = getelementptr i8, ptr %843, i64 8
  store i64 %.sroa.6.0287.i3019.in, ptr %844, align 4
  %.sroa_idx104.i3031 = getelementptr i8, ptr %843, i64 16
  store i64 %.sroa.12.0286.i3020.in, ptr %.sroa_idx104.i3031, align 4
  %.sroa_idx105.i3032 = getelementptr i8, ptr %843, i64 24
  store i32 %.sroa.17.0285.i3021, ptr %.sroa_idx105.i3032, align 4
  %845 = icmp ne ptr %837, @nil_typ
  %846 = icmp ne ptr %837, null
  %.not94.i3033 = and i1 %845, %846
  br i1 %.not94.i3033, label %.cont.i3038, label %851

.cont.i3038:                                      ; preds = %814
  %847 = add nuw nsw i32 %.0290.i3016, 1
  %848 = xor i1 %.074289.i3017, true
  %hash_coef_ptr.i.i46.i3039 = getelementptr i8, ptr %837, i64 8
  %tbl_size_ptr.i.i47.i3040 = getelementptr i8, ptr %837, i64 16
  %offset_tbl_ptr.i.i48.i3041 = getelementptr i8, ptr %837, i64 40
  %hash_coef.i.i49.i3042 = load i64, ptr %hash_coef_ptr.i.i46.i3039, align 4
  %tbl_size.i.i50.i3043 = load i64, ptr %tbl_size_ptr.i.i47.i3040, align 4
  %offset_tbl.i.i51.i3044 = load ptr, ptr %offset_tbl_ptr.i.i48.i3041, align 8
  %product.i.i.i52.i3045 = mul i64 %hash_coef.i.i49.i3042, 4015701072841558310
  %shifted.i.i.i53.i3046 = lshr i64 %product.i.i.i52.i3045, 32
  %xored.i.i.i54.i3047 = xor i64 %shifted.i.i.i53.i3046, %product.i.i.i52.i3045
  %hash.i.i.i55.i3048 = and i64 %xored.i.i.i54.i3047, %tbl_size.i.i50.i3043
  %offset_ptr.i.i56.i3049 = getelementptr i32, ptr %offset_tbl.i.i51.i3044, i64 %hash.i.i.i55.i3048
  %offset.i.i57.i3050 = load i32, ptr %offset_ptr.i.i56.i3049, align 4
  %849 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %850 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3051 = icmp eq i32 %847, 100
  br i1 %exitcond.not.i3051, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060, label %814

851:                                              ; preds = %814
  %852 = load i32, ptr %91, align 4
  %853 = add i32 %852, 1
  %854 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %853, ptr %91, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060: ; preds = %851, %.cont.i3038
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  br label %._crit_edge.i2355

._crit_edge.i2355:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3060, %800
  %indvars.iv.next.i2356 = add nuw nsw i64 %indvars.iv.i2353, 1
  %exitcond.not.i2357 = icmp eq i64 %indvars.iv.next.i2356, %wide.trip.count.i2314
  br i1 %exitcond.not.i2357, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375, label %800

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375: ; preds = %._crit_edge.i2355, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2337.thread
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  %hash_coef.i.i21.i1228 = load i64, ptr %hash_coef_ptr.i.i46.i.le, align 4, !noalias !353
  %tbl_size.i.i22.i1229 = load i64, ptr %tbl_size_ptr.i.i47.i.le, align 4, !noalias !353
  %offset_tbl.i.i23.i1230 = load ptr, ptr %offset_tbl_ptr.i.i48.i.le, align 8, !noalias !353
  %product.i.i.i24.i1231 = mul i64 %hash_coef.i.i21.i1228, 4015701072841558310
  %shifted.i.i.i25.i1232 = lshr i64 %product.i.i.i24.i1231, 32
  %xored.i.i.i26.i1233 = xor i64 %shifted.i.i.i25.i1232, %product.i.i.i24.i1231
  %hash.i.i.i27.i1234 = and i64 %xored.i.i.i26.i1233, %tbl_size.i.i22.i1229
  %offset_ptr.i.i28.i1235 = getelementptr i32, ptr %offset_tbl.i.i23.i1230, i64 %hash.i.i.i27.i1234
  %offset.i.i29.i1236 = load i32, ptr %offset_ptr.i.i28.i1235, align 4, !noalias !353
  %855 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %856 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %857 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %858

858:                                              ; preds = %.cont.i1260, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375
  %.0290.i1238 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375 ], [ %891, %.cont.i1260 ]
  %.074289.i1239 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375 ], [ %892, %.cont.i1260 ]
  %.sroa.0.0288.i1240 = phi ptr [ %713, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375 ], [ %881, %.cont.i1260 ]
  %.sroa.6.0287.i1241.in = phi i64 [ %715, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375 ], [ %883, %.cont.i1260 ]
  %.sroa.12.0286.i1242.in = phi i64 [ %716, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375 ], [ %884, %.cont.i1260 ]
  %.sroa.17.0285.i1243 = phi i32 [ %offset.i.i29.i1236, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2375 ], [ %offset.i.i57.i1272, %.cont.i1260 ]
  %.sroa.12.0286.i1242 = inttoptr i64 %.sroa.12.0286.i1242.in to ptr
  %.sroa.6.0287.i1241 = inttoptr i64 %.sroa.6.0287.i1241.in to ptr
  %859 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1240, 0
  %860 = insertvalue { ptr, ptr, ptr, i32 } %859, ptr %.sroa.6.0287.i1241, 1
  %861 = insertvalue { ptr, ptr, ptr, i32 } %860, ptr %.sroa.12.0286.i1242, 2
  %862 = insertvalue { ptr, ptr, ptr, i32 } %861, i32 %.sroa.17.0285.i1243, 3
  %863 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1240)
  %864 = sext i32 %.sroa.17.0285.i1243 to i64
  %865 = getelementptr ptr, ptr %.sroa.0.0288.i1240, i64 %864
  %866 = getelementptr i8, ptr %865, i64 64
  %867 = load ptr, ptr %866, align 8
  %result.i15.i1244 = call ptr %867({ ptr, ptr, ptr, i32 } %862, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %868 = call i32 %result.i15.i1244({ ptr, ptr, ptr, i32 } %862, { ptr, ptr, ptr, i32 } %862, ptr nonnull align 8 %2) #53
  %..i1245 = select i1 %.074289.i1239, ptr %60, ptr %62
  %.188.i1246 = select i1 %.074289.i1239, i64 104, i64 112
  %.189.i1247 = select i1 %.074289.i1239, ptr %61, ptr %63
  %.190.i1248 = select i1 %.074289.i1239, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1245, align 8
  %869 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1245)
  %870 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1246
  %871 = load ptr, ptr %870, align 8
  store ptr @i32_typ, ptr %.189.i1247, align 8
  %result.i14.i1249 = call ptr %871({ ptr, ptr, ptr, i32 } %125, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1247) #46
  %872 = call i32 %result.i14.i1249({ ptr, ptr, ptr, i32 } %125, { ptr, ptr, ptr, i32 } %125, ptr nonnull align 8 dereferenceable(8) %..i1245, i32 %868) #53
  %873 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %874 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1248
  %875 = load ptr, ptr %874, align 8
  %876 = load ptr, ptr %875, align 8
  %877 = call { ptr } %876(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i1250 = extractvalue { ptr } %877, 0
  %878 = sext i32 %872 to i64
  %879 = shl nsw i64 %878, 5
  %880 = getelementptr i8, ptr %.fca.0.extract55.i1250, i64 %879
  %881 = load ptr, ptr %880, align 8
  %882 = getelementptr i8, ptr %880, i64 8
  %883 = load i64, ptr %882, align 4
  %.sroa_idx.i1251 = getelementptr i8, ptr %880, i64 16
  %884 = load i64, ptr %.sroa_idx.i1251, align 4
  %885 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %886 = call { ptr } %876(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i1252 = extractvalue { ptr } %886, 0
  %887 = getelementptr i8, ptr %.fca.0.extract52.i1252, i64 %879
  store ptr %.sroa.0.0288.i1240, ptr %887, align 8
  %888 = getelementptr i8, ptr %887, i64 8
  store i64 %.sroa.6.0287.i1241.in, ptr %888, align 4
  %.sroa_idx104.i1253 = getelementptr i8, ptr %887, i64 16
  store i64 %.sroa.12.0286.i1242.in, ptr %.sroa_idx104.i1253, align 4
  %.sroa_idx105.i1254 = getelementptr i8, ptr %887, i64 24
  store i32 %.sroa.17.0285.i1243, ptr %.sroa_idx105.i1254, align 4
  %889 = icmp ne ptr %881, @nil_typ
  %890 = icmp ne ptr %881, null
  %.not94.i1255 = and i1 %889, %890
  br i1 %.not94.i1255, label %.cont.i1260, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1282

.cont.i1260:                                      ; preds = %858
  %891 = add nuw nsw i32 %.0290.i1238, 1
  %892 = xor i1 %.074289.i1239, true
  %hash_coef_ptr.i.i46.i1261 = getelementptr i8, ptr %881, i64 8
  %tbl_size_ptr.i.i47.i1262 = getelementptr i8, ptr %881, i64 16
  %offset_tbl_ptr.i.i48.i1263 = getelementptr i8, ptr %881, i64 40
  %hash_coef.i.i49.i1264 = load i64, ptr %hash_coef_ptr.i.i46.i1261, align 4
  %tbl_size.i.i50.i1265 = load i64, ptr %tbl_size_ptr.i.i47.i1262, align 4
  %offset_tbl.i.i51.i1266 = load ptr, ptr %offset_tbl_ptr.i.i48.i1263, align 8
  %product.i.i.i52.i1267 = mul i64 %hash_coef.i.i49.i1264, 4015701072841558310
  %shifted.i.i.i53.i1268 = lshr i64 %product.i.i.i52.i1267, 32
  %xored.i.i.i54.i1269 = xor i64 %shifted.i.i.i53.i1268, %product.i.i.i52.i1267
  %hash.i.i.i55.i1270 = and i64 %xored.i.i.i54.i1269, %tbl_size.i.i50.i1265
  %offset_ptr.i.i56.i1271 = getelementptr i32, ptr %offset_tbl.i.i51.i1266, i64 %hash.i.i.i55.i1270
  %offset.i.i57.i1272 = load i32, ptr %offset_ptr.i.i56.i1271, align 4
  %893 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %894 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1273 = icmp eq i32 %891, 100
  br i1 %exitcond.not.i1273, label %898, label %858

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1282: ; preds = %858
  %895 = load i32, ptr %91, align 4
  %896 = add i32 %895, 1
  %897 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %896, ptr %91, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  br label %CuckooMap_insert_keyK_valueV.exit

898:                                              ; preds = %.cont.i1260
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  %899 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %900 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %901 = load ptr, ptr %89, align 8
  %902 = load ptr, ptr %90, align 8
  %903 = load i32, ptr %88, align 8
  %904 = shl i32 %903, 1
  %spec.select.i1298 = call i32 @llvm.smax.i32(i32 %904, i32 noundef 16) #40
  store i32 %spec.select.i1298, ptr %88, align 8
  %905 = zext nneg i32 %spec.select.i1298 to i64
  %906 = shl nuw nsw i64 %905, 5
  %result.i5.i1299 = call noalias ptr @bump_malloc_wrapper(i64 noundef %906) #48
  store ptr %result.i5.i1299, ptr %89, align 8
  %result.i4.i1300 = call noalias ptr @bump_malloc_wrapper(i64 noundef %906) #48
  store ptr %result.i4.i1300, ptr %90, align 8
  store i32 0, ptr %91, align 4
  %907 = icmp sgt i32 %903, 0
  br i1 %907, label %.lr.ph.i2377, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2413.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2413.thread: ; preds = %898
  %908 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i2377:                                     ; preds = %898
  %wide.trip.count.i2390 = zext nneg i32 %903 to i64
  br label %909

909:                                              ; preds = %._crit_edge.i2393, %.lr.ph.i2377
  %indvars.iv.i2391 = phi i64 [ 0, %.lr.ph.i2377 ], [ %indvars.iv.next.i2394, %._crit_edge.i2393 ]
  %910 = shl nuw nsw i64 %indvars.iv.i2391, 5
  %911 = getelementptr i8, ptr %901, i64 %910
  %912 = load ptr, ptr %911, align 8
  %913 = icmp ne ptr %912, @nil_typ
  %914 = icmp ne ptr %912, null
  %.not17.i2392 = and i1 %913, %914
  br i1 %.not17.i2392, label %915, label %._crit_edge.i2393

915:                                              ; preds = %909
  %916 = getelementptr i8, ptr %911, i64 8
  %917 = load i64, ptr %916, align 4
  %.sroa_idx.i2396 = getelementptr i8, ptr %911, i64 16
  %918 = load i64, ptr %.sroa_idx.i2396, align 4
  %hash_coef_ptr.i.i6.i2397 = getelementptr i8, ptr %912, i64 8
  %tbl_size_ptr.i.i7.i2398 = getelementptr i8, ptr %912, i64 16
  %offset_tbl_ptr.i.i8.i2399 = getelementptr i8, ptr %912, i64 40
  %919 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  %hash_coef.i.i21.i3078 = load i64, ptr %hash_coef_ptr.i.i6.i2397, align 4, !noalias !356
  %tbl_size.i.i22.i3079 = load i64, ptr %tbl_size_ptr.i.i7.i2398, align 4, !noalias !356
  %offset_tbl.i.i23.i3080 = load ptr, ptr %offset_tbl_ptr.i.i8.i2399, align 8, !noalias !356
  %product.i.i.i24.i3081 = mul i64 %hash_coef.i.i21.i3078, 4015701072841558310
  %shifted.i.i.i25.i3082 = lshr i64 %product.i.i.i24.i3081, 32
  %xored.i.i.i26.i3083 = xor i64 %shifted.i.i.i25.i3082, %product.i.i.i24.i3081
  %hash.i.i.i27.i3084 = and i64 %xored.i.i.i26.i3083, %tbl_size.i.i22.i3079
  %offset_ptr.i.i28.i3085 = getelementptr i32, ptr %offset_tbl.i.i23.i3080, i64 %hash.i.i.i27.i3084
  %offset.i.i29.i3086 = load i32, ptr %offset_ptr.i.i28.i3085, align 4, !noalias !356
  %920 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %921 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %922 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %923

923:                                              ; preds = %.cont.i3109, %915
  %.0290.i3087 = phi i32 [ 0, %915 ], [ %956, %.cont.i3109 ]
  %.074289.i3088 = phi i1 [ true, %915 ], [ %957, %.cont.i3109 ]
  %.sroa.0.0288.i3089 = phi ptr [ %912, %915 ], [ %946, %.cont.i3109 ]
  %.sroa.6.0287.i3090.in = phi i64 [ %917, %915 ], [ %948, %.cont.i3109 ]
  %.sroa.12.0286.i3091.in = phi i64 [ %918, %915 ], [ %949, %.cont.i3109 ]
  %.sroa.17.0285.i3092 = phi i32 [ %offset.i.i29.i3086, %915 ], [ %offset.i.i57.i3121, %.cont.i3109 ]
  %.sroa.12.0286.i3091 = inttoptr i64 %.sroa.12.0286.i3091.in to ptr
  %.sroa.6.0287.i3090 = inttoptr i64 %.sroa.6.0287.i3090.in to ptr
  %924 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3089, 0
  %925 = insertvalue { ptr, ptr, ptr, i32 } %924, ptr %.sroa.6.0287.i3090, 1
  %926 = insertvalue { ptr, ptr, ptr, i32 } %925, ptr %.sroa.12.0286.i3091, 2
  %927 = insertvalue { ptr, ptr, ptr, i32 } %926, i32 %.sroa.17.0285.i3092, 3
  %928 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3089)
  %929 = sext i32 %.sroa.17.0285.i3092 to i64
  %930 = getelementptr ptr, ptr %.sroa.0.0288.i3089, i64 %929
  %931 = getelementptr i8, ptr %930, i64 64
  %932 = load ptr, ptr %931, align 8
  %result.i15.i3093 = call ptr %932({ ptr, ptr, ptr, i32 } %927, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %933 = call i32 %result.i15.i3093({ ptr, ptr, ptr, i32 } %927, { ptr, ptr, ptr, i32 } %927, ptr nonnull align 8 %2) #53
  %..i3094 = select i1 %.074289.i3088, ptr %32, ptr %34
  %.188.i3095 = select i1 %.074289.i3088, i64 104, i64 112
  %.189.i3096 = select i1 %.074289.i3088, ptr %33, ptr %35
  %.190.i3097 = select i1 %.074289.i3088, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3094, align 8
  %934 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3094)
  %935 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3095
  %936 = load ptr, ptr %935, align 8
  store ptr @i32_typ, ptr %.189.i3096, align 8
  %result.i14.i3098 = call ptr %936({ ptr, ptr, ptr, i32 } %126, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3096) #46
  %937 = call i32 %result.i14.i3098({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull align 8 dereferenceable(8) %..i3094, i32 %933) #53
  %938 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %939 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3097
  %940 = load ptr, ptr %939, align 8
  %941 = load ptr, ptr %940, align 8
  %942 = call { ptr } %941(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i3099 = extractvalue { ptr } %942, 0
  %943 = sext i32 %937 to i64
  %944 = shl nsw i64 %943, 5
  %945 = getelementptr i8, ptr %.fca.0.extract55.i3099, i64 %944
  %946 = load ptr, ptr %945, align 8
  %947 = getelementptr i8, ptr %945, i64 8
  %948 = load i64, ptr %947, align 4
  %.sroa_idx.i3100 = getelementptr i8, ptr %945, i64 16
  %949 = load i64, ptr %.sroa_idx.i3100, align 4
  %950 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %951 = call { ptr } %941(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i3101 = extractvalue { ptr } %951, 0
  %952 = getelementptr i8, ptr %.fca.0.extract52.i3101, i64 %944
  store ptr %.sroa.0.0288.i3089, ptr %952, align 8
  %953 = getelementptr i8, ptr %952, i64 8
  store i64 %.sroa.6.0287.i3090.in, ptr %953, align 4
  %.sroa_idx104.i3102 = getelementptr i8, ptr %952, i64 16
  store i64 %.sroa.12.0286.i3091.in, ptr %.sroa_idx104.i3102, align 4
  %.sroa_idx105.i3103 = getelementptr i8, ptr %952, i64 24
  store i32 %.sroa.17.0285.i3092, ptr %.sroa_idx105.i3103, align 4
  %954 = icmp ne ptr %946, @nil_typ
  %955 = icmp ne ptr %946, null
  %.not94.i3104 = and i1 %954, %955
  br i1 %.not94.i3104, label %.cont.i3109, label %960

.cont.i3109:                                      ; preds = %923
  %956 = add nuw nsw i32 %.0290.i3087, 1
  %957 = xor i1 %.074289.i3088, true
  %hash_coef_ptr.i.i46.i3110 = getelementptr i8, ptr %946, i64 8
  %tbl_size_ptr.i.i47.i3111 = getelementptr i8, ptr %946, i64 16
  %offset_tbl_ptr.i.i48.i3112 = getelementptr i8, ptr %946, i64 40
  %hash_coef.i.i49.i3113 = load i64, ptr %hash_coef_ptr.i.i46.i3110, align 4
  %tbl_size.i.i50.i3114 = load i64, ptr %tbl_size_ptr.i.i47.i3111, align 4
  %offset_tbl.i.i51.i3115 = load ptr, ptr %offset_tbl_ptr.i.i48.i3112, align 8
  %product.i.i.i52.i3116 = mul i64 %hash_coef.i.i49.i3113, 4015701072841558310
  %shifted.i.i.i53.i3117 = lshr i64 %product.i.i.i52.i3116, 32
  %xored.i.i.i54.i3118 = xor i64 %shifted.i.i.i53.i3117, %product.i.i.i52.i3116
  %hash.i.i.i55.i3119 = and i64 %xored.i.i.i54.i3118, %tbl_size.i.i50.i3114
  %offset_ptr.i.i56.i3120 = getelementptr i32, ptr %offset_tbl.i.i51.i3115, i64 %hash.i.i.i55.i3119
  %offset.i.i57.i3121 = load i32, ptr %offset_ptr.i.i56.i3120, align 4
  %958 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %959 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3122 = icmp eq i32 %956, 100
  br i1 %exitcond.not.i3122, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131, label %923

960:                                              ; preds = %923
  %961 = load i32, ptr %91, align 4
  %962 = add i32 %961, 1
  %963 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %962, ptr %91, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131: ; preds = %960, %.cont.i3109
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  br label %._crit_edge.i2393

._crit_edge.i2393:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3131, %909
  %indvars.iv.next.i2394 = add nuw nsw i64 %indvars.iv.i2391, 1
  %exitcond.not.i2395 = icmp eq i64 %indvars.iv.next.i2394, %wide.trip.count.i2390
  br i1 %exitcond.not.i2395, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2413, label %909

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2413: ; preds = %._crit_edge.i2393
  %964 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %965

965:                                              ; preds = %._crit_edge.i2431, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2413
  %indvars.iv.i2429 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2413 ], [ %indvars.iv.next.i2432, %._crit_edge.i2431 ]
  %966 = shl nuw nsw i64 %indvars.iv.i2429, 5
  %967 = getelementptr i8, ptr %902, i64 %966
  %968 = load ptr, ptr %967, align 8
  %969 = icmp ne ptr %968, @nil_typ
  %970 = icmp ne ptr %968, null
  %.not17.i2430 = and i1 %969, %970
  br i1 %.not17.i2430, label %971, label %._crit_edge.i2431

971:                                              ; preds = %965
  %972 = getelementptr i8, ptr %967, i64 8
  %973 = load i64, ptr %972, align 4
  %.sroa_idx.i2434 = getelementptr i8, ptr %967, i64 16
  %974 = load i64, ptr %.sroa_idx.i2434, align 4
  %hash_coef_ptr.i.i6.i2435 = getelementptr i8, ptr %968, i64 8
  %tbl_size_ptr.i.i7.i2436 = getelementptr i8, ptr %968, i64 16
  %offset_tbl_ptr.i.i8.i2437 = getelementptr i8, ptr %968, i64 40
  %975 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %hash_coef.i.i21.i3149 = load i64, ptr %hash_coef_ptr.i.i6.i2435, align 4, !noalias !359
  %tbl_size.i.i22.i3150 = load i64, ptr %tbl_size_ptr.i.i7.i2436, align 4, !noalias !359
  %offset_tbl.i.i23.i3151 = load ptr, ptr %offset_tbl_ptr.i.i8.i2437, align 8, !noalias !359
  %product.i.i.i24.i3152 = mul i64 %hash_coef.i.i21.i3149, 4015701072841558310
  %shifted.i.i.i25.i3153 = lshr i64 %product.i.i.i24.i3152, 32
  %xored.i.i.i26.i3154 = xor i64 %shifted.i.i.i25.i3153, %product.i.i.i24.i3152
  %hash.i.i.i27.i3155 = and i64 %xored.i.i.i26.i3154, %tbl_size.i.i22.i3150
  %offset_ptr.i.i28.i3156 = getelementptr i32, ptr %offset_tbl.i.i23.i3151, i64 %hash.i.i.i27.i3155
  %offset.i.i29.i3157 = load i32, ptr %offset_ptr.i.i28.i3156, align 4, !noalias !359
  %976 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %979

979:                                              ; preds = %.cont.i3180, %971
  %.0290.i3158 = phi i32 [ 0, %971 ], [ %1012, %.cont.i3180 ]
  %.074289.i3159 = phi i1 [ true, %971 ], [ %1013, %.cont.i3180 ]
  %.sroa.0.0288.i3160 = phi ptr [ %968, %971 ], [ %1002, %.cont.i3180 ]
  %.sroa.6.0287.i3161.in = phi i64 [ %973, %971 ], [ %1004, %.cont.i3180 ]
  %.sroa.12.0286.i3162.in = phi i64 [ %974, %971 ], [ %1005, %.cont.i3180 ]
  %.sroa.17.0285.i3163 = phi i32 [ %offset.i.i29.i3157, %971 ], [ %offset.i.i57.i3192, %.cont.i3180 ]
  %.sroa.12.0286.i3162 = inttoptr i64 %.sroa.12.0286.i3162.in to ptr
  %.sroa.6.0287.i3161 = inttoptr i64 %.sroa.6.0287.i3161.in to ptr
  %980 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3160, 0
  %981 = insertvalue { ptr, ptr, ptr, i32 } %980, ptr %.sroa.6.0287.i3161, 1
  %982 = insertvalue { ptr, ptr, ptr, i32 } %981, ptr %.sroa.12.0286.i3162, 2
  %983 = insertvalue { ptr, ptr, ptr, i32 } %982, i32 %.sroa.17.0285.i3163, 3
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3160)
  %985 = sext i32 %.sroa.17.0285.i3163 to i64
  %986 = getelementptr ptr, ptr %.sroa.0.0288.i3160, i64 %985
  %987 = getelementptr i8, ptr %986, i64 64
  %988 = load ptr, ptr %987, align 8
  %result.i15.i3164 = call ptr %988({ ptr, ptr, ptr, i32 } %983, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %989 = call i32 %result.i15.i3164({ ptr, ptr, ptr, i32 } %983, { ptr, ptr, ptr, i32 } %983, ptr nonnull align 8 %2) #53
  %..i3165 = select i1 %.074289.i3159, ptr %28, ptr %30
  %.188.i3166 = select i1 %.074289.i3159, i64 104, i64 112
  %.189.i3167 = select i1 %.074289.i3159, ptr %29, ptr %31
  %.190.i3168 = select i1 %.074289.i3159, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3165, align 8
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3165)
  %991 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3166
  %992 = load ptr, ptr %991, align 8
  store ptr @i32_typ, ptr %.189.i3167, align 8
  %result.i14.i3169 = call ptr %992({ ptr, ptr, ptr, i32 } %126, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3167) #46
  %993 = call i32 %result.i14.i3169({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull align 8 dereferenceable(8) %..i3165, i32 %989) #53
  %994 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %995 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3168
  %996 = load ptr, ptr %995, align 8
  %997 = load ptr, ptr %996, align 8
  %998 = call { ptr } %997(ptr nonnull %result.i83) #43
  %.fca.0.extract55.i3170 = extractvalue { ptr } %998, 0
  %999 = sext i32 %993 to i64
  %1000 = shl nsw i64 %999, 5
  %1001 = getelementptr i8, ptr %.fca.0.extract55.i3170, i64 %1000
  %1002 = load ptr, ptr %1001, align 8
  %1003 = getelementptr i8, ptr %1001, i64 8
  %1004 = load i64, ptr %1003, align 4
  %.sroa_idx.i3171 = getelementptr i8, ptr %1001, i64 16
  %1005 = load i64, ptr %.sroa_idx.i3171, align 4
  %1006 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1007 = call { ptr } %997(ptr nonnull %result.i83) #43
  %.fca.0.extract52.i3172 = extractvalue { ptr } %1007, 0
  %1008 = getelementptr i8, ptr %.fca.0.extract52.i3172, i64 %1000
  store ptr %.sroa.0.0288.i3160, ptr %1008, align 8
  %1009 = getelementptr i8, ptr %1008, i64 8
  store i64 %.sroa.6.0287.i3161.in, ptr %1009, align 4
  %.sroa_idx104.i3173 = getelementptr i8, ptr %1008, i64 16
  store i64 %.sroa.12.0286.i3162.in, ptr %.sroa_idx104.i3173, align 4
  %.sroa_idx105.i3174 = getelementptr i8, ptr %1008, i64 24
  store i32 %.sroa.17.0285.i3163, ptr %.sroa_idx105.i3174, align 4
  %1010 = icmp ne ptr %1002, @nil_typ
  %1011 = icmp ne ptr %1002, null
  %.not94.i3175 = and i1 %1010, %1011
  br i1 %.not94.i3175, label %.cont.i3180, label %1016

.cont.i3180:                                      ; preds = %979
  %1012 = add nuw nsw i32 %.0290.i3158, 1
  %1013 = xor i1 %.074289.i3159, true
  %hash_coef_ptr.i.i46.i3181 = getelementptr i8, ptr %1002, i64 8
  %tbl_size_ptr.i.i47.i3182 = getelementptr i8, ptr %1002, i64 16
  %offset_tbl_ptr.i.i48.i3183 = getelementptr i8, ptr %1002, i64 40
  %hash_coef.i.i49.i3184 = load i64, ptr %hash_coef_ptr.i.i46.i3181, align 4
  %tbl_size.i.i50.i3185 = load i64, ptr %tbl_size_ptr.i.i47.i3182, align 4
  %offset_tbl.i.i51.i3186 = load ptr, ptr %offset_tbl_ptr.i.i48.i3183, align 8
  %product.i.i.i52.i3187 = mul i64 %hash_coef.i.i49.i3184, 4015701072841558310
  %shifted.i.i.i53.i3188 = lshr i64 %product.i.i.i52.i3187, 32
  %xored.i.i.i54.i3189 = xor i64 %shifted.i.i.i53.i3188, %product.i.i.i52.i3187
  %hash.i.i.i55.i3190 = and i64 %xored.i.i.i54.i3189, %tbl_size.i.i50.i3185
  %offset_ptr.i.i56.i3191 = getelementptr i32, ptr %offset_tbl.i.i51.i3186, i64 %hash.i.i.i55.i3190
  %offset.i.i57.i3192 = load i32, ptr %offset_ptr.i.i56.i3191, align 4
  %1014 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1015 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3193 = icmp eq i32 %1012, 100
  br i1 %exitcond.not.i3193, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202, label %979

1016:                                             ; preds = %979
  %1017 = load i32, ptr %91, align 4
  %1018 = add i32 %1017, 1
  %1019 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1018, ptr %91, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202: ; preds = %1016, %.cont.i3180
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  br label %._crit_edge.i2431

._crit_edge.i2431:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202, %965
  %indvars.iv.next.i2432 = add nuw nsw i64 %indvars.iv.i2429, 1
  %exitcond.not.i2433 = icmp eq i64 %indvars.iv.next.i2432, %wide.trip.count.i2390
  br i1 %exitcond.not.i2433, label %CuckooMap_insert_keyK_valueV.exit, label %965

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i2431, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2413.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1282, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1152, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store ptr @_parameterization_i32, ptr %69, align 8
  %1020 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %69)
  %1021 = load ptr, ptr %97, align 8
  %1022 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %1023 = sext i32 %.0376301 to i64
  %1024 = shl nsw i64 %1023, 2
  %1025 = getelementptr i8, ptr %1021, i64 %1024
  store i32 %132, ptr %1025, align 1
  store i1 true, ptr %.sroa.0335.sroa.0, align 8
  %.sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.0. = load i8, ptr %.sroa.0335.sroa.0, align 8
  %.sroa.0335.0.insert.ext = zext i8 %.sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.0. to i160
  %1026 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0335.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %70, align 8
  %1027 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %70)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1028 = load ptr, ptr %105, align 8
  %1029 = call i32 %1028({ ptr, i160 } %133) #53
  %1030 = load i32, ptr %107, align 8
  %1031 = add i32 %1030, -1
  %1032 = and i32 %1031, %1029
  %1033 = load ptr, ptr %108, align 8
  %1034 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1035 = sext i32 %1032 to i64
  %1036 = shl nsw i64 %1035, 5
  %1037 = getelementptr i8, ptr %1033, i64 %1036
  %1038 = load ptr, ptr %1037, align 8
  %1039 = getelementptr i8, ptr %1037, i64 8
  %1040 = icmp ne ptr %1038, @nil_typ
  %1041 = icmp ne ptr %1038, null
  %.not66.i1346 = and i1 %1040, %1041
  br i1 %.not66.i1346, label %1042, label %1140

1042:                                             ; preds = %CuckooMap_insert_keyK_valueV.exit
  %1043 = load i64, ptr %1039, align 4
  %.sroa_idx.i1348 = getelementptr i8, ptr %1037, i64 16
  %1044 = load i64, ptr %.sroa_idx.i1348, align 4
  %1045 = inttoptr i64 %1043 to ptr
  %1046 = inttoptr i64 %1044 to ptr
  %hash_coef_ptr.i.i11.i1349 = getelementptr i8, ptr %1038, i64 8
  %tbl_size_ptr.i.i12.i1350 = getelementptr i8, ptr %1038, i64 16
  %offset_tbl_ptr.i.i13.i1351 = getelementptr i8, ptr %1038, i64 40
  %hash_coef.i.i14.i1352 = load i64, ptr %hash_coef_ptr.i.i11.i1349, align 4, !noalias !362
  %tbl_size.i.i15.i1353 = load i64, ptr %tbl_size_ptr.i.i12.i1350, align 4, !noalias !362
  %offset_tbl.i.i16.i1354 = load ptr, ptr %offset_tbl_ptr.i.i13.i1351, align 8, !noalias !362
  %product.i.i.i17.i1355 = mul i64 %hash_coef.i.i14.i1352, 4015701072841558310
  %shifted.i.i.i18.i1356 = lshr i64 %product.i.i.i17.i1355, 32
  %xored.i.i.i19.i1357 = xor i64 %shifted.i.i.i18.i1356, %product.i.i.i17.i1355
  %hash.i.i.i20.i1358 = and i64 %xored.i.i.i19.i1357, %tbl_size.i.i15.i1353
  %offset_ptr.i.i21.i1359 = getelementptr i32, ptr %offset_tbl.i.i16.i1354, i64 %hash.i.i.i20.i1358
  %offset.i.i22.i1360 = load i32, ptr %offset_ptr.i.i21.i1359, align 4, !noalias !362
  %1047 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1038, 0
  %1048 = insertvalue { ptr, ptr, ptr, i32 } %1047, ptr %1045, 1
  %1049 = insertvalue { ptr, ptr, ptr, i32 } %1048, ptr %1046, 2
  %1050 = insertvalue { ptr, ptr, ptr, i32 } %1049, i32 %offset.i.i22.i1360, 3
  %1051 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1052 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1038) #40
  %1053 = sext i32 %offset.i.i22.i1360 to i64
  %1054 = getelementptr ptr, ptr %1038, i64 %1053
  %1055 = getelementptr i8, ptr %1054, i64 64
  %1056 = load ptr, ptr %1055, align 8
  %result.i8.i1361 = call ptr %1056({ ptr, ptr, ptr, i32 } %1050, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1057 = call i32 %result.i8.i1361({ ptr, ptr, ptr, i32 } %1050, { ptr, ptr, ptr, i32 } %1050, ptr nonnull align 8 %2) #53
  %1058 = icmp eq i32 %1057, %1029
  br i1 %1058, label %._crit_edge.i1362, label %1140

._crit_edge.i1362:                                ; preds = %1042
  %1059 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1060 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1038)
  %1061 = getelementptr i8, ptr %1054, i64 48
  %1062 = load ptr, ptr %1061, align 8
  %result.i7.i1363 = call ptr %1062({ ptr, ptr, ptr, i32 } %1050, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1063 = call { ptr, i160 } %result.i7.i1363({ ptr, ptr, ptr, i32 } %1050, { ptr, ptr, ptr, i32 } %1050, ptr nonnull align 8 %2) #53
  %1064 = load ptr, ptr %106, align 8
  %1065 = call i1 %1064({ ptr, i160 } %1063, { ptr, i160 } %133) #53
  br i1 %1065, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1375, label %1140

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1375: ; preds = %._crit_edge.i1362
  %1066 = load ptr, ptr %result.i78, align 8
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1068 = load ptr, ptr %100, align 8
  %1069 = load ptr, ptr %1066, align 8, !alias.scope !365
  %1070 = getelementptr i8, ptr %1069, i64 72
  %1071 = load ptr, ptr %1070, align 8, !alias.scope !365
  %result.i1.i.i1367 = call { i64, i64 } %1071(ptr nocapture nofree nonnull readonly align 8 %1066) #44, !alias.scope !365
  %1072 = extractvalue { i64, i64 } %result.i1.i.i1367, 0
  %1073 = extractvalue { i64, i64 } %result.i1.i.i1367, 1
  %1074 = urem i64 20, %1073
  %1075 = icmp eq i64 %1074, 0
  %1076 = sub i64 %1073, %1074
  %1077 = select i1 %1075, i64 0, i64 %1076
  %1078 = add i64 %1072, 20
  %1079 = add i64 %1078, %1077
  %1080 = load ptr, ptr %1068, align 8, !alias.scope !365
  %1081 = getelementptr i8, ptr %1080, i64 72
  %1082 = load ptr, ptr %1081, align 8, !alias.scope !365
  %result.i.i.i1368 = call { i64, i64 } %1082(ptr nocapture nofree nonnull readonly align 8 %1068) #44, !alias.scope !365
  %1083 = extractvalue { i64, i64 } %result.i.i.i1368, 0
  %1084 = extractvalue { i64, i64 } %result.i.i.i1368, 1
  %1085 = call i64 @llvm.umax.i64(i64 %1073, i64 %1084) #41
  %1086 = call i64 @llvm.umax.i64(i64 %1085, i64 noundef 8) #41, !range !16
  %1087 = urem i64 %1079, %1084
  %1088 = icmp eq i64 %1087, 0
  %1089 = sub i64 %1084, %1087
  %1090 = select i1 %1088, i64 0, i64 %1089
  %1091 = add i64 %1083, %1079
  %1092 = add i64 %1091, %1090
  %1093 = urem i64 %1092, %1086
  %1094 = icmp eq i64 %1093, 0
  %1095 = sub i64 %1086, %1093
  %1096 = select i1 %1094, i64 0, i64 %1095
  %1097 = add i64 %1096, %1092
  %result.i9.i1369 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1097) #48
  store ptr %1066, ptr %result.i9.i1369, align 8
  %1098 = getelementptr inbounds i8, ptr %result.i9.i1369, i64 8
  store ptr %1068, ptr %1098, align 8
  %1099 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1369)
  %1100 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1101 = load ptr, ptr %1066, align 8
  %1102 = getelementptr i8, ptr %1101, i64 72
  %1103 = load ptr, ptr %1102, align 8
  %result.i.i38.i1370 = call { i64, i64 } %1103(ptr nocapture nofree nonnull readonly align 8 %1066) #44
  %1104 = extractvalue { i64, i64 } %result.i.i38.i1370, 1
  %1105 = urem i64 20, %1104
  %1106 = icmp eq i64 %1105, 0
  %reass.sub3927 = sub i64 %1104, %1105
  %1107 = add i64 %reass.sub3927, 20
  %1108 = select i1 %1106, i64 20, i64 %1107
  %1109 = getelementptr i8, ptr %result.i9.i1369, i64 %1108
  %1110 = getelementptr i8, ptr %1101, i64 64
  %1111 = load ptr, ptr %1110, align 8
  call void %1111({ ptr, i160 } %133, ptr nocapture nofree nonnull readonly align 8 %1066, ptr nocapture nofree writeonly %1109) #45
  %1112 = load ptr, ptr %result.i9.i1369, align 8
  %1113 = load ptr, ptr %1112, align 8
  %1114 = getelementptr i8, ptr %1113, i64 72
  %1115 = load ptr, ptr %1114, align 8
  %result.i1.i39.i1372 = call { i64, i64 } %1115(ptr nocapture nofree nonnull readonly align 8 %1112) #44
  %1116 = extractvalue { i64, i64 } %result.i1.i39.i1372, 0
  %1117 = extractvalue { i64, i64 } %result.i1.i39.i1372, 1
  %1118 = urem i64 20, %1117
  %1119 = icmp eq i64 %1118, 0
  %1120 = sub i64 %1117, %1118
  %1121 = select i1 %1119, i64 0, i64 %1120
  %1122 = add i64 %1116, 20
  %1123 = add i64 %1122, %1121
  %1124 = load ptr, ptr %1098, align 8
  %1125 = load ptr, ptr %1124, align 8
  %1126 = getelementptr i8, ptr %1125, i64 72
  %1127 = load ptr, ptr %1126, align 8
  %result.i.i40.i1373 = call { i64, i64 } %1127(ptr nocapture nofree nonnull readonly align 8 %1124) #44
  %1128 = extractvalue { i64, i64 } %result.i.i40.i1373, 1
  %1129 = urem i64 %1123, %1128
  %1130 = icmp eq i64 %1129, 0
  %1131 = sub i64 %1128, %1129
  %1132 = select i1 %1130, i64 0, i64 %1131
  %1133 = getelementptr i8, ptr %result.i9.i1369, i64 %1123
  %1134 = getelementptr i8, ptr %1133, i64 %1132
  %1135 = getelementptr i8, ptr %1125, i64 64
  %1136 = load ptr, ptr %1135, align 8
  call void %1136({ ptr, i160 } %1026, ptr nocapture nofree nonnull readonly align 8 %1124, ptr nocapture nofree writeonly %1134) #45
  %1137 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1138 = getelementptr inbounds i8, ptr %result.i9.i1369, i64 16
  store i32 %1029, ptr %1138, align 8
  store ptr @Entry, ptr %1037, align 8
  %1139 = ptrtoint ptr %result.i9.i1369 to i64
  store i64 %1139, ptr %1039, align 4
  %.sroa_idx30.i1374 = getelementptr i8, ptr %1037, i64 24
  store i32 10, ptr %.sroa_idx30.i1374, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit530

1140:                                             ; preds = %._crit_edge.i1362, %1042, %CuckooMap_insert_keyK_valueV.exit
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1141 = add i32 %1029, 2127912214
  %1142 = shl i32 %1029, 12
  %1143 = add i32 %1141, %1142
  %1144 = ashr i32 %1143, 19
  %1145 = xor i32 %1143, %1144
  %1146 = xor i32 %1145, -949894596
  %1147 = add i32 %1146, 374761393
  %1148 = shl i32 %1146, 5
  %1149 = add i32 %1147, %1148
  %1150 = add i32 %1149, -744332180
  %1151 = shl i32 %1149, 9
  %1152 = xor i32 %1150, %1151
  %1153 = add i32 %1152, -42973499
  %1154 = shl i32 %1152, 3
  %1155 = add i32 %1153, %1154
  %1156 = ashr i32 %1155, 16
  %1157 = xor i32 %1155, %1156
  %1158 = xor i32 %1157, -1252372727
  %1159 = load i32, ptr %107, align 8
  %1160 = add i32 %1159, -1
  %1161 = and i32 %1160, %1158
  %1162 = load ptr, ptr %109, align 8
  %1163 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1164 = sext i32 %1161 to i64
  %1165 = shl nsw i64 %1164, 5
  %1166 = getelementptr i8, ptr %1162, i64 %1165
  %1167 = load ptr, ptr %1166, align 8
  %1168 = getelementptr i8, ptr %1166, i64 8
  %1169 = icmp ne ptr %1167, @nil_typ
  %1170 = icmp ne ptr %1167, null
  %.not66.i1405 = and i1 %1169, %1170
  br i1 %.not66.i1405, label %1171, label %1269

1171:                                             ; preds = %1140
  %1172 = load i64, ptr %1168, align 4
  %.sroa_idx.i1407 = getelementptr i8, ptr %1166, i64 16
  %1173 = load i64, ptr %.sroa_idx.i1407, align 4
  %1174 = inttoptr i64 %1172 to ptr
  %1175 = inttoptr i64 %1173 to ptr
  %hash_coef_ptr.i.i11.i1408 = getelementptr i8, ptr %1167, i64 8
  %tbl_size_ptr.i.i12.i1409 = getelementptr i8, ptr %1167, i64 16
  %offset_tbl_ptr.i.i13.i1410 = getelementptr i8, ptr %1167, i64 40
  %hash_coef.i.i14.i1411 = load i64, ptr %hash_coef_ptr.i.i11.i1408, align 4, !noalias !368
  %tbl_size.i.i15.i1412 = load i64, ptr %tbl_size_ptr.i.i12.i1409, align 4, !noalias !368
  %offset_tbl.i.i16.i1413 = load ptr, ptr %offset_tbl_ptr.i.i13.i1410, align 8, !noalias !368
  %product.i.i.i17.i1414 = mul i64 %hash_coef.i.i14.i1411, 4015701072841558310
  %shifted.i.i.i18.i1415 = lshr i64 %product.i.i.i17.i1414, 32
  %xored.i.i.i19.i1416 = xor i64 %shifted.i.i.i18.i1415, %product.i.i.i17.i1414
  %hash.i.i.i20.i1417 = and i64 %xored.i.i.i19.i1416, %tbl_size.i.i15.i1412
  %offset_ptr.i.i21.i1418 = getelementptr i32, ptr %offset_tbl.i.i16.i1413, i64 %hash.i.i.i20.i1417
  %offset.i.i22.i1419 = load i32, ptr %offset_ptr.i.i21.i1418, align 4, !noalias !368
  %1176 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1167, 0
  %1177 = insertvalue { ptr, ptr, ptr, i32 } %1176, ptr %1174, 1
  %1178 = insertvalue { ptr, ptr, ptr, i32 } %1177, ptr %1175, 2
  %1179 = insertvalue { ptr, ptr, ptr, i32 } %1178, i32 %offset.i.i22.i1419, 3
  %1180 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1181 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1167) #40
  %1182 = sext i32 %offset.i.i22.i1419 to i64
  %1183 = getelementptr ptr, ptr %1167, i64 %1182
  %1184 = getelementptr i8, ptr %1183, i64 64
  %1185 = load ptr, ptr %1184, align 8
  %result.i8.i1420 = call ptr %1185({ ptr, ptr, ptr, i32 } %1179, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1186 = call i32 %result.i8.i1420({ ptr, ptr, ptr, i32 } %1179, { ptr, ptr, ptr, i32 } %1179, ptr nonnull align 8 %2) #53
  %1187 = icmp eq i32 %1186, %1029
  br i1 %1187, label %._crit_edge.i1421, label %1269

._crit_edge.i1421:                                ; preds = %1171
  %1188 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1189 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1167)
  %1190 = getelementptr i8, ptr %1183, i64 48
  %1191 = load ptr, ptr %1190, align 8
  %result.i7.i1422 = call ptr %1191({ ptr, ptr, ptr, i32 } %1179, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1192 = call { ptr, i160 } %result.i7.i1422({ ptr, ptr, ptr, i32 } %1179, { ptr, ptr, ptr, i32 } %1179, ptr nonnull align 8 %2) #53
  %1193 = load ptr, ptr %106, align 8
  %1194 = call i1 %1193({ ptr, i160 } %1192, { ptr, i160 } %133) #53
  br i1 %1194, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1434, label %1269

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1434: ; preds = %._crit_edge.i1421
  %1195 = load ptr, ptr %result.i78, align 8
  %1196 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1197 = load ptr, ptr %100, align 8
  %1198 = load ptr, ptr %1195, align 8, !alias.scope !371
  %1199 = getelementptr i8, ptr %1198, i64 72
  %1200 = load ptr, ptr %1199, align 8, !alias.scope !371
  %result.i1.i.i1426 = call { i64, i64 } %1200(ptr nocapture nofree nonnull readonly align 8 %1195) #44, !alias.scope !371
  %1201 = extractvalue { i64, i64 } %result.i1.i.i1426, 0
  %1202 = extractvalue { i64, i64 } %result.i1.i.i1426, 1
  %1203 = urem i64 20, %1202
  %1204 = icmp eq i64 %1203, 0
  %1205 = sub i64 %1202, %1203
  %1206 = select i1 %1204, i64 0, i64 %1205
  %1207 = add i64 %1201, 20
  %1208 = add i64 %1207, %1206
  %1209 = load ptr, ptr %1197, align 8, !alias.scope !371
  %1210 = getelementptr i8, ptr %1209, i64 72
  %1211 = load ptr, ptr %1210, align 8, !alias.scope !371
  %result.i.i.i1427 = call { i64, i64 } %1211(ptr nocapture nofree nonnull readonly align 8 %1197) #44, !alias.scope !371
  %1212 = extractvalue { i64, i64 } %result.i.i.i1427, 0
  %1213 = extractvalue { i64, i64 } %result.i.i.i1427, 1
  %1214 = call i64 @llvm.umax.i64(i64 %1202, i64 %1213) #41
  %1215 = call i64 @llvm.umax.i64(i64 %1214, i64 noundef 8) #41, !range !16
  %1216 = urem i64 %1208, %1213
  %1217 = icmp eq i64 %1216, 0
  %1218 = sub i64 %1213, %1216
  %1219 = select i1 %1217, i64 0, i64 %1218
  %1220 = add i64 %1212, %1208
  %1221 = add i64 %1220, %1219
  %1222 = urem i64 %1221, %1215
  %1223 = icmp eq i64 %1222, 0
  %1224 = sub i64 %1215, %1222
  %1225 = select i1 %1223, i64 0, i64 %1224
  %1226 = add i64 %1225, %1221
  %result.i9.i1428 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1226) #48
  store ptr %1195, ptr %result.i9.i1428, align 8
  %1227 = getelementptr inbounds i8, ptr %result.i9.i1428, i64 8
  store ptr %1197, ptr %1227, align 8
  %1228 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i1428)
  %1229 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1230 = load ptr, ptr %1195, align 8
  %1231 = getelementptr i8, ptr %1230, i64 72
  %1232 = load ptr, ptr %1231, align 8
  %result.i.i38.i1429 = call { i64, i64 } %1232(ptr nocapture nofree nonnull readonly align 8 %1195) #44
  %1233 = extractvalue { i64, i64 } %result.i.i38.i1429, 1
  %1234 = urem i64 20, %1233
  %1235 = icmp eq i64 %1234, 0
  %reass.sub3926 = sub i64 %1233, %1234
  %1236 = add i64 %reass.sub3926, 20
  %1237 = select i1 %1235, i64 20, i64 %1236
  %1238 = getelementptr i8, ptr %result.i9.i1428, i64 %1237
  %1239 = getelementptr i8, ptr %1230, i64 64
  %1240 = load ptr, ptr %1239, align 8
  call void %1240({ ptr, i160 } %133, ptr nocapture nofree nonnull readonly align 8 %1195, ptr nocapture nofree writeonly %1238) #45
  %1241 = load ptr, ptr %result.i9.i1428, align 8
  %1242 = load ptr, ptr %1241, align 8
  %1243 = getelementptr i8, ptr %1242, i64 72
  %1244 = load ptr, ptr %1243, align 8
  %result.i1.i39.i1431 = call { i64, i64 } %1244(ptr nocapture nofree nonnull readonly align 8 %1241) #44
  %1245 = extractvalue { i64, i64 } %result.i1.i39.i1431, 0
  %1246 = extractvalue { i64, i64 } %result.i1.i39.i1431, 1
  %1247 = urem i64 20, %1246
  %1248 = icmp eq i64 %1247, 0
  %1249 = sub i64 %1246, %1247
  %1250 = select i1 %1248, i64 0, i64 %1249
  %1251 = add i64 %1245, 20
  %1252 = add i64 %1251, %1250
  %1253 = load ptr, ptr %1227, align 8
  %1254 = load ptr, ptr %1253, align 8
  %1255 = getelementptr i8, ptr %1254, i64 72
  %1256 = load ptr, ptr %1255, align 8
  %result.i.i40.i1432 = call { i64, i64 } %1256(ptr nocapture nofree nonnull readonly align 8 %1253) #44
  %1257 = extractvalue { i64, i64 } %result.i.i40.i1432, 1
  %1258 = urem i64 %1252, %1257
  %1259 = icmp eq i64 %1258, 0
  %1260 = sub i64 %1257, %1258
  %1261 = select i1 %1259, i64 0, i64 %1260
  %1262 = getelementptr i8, ptr %result.i9.i1428, i64 %1252
  %1263 = getelementptr i8, ptr %1262, i64 %1261
  %1264 = getelementptr i8, ptr %1254, i64 64
  %1265 = load ptr, ptr %1264, align 8
  call void %1265({ ptr, i160 } %1026, ptr nocapture nofree nonnull readonly align 8 %1253, ptr nocapture nofree writeonly %1263) #45
  %1266 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1267 = getelementptr inbounds i8, ptr %result.i9.i1428, i64 16
  store i32 %1029, ptr %1267, align 8
  store ptr @Entry, ptr %1166, align 8
  %1268 = ptrtoint ptr %result.i9.i1428 to i64
  store i64 %1268, ptr %1168, align 4
  %.sroa_idx30.i1433 = getelementptr i8, ptr %1166, i64 24
  store i32 10, ptr %.sroa_idx30.i1433, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %CuckooMap_insert_keyK_valueV.exit530

1269:                                             ; preds = %._crit_edge.i1421, %1171, %1140
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1270 = load i32, ptr %111, align 4
  %1271 = load i32, ptr %107, align 8
  %.not.i488 = icmp slt i32 %1270, %1271
  br i1 %.not.i488, label %._crit_edge.i490, label %1272

1272:                                             ; preds = %1269
  %1273 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1274 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1275 = load ptr, ptr %108, align 8
  %1276 = load ptr, ptr %109, align 8
  %1277 = shl i32 %1271, 1
  %spec.select.i1450 = call i32 @llvm.smax.i32(i32 %1277, i32 noundef 16) #40
  store i32 %spec.select.i1450, ptr %107, align 8
  %1278 = zext nneg i32 %spec.select.i1450 to i64
  %1279 = shl nuw nsw i64 %1278, 5
  %result.i5.i1451 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1279) #48
  store ptr %result.i5.i1451, ptr %108, align 8
  %result.i4.i1452 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1279) #48
  store ptr %result.i4.i1452, ptr %109, align 8
  store i32 0, ptr %111, align 4
  %1280 = icmp sgt i32 %1271, 0
  br i1 %1280, label %.lr.ph.i2453, label %._crit_edge.i490

.lr.ph.i2453:                                     ; preds = %1272
  %wide.trip.count.i2466 = zext nneg i32 %1271 to i64
  br label %1281

1281:                                             ; preds = %._crit_edge.i2469, %.lr.ph.i2453
  %indvars.iv.i2467 = phi i64 [ 0, %.lr.ph.i2453 ], [ %indvars.iv.next.i2470, %._crit_edge.i2469 ]
  %1282 = shl nuw nsw i64 %indvars.iv.i2467, 5
  %1283 = getelementptr i8, ptr %1275, i64 %1282
  %1284 = load ptr, ptr %1283, align 8
  %1285 = icmp ne ptr %1284, @nil_typ
  %1286 = icmp ne ptr %1284, null
  %.not17.i2468 = and i1 %1285, %1286
  br i1 %.not17.i2468, label %1287, label %._crit_edge.i2469

1287:                                             ; preds = %1281
  %1288 = getelementptr i8, ptr %1283, i64 8
  %1289 = load i64, ptr %1288, align 4
  %.sroa_idx.i2472 = getelementptr i8, ptr %1283, i64 16
  %1290 = load i64, ptr %.sroa_idx.i2472, align 4
  %hash_coef_ptr.i.i6.i2473 = getelementptr i8, ptr %1284, i64 8
  %tbl_size_ptr.i.i7.i2474 = getelementptr i8, ptr %1284, i64 16
  %offset_tbl_ptr.i.i8.i2475 = getelementptr i8, ptr %1284, i64 40
  %1291 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  %hash_coef.i.i21.i3220 = load i64, ptr %hash_coef_ptr.i.i6.i2473, align 4, !noalias !374
  %tbl_size.i.i22.i3221 = load i64, ptr %tbl_size_ptr.i.i7.i2474, align 4, !noalias !374
  %offset_tbl.i.i23.i3222 = load ptr, ptr %offset_tbl_ptr.i.i8.i2475, align 8, !noalias !374
  %product.i.i.i24.i3223 = mul i64 %hash_coef.i.i21.i3220, 4015701072841558310
  %shifted.i.i.i25.i3224 = lshr i64 %product.i.i.i24.i3223, 32
  %xored.i.i.i26.i3225 = xor i64 %shifted.i.i.i25.i3224, %product.i.i.i24.i3223
  %hash.i.i.i27.i3226 = and i64 %xored.i.i.i26.i3225, %tbl_size.i.i22.i3221
  %offset_ptr.i.i28.i3227 = getelementptr i32, ptr %offset_tbl.i.i23.i3222, i64 %hash.i.i.i27.i3226
  %offset.i.i29.i3228 = load i32, ptr %offset_ptr.i.i28.i3227, align 4, !noalias !374
  %1292 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1293 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1294 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1295

1295:                                             ; preds = %.cont.i3251, %1287
  %.0290.i3229 = phi i32 [ 0, %1287 ], [ %1328, %.cont.i3251 ]
  %.074289.i3230 = phi i1 [ true, %1287 ], [ %1329, %.cont.i3251 ]
  %.sroa.0.0288.i3231 = phi ptr [ %1284, %1287 ], [ %1318, %.cont.i3251 ]
  %.sroa.6.0287.i3232.in = phi i64 [ %1289, %1287 ], [ %1320, %.cont.i3251 ]
  %.sroa.12.0286.i3233.in = phi i64 [ %1290, %1287 ], [ %1321, %.cont.i3251 ]
  %.sroa.17.0285.i3234 = phi i32 [ %offset.i.i29.i3228, %1287 ], [ %offset.i.i57.i3263, %.cont.i3251 ]
  %.sroa.12.0286.i3233 = inttoptr i64 %.sroa.12.0286.i3233.in to ptr
  %.sroa.6.0287.i3232 = inttoptr i64 %.sroa.6.0287.i3232.in to ptr
  %1296 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3231, 0
  %1297 = insertvalue { ptr, ptr, ptr, i32 } %1296, ptr %.sroa.6.0287.i3232, 1
  %1298 = insertvalue { ptr, ptr, ptr, i32 } %1297, ptr %.sroa.12.0286.i3233, 2
  %1299 = insertvalue { ptr, ptr, ptr, i32 } %1298, i32 %.sroa.17.0285.i3234, 3
  %1300 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3231)
  %1301 = sext i32 %.sroa.17.0285.i3234 to i64
  %1302 = getelementptr ptr, ptr %.sroa.0.0288.i3231, i64 %1301
  %1303 = getelementptr i8, ptr %1302, i64 64
  %1304 = load ptr, ptr %1303, align 8
  %result.i15.i3235 = call ptr %1304({ ptr, ptr, ptr, i32 } %1299, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1305 = call i32 %result.i15.i3235({ ptr, ptr, ptr, i32 } %1299, { ptr, ptr, ptr, i32 } %1299, ptr nonnull align 8 %2) #53
  %..i3236 = select i1 %.074289.i3230, ptr %24, ptr %26
  %.188.i3237 = select i1 %.074289.i3230, i64 104, i64 112
  %.189.i3238 = select i1 %.074289.i3230, ptr %25, ptr %27
  %.190.i3239 = select i1 %.074289.i3230, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3236, align 8
  %1306 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3236)
  %1307 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3237
  %1308 = load ptr, ptr %1307, align 8
  store ptr @i32_typ, ptr %.189.i3238, align 8
  %result.i14.i3240 = call ptr %1308({ ptr, ptr, ptr, i32 } %127, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3238) #46
  %1309 = call i32 %result.i14.i3240({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr nonnull align 8 dereferenceable(8) %..i3236, i32 %1305) #53
  %1310 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1311 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3239
  %1312 = load ptr, ptr %1311, align 8
  %1313 = load ptr, ptr %1312, align 8
  %1314 = call { ptr } %1313(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i3241 = extractvalue { ptr } %1314, 0
  %1315 = sext i32 %1309 to i64
  %1316 = shl nsw i64 %1315, 5
  %1317 = getelementptr i8, ptr %.fca.0.extract55.i3241, i64 %1316
  %1318 = load ptr, ptr %1317, align 8
  %1319 = getelementptr i8, ptr %1317, i64 8
  %1320 = load i64, ptr %1319, align 4
  %.sroa_idx.i3242 = getelementptr i8, ptr %1317, i64 16
  %1321 = load i64, ptr %.sroa_idx.i3242, align 4
  %1322 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1323 = call { ptr } %1313(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i3243 = extractvalue { ptr } %1323, 0
  %1324 = getelementptr i8, ptr %.fca.0.extract52.i3243, i64 %1316
  store ptr %.sroa.0.0288.i3231, ptr %1324, align 8
  %1325 = getelementptr i8, ptr %1324, i64 8
  store i64 %.sroa.6.0287.i3232.in, ptr %1325, align 4
  %.sroa_idx104.i3244 = getelementptr i8, ptr %1324, i64 16
  store i64 %.sroa.12.0286.i3233.in, ptr %.sroa_idx104.i3244, align 4
  %.sroa_idx105.i3245 = getelementptr i8, ptr %1324, i64 24
  store i32 %.sroa.17.0285.i3234, ptr %.sroa_idx105.i3245, align 4
  %1326 = icmp ne ptr %1318, @nil_typ
  %1327 = icmp ne ptr %1318, null
  %.not94.i3246 = and i1 %1326, %1327
  br i1 %.not94.i3246, label %.cont.i3251, label %1332

.cont.i3251:                                      ; preds = %1295
  %1328 = add nuw nsw i32 %.0290.i3229, 1
  %1329 = xor i1 %.074289.i3230, true
  %hash_coef_ptr.i.i46.i3252 = getelementptr i8, ptr %1318, i64 8
  %tbl_size_ptr.i.i47.i3253 = getelementptr i8, ptr %1318, i64 16
  %offset_tbl_ptr.i.i48.i3254 = getelementptr i8, ptr %1318, i64 40
  %hash_coef.i.i49.i3255 = load i64, ptr %hash_coef_ptr.i.i46.i3252, align 4
  %tbl_size.i.i50.i3256 = load i64, ptr %tbl_size_ptr.i.i47.i3253, align 4
  %offset_tbl.i.i51.i3257 = load ptr, ptr %offset_tbl_ptr.i.i48.i3254, align 8
  %product.i.i.i52.i3258 = mul i64 %hash_coef.i.i49.i3255, 4015701072841558310
  %shifted.i.i.i53.i3259 = lshr i64 %product.i.i.i52.i3258, 32
  %xored.i.i.i54.i3260 = xor i64 %shifted.i.i.i53.i3259, %product.i.i.i52.i3258
  %hash.i.i.i55.i3261 = and i64 %xored.i.i.i54.i3260, %tbl_size.i.i50.i3256
  %offset_ptr.i.i56.i3262 = getelementptr i32, ptr %offset_tbl.i.i51.i3257, i64 %hash.i.i.i55.i3261
  %offset.i.i57.i3263 = load i32, ptr %offset_ptr.i.i56.i3262, align 4
  %1330 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1331 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3264 = icmp eq i32 %1328, 100
  br i1 %exitcond.not.i3264, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273, label %1295

1332:                                             ; preds = %1295
  %1333 = load i32, ptr %111, align 4
  %1334 = add i32 %1333, 1
  %1335 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1334, ptr %111, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273: ; preds = %1332, %.cont.i3251
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  br label %._crit_edge.i2469

._crit_edge.i2469:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3273, %1281
  %indvars.iv.next.i2470 = add nuw nsw i64 %indvars.iv.i2467, 1
  %exitcond.not.i2471 = icmp eq i64 %indvars.iv.next.i2470, %wide.trip.count.i2466
  br i1 %exitcond.not.i2471, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2489, label %1281

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2489: ; preds = %._crit_edge.i2507, %._crit_edge.i2469
  %indvars.iv.i2505 = phi i64 [ %indvars.iv.next.i2508, %._crit_edge.i2507 ], [ 0, %._crit_edge.i2469 ]
  %1336 = shl nuw nsw i64 %indvars.iv.i2505, 5
  %1337 = getelementptr i8, ptr %1276, i64 %1336
  %1338 = load ptr, ptr %1337, align 8
  %1339 = icmp ne ptr %1338, @nil_typ
  %1340 = icmp ne ptr %1338, null
  %.not17.i2506 = and i1 %1339, %1340
  br i1 %.not17.i2506, label %1341, label %._crit_edge.i2507

1341:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2489
  %1342 = getelementptr i8, ptr %1337, i64 8
  %1343 = load i64, ptr %1342, align 4
  %.sroa_idx.i2510 = getelementptr i8, ptr %1337, i64 16
  %1344 = load i64, ptr %.sroa_idx.i2510, align 4
  %hash_coef_ptr.i.i6.i2511 = getelementptr i8, ptr %1338, i64 8
  %tbl_size_ptr.i.i7.i2512 = getelementptr i8, ptr %1338, i64 16
  %offset_tbl_ptr.i.i8.i2513 = getelementptr i8, ptr %1338, i64 40
  %1345 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  %hash_coef.i.i21.i3291 = load i64, ptr %hash_coef_ptr.i.i6.i2511, align 4, !noalias !377
  %tbl_size.i.i22.i3292 = load i64, ptr %tbl_size_ptr.i.i7.i2512, align 4, !noalias !377
  %offset_tbl.i.i23.i3293 = load ptr, ptr %offset_tbl_ptr.i.i8.i2513, align 8, !noalias !377
  %product.i.i.i24.i3294 = mul i64 %hash_coef.i.i21.i3291, 4015701072841558310
  %shifted.i.i.i25.i3295 = lshr i64 %product.i.i.i24.i3294, 32
  %xored.i.i.i26.i3296 = xor i64 %shifted.i.i.i25.i3295, %product.i.i.i24.i3294
  %hash.i.i.i27.i3297 = and i64 %xored.i.i.i26.i3296, %tbl_size.i.i22.i3292
  %offset_ptr.i.i28.i3298 = getelementptr i32, ptr %offset_tbl.i.i23.i3293, i64 %hash.i.i.i27.i3297
  %offset.i.i29.i3299 = load i32, ptr %offset_ptr.i.i28.i3298, align 4, !noalias !377
  %1346 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1347 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1348 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1349

1349:                                             ; preds = %.cont.i3322, %1341
  %.0290.i3300 = phi i32 [ 0, %1341 ], [ %1382, %.cont.i3322 ]
  %.074289.i3301 = phi i1 [ true, %1341 ], [ %1383, %.cont.i3322 ]
  %.sroa.0.0288.i3302 = phi ptr [ %1338, %1341 ], [ %1372, %.cont.i3322 ]
  %.sroa.6.0287.i3303.in = phi i64 [ %1343, %1341 ], [ %1374, %.cont.i3322 ]
  %.sroa.12.0286.i3304.in = phi i64 [ %1344, %1341 ], [ %1375, %.cont.i3322 ]
  %.sroa.17.0285.i3305 = phi i32 [ %offset.i.i29.i3299, %1341 ], [ %offset.i.i57.i3334, %.cont.i3322 ]
  %.sroa.12.0286.i3304 = inttoptr i64 %.sroa.12.0286.i3304.in to ptr
  %.sroa.6.0287.i3303 = inttoptr i64 %.sroa.6.0287.i3303.in to ptr
  %1350 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3302, 0
  %1351 = insertvalue { ptr, ptr, ptr, i32 } %1350, ptr %.sroa.6.0287.i3303, 1
  %1352 = insertvalue { ptr, ptr, ptr, i32 } %1351, ptr %.sroa.12.0286.i3304, 2
  %1353 = insertvalue { ptr, ptr, ptr, i32 } %1352, i32 %.sroa.17.0285.i3305, 3
  %1354 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3302)
  %1355 = sext i32 %.sroa.17.0285.i3305 to i64
  %1356 = getelementptr ptr, ptr %.sroa.0.0288.i3302, i64 %1355
  %1357 = getelementptr i8, ptr %1356, i64 64
  %1358 = load ptr, ptr %1357, align 8
  %result.i15.i3306 = call ptr %1358({ ptr, ptr, ptr, i32 } %1353, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1359 = call i32 %result.i15.i3306({ ptr, ptr, ptr, i32 } %1353, { ptr, ptr, ptr, i32 } %1353, ptr nonnull align 8 %2) #53
  %..i3307 = select i1 %.074289.i3301, ptr %20, ptr %22
  %.188.i3308 = select i1 %.074289.i3301, i64 104, i64 112
  %.189.i3309 = select i1 %.074289.i3301, ptr %21, ptr %23
  %.190.i3310 = select i1 %.074289.i3301, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3307, align 8
  %1360 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3307)
  %1361 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3308
  %1362 = load ptr, ptr %1361, align 8
  store ptr @i32_typ, ptr %.189.i3309, align 8
  %result.i14.i3311 = call ptr %1362({ ptr, ptr, ptr, i32 } %127, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3309) #46
  %1363 = call i32 %result.i14.i3311({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr nonnull align 8 dereferenceable(8) %..i3307, i32 %1359) #53
  %1364 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1365 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3310
  %1366 = load ptr, ptr %1365, align 8
  %1367 = load ptr, ptr %1366, align 8
  %1368 = call { ptr } %1367(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i3312 = extractvalue { ptr } %1368, 0
  %1369 = sext i32 %1363 to i64
  %1370 = shl nsw i64 %1369, 5
  %1371 = getelementptr i8, ptr %.fca.0.extract55.i3312, i64 %1370
  %1372 = load ptr, ptr %1371, align 8
  %1373 = getelementptr i8, ptr %1371, i64 8
  %1374 = load i64, ptr %1373, align 4
  %.sroa_idx.i3313 = getelementptr i8, ptr %1371, i64 16
  %1375 = load i64, ptr %.sroa_idx.i3313, align 4
  %1376 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1377 = call { ptr } %1367(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i3314 = extractvalue { ptr } %1377, 0
  %1378 = getelementptr i8, ptr %.fca.0.extract52.i3314, i64 %1370
  store ptr %.sroa.0.0288.i3302, ptr %1378, align 8
  %1379 = getelementptr i8, ptr %1378, i64 8
  store i64 %.sroa.6.0287.i3303.in, ptr %1379, align 4
  %.sroa_idx104.i3315 = getelementptr i8, ptr %1378, i64 16
  store i64 %.sroa.12.0286.i3304.in, ptr %.sroa_idx104.i3315, align 4
  %.sroa_idx105.i3316 = getelementptr i8, ptr %1378, i64 24
  store i32 %.sroa.17.0285.i3305, ptr %.sroa_idx105.i3316, align 4
  %1380 = icmp ne ptr %1372, @nil_typ
  %1381 = icmp ne ptr %1372, null
  %.not94.i3317 = and i1 %1380, %1381
  br i1 %.not94.i3317, label %.cont.i3322, label %1386

.cont.i3322:                                      ; preds = %1349
  %1382 = add nuw nsw i32 %.0290.i3300, 1
  %1383 = xor i1 %.074289.i3301, true
  %hash_coef_ptr.i.i46.i3323 = getelementptr i8, ptr %1372, i64 8
  %tbl_size_ptr.i.i47.i3324 = getelementptr i8, ptr %1372, i64 16
  %offset_tbl_ptr.i.i48.i3325 = getelementptr i8, ptr %1372, i64 40
  %hash_coef.i.i49.i3326 = load i64, ptr %hash_coef_ptr.i.i46.i3323, align 4
  %tbl_size.i.i50.i3327 = load i64, ptr %tbl_size_ptr.i.i47.i3324, align 4
  %offset_tbl.i.i51.i3328 = load ptr, ptr %offset_tbl_ptr.i.i48.i3325, align 8
  %product.i.i.i52.i3329 = mul i64 %hash_coef.i.i49.i3326, 4015701072841558310
  %shifted.i.i.i53.i3330 = lshr i64 %product.i.i.i52.i3329, 32
  %xored.i.i.i54.i3331 = xor i64 %shifted.i.i.i53.i3330, %product.i.i.i52.i3329
  %hash.i.i.i55.i3332 = and i64 %xored.i.i.i54.i3331, %tbl_size.i.i50.i3327
  %offset_ptr.i.i56.i3333 = getelementptr i32, ptr %offset_tbl.i.i51.i3328, i64 %hash.i.i.i55.i3332
  %offset.i.i57.i3334 = load i32, ptr %offset_ptr.i.i56.i3333, align 4
  %1384 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1385 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3335 = icmp eq i32 %1382, 100
  br i1 %exitcond.not.i3335, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344, label %1349

1386:                                             ; preds = %1349
  %1387 = load i32, ptr %111, align 4
  %1388 = add i32 %1387, 1
  %1389 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1388, ptr %111, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344: ; preds = %1386, %.cont.i3322
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  br label %._crit_edge.i2507

._crit_edge.i2507:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3344, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2489
  %indvars.iv.next.i2508 = add nuw nsw i64 %indvars.iv.i2505, 1
  %exitcond.not.i2509 = icmp eq i64 %indvars.iv.next.i2508, %wide.trip.count.i2466
  br i1 %exitcond.not.i2509, label %._crit_edge.i490, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2489

._crit_edge.i490:                                 ; preds = %._crit_edge.i2507, %1272, %1269
  %1390 = load ptr, ptr %result.i78, align 8
  %1391 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1392 = load ptr, ptr %100, align 8
  %1393 = load ptr, ptr %1390, align 8
  %1394 = getelementptr i8, ptr %1393, i64 72
  %1395 = load ptr, ptr %1394, align 8
  %result.i1.i.i493 = call { i64, i64 } %1395(ptr nocapture nofree nonnull readonly align 8 %1390) #44
  %1396 = extractvalue { i64, i64 } %result.i1.i.i493, 0
  %1397 = extractvalue { i64, i64 } %result.i1.i.i493, 1
  %1398 = urem i64 20, %1397
  %1399 = icmp eq i64 %1398, 0
  %1400 = sub i64 %1397, %1398
  %1401 = select i1 %1399, i64 0, i64 %1400
  %1402 = add i64 %1396, 20
  %1403 = add i64 %1402, %1401
  %1404 = load ptr, ptr %1392, align 8
  %1405 = getelementptr i8, ptr %1404, i64 72
  %1406 = load ptr, ptr %1405, align 8
  %result.i.i.i494 = call { i64, i64 } %1406(ptr nocapture nofree nonnull readonly align 8 %1392) #44
  %1407 = extractvalue { i64, i64 } %result.i.i.i494, 0
  %1408 = extractvalue { i64, i64 } %result.i.i.i494, 1
  %1409 = call i64 @llvm.umax.i64(i64 %1397, i64 %1408) #41
  %1410 = call i64 @llvm.umax.i64(i64 %1409, i64 noundef 8) #41, !range !16
  %1411 = urem i64 %1403, %1408
  %1412 = icmp eq i64 %1411, 0
  %1413 = sub i64 %1408, %1411
  %1414 = select i1 %1412, i64 0, i64 %1413
  %1415 = add i64 %1407, %1403
  %1416 = add i64 %1415, %1414
  %1417 = urem i64 %1416, %1410
  %1418 = icmp eq i64 %1417, 0
  %1419 = sub i64 %1410, %1417
  %1420 = select i1 %1418, i64 0, i64 %1419
  %1421 = add i64 %1420, %1416
  %result.i22.i495 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %1421) #48
  store ptr %1390, ptr %result.i22.i495, align 8
  %1422 = getelementptr inbounds i8, ptr %result.i22.i495, i64 8
  store ptr %1392, ptr %1422, align 8
  %1423 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i495)
  %1424 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1425 = load ptr, ptr %1390, align 8
  %1426 = getelementptr i8, ptr %1425, i64 72
  %1427 = load ptr, ptr %1426, align 8
  %result.i.i127.i496 = call { i64, i64 } %1427(ptr nocapture nofree nonnull readonly align 8 %1390) #44
  %1428 = extractvalue { i64, i64 } %result.i.i127.i496, 1
  %1429 = urem i64 20, %1428
  %1430 = icmp eq i64 %1429, 0
  %reass.sub = sub i64 %1428, %1429
  %1431 = add i64 %reass.sub, 20
  %1432 = select i1 %1430, i64 20, i64 %1431
  %1433 = getelementptr i8, ptr %result.i22.i495, i64 %1432
  %1434 = getelementptr i8, ptr %1425, i64 64
  %1435 = load ptr, ptr %1434, align 8
  call void %1435({ ptr, i160 } %133, ptr nocapture nofree nonnull readonly align 8 %1390, ptr nocapture nofree writeonly %1433) #45
  %1436 = load ptr, ptr %result.i22.i495, align 8
  %1437 = load ptr, ptr %1436, align 8
  %1438 = getelementptr i8, ptr %1437, i64 72
  %1439 = load ptr, ptr %1438, align 8
  %result.i1.i128.i498 = call { i64, i64 } %1439(ptr nocapture nofree nonnull readonly align 8 %1436) #44
  %1440 = extractvalue { i64, i64 } %result.i1.i128.i498, 0
  %1441 = extractvalue { i64, i64 } %result.i1.i128.i498, 1
  %1442 = urem i64 20, %1441
  %1443 = icmp eq i64 %1442, 0
  %1444 = sub i64 %1441, %1442
  %1445 = select i1 %1443, i64 0, i64 %1444
  %1446 = add i64 %1440, 20
  %1447 = add i64 %1446, %1445
  %1448 = load ptr, ptr %1422, align 8
  %1449 = load ptr, ptr %1448, align 8
  %1450 = getelementptr i8, ptr %1449, i64 72
  %1451 = load ptr, ptr %1450, align 8
  %result.i.i129.i499 = call { i64, i64 } %1451(ptr nocapture nofree nonnull readonly align 8 %1448) #44
  %1452 = extractvalue { i64, i64 } %result.i.i129.i499, 1
  %1453 = urem i64 %1447, %1452
  %1454 = icmp eq i64 %1453, 0
  %1455 = sub i64 %1452, %1453
  %1456 = select i1 %1454, i64 0, i64 %1455
  %1457 = getelementptr i8, ptr %result.i22.i495, i64 %1447
  %1458 = getelementptr i8, ptr %1457, i64 %1456
  %1459 = getelementptr i8, ptr %1449, i64 64
  %1460 = load ptr, ptr %1459, align 8
  call void %1460({ ptr, i160 } %1026, ptr nocapture nofree nonnull readonly align 8 %1448, ptr nocapture nofree writeonly %1458) #45
  %1461 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1462 = getelementptr inbounds i8, ptr %result.i22.i495, i64 16
  store i32 %1029, ptr %1462, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  %1463 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1464 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1465 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1466

1466:                                             ; preds = %.cont.i1507, %._crit_edge.i490
  %.0290.i1485 = phi i32 [ 0, %._crit_edge.i490 ], [ %1501, %.cont.i1507 ]
  %.074289.i1486 = phi i1 [ true, %._crit_edge.i490 ], [ %1502, %.cont.i1507 ]
  %.sroa.0.0288.i1487 = phi ptr [ @Entry, %._crit_edge.i490 ], [ %1489, %.cont.i1507 ]
  %.sroa.6.0287.i1488 = phi ptr [ %result.i22.i495, %._crit_edge.i490 ], [ %1503, %.cont.i1507 ]
  %.sroa.12.0286.i1489 = phi ptr [ undef, %._crit_edge.i490 ], [ %1504, %.cont.i1507 ]
  %.sroa.17.0285.i1490 = phi i32 [ 10, %._crit_edge.i490 ], [ %offset.i.i57.i1519, %.cont.i1507 ]
  %1467 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1487, 0
  %1468 = insertvalue { ptr, ptr, ptr, i32 } %1467, ptr %.sroa.6.0287.i1488, 1
  %1469 = insertvalue { ptr, ptr, ptr, i32 } %1468, ptr %.sroa.12.0286.i1489, 2
  %1470 = insertvalue { ptr, ptr, ptr, i32 } %1469, i32 %.sroa.17.0285.i1490, 3
  %1471 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1487)
  %1472 = sext i32 %.sroa.17.0285.i1490 to i64
  %1473 = getelementptr ptr, ptr %.sroa.0.0288.i1487, i64 %1472
  %1474 = getelementptr i8, ptr %1473, i64 64
  %1475 = load ptr, ptr %1474, align 8
  %result.i15.i1491 = call ptr %1475({ ptr, ptr, ptr, i32 } %1470, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1476 = call i32 %result.i15.i1491({ ptr, ptr, ptr, i32 } %1470, { ptr, ptr, ptr, i32 } %1470, ptr nonnull align 8 %2) #53
  %..i1492 = select i1 %.074289.i1486, ptr %56, ptr %58
  %.188.i1493 = select i1 %.074289.i1486, i64 104, i64 112
  %.189.i1494 = select i1 %.074289.i1486, ptr %57, ptr %59
  %.190.i1495 = select i1 %.074289.i1486, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1492, align 8
  %1477 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1492)
  %1478 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1493
  %1479 = load ptr, ptr %1478, align 8
  store ptr @i32_typ, ptr %.189.i1494, align 8
  %result.i14.i1496 = call ptr %1479({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1494) #46
  %1480 = call i32 %result.i14.i1496({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i1492, i32 %1476) #53
  %1481 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1482 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1495
  %1483 = load ptr, ptr %1482, align 8
  %1484 = load ptr, ptr %1483, align 8
  %1485 = call { ptr } %1484(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i1497 = extractvalue { ptr } %1485, 0
  %1486 = sext i32 %1480 to i64
  %1487 = shl nsw i64 %1486, 5
  %1488 = getelementptr i8, ptr %.fca.0.extract55.i1497, i64 %1487
  %1489 = load ptr, ptr %1488, align 8
  %1490 = getelementptr i8, ptr %1488, i64 8
  %1491 = load i64, ptr %1490, align 4
  %.sroa_idx.i1498 = getelementptr i8, ptr %1488, i64 16
  %1492 = load i64, ptr %.sroa_idx.i1498, align 4
  %1493 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1494 = call { ptr } %1484(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i1499 = extractvalue { ptr } %1494, 0
  %1495 = getelementptr i8, ptr %.fca.0.extract52.i1499, i64 %1487
  store ptr %.sroa.0.0288.i1487, ptr %1495, align 8
  %1496 = getelementptr i8, ptr %1495, i64 8
  %1497 = ptrtoint ptr %.sroa.6.0287.i1488 to i64
  %1498 = ptrtoint ptr %.sroa.12.0286.i1489 to i64
  store i64 %1497, ptr %1496, align 4
  %.sroa_idx104.i1500 = getelementptr i8, ptr %1495, i64 16
  store i64 %1498, ptr %.sroa_idx104.i1500, align 4
  %.sroa_idx105.i1501 = getelementptr i8, ptr %1495, i64 24
  store i32 %.sroa.17.0285.i1490, ptr %.sroa_idx105.i1501, align 4
  %1499 = icmp ne ptr %1489, @nil_typ
  %1500 = icmp ne ptr %1489, null
  %.not94.i1502 = and i1 %1499, %1500
  br i1 %.not94.i1502, label %.cont.i1507, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1529

.cont.i1507:                                      ; preds = %1466
  %1501 = add nuw nsw i32 %.0290.i1485, 1
  %1502 = xor i1 %.074289.i1486, true
  %1503 = inttoptr i64 %1491 to ptr
  %1504 = inttoptr i64 %1492 to ptr
  %hash_coef_ptr.i.i46.i1508 = getelementptr i8, ptr %1489, i64 8
  %tbl_size_ptr.i.i47.i1509 = getelementptr i8, ptr %1489, i64 16
  %offset_tbl_ptr.i.i48.i1510 = getelementptr i8, ptr %1489, i64 40
  %hash_coef.i.i49.i1511 = load i64, ptr %hash_coef_ptr.i.i46.i1508, align 4
  %tbl_size.i.i50.i1512 = load i64, ptr %tbl_size_ptr.i.i47.i1509, align 4
  %offset_tbl.i.i51.i1513 = load ptr, ptr %offset_tbl_ptr.i.i48.i1510, align 8
  %product.i.i.i52.i1514 = mul i64 %hash_coef.i.i49.i1511, 4015701072841558310
  %shifted.i.i.i53.i1515 = lshr i64 %product.i.i.i52.i1514, 32
  %xored.i.i.i54.i1516 = xor i64 %shifted.i.i.i53.i1515, %product.i.i.i52.i1514
  %hash.i.i.i55.i1517 = and i64 %xored.i.i.i54.i1516, %tbl_size.i.i50.i1512
  %offset_ptr.i.i56.i1518 = getelementptr i32, ptr %offset_tbl.i.i51.i1513, i64 %hash.i.i.i55.i1517
  %offset.i.i57.i1519 = load i32, ptr %offset_ptr.i.i56.i1518, align 4
  %1505 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1506 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1520 = icmp eq i32 %1501, 100
  br i1 %exitcond.not.i1520, label %1510, label %1466

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1529: ; preds = %1466
  %1507 = load i32, ptr %111, align 4
  %1508 = add i32 %1507, 1
  %1509 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1508, ptr %111, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  br label %CuckooMap_insert_keyK_valueV.exit530

1510:                                             ; preds = %.cont.i1507
  %hash_coef_ptr.i.i46.i1508.le = getelementptr i8, ptr %1489, i64 8
  %tbl_size_ptr.i.i47.i1509.le = getelementptr i8, ptr %1489, i64 16
  %offset_tbl_ptr.i.i48.i1510.le = getelementptr i8, ptr %1489, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  %1511 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1512 = load ptr, ptr %108, align 8
  %1513 = load ptr, ptr %109, align 8
  %1514 = load i32, ptr %107, align 8
  %1515 = shl i32 %1514, 1
  %spec.select.i1545 = call i32 @llvm.smax.i32(i32 %1515, i32 noundef 16) #40
  store i32 %spec.select.i1545, ptr %107, align 8
  %1516 = zext nneg i32 %spec.select.i1545 to i64
  %1517 = shl nuw nsw i64 %1516, 5
  %result.i5.i1546 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1517) #48
  store ptr %result.i5.i1546, ptr %108, align 8
  %result.i4.i1547 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1517) #48
  store ptr %result.i4.i1547, ptr %109, align 8
  store i32 0, ptr %111, align 4
  %1518 = icmp sgt i32 %1514, 0
  br i1 %1518, label %.lr.ph.i2529, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603

.lr.ph.i2529:                                     ; preds = %1510
  %wide.trip.count.i2542 = zext nneg i32 %1514 to i64
  br label %1519

1519:                                             ; preds = %._crit_edge.i2545, %.lr.ph.i2529
  %indvars.iv.i2543 = phi i64 [ 0, %.lr.ph.i2529 ], [ %indvars.iv.next.i2546, %._crit_edge.i2545 ]
  %1520 = shl nuw nsw i64 %indvars.iv.i2543, 5
  %1521 = getelementptr i8, ptr %1512, i64 %1520
  %1522 = load ptr, ptr %1521, align 8
  %1523 = icmp ne ptr %1522, @nil_typ
  %1524 = icmp ne ptr %1522, null
  %.not17.i2544 = and i1 %1523, %1524
  br i1 %.not17.i2544, label %1525, label %._crit_edge.i2545

1525:                                             ; preds = %1519
  %1526 = getelementptr i8, ptr %1521, i64 8
  %1527 = load i64, ptr %1526, align 4
  %.sroa_idx.i2548 = getelementptr i8, ptr %1521, i64 16
  %1528 = load i64, ptr %.sroa_idx.i2548, align 4
  %hash_coef_ptr.i.i6.i2549 = getelementptr i8, ptr %1522, i64 8
  %tbl_size_ptr.i.i7.i2550 = getelementptr i8, ptr %1522, i64 16
  %offset_tbl_ptr.i.i8.i2551 = getelementptr i8, ptr %1522, i64 40
  %1529 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %hash_coef.i.i21.i3362 = load i64, ptr %hash_coef_ptr.i.i6.i2549, align 4, !noalias !380
  %tbl_size.i.i22.i3363 = load i64, ptr %tbl_size_ptr.i.i7.i2550, align 4, !noalias !380
  %offset_tbl.i.i23.i3364 = load ptr, ptr %offset_tbl_ptr.i.i8.i2551, align 8, !noalias !380
  %product.i.i.i24.i3365 = mul i64 %hash_coef.i.i21.i3362, 4015701072841558310
  %shifted.i.i.i25.i3366 = lshr i64 %product.i.i.i24.i3365, 32
  %xored.i.i.i26.i3367 = xor i64 %shifted.i.i.i25.i3366, %product.i.i.i24.i3365
  %hash.i.i.i27.i3368 = and i64 %xored.i.i.i26.i3367, %tbl_size.i.i22.i3363
  %offset_ptr.i.i28.i3369 = getelementptr i32, ptr %offset_tbl.i.i23.i3364, i64 %hash.i.i.i27.i3368
  %offset.i.i29.i3370 = load i32, ptr %offset_ptr.i.i28.i3369, align 4, !noalias !380
  %1530 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1531 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1532 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1533

1533:                                             ; preds = %.cont.i3393, %1525
  %.0290.i3371 = phi i32 [ 0, %1525 ], [ %1566, %.cont.i3393 ]
  %.074289.i3372 = phi i1 [ true, %1525 ], [ %1567, %.cont.i3393 ]
  %.sroa.0.0288.i3373 = phi ptr [ %1522, %1525 ], [ %1556, %.cont.i3393 ]
  %.sroa.6.0287.i3374.in = phi i64 [ %1527, %1525 ], [ %1558, %.cont.i3393 ]
  %.sroa.12.0286.i3375.in = phi i64 [ %1528, %1525 ], [ %1559, %.cont.i3393 ]
  %.sroa.17.0285.i3376 = phi i32 [ %offset.i.i29.i3370, %1525 ], [ %offset.i.i57.i3405, %.cont.i3393 ]
  %.sroa.12.0286.i3375 = inttoptr i64 %.sroa.12.0286.i3375.in to ptr
  %.sroa.6.0287.i3374 = inttoptr i64 %.sroa.6.0287.i3374.in to ptr
  %1534 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3373, 0
  %1535 = insertvalue { ptr, ptr, ptr, i32 } %1534, ptr %.sroa.6.0287.i3374, 1
  %1536 = insertvalue { ptr, ptr, ptr, i32 } %1535, ptr %.sroa.12.0286.i3375, 2
  %1537 = insertvalue { ptr, ptr, ptr, i32 } %1536, i32 %.sroa.17.0285.i3376, 3
  %1538 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3373)
  %1539 = sext i32 %.sroa.17.0285.i3376 to i64
  %1540 = getelementptr ptr, ptr %.sroa.0.0288.i3373, i64 %1539
  %1541 = getelementptr i8, ptr %1540, i64 64
  %1542 = load ptr, ptr %1541, align 8
  %result.i15.i3377 = call ptr %1542({ ptr, ptr, ptr, i32 } %1537, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1543 = call i32 %result.i15.i3377({ ptr, ptr, ptr, i32 } %1537, { ptr, ptr, ptr, i32 } %1537, ptr nonnull align 8 %2) #53
  %..i3378 = select i1 %.074289.i3372, ptr %16, ptr %18
  %.188.i3379 = select i1 %.074289.i3372, i64 104, i64 112
  %.189.i3380 = select i1 %.074289.i3372, ptr %17, ptr %19
  %.190.i3381 = select i1 %.074289.i3372, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3378, align 8
  %1544 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3378)
  %1545 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3379
  %1546 = load ptr, ptr %1545, align 8
  store ptr @i32_typ, ptr %.189.i3380, align 8
  %result.i14.i3382 = call ptr %1546({ ptr, ptr, ptr, i32 } %127, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3380) #46
  %1547 = call i32 %result.i14.i3382({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr nonnull align 8 dereferenceable(8) %..i3378, i32 %1543) #53
  %1548 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1549 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3381
  %1550 = load ptr, ptr %1549, align 8
  %1551 = load ptr, ptr %1550, align 8
  %1552 = call { ptr } %1551(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i3383 = extractvalue { ptr } %1552, 0
  %1553 = sext i32 %1547 to i64
  %1554 = shl nsw i64 %1553, 5
  %1555 = getelementptr i8, ptr %.fca.0.extract55.i3383, i64 %1554
  %1556 = load ptr, ptr %1555, align 8
  %1557 = getelementptr i8, ptr %1555, i64 8
  %1558 = load i64, ptr %1557, align 4
  %.sroa_idx.i3384 = getelementptr i8, ptr %1555, i64 16
  %1559 = load i64, ptr %.sroa_idx.i3384, align 4
  %1560 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1561 = call { ptr } %1551(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i3385 = extractvalue { ptr } %1561, 0
  %1562 = getelementptr i8, ptr %.fca.0.extract52.i3385, i64 %1554
  store ptr %.sroa.0.0288.i3373, ptr %1562, align 8
  %1563 = getelementptr i8, ptr %1562, i64 8
  store i64 %.sroa.6.0287.i3374.in, ptr %1563, align 4
  %.sroa_idx104.i3386 = getelementptr i8, ptr %1562, i64 16
  store i64 %.sroa.12.0286.i3375.in, ptr %.sroa_idx104.i3386, align 4
  %.sroa_idx105.i3387 = getelementptr i8, ptr %1562, i64 24
  store i32 %.sroa.17.0285.i3376, ptr %.sroa_idx105.i3387, align 4
  %1564 = icmp ne ptr %1556, @nil_typ
  %1565 = icmp ne ptr %1556, null
  %.not94.i3388 = and i1 %1564, %1565
  br i1 %.not94.i3388, label %.cont.i3393, label %1570

.cont.i3393:                                      ; preds = %1533
  %1566 = add nuw nsw i32 %.0290.i3371, 1
  %1567 = xor i1 %.074289.i3372, true
  %hash_coef_ptr.i.i46.i3394 = getelementptr i8, ptr %1556, i64 8
  %tbl_size_ptr.i.i47.i3395 = getelementptr i8, ptr %1556, i64 16
  %offset_tbl_ptr.i.i48.i3396 = getelementptr i8, ptr %1556, i64 40
  %hash_coef.i.i49.i3397 = load i64, ptr %hash_coef_ptr.i.i46.i3394, align 4
  %tbl_size.i.i50.i3398 = load i64, ptr %tbl_size_ptr.i.i47.i3395, align 4
  %offset_tbl.i.i51.i3399 = load ptr, ptr %offset_tbl_ptr.i.i48.i3396, align 8
  %product.i.i.i52.i3400 = mul i64 %hash_coef.i.i49.i3397, 4015701072841558310
  %shifted.i.i.i53.i3401 = lshr i64 %product.i.i.i52.i3400, 32
  %xored.i.i.i54.i3402 = xor i64 %shifted.i.i.i53.i3401, %product.i.i.i52.i3400
  %hash.i.i.i55.i3403 = and i64 %xored.i.i.i54.i3402, %tbl_size.i.i50.i3398
  %offset_ptr.i.i56.i3404 = getelementptr i32, ptr %offset_tbl.i.i51.i3399, i64 %hash.i.i.i55.i3403
  %offset.i.i57.i3405 = load i32, ptr %offset_ptr.i.i56.i3404, align 4
  %1568 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1569 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3406 = icmp eq i32 %1566, 100
  br i1 %exitcond.not.i3406, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415, label %1533

1570:                                             ; preds = %1533
  %1571 = load i32, ptr %111, align 4
  %1572 = add i32 %1571, 1
  %1573 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1572, ptr %111, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415: ; preds = %1570, %.cont.i3393
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  br label %._crit_edge.i2545

._crit_edge.i2545:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3415, %1519
  %indvars.iv.next.i2546 = add nuw nsw i64 %indvars.iv.i2543, 1
  %exitcond.not.i2547 = icmp eq i64 %indvars.iv.next.i2546, %wide.trip.count.i2542
  br i1 %exitcond.not.i2547, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2565, label %1519

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2565: ; preds = %._crit_edge.i2583, %._crit_edge.i2545
  %indvars.iv.i2581 = phi i64 [ %indvars.iv.next.i2584, %._crit_edge.i2583 ], [ 0, %._crit_edge.i2545 ]
  %1574 = shl nuw nsw i64 %indvars.iv.i2581, 5
  %1575 = getelementptr i8, ptr %1513, i64 %1574
  %1576 = load ptr, ptr %1575, align 8
  %1577 = icmp ne ptr %1576, @nil_typ
  %1578 = icmp ne ptr %1576, null
  %.not17.i2582 = and i1 %1577, %1578
  br i1 %.not17.i2582, label %1579, label %._crit_edge.i2583

1579:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2565
  %1580 = getelementptr i8, ptr %1575, i64 8
  %1581 = load i64, ptr %1580, align 4
  %.sroa_idx.i2586 = getelementptr i8, ptr %1575, i64 16
  %1582 = load i64, ptr %.sroa_idx.i2586, align 4
  %hash_coef_ptr.i.i6.i2587 = getelementptr i8, ptr %1576, i64 8
  %tbl_size_ptr.i.i7.i2588 = getelementptr i8, ptr %1576, i64 16
  %offset_tbl_ptr.i.i8.i2589 = getelementptr i8, ptr %1576, i64 40
  %1583 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  %hash_coef.i.i21.i3433 = load i64, ptr %hash_coef_ptr.i.i6.i2587, align 4, !noalias !383
  %tbl_size.i.i22.i3434 = load i64, ptr %tbl_size_ptr.i.i7.i2588, align 4, !noalias !383
  %offset_tbl.i.i23.i3435 = load ptr, ptr %offset_tbl_ptr.i.i8.i2589, align 8, !noalias !383
  %product.i.i.i24.i3436 = mul i64 %hash_coef.i.i21.i3433, 4015701072841558310
  %shifted.i.i.i25.i3437 = lshr i64 %product.i.i.i24.i3436, 32
  %xored.i.i.i26.i3438 = xor i64 %shifted.i.i.i25.i3437, %product.i.i.i24.i3436
  %hash.i.i.i27.i3439 = and i64 %xored.i.i.i26.i3438, %tbl_size.i.i22.i3434
  %offset_ptr.i.i28.i3440 = getelementptr i32, ptr %offset_tbl.i.i23.i3435, i64 %hash.i.i.i27.i3439
  %offset.i.i29.i3441 = load i32, ptr %offset_ptr.i.i28.i3440, align 4, !noalias !383
  %1584 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1585 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1586 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1587

1587:                                             ; preds = %.cont.i3464, %1579
  %.0290.i3442 = phi i32 [ 0, %1579 ], [ %1620, %.cont.i3464 ]
  %.074289.i3443 = phi i1 [ true, %1579 ], [ %1621, %.cont.i3464 ]
  %.sroa.0.0288.i3444 = phi ptr [ %1576, %1579 ], [ %1610, %.cont.i3464 ]
  %.sroa.6.0287.i3445.in = phi i64 [ %1581, %1579 ], [ %1612, %.cont.i3464 ]
  %.sroa.12.0286.i3446.in = phi i64 [ %1582, %1579 ], [ %1613, %.cont.i3464 ]
  %.sroa.17.0285.i3447 = phi i32 [ %offset.i.i29.i3441, %1579 ], [ %offset.i.i57.i3476, %.cont.i3464 ]
  %.sroa.12.0286.i3446 = inttoptr i64 %.sroa.12.0286.i3446.in to ptr
  %.sroa.6.0287.i3445 = inttoptr i64 %.sroa.6.0287.i3445.in to ptr
  %1588 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3444, 0
  %1589 = insertvalue { ptr, ptr, ptr, i32 } %1588, ptr %.sroa.6.0287.i3445, 1
  %1590 = insertvalue { ptr, ptr, ptr, i32 } %1589, ptr %.sroa.12.0286.i3446, 2
  %1591 = insertvalue { ptr, ptr, ptr, i32 } %1590, i32 %.sroa.17.0285.i3447, 3
  %1592 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3444)
  %1593 = sext i32 %.sroa.17.0285.i3447 to i64
  %1594 = getelementptr ptr, ptr %.sroa.0.0288.i3444, i64 %1593
  %1595 = getelementptr i8, ptr %1594, i64 64
  %1596 = load ptr, ptr %1595, align 8
  %result.i15.i3448 = call ptr %1596({ ptr, ptr, ptr, i32 } %1591, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1597 = call i32 %result.i15.i3448({ ptr, ptr, ptr, i32 } %1591, { ptr, ptr, ptr, i32 } %1591, ptr nonnull align 8 %2) #53
  %..i3449 = select i1 %.074289.i3443, ptr %12, ptr %14
  %.188.i3450 = select i1 %.074289.i3443, i64 104, i64 112
  %.189.i3451 = select i1 %.074289.i3443, ptr %13, ptr %15
  %.190.i3452 = select i1 %.074289.i3443, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3449, align 8
  %1598 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3449)
  %1599 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3450
  %1600 = load ptr, ptr %1599, align 8
  store ptr @i32_typ, ptr %.189.i3451, align 8
  %result.i14.i3453 = call ptr %1600({ ptr, ptr, ptr, i32 } %127, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3451) #46
  %1601 = call i32 %result.i14.i3453({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr nonnull align 8 dereferenceable(8) %..i3449, i32 %1597) #53
  %1602 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1603 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3452
  %1604 = load ptr, ptr %1603, align 8
  %1605 = load ptr, ptr %1604, align 8
  %1606 = call { ptr } %1605(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i3454 = extractvalue { ptr } %1606, 0
  %1607 = sext i32 %1601 to i64
  %1608 = shl nsw i64 %1607, 5
  %1609 = getelementptr i8, ptr %.fca.0.extract55.i3454, i64 %1608
  %1610 = load ptr, ptr %1609, align 8
  %1611 = getelementptr i8, ptr %1609, i64 8
  %1612 = load i64, ptr %1611, align 4
  %.sroa_idx.i3455 = getelementptr i8, ptr %1609, i64 16
  %1613 = load i64, ptr %.sroa_idx.i3455, align 4
  %1614 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1615 = call { ptr } %1605(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i3456 = extractvalue { ptr } %1615, 0
  %1616 = getelementptr i8, ptr %.fca.0.extract52.i3456, i64 %1608
  store ptr %.sroa.0.0288.i3444, ptr %1616, align 8
  %1617 = getelementptr i8, ptr %1616, i64 8
  store i64 %.sroa.6.0287.i3445.in, ptr %1617, align 4
  %.sroa_idx104.i3457 = getelementptr i8, ptr %1616, i64 16
  store i64 %.sroa.12.0286.i3446.in, ptr %.sroa_idx104.i3457, align 4
  %.sroa_idx105.i3458 = getelementptr i8, ptr %1616, i64 24
  store i32 %.sroa.17.0285.i3447, ptr %.sroa_idx105.i3458, align 4
  %1618 = icmp ne ptr %1610, @nil_typ
  %1619 = icmp ne ptr %1610, null
  %.not94.i3459 = and i1 %1618, %1619
  br i1 %.not94.i3459, label %.cont.i3464, label %1624

.cont.i3464:                                      ; preds = %1587
  %1620 = add nuw nsw i32 %.0290.i3442, 1
  %1621 = xor i1 %.074289.i3443, true
  %hash_coef_ptr.i.i46.i3465 = getelementptr i8, ptr %1610, i64 8
  %tbl_size_ptr.i.i47.i3466 = getelementptr i8, ptr %1610, i64 16
  %offset_tbl_ptr.i.i48.i3467 = getelementptr i8, ptr %1610, i64 40
  %hash_coef.i.i49.i3468 = load i64, ptr %hash_coef_ptr.i.i46.i3465, align 4
  %tbl_size.i.i50.i3469 = load i64, ptr %tbl_size_ptr.i.i47.i3466, align 4
  %offset_tbl.i.i51.i3470 = load ptr, ptr %offset_tbl_ptr.i.i48.i3467, align 8
  %product.i.i.i52.i3471 = mul i64 %hash_coef.i.i49.i3468, 4015701072841558310
  %shifted.i.i.i53.i3472 = lshr i64 %product.i.i.i52.i3471, 32
  %xored.i.i.i54.i3473 = xor i64 %shifted.i.i.i53.i3472, %product.i.i.i52.i3471
  %hash.i.i.i55.i3474 = and i64 %xored.i.i.i54.i3473, %tbl_size.i.i50.i3469
  %offset_ptr.i.i56.i3475 = getelementptr i32, ptr %offset_tbl.i.i51.i3470, i64 %hash.i.i.i55.i3474
  %offset.i.i57.i3476 = load i32, ptr %offset_ptr.i.i56.i3475, align 4
  %1622 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1623 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3477 = icmp eq i32 %1620, 100
  br i1 %exitcond.not.i3477, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486, label %1587

1624:                                             ; preds = %1587
  %1625 = load i32, ptr %111, align 4
  %1626 = add i32 %1625, 1
  %1627 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1626, ptr %111, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486: ; preds = %1624, %.cont.i3464
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  br label %._crit_edge.i2583

._crit_edge.i2583:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3486, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2565
  %indvars.iv.next.i2584 = add nuw nsw i64 %indvars.iv.i2581, 1
  %exitcond.not.i2585 = icmp eq i64 %indvars.iv.next.i2584, %wide.trip.count.i2542
  br i1 %exitcond.not.i2585, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2565

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603: ; preds = %._crit_edge.i2583, %1510
  %1628 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %hash_coef.i.i21.i1570 = load i64, ptr %hash_coef_ptr.i.i46.i1508.le, align 4, !noalias !386
  %tbl_size.i.i22.i1571 = load i64, ptr %tbl_size_ptr.i.i47.i1509.le, align 4, !noalias !386
  %offset_tbl.i.i23.i1572 = load ptr, ptr %offset_tbl_ptr.i.i48.i1510.le, align 8, !noalias !386
  %product.i.i.i24.i1573 = mul i64 %hash_coef.i.i21.i1570, 4015701072841558310
  %shifted.i.i.i25.i1574 = lshr i64 %product.i.i.i24.i1573, 32
  %xored.i.i.i26.i1575 = xor i64 %shifted.i.i.i25.i1574, %product.i.i.i24.i1573
  %hash.i.i.i27.i1576 = and i64 %xored.i.i.i26.i1575, %tbl_size.i.i22.i1571
  %offset_ptr.i.i28.i1577 = getelementptr i32, ptr %offset_tbl.i.i23.i1572, i64 %hash.i.i.i27.i1576
  %offset.i.i29.i1578 = load i32, ptr %offset_ptr.i.i28.i1577, align 4, !noalias !386
  %1629 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1630 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1631 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1632

1632:                                             ; preds = %.cont.i1602, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603
  %.0290.i1580 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603 ], [ %1665, %.cont.i1602 ]
  %.074289.i1581 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603 ], [ %1666, %.cont.i1602 ]
  %.sroa.0.0288.i1582 = phi ptr [ %1489, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603 ], [ %1655, %.cont.i1602 ]
  %.sroa.6.0287.i1583.in = phi i64 [ %1491, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603 ], [ %1657, %.cont.i1602 ]
  %.sroa.12.0286.i1584.in = phi i64 [ %1492, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603 ], [ %1658, %.cont.i1602 ]
  %.sroa.17.0285.i1585 = phi i32 [ %offset.i.i29.i1578, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2603 ], [ %offset.i.i57.i1614, %.cont.i1602 ]
  %.sroa.12.0286.i1584 = inttoptr i64 %.sroa.12.0286.i1584.in to ptr
  %.sroa.6.0287.i1583 = inttoptr i64 %.sroa.6.0287.i1583.in to ptr
  %1633 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1582, 0
  %1634 = insertvalue { ptr, ptr, ptr, i32 } %1633, ptr %.sroa.6.0287.i1583, 1
  %1635 = insertvalue { ptr, ptr, ptr, i32 } %1634, ptr %.sroa.12.0286.i1584, 2
  %1636 = insertvalue { ptr, ptr, ptr, i32 } %1635, i32 %.sroa.17.0285.i1585, 3
  %1637 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1582)
  %1638 = sext i32 %.sroa.17.0285.i1585 to i64
  %1639 = getelementptr ptr, ptr %.sroa.0.0288.i1582, i64 %1638
  %1640 = getelementptr i8, ptr %1639, i64 64
  %1641 = load ptr, ptr %1640, align 8
  %result.i15.i1586 = call ptr %1641({ ptr, ptr, ptr, i32 } %1636, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1642 = call i32 %result.i15.i1586({ ptr, ptr, ptr, i32 } %1636, { ptr, ptr, ptr, i32 } %1636, ptr nonnull align 8 %2) #53
  %..i1587 = select i1 %.074289.i1581, ptr %52, ptr %54
  %.188.i1588 = select i1 %.074289.i1581, i64 104, i64 112
  %.189.i1589 = select i1 %.074289.i1581, ptr %53, ptr %55
  %.190.i1590 = select i1 %.074289.i1581, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1587, align 8
  %1643 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1587)
  %1644 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1588
  %1645 = load ptr, ptr %1644, align 8
  store ptr @i32_typ, ptr %.189.i1589, align 8
  %result.i14.i1591 = call ptr %1645({ ptr, ptr, ptr, i32 } %122, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1589) #46
  %1646 = call i32 %result.i14.i1591({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull align 8 dereferenceable(8) %..i1587, i32 %1642) #53
  %1647 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1648 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1590
  %1649 = load ptr, ptr %1648, align 8
  %1650 = load ptr, ptr %1649, align 8
  %1651 = call { ptr } %1650(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i1592 = extractvalue { ptr } %1651, 0
  %1652 = sext i32 %1646 to i64
  %1653 = shl nsw i64 %1652, 5
  %1654 = getelementptr i8, ptr %.fca.0.extract55.i1592, i64 %1653
  %1655 = load ptr, ptr %1654, align 8
  %1656 = getelementptr i8, ptr %1654, i64 8
  %1657 = load i64, ptr %1656, align 4
  %.sroa_idx.i1593 = getelementptr i8, ptr %1654, i64 16
  %1658 = load i64, ptr %.sroa_idx.i1593, align 4
  %1659 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1660 = call { ptr } %1650(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i1594 = extractvalue { ptr } %1660, 0
  %1661 = getelementptr i8, ptr %.fca.0.extract52.i1594, i64 %1653
  store ptr %.sroa.0.0288.i1582, ptr %1661, align 8
  %1662 = getelementptr i8, ptr %1661, i64 8
  store i64 %.sroa.6.0287.i1583.in, ptr %1662, align 4
  %.sroa_idx104.i1595 = getelementptr i8, ptr %1661, i64 16
  store i64 %.sroa.12.0286.i1584.in, ptr %.sroa_idx104.i1595, align 4
  %.sroa_idx105.i1596 = getelementptr i8, ptr %1661, i64 24
  store i32 %.sroa.17.0285.i1585, ptr %.sroa_idx105.i1596, align 4
  %1663 = icmp ne ptr %1655, @nil_typ
  %1664 = icmp ne ptr %1655, null
  %.not94.i1597 = and i1 %1663, %1664
  br i1 %.not94.i1597, label %.cont.i1602, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1624

.cont.i1602:                                      ; preds = %1632
  %1665 = add nuw nsw i32 %.0290.i1580, 1
  %1666 = xor i1 %.074289.i1581, true
  %hash_coef_ptr.i.i46.i1603 = getelementptr i8, ptr %1655, i64 8
  %tbl_size_ptr.i.i47.i1604 = getelementptr i8, ptr %1655, i64 16
  %offset_tbl_ptr.i.i48.i1605 = getelementptr i8, ptr %1655, i64 40
  %hash_coef.i.i49.i1606 = load i64, ptr %hash_coef_ptr.i.i46.i1603, align 4
  %tbl_size.i.i50.i1607 = load i64, ptr %tbl_size_ptr.i.i47.i1604, align 4
  %offset_tbl.i.i51.i1608 = load ptr, ptr %offset_tbl_ptr.i.i48.i1605, align 8
  %product.i.i.i52.i1609 = mul i64 %hash_coef.i.i49.i1606, 4015701072841558310
  %shifted.i.i.i53.i1610 = lshr i64 %product.i.i.i52.i1609, 32
  %xored.i.i.i54.i1611 = xor i64 %shifted.i.i.i53.i1610, %product.i.i.i52.i1609
  %hash.i.i.i55.i1612 = and i64 %xored.i.i.i54.i1611, %tbl_size.i.i50.i1607
  %offset_ptr.i.i56.i1613 = getelementptr i32, ptr %offset_tbl.i.i51.i1608, i64 %hash.i.i.i55.i1612
  %offset.i.i57.i1614 = load i32, ptr %offset_ptr.i.i56.i1613, align 4
  %1667 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1668 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i1615 = icmp eq i32 %1665, 100
  br i1 %exitcond.not.i1615, label %1672, label %1632

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1624: ; preds = %1632
  %1669 = load i32, ptr %111, align 4
  %1670 = add i32 %1669, 1
  %1671 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1670, ptr %111, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  br label %CuckooMap_insert_keyK_valueV.exit530

1672:                                             ; preds = %.cont.i1602
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %1673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1674 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1675 = load ptr, ptr %108, align 8
  %1676 = load ptr, ptr %109, align 8
  %1677 = load i32, ptr %107, align 8
  %1678 = shl i32 %1677, 1
  %spec.select.i1640 = call i32 @llvm.smax.i32(i32 %1678, i32 noundef 16) #40
  store i32 %spec.select.i1640, ptr %107, align 8
  %1679 = zext nneg i32 %spec.select.i1640 to i64
  %1680 = shl nuw nsw i64 %1679, 5
  %result.i5.i1641 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1680) #48
  store ptr %result.i5.i1641, ptr %108, align 8
  %result.i4.i1642 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1680) #48
  store ptr %result.i4.i1642, ptr %109, align 8
  store i32 0, ptr %111, align 4
  %1681 = icmp sgt i32 %1677, 0
  br i1 %1681, label %.lr.ph.i2605, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2641.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2641.thread: ; preds = %1672
  %1682 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit530

.lr.ph.i2605:                                     ; preds = %1672
  %wide.trip.count.i2618 = zext nneg i32 %1677 to i64
  br label %1683

1683:                                             ; preds = %._crit_edge.i2621, %.lr.ph.i2605
  %indvars.iv.i2619 = phi i64 [ 0, %.lr.ph.i2605 ], [ %indvars.iv.next.i2622, %._crit_edge.i2621 ]
  %1684 = shl nuw nsw i64 %indvars.iv.i2619, 5
  %1685 = getelementptr i8, ptr %1675, i64 %1684
  %1686 = load ptr, ptr %1685, align 8
  %1687 = icmp ne ptr %1686, @nil_typ
  %1688 = icmp ne ptr %1686, null
  %.not17.i2620 = and i1 %1687, %1688
  br i1 %.not17.i2620, label %1689, label %._crit_edge.i2621

1689:                                             ; preds = %1683
  %1690 = getelementptr i8, ptr %1685, i64 8
  %1691 = load i64, ptr %1690, align 4
  %.sroa_idx.i2624 = getelementptr i8, ptr %1685, i64 16
  %1692 = load i64, ptr %.sroa_idx.i2624, align 4
  %hash_coef_ptr.i.i6.i2625 = getelementptr i8, ptr %1686, i64 8
  %tbl_size_ptr.i.i7.i2626 = getelementptr i8, ptr %1686, i64 16
  %offset_tbl_ptr.i.i8.i2627 = getelementptr i8, ptr %1686, i64 40
  %1693 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %hash_coef.i.i21.i3504 = load i64, ptr %hash_coef_ptr.i.i6.i2625, align 4, !noalias !389
  %tbl_size.i.i22.i3505 = load i64, ptr %tbl_size_ptr.i.i7.i2626, align 4, !noalias !389
  %offset_tbl.i.i23.i3506 = load ptr, ptr %offset_tbl_ptr.i.i8.i2627, align 8, !noalias !389
  %product.i.i.i24.i3507 = mul i64 %hash_coef.i.i21.i3504, 4015701072841558310
  %shifted.i.i.i25.i3508 = lshr i64 %product.i.i.i24.i3507, 32
  %xored.i.i.i26.i3509 = xor i64 %shifted.i.i.i25.i3508, %product.i.i.i24.i3507
  %hash.i.i.i27.i3510 = and i64 %xored.i.i.i26.i3509, %tbl_size.i.i22.i3505
  %offset_ptr.i.i28.i3511 = getelementptr i32, ptr %offset_tbl.i.i23.i3506, i64 %hash.i.i.i27.i3510
  %offset.i.i29.i3512 = load i32, ptr %offset_ptr.i.i28.i3511, align 4, !noalias !389
  %1694 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1695 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1696 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1697

1697:                                             ; preds = %.cont.i3535, %1689
  %.0290.i3513 = phi i32 [ 0, %1689 ], [ %1730, %.cont.i3535 ]
  %.074289.i3514 = phi i1 [ true, %1689 ], [ %1731, %.cont.i3535 ]
  %.sroa.0.0288.i3515 = phi ptr [ %1686, %1689 ], [ %1720, %.cont.i3535 ]
  %.sroa.6.0287.i3516.in = phi i64 [ %1691, %1689 ], [ %1722, %.cont.i3535 ]
  %.sroa.12.0286.i3517.in = phi i64 [ %1692, %1689 ], [ %1723, %.cont.i3535 ]
  %.sroa.17.0285.i3518 = phi i32 [ %offset.i.i29.i3512, %1689 ], [ %offset.i.i57.i3547, %.cont.i3535 ]
  %.sroa.12.0286.i3517 = inttoptr i64 %.sroa.12.0286.i3517.in to ptr
  %.sroa.6.0287.i3516 = inttoptr i64 %.sroa.6.0287.i3516.in to ptr
  %1698 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3515, 0
  %1699 = insertvalue { ptr, ptr, ptr, i32 } %1698, ptr %.sroa.6.0287.i3516, 1
  %1700 = insertvalue { ptr, ptr, ptr, i32 } %1699, ptr %.sroa.12.0286.i3517, 2
  %1701 = insertvalue { ptr, ptr, ptr, i32 } %1700, i32 %.sroa.17.0285.i3518, 3
  %1702 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3515)
  %1703 = sext i32 %.sroa.17.0285.i3518 to i64
  %1704 = getelementptr ptr, ptr %.sroa.0.0288.i3515, i64 %1703
  %1705 = getelementptr i8, ptr %1704, i64 64
  %1706 = load ptr, ptr %1705, align 8
  %result.i15.i3519 = call ptr %1706({ ptr, ptr, ptr, i32 } %1701, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1707 = call i32 %result.i15.i3519({ ptr, ptr, ptr, i32 } %1701, { ptr, ptr, ptr, i32 } %1701, ptr nonnull align 8 %2) #53
  %..i3520 = select i1 %.074289.i3514, ptr %8, ptr %10
  %.188.i3521 = select i1 %.074289.i3514, i64 104, i64 112
  %.189.i3522 = select i1 %.074289.i3514, ptr %9, ptr %11
  %.190.i3523 = select i1 %.074289.i3514, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3520, align 8
  %1708 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3520)
  %1709 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3521
  %1710 = load ptr, ptr %1709, align 8
  store ptr @i32_typ, ptr %.189.i3522, align 8
  %result.i14.i3524 = call ptr %1710({ ptr, ptr, ptr, i32 } %127, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3522) #46
  %1711 = call i32 %result.i14.i3524({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr nonnull align 8 dereferenceable(8) %..i3520, i32 %1707) #53
  %1712 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1713 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3523
  %1714 = load ptr, ptr %1713, align 8
  %1715 = load ptr, ptr %1714, align 8
  %1716 = call { ptr } %1715(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i3525 = extractvalue { ptr } %1716, 0
  %1717 = sext i32 %1711 to i64
  %1718 = shl nsw i64 %1717, 5
  %1719 = getelementptr i8, ptr %.fca.0.extract55.i3525, i64 %1718
  %1720 = load ptr, ptr %1719, align 8
  %1721 = getelementptr i8, ptr %1719, i64 8
  %1722 = load i64, ptr %1721, align 4
  %.sroa_idx.i3526 = getelementptr i8, ptr %1719, i64 16
  %1723 = load i64, ptr %.sroa_idx.i3526, align 4
  %1724 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1725 = call { ptr } %1715(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i3527 = extractvalue { ptr } %1725, 0
  %1726 = getelementptr i8, ptr %.fca.0.extract52.i3527, i64 %1718
  store ptr %.sroa.0.0288.i3515, ptr %1726, align 8
  %1727 = getelementptr i8, ptr %1726, i64 8
  store i64 %.sroa.6.0287.i3516.in, ptr %1727, align 4
  %.sroa_idx104.i3528 = getelementptr i8, ptr %1726, i64 16
  store i64 %.sroa.12.0286.i3517.in, ptr %.sroa_idx104.i3528, align 4
  %.sroa_idx105.i3529 = getelementptr i8, ptr %1726, i64 24
  store i32 %.sroa.17.0285.i3518, ptr %.sroa_idx105.i3529, align 4
  %1728 = icmp ne ptr %1720, @nil_typ
  %1729 = icmp ne ptr %1720, null
  %.not94.i3530 = and i1 %1728, %1729
  br i1 %.not94.i3530, label %.cont.i3535, label %1734

.cont.i3535:                                      ; preds = %1697
  %1730 = add nuw nsw i32 %.0290.i3513, 1
  %1731 = xor i1 %.074289.i3514, true
  %hash_coef_ptr.i.i46.i3536 = getelementptr i8, ptr %1720, i64 8
  %tbl_size_ptr.i.i47.i3537 = getelementptr i8, ptr %1720, i64 16
  %offset_tbl_ptr.i.i48.i3538 = getelementptr i8, ptr %1720, i64 40
  %hash_coef.i.i49.i3539 = load i64, ptr %hash_coef_ptr.i.i46.i3536, align 4
  %tbl_size.i.i50.i3540 = load i64, ptr %tbl_size_ptr.i.i47.i3537, align 4
  %offset_tbl.i.i51.i3541 = load ptr, ptr %offset_tbl_ptr.i.i48.i3538, align 8
  %product.i.i.i52.i3542 = mul i64 %hash_coef.i.i49.i3539, 4015701072841558310
  %shifted.i.i.i53.i3543 = lshr i64 %product.i.i.i52.i3542, 32
  %xored.i.i.i54.i3544 = xor i64 %shifted.i.i.i53.i3543, %product.i.i.i52.i3542
  %hash.i.i.i55.i3545 = and i64 %xored.i.i.i54.i3544, %tbl_size.i.i50.i3540
  %offset_ptr.i.i56.i3546 = getelementptr i32, ptr %offset_tbl.i.i51.i3541, i64 %hash.i.i.i55.i3545
  %offset.i.i57.i3547 = load i32, ptr %offset_ptr.i.i56.i3546, align 4
  %1732 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1733 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3548 = icmp eq i32 %1730, 100
  br i1 %exitcond.not.i3548, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557, label %1697

1734:                                             ; preds = %1697
  %1735 = load i32, ptr %111, align 4
  %1736 = add i32 %1735, 1
  %1737 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1736, ptr %111, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557: ; preds = %1734, %.cont.i3535
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  br label %._crit_edge.i2621

._crit_edge.i2621:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3557, %1683
  %indvars.iv.next.i2622 = add nuw nsw i64 %indvars.iv.i2619, 1
  %exitcond.not.i2623 = icmp eq i64 %indvars.iv.next.i2622, %wide.trip.count.i2618
  br i1 %exitcond.not.i2623, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2641, label %1683

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2641: ; preds = %._crit_edge.i2621
  %1738 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %1739

1739:                                             ; preds = %._crit_edge.i2659, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2641
  %indvars.iv.i2657 = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2641 ], [ %indvars.iv.next.i2660, %._crit_edge.i2659 ]
  %1740 = shl nuw nsw i64 %indvars.iv.i2657, 5
  %1741 = getelementptr i8, ptr %1676, i64 %1740
  %1742 = load ptr, ptr %1741, align 8
  %1743 = icmp ne ptr %1742, @nil_typ
  %1744 = icmp ne ptr %1742, null
  %.not17.i2658 = and i1 %1743, %1744
  br i1 %.not17.i2658, label %1745, label %._crit_edge.i2659

1745:                                             ; preds = %1739
  %1746 = getelementptr i8, ptr %1741, i64 8
  %1747 = load i64, ptr %1746, align 4
  %.sroa_idx.i2662 = getelementptr i8, ptr %1741, i64 16
  %1748 = load i64, ptr %.sroa_idx.i2662, align 4
  %hash_coef_ptr.i.i6.i2663 = getelementptr i8, ptr %1742, i64 8
  %tbl_size_ptr.i.i7.i2664 = getelementptr i8, ptr %1742, i64 16
  %offset_tbl_ptr.i.i8.i2665 = getelementptr i8, ptr %1742, i64 40
  %1749 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %hash_coef.i.i21.i3575 = load i64, ptr %hash_coef_ptr.i.i6.i2663, align 4, !noalias !392
  %tbl_size.i.i22.i3576 = load i64, ptr %tbl_size_ptr.i.i7.i2664, align 4, !noalias !392
  %offset_tbl.i.i23.i3577 = load ptr, ptr %offset_tbl_ptr.i.i8.i2665, align 8, !noalias !392
  %product.i.i.i24.i3578 = mul i64 %hash_coef.i.i21.i3575, 4015701072841558310
  %shifted.i.i.i25.i3579 = lshr i64 %product.i.i.i24.i3578, 32
  %xored.i.i.i26.i3580 = xor i64 %shifted.i.i.i25.i3579, %product.i.i.i24.i3578
  %hash.i.i.i27.i3581 = and i64 %xored.i.i.i26.i3580, %tbl_size.i.i22.i3576
  %offset_ptr.i.i28.i3582 = getelementptr i32, ptr %offset_tbl.i.i23.i3577, i64 %hash.i.i.i27.i3581
  %offset.i.i29.i3583 = load i32, ptr %offset_ptr.i.i28.i3582, align 4, !noalias !392
  %1750 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1751 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1752 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1753

1753:                                             ; preds = %.cont.i3606, %1745
  %.0290.i3584 = phi i32 [ 0, %1745 ], [ %1786, %.cont.i3606 ]
  %.074289.i3585 = phi i1 [ true, %1745 ], [ %1787, %.cont.i3606 ]
  %.sroa.0.0288.i3586 = phi ptr [ %1742, %1745 ], [ %1776, %.cont.i3606 ]
  %.sroa.6.0287.i3587.in = phi i64 [ %1747, %1745 ], [ %1778, %.cont.i3606 ]
  %.sroa.12.0286.i3588.in = phi i64 [ %1748, %1745 ], [ %1779, %.cont.i3606 ]
  %.sroa.17.0285.i3589 = phi i32 [ %offset.i.i29.i3583, %1745 ], [ %offset.i.i57.i3618, %.cont.i3606 ]
  %.sroa.12.0286.i3588 = inttoptr i64 %.sroa.12.0286.i3588.in to ptr
  %.sroa.6.0287.i3587 = inttoptr i64 %.sroa.6.0287.i3587.in to ptr
  %1754 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i3586, 0
  %1755 = insertvalue { ptr, ptr, ptr, i32 } %1754, ptr %.sroa.6.0287.i3587, 1
  %1756 = insertvalue { ptr, ptr, ptr, i32 } %1755, ptr %.sroa.12.0286.i3588, 2
  %1757 = insertvalue { ptr, ptr, ptr, i32 } %1756, i32 %.sroa.17.0285.i3589, 3
  %1758 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i3586)
  %1759 = sext i32 %.sroa.17.0285.i3589 to i64
  %1760 = getelementptr ptr, ptr %.sroa.0.0288.i3586, i64 %1759
  %1761 = getelementptr i8, ptr %1760, i64 64
  %1762 = load ptr, ptr %1761, align 8
  %result.i15.i3590 = call ptr %1762({ ptr, ptr, ptr, i32 } %1757, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1763 = call i32 %result.i15.i3590({ ptr, ptr, ptr, i32 } %1757, { ptr, ptr, ptr, i32 } %1757, ptr nonnull align 8 %2) #53
  %..i3591 = select i1 %.074289.i3585, ptr %4, ptr %6
  %.188.i3592 = select i1 %.074289.i3585, i64 104, i64 112
  %.189.i3593 = select i1 %.074289.i3585, ptr %5, ptr %7
  %.190.i3594 = select i1 %.074289.i3585, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i3591, align 8
  %1764 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i3591)
  %1765 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i3592
  %1766 = load ptr, ptr %1765, align 8
  store ptr @i32_typ, ptr %.189.i3593, align 8
  %result.i14.i3595 = call ptr %1766({ ptr, ptr, ptr, i32 } %127, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i3593) #46
  %1767 = call i32 %result.i14.i3595({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr nonnull align 8 dereferenceable(8) %..i3591, i32 %1763) #53
  %1768 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1769 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i3594
  %1770 = load ptr, ptr %1769, align 8
  %1771 = load ptr, ptr %1770, align 8
  %1772 = call { ptr } %1771(ptr nonnull %result.i78) #43
  %.fca.0.extract55.i3596 = extractvalue { ptr } %1772, 0
  %1773 = sext i32 %1767 to i64
  %1774 = shl nsw i64 %1773, 5
  %1775 = getelementptr i8, ptr %.fca.0.extract55.i3596, i64 %1774
  %1776 = load ptr, ptr %1775, align 8
  %1777 = getelementptr i8, ptr %1775, i64 8
  %1778 = load i64, ptr %1777, align 4
  %.sroa_idx.i3597 = getelementptr i8, ptr %1775, i64 16
  %1779 = load i64, ptr %.sroa_idx.i3597, align 4
  %1780 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1781 = call { ptr } %1771(ptr nonnull %result.i78) #43
  %.fca.0.extract52.i3598 = extractvalue { ptr } %1781, 0
  %1782 = getelementptr i8, ptr %.fca.0.extract52.i3598, i64 %1774
  store ptr %.sroa.0.0288.i3586, ptr %1782, align 8
  %1783 = getelementptr i8, ptr %1782, i64 8
  store i64 %.sroa.6.0287.i3587.in, ptr %1783, align 4
  %.sroa_idx104.i3599 = getelementptr i8, ptr %1782, i64 16
  store i64 %.sroa.12.0286.i3588.in, ptr %.sroa_idx104.i3599, align 4
  %.sroa_idx105.i3600 = getelementptr i8, ptr %1782, i64 24
  store i32 %.sroa.17.0285.i3589, ptr %.sroa_idx105.i3600, align 4
  %1784 = icmp ne ptr %1776, @nil_typ
  %1785 = icmp ne ptr %1776, null
  %.not94.i3601 = and i1 %1784, %1785
  br i1 %.not94.i3601, label %.cont.i3606, label %1790

.cont.i3606:                                      ; preds = %1753
  %1786 = add nuw nsw i32 %.0290.i3584, 1
  %1787 = xor i1 %.074289.i3585, true
  %hash_coef_ptr.i.i46.i3607 = getelementptr i8, ptr %1776, i64 8
  %tbl_size_ptr.i.i47.i3608 = getelementptr i8, ptr %1776, i64 16
  %offset_tbl_ptr.i.i48.i3609 = getelementptr i8, ptr %1776, i64 40
  %hash_coef.i.i49.i3610 = load i64, ptr %hash_coef_ptr.i.i46.i3607, align 4
  %tbl_size.i.i50.i3611 = load i64, ptr %tbl_size_ptr.i.i47.i3608, align 4
  %offset_tbl.i.i51.i3612 = load ptr, ptr %offset_tbl_ptr.i.i48.i3609, align 8
  %product.i.i.i52.i3613 = mul i64 %hash_coef.i.i49.i3610, 4015701072841558310
  %shifted.i.i.i53.i3614 = lshr i64 %product.i.i.i52.i3613, 32
  %xored.i.i.i54.i3615 = xor i64 %shifted.i.i.i53.i3614, %product.i.i.i52.i3613
  %hash.i.i.i55.i3616 = and i64 %xored.i.i.i54.i3615, %tbl_size.i.i50.i3611
  %offset_ptr.i.i56.i3617 = getelementptr i32, ptr %offset_tbl.i.i51.i3612, i64 %hash.i.i.i55.i3616
  %offset.i.i57.i3618 = load i32, ptr %offset_ptr.i.i56.i3617, align 4
  %1788 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1789 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %exitcond.not.i3619 = icmp eq i32 %1786, 100
  br i1 %exitcond.not.i3619, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3628, label %1753

1790:                                             ; preds = %1753
  %1791 = load i32, ptr %111, align 4
  %1792 = add i32 %1791, 1
  %1793 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1792, ptr %111, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3628

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3628: ; preds = %1790, %.cont.i3606
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  br label %._crit_edge.i2659

._crit_edge.i2659:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3628, %1739
  %indvars.iv.next.i2660 = add nuw nsw i64 %indvars.iv.i2657, 1
  %exitcond.not.i2661 = icmp eq i64 %indvars.iv.next.i2660, %wide.trip.count.i2618
  br i1 %exitcond.not.i2661, label %CuckooMap_insert_keyK_valueV.exit530, label %1739

CuckooMap_insert_keyK_valueV.exit530:             ; preds = %._crit_edge.i2659, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit2641.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1624, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1529, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1434, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1375
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1794 = add nsw i32 %.0376301, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit530, %CuckooMap_get_keyK.exit
  %_parameterization_Bool = phi ptr [ @_parameterization_Bool, %CuckooMap_insert_keyK_valueV.exit530 ], [ %_parameterization_Bool296298, %CuckooMap_get_keyK.exit ]
  %_parameterization_i32293 = phi ptr [ @_parameterization_i32, %CuckooMap_insert_keyK_valueV.exit530 ], [ %_parameterization_i32294299, %CuckooMap_get_keyK.exit ]
  %_parameterization_i32 = phi ptr [ @_parameterization_i32, %CuckooMap_insert_keyK_valueV.exit530 ], [ %_parameterization_i32291300, %CuckooMap_get_keyK.exit ]
  %.1377 = phi i32 [ %1794, %CuckooMap_insert_keyK_valueV.exit530 ], [ %.0376301, %CuckooMap_get_keyK.exit ]
  %1795 = add nuw nsw i32 %.0374302, 1
  %1796 = icmp slt i32 %.1377, %0
  %1797 = icmp slt i32 %1795, %112
  %spec.select = select i1 %1796, i1 %1797, i1 false
  br i1 %spec.select, label %129, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %_parameterization_Bool296.lcssa = phi ptr [ %.promoted295, %1 ], [ %_parameterization_Bool, %._crit_edge1 ]
  %_parameterization_i32294.lcssa = phi ptr [ %.promoted292, %1 ], [ %_parameterization_i32293, %._crit_edge1 ]
  %_parameterization_i32291.lcssa = phi ptr [ %.promoted, %1 ], [ %_parameterization_i32, %._crit_edge1 ]
  %.0376.lcssa = phi i32 [ 0, %1 ], [ %.1377, %._crit_edge1 ]
  store ptr %_parameterization_i32291.lcssa, ptr %113, align 8
  store ptr %_parameterization_i32294.lcssa, ptr %114, align 8
  store ptr %_parameterization_Bool296.lcssa, ptr %115, align 8
  %1798 = icmp slt i32 %.0376.lcssa, %0
  br i1 %1798, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1799 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1800 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i.i2012.h2s3888, align 1
  %1801 = getelementptr inbounds i8, ptr %result.i.i2012.h2s3888, i64 29
  store i8 0, ptr %1801, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i.i2012.h2s3888) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1802 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0376.lcssa) #55
  %1803 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1804 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1805 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <29 x i8> <i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %result.i.i2027.h2s3886, align 1
  %1806 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1807 = getelementptr inbounds i8, ptr %result.i.i2027.h2s3886, i64 29
  store i8 0, ptr %1807, align 1
  %puts.i805 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(30) %result.i.i2027.h2s3886) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge.lr.ph.i, %._crit_edge3._crit_edge
  %.0384 = phi i32 [ %.0376.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %1808 = call i64 @clock()
  %1809 = load <37 x i8>, ptr @wovqv_Warning_Remove_returned_Nil_for_key_, align 64
  %1810 = getelementptr inbounds i8, ptr %72, i64 8
  %1811 = getelementptr inbounds i8, ptr %72, i64 16
  %1812 = load <45 x i8>, ptr @hnbwj_Warning_Remove_returned_wrong_value_for_key_, align 64
  %1813 = getelementptr inbounds i8, ptr %71, i64 8
  %1814 = getelementptr inbounds i8, ptr %71, i64 16
  %.promoted309 = load ptr, ptr %1811, align 8
  %.promoted312 = load ptr, ptr %1814, align 8
  %1815 = icmp sgt i32 %.0384, 0
  br i1 %1815, label %.lr.ph321.preheader, label %._crit_edge8

.lr.ph321.preheader:                              ; preds = %._crit_edge4
  %1816 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %1817 = zext nneg i32 %.0384 to i64
  %.pre = load ptr, ptr %97, align 8
  %1818 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  br label %.lr.ph321

.lr.ph321:                                        ; preds = %._crit_edge5, %.lr.ph321.preheader
  %indvars.iv = phi i64 [ 0, %.lr.ph321.preheader ], [ %indvars.iv.next, %._crit_edge5 ]
  %.0373320 = phi i32 [ 0, %.lr.ph321.preheader ], [ %.1, %._crit_edge5 ]
  %.0379319 = phi i1 [ true, %.lr.ph321.preheader ], [ %.2381, %._crit_edge5 ]
  %_parameterization_i32311317 = phi ptr [ %.promoted309, %.lr.ph321.preheader ], [ %_parameterization_i32310, %._crit_edge5 ]
  %_parameterization_i32315316 = phi ptr [ %.promoted312, %.lr.ph321.preheader ], [ %_parameterization_i32313, %._crit_edge5 ]
  %1819 = shl i64 %indvars.iv, 2
  %1820 = getelementptr i8, ptr %.pre, i64 %1819
  %1821 = load i32, ptr %1820, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %1821 to i160
  %1822 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %1823 = load ptr, ptr %86, align 8
  %1824 = call i32 %1823({ ptr, i160 } %1822) #53
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1826 = load i32, ptr %88, align 8
  %1827 = add i32 %1826, -1
  %1828 = and i32 %1827, %1824
  %1829 = load ptr, ptr %89, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1830 = sext i32 %1828 to i64
  %1831 = shl nsw i64 %1830, 5
  %1832 = getelementptr i8, ptr %1829, i64 %1831
  %1833 = load ptr, ptr %1832, align 8
  %1834 = icmp ne ptr %1833, @nil_typ
  %1835 = icmp ne ptr %1833, null
  %.not53.i = and i1 %1834, %1835
  br i1 %.not53.i, label %1836, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

1836:                                             ; preds = %.lr.ph321
  %1837 = getelementptr i8, ptr %1832, i64 8
  %1838 = load i64, ptr %1837, align 4
  %.sroa_idx.i1688 = getelementptr i8, ptr %1832, i64 16
  %1839 = load i64, ptr %.sroa_idx.i1688, align 4
  %1840 = inttoptr i64 %1838 to ptr
  %1841 = inttoptr i64 %1839 to ptr
  %hash_coef_ptr.i.i4.i1689 = getelementptr i8, ptr %1833, i64 8
  %tbl_size_ptr.i.i5.i1690 = getelementptr i8, ptr %1833, i64 16
  %offset_tbl_ptr.i.i6.i1691 = getelementptr i8, ptr %1833, i64 40
  %hash_coef.i.i7.i1692 = load i64, ptr %hash_coef_ptr.i.i4.i1689, align 4, !noalias !395
  %tbl_size.i.i8.i1693 = load i64, ptr %tbl_size_ptr.i.i5.i1690, align 4, !noalias !395
  %offset_tbl.i.i9.i1694 = load ptr, ptr %offset_tbl_ptr.i.i6.i1691, align 8, !noalias !395
  %product.i.i.i10.i1695 = mul i64 %hash_coef.i.i7.i1692, 4015701072841558310
  %shifted.i.i.i11.i1696 = lshr i64 %product.i.i.i10.i1695, 32
  %xored.i.i.i12.i1697 = xor i64 %shifted.i.i.i11.i1696, %product.i.i.i10.i1695
  %hash.i.i.i13.i1698 = and i64 %xored.i.i.i12.i1697, %tbl_size.i.i8.i1693
  %offset_ptr.i.i14.i1699 = getelementptr i32, ptr %offset_tbl.i.i9.i1694, i64 %hash.i.i.i13.i1698
  %offset.i.i15.i1700 = load i32, ptr %offset_ptr.i.i14.i1699, align 4, !noalias !395
  %1842 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1833, 0
  %1843 = insertvalue { ptr, ptr, ptr, i32 } %1842, ptr %1840, 1
  %1844 = insertvalue { ptr, ptr, ptr, i32 } %1843, ptr %1841, 2
  %1845 = insertvalue { ptr, ptr, ptr, i32 } %1844, i32 %offset.i.i15.i1700, 3
  %1846 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1847 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1833) #40
  %1848 = sext i32 %offset.i.i15.i1700 to i64
  %1849 = getelementptr ptr, ptr %1833, i64 %1848
  %1850 = getelementptr i8, ptr %1849, i64 64
  %1851 = load ptr, ptr %1850, align 8
  %result.i2.i = call ptr %1851({ ptr, ptr, ptr, i32 } %1845, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1852 = call i32 %result.i2.i({ ptr, ptr, ptr, i32 } %1845, { ptr, ptr, ptr, i32 } %1845, ptr nonnull align 8 %2) #53
  %1853 = icmp eq i32 %1852, %1824
  br i1 %1853, label %._crit_edge.i1701, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1701:                                ; preds = %1836
  %1854 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1855 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1833)
  %1856 = getelementptr i8, ptr %1849, i64 48
  %1857 = load ptr, ptr %1856, align 8
  %result.i1.i1702 = call ptr %1857({ ptr, ptr, ptr, i32 } %1845, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1858 = call { ptr, i160 } %result.i1.i1702({ ptr, ptr, ptr, i32 } %1845, { ptr, ptr, ptr, i32 } %1845, ptr nonnull align 8 %2) #53
  %1859 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1860 = load ptr, ptr %87, align 8
  %1861 = call i1 %1860({ ptr, i160 } %1858, { ptr, i160 } %1822) #53
  br i1 %1861, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1701, %1836, %.lr.ph321
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1872

CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1701
  %1862 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1863 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1833)
  %1864 = getelementptr i8, ptr %1849, i64 56
  %1865 = load ptr, ptr %1864, align 8
  %result.i.i1703 = call ptr %1865({ ptr, ptr, ptr, i32 } %1845, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1866 = call { ptr, i160 } %result.i.i1703({ ptr, ptr, ptr, i32 } %1845, { ptr, ptr, ptr, i32 } %1845, ptr nonnull align 8 %2) #53
  %.fca.0.extract30.i = extractvalue { ptr, i160 } %1866, 0
  %.fca.1.extract31.i = extractvalue { ptr, i160 } %1866, 1
  store ptr @nil_typ, ptr %1832, align 8
  %1867 = load i32, ptr %91, align 4
  %1868 = add i32 %1867, -1
  store i32 %1868, ptr %91, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1869 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1870 = icmp ne ptr %.fca.0.extract30.i, @nil_typ
  %1871 = icmp ne ptr %.fca.0.extract30.i, null
  %.not63.i592 = and i1 %1870, %1871
  %extract.t1946 = trunc i160 %.fca.1.extract31.i to i32
  br i1 %.not63.i592, label %CuckooMap_remove_keyK.exit, label %1872

1872:                                             ; preds = %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread
  %1873 = add i32 %1824, 2127912214
  %1874 = shl i32 %1824, 12
  %1875 = add i32 %1873, %1874
  %1876 = ashr i32 %1875, 19
  %1877 = xor i32 %1875, %1876
  %1878 = xor i32 %1877, -949894596
  %1879 = add i32 %1878, 374761393
  %1880 = shl i32 %1878, 5
  %1881 = add i32 %1879, %1880
  %1882 = add i32 %1881, -744332180
  %1883 = shl i32 %1881, 9
  %1884 = xor i32 %1882, %1883
  %1885 = add i32 %1884, -42973499
  %1886 = shl i32 %1884, 3
  %1887 = add i32 %1885, %1886
  %1888 = ashr i32 %1887, 16
  %1889 = xor i32 %1887, %1888
  %1890 = xor i32 %1889, -1252372727
  %1891 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1892 = load i32, ptr %88, align 8
  %1893 = add i32 %1892, -1
  %1894 = and i32 %1893, %1890
  %1895 = load ptr, ptr %90, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1896 = sext i32 %1894 to i64
  %1897 = shl nsw i64 %1896, 5
  %1898 = getelementptr i8, ptr %1895, i64 %1897
  %1899 = load ptr, ptr %1898, align 8
  %1900 = icmp ne ptr %1899, @nil_typ
  %1901 = icmp ne ptr %1899, null
  %.not53.i1733 = and i1 %1900, %1901
  br i1 %.not53.i1733, label %1902, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758

1902:                                             ; preds = %1872
  %1903 = getelementptr i8, ptr %1898, i64 8
  %1904 = load i64, ptr %1903, align 4
  %.sroa_idx.i1738 = getelementptr i8, ptr %1898, i64 16
  %1905 = load i64, ptr %.sroa_idx.i1738, align 4
  %1906 = inttoptr i64 %1904 to ptr
  %1907 = inttoptr i64 %1905 to ptr
  %hash_coef_ptr.i.i4.i1739 = getelementptr i8, ptr %1899, i64 8
  %tbl_size_ptr.i.i5.i1740 = getelementptr i8, ptr %1899, i64 16
  %offset_tbl_ptr.i.i6.i1741 = getelementptr i8, ptr %1899, i64 40
  %hash_coef.i.i7.i1742 = load i64, ptr %hash_coef_ptr.i.i4.i1739, align 4, !noalias !398
  %tbl_size.i.i8.i1743 = load i64, ptr %tbl_size_ptr.i.i5.i1740, align 4, !noalias !398
  %offset_tbl.i.i9.i1744 = load ptr, ptr %offset_tbl_ptr.i.i6.i1741, align 8, !noalias !398
  %product.i.i.i10.i1745 = mul i64 %hash_coef.i.i7.i1742, 4015701072841558310
  %shifted.i.i.i11.i1746 = lshr i64 %product.i.i.i10.i1745, 32
  %xored.i.i.i12.i1747 = xor i64 %shifted.i.i.i11.i1746, %product.i.i.i10.i1745
  %hash.i.i.i13.i1748 = and i64 %xored.i.i.i12.i1747, %tbl_size.i.i8.i1743
  %offset_ptr.i.i14.i1749 = getelementptr i32, ptr %offset_tbl.i.i9.i1744, i64 %hash.i.i.i13.i1748
  %offset.i.i15.i1750 = load i32, ptr %offset_ptr.i.i14.i1749, align 4, !noalias !398
  %1908 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1899, 0
  %1909 = insertvalue { ptr, ptr, ptr, i32 } %1908, ptr %1906, 1
  %1910 = insertvalue { ptr, ptr, ptr, i32 } %1909, ptr %1907, 2
  %1911 = insertvalue { ptr, ptr, ptr, i32 } %1910, i32 %offset.i.i15.i1750, 3
  %1912 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1913 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1899) #40
  %1914 = sext i32 %offset.i.i15.i1750 to i64
  %1915 = getelementptr ptr, ptr %1899, i64 %1914
  %1916 = getelementptr i8, ptr %1915, i64 64
  %1917 = load ptr, ptr %1916, align 8
  %result.i2.i1751 = call ptr %1917({ ptr, ptr, ptr, i32 } %1911, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1918 = call i32 %result.i2.i1751({ ptr, ptr, ptr, i32 } %1911, { ptr, ptr, ptr, i32 } %1911, ptr nonnull align 8 %2) #53
  %1919 = icmp eq i32 %1918, %1824
  br i1 %1919, label %._crit_edge.i1752, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758

._crit_edge.i1752:                                ; preds = %1902
  %1920 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1921 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1899)
  %1922 = getelementptr i8, ptr %1915, i64 48
  %1923 = load ptr, ptr %1922, align 8
  %result.i1.i1753 = call ptr %1923({ ptr, ptr, ptr, i32 } %1911, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1924 = call { ptr, i160 } %result.i1.i1753({ ptr, ptr, ptr, i32 } %1911, { ptr, ptr, ptr, i32 } %1911, ptr nonnull align 8 %2) #53
  %1925 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1926 = load ptr, ptr %87, align 8
  %1927 = call i1 %1926({ ptr, i160 } %1924, { ptr, i160 } %1822) #53
  br i1 %1927, label %1928, label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758

1928:                                             ; preds = %._crit_edge.i1752
  %1929 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1930 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1899)
  %1931 = getelementptr i8, ptr %1915, i64 56
  %1932 = load ptr, ptr %1931, align 8
  %result.i.i1755 = call ptr %1932({ ptr, ptr, ptr, i32 } %1911, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %1933 = call { ptr, i160 } %result.i.i1755({ ptr, ptr, ptr, i32 } %1911, { ptr, ptr, ptr, i32 } %1911, ptr nonnull align 8 %2) #53
  %.fca.0.extract30.i1756 = extractvalue { ptr, i160 } %1933, 0
  %.fca.1.extract31.i1757 = extractvalue { ptr, i160 } %1933, 1
  store ptr @nil_typ, ptr %1898, align 8
  %1934 = load i32, ptr %91, align 4
  %1935 = add i32 %1934, -1
  store i32 %1935, ptr %91, align 4
  %1936 = trunc i160 %.fca.1.extract31.i1757 to i32
  br label %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758

CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758: ; preds = %1928, %._crit_edge.i1752, %1902, %1872
  %.reg2mem47.sroa.3.0.i1734 = phi i32 [ %1936, %1928 ], [ poison, %._crit_edge.i1752 ], [ poison, %1872 ], [ poison, %1902 ]
  %.reg2mem45.0.i1735 = phi ptr [ %.fca.0.extract30.i1756, %1928 ], [ @nil_typ, %._crit_edge.i1752 ], [ @nil_typ, %1872 ], [ @nil_typ, %1902 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1937 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i597 = icmp eq ptr %.reg2mem45.0.i1735, null
  %1938 = select i1 %.not.i597, ptr @nil_typ, ptr %.reg2mem45.0.i1735
  br label %CuckooMap_remove_keyK.exit

CuckooMap_remove_keyK.exit:                       ; preds = %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit
  %.not63.i5921940.off0 = phi i32 [ %.reg2mem47.sroa.3.0.i1734, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758 ], [ %extract.t1946, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %.reg2mem56.0.i598 = phi ptr [ %1938, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1758 ], [ %.fca.0.extract30.i, %CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit ]
  %1939 = icmp ne ptr %.reg2mem56.0.i598, @nil_typ
  %1940 = icmp ne ptr %.reg2mem56.0.i598, null
  %.not388 = and i1 %1939, %1940
  br i1 %.not388, label %1941, label %._crit_edge.lr.ph.i2068

1941:                                             ; preds = %CuckooMap_remove_keyK.exit
  %1942 = add i32 %1821, 1
  %.not = icmp eq i32 %1942, %.not63.i5921940.off0
  br i1 %.not, label %._crit_edge6, label %._crit_edge.lr.ph.i2048

._crit_edge.lr.ph.i2048:                          ; preds = %1941
  %result.i71.h2s3894 = alloca [46 x i8], align 1
  %1943 = getelementptr inbounds i8, ptr %result.i71.h2s3894, i64 45
  store i8 0, ptr %1943, align 1
  store <45 x i8> %1812, ptr %result.i71.h2s3894, align 1
  store ptr @_parameterization_Bufferi8, ptr %71, align 8
  store ptr @_parameterization_i32, ptr %1813, align 8
  %1944 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %71)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1945 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1946 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %result.i.i2047.h2s3895 = alloca [46 x i8], align 1
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(46) %result.i.i2047.h2s3895, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(46) %result.i71.h2s3894, i64 noundef 45, i1 noundef false)
  %1947 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1948 = getelementptr inbounds i8, ptr %result.i.i2047.h2s3895, i64 45
  store i8 0, ptr %1948, align 1
  %puts.i825 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(46) %result.i.i2047.h2s3895) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1949 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1950 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1821) #55
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge.lr.ph.i2048, %1941
  %_parameterization_i32314 = phi ptr [ @_parameterization_i32, %._crit_edge.lr.ph.i2048 ], [ %_parameterization_i32315316, %1941 ]
  %.1380 = phi i1 [ false, %._crit_edge.lr.ph.i2048 ], [ %.0379319, %1941 ]
  %1951 = add i32 %.0373320, 1
  br label %._crit_edge5

._crit_edge.lr.ph.i2068:                          ; preds = %CuckooMap_remove_keyK.exit
  %result.i69.h2s3892 = alloca [38 x i8], align 1
  %1952 = getelementptr inbounds i8, ptr %result.i69.h2s3892, i64 37
  store i8 0, ptr %1952, align 1
  store <37 x i8> %1809, ptr %result.i69.h2s3892, align 1
  store ptr @_parameterization_Bufferi8, ptr %72, align 8
  store ptr @_parameterization_i32, ptr %1810, align 8
  %1953 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %72)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1954 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1955 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %result.i.i2067.h2s3893 = alloca [38 x i8], align 1
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(38) %result.i.i2067.h2s3893, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(38) %result.i69.h2s3892, i64 noundef 37, i1 noundef false)
  %1956 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1957 = getelementptr inbounds i8, ptr %result.i.i2067.h2s3893, i64 37
  store i8 0, ptr %1957, align 1
  %puts.i845 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(38) %result.i.i2067.h2s3893) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1958 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1959 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1821) #55
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge.lr.ph.i2068, %._crit_edge6
  %_parameterization_i32313 = phi ptr [ %_parameterization_i32314, %._crit_edge6 ], [ %_parameterization_i32315316, %._crit_edge.lr.ph.i2068 ]
  %_parameterization_i32310 = phi ptr [ %_parameterization_i32311317, %._crit_edge6 ], [ @_parameterization_i32, %._crit_edge.lr.ph.i2068 ]
  %.2381 = phi i1 [ %.1380, %._crit_edge6 ], [ false, %._crit_edge.lr.ph.i2068 ]
  %.1 = phi i32 [ %1951, %._crit_edge6 ], [ %.0373320, %._crit_edge.lr.ph.i2068 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %1817
  br i1 %exitcond.not, label %._crit_edge8, label %.lr.ph321

._crit_edge8:                                     ; preds = %._crit_edge5, %._crit_edge4
  %_parameterization_i32315.lcssa = phi ptr [ %.promoted312, %._crit_edge4 ], [ %_parameterization_i32313, %._crit_edge5 ]
  %_parameterization_i32311.lcssa = phi ptr [ %.promoted309, %._crit_edge4 ], [ %_parameterization_i32310, %._crit_edge5 ]
  %.0379.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.2381, %._crit_edge5 ]
  %.0373.lcssa = phi i32 [ 0, %._crit_edge4 ], [ %.1, %._crit_edge5 ]
  store ptr %_parameterization_i32311.lcssa, ptr %1811, align 8
  store ptr %_parameterization_i32315.lcssa, ptr %1814, align 8
  %1960 = call i64 @clock()
  %.not389 = icmp eq i32 %.0373.lcssa, %.0384
  %1961 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1962 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  %1963 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1964 = load i32, ptr %91, align 4
  %.not390 = icmp eq i32 %1964, 0
  %1965 = select i1 %.not390, i1 %.not389, i1 false
  %spec.select396 = select i1 %1965, i1 %.0379.lcssa, i1 false
  br i1 %1815, label %1966, label %._crit_edge.lr.ph.i2088

1966:                                             ; preds = %._crit_edge8
  %1967 = load ptr, ptr %97, align 8
  %1968 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %1969 = load i32, ptr %1967, align 1
  %.sroa.2.sroa.0.0.insert.ext.i1759 = zext i32 %1969 to i160
  %1970 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i1759, 1
  %1971 = load ptr, ptr %86, align 8
  %1972 = call i32 %1971({ ptr, i160 } %1970) #53
  %1973 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1974 = load i32, ptr %88, align 8
  %1975 = add i32 %1974, -1
  %1976 = and i32 %1975, %1972
  %1977 = load ptr, ptr %89, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1978 = sext i32 %1976 to i64
  %1979 = shl nsw i64 %1978, 5
  %1980 = getelementptr i8, ptr %1977, i64 %1979
  %1981 = load ptr, ptr %1980, align 8
  %1982 = icmp ne ptr %1981, @nil_typ
  %1983 = icmp ne ptr %1981, null
  %.not45.i1801 = and i1 %1982, %1983
  br i1 %.not45.i1801, label %1984, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826.thread

1984:                                             ; preds = %1966
  %1985 = getelementptr i8, ptr %1980, i64 8
  %1986 = load i64, ptr %1985, align 4
  %.sroa_idx.i1806 = getelementptr i8, ptr %1980, i64 16
  %1987 = load i64, ptr %.sroa_idx.i1806, align 4
  %1988 = inttoptr i64 %1986 to ptr
  %1989 = inttoptr i64 %1987 to ptr
  %hash_coef_ptr.i.i4.i1807 = getelementptr i8, ptr %1981, i64 8
  %tbl_size_ptr.i.i5.i1808 = getelementptr i8, ptr %1981, i64 16
  %offset_tbl_ptr.i.i6.i1809 = getelementptr i8, ptr %1981, i64 40
  %hash_coef.i.i7.i1810 = load i64, ptr %hash_coef_ptr.i.i4.i1807, align 4, !noalias !401
  %tbl_size.i.i8.i1811 = load i64, ptr %tbl_size_ptr.i.i5.i1808, align 4, !noalias !401
  %offset_tbl.i.i9.i1812 = load ptr, ptr %offset_tbl_ptr.i.i6.i1809, align 8, !noalias !401
  %product.i.i.i10.i1813 = mul i64 %hash_coef.i.i7.i1810, 4015701072841558310
  %shifted.i.i.i11.i1814 = lshr i64 %product.i.i.i10.i1813, 32
  %xored.i.i.i12.i1815 = xor i64 %shifted.i.i.i11.i1814, %product.i.i.i10.i1813
  %hash.i.i.i13.i1816 = and i64 %xored.i.i.i12.i1815, %tbl_size.i.i8.i1811
  %offset_ptr.i.i14.i1817 = getelementptr i32, ptr %offset_tbl.i.i9.i1812, i64 %hash.i.i.i13.i1816
  %offset.i.i15.i1818 = load i32, ptr %offset_ptr.i.i14.i1817, align 4, !noalias !401
  %1990 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1981, 0
  %1991 = insertvalue { ptr, ptr, ptr, i32 } %1990, ptr %1988, 1
  %1992 = insertvalue { ptr, ptr, ptr, i32 } %1991, ptr %1989, 2
  %1993 = insertvalue { ptr, ptr, ptr, i32 } %1992, i32 %offset.i.i15.i1818, 3
  %1994 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %1995 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1981) #40
  %1996 = sext i32 %offset.i.i15.i1818 to i64
  %1997 = getelementptr ptr, ptr %1981, i64 %1996
  %1998 = getelementptr i8, ptr %1997, i64 64
  %1999 = load ptr, ptr %1998, align 8
  %result.i2.i1819 = call ptr %1999({ ptr, ptr, ptr, i32 } %1993, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2000 = call i32 %result.i2.i1819({ ptr, ptr, ptr, i32 } %1993, { ptr, ptr, ptr, i32 } %1993, ptr nonnull align 8 %2) #53
  %2001 = icmp eq i32 %2000, %1972
  br i1 %2001, label %._crit_edge.i1820, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826.thread

._crit_edge.i1820:                                ; preds = %1984
  %2002 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2003 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1981)
  %2004 = getelementptr i8, ptr %1997, i64 48
  %2005 = load ptr, ptr %2004, align 8
  %result.i1.i1821 = call ptr %2005({ ptr, ptr, ptr, i32 } %1993, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2006 = call { ptr, i160 } %result.i1.i1821({ ptr, ptr, ptr, i32 } %1993, { ptr, ptr, ptr, i32 } %1993, ptr nonnull align 8 %2) #53
  %2007 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %2008 = load ptr, ptr %87, align 8
  %2009 = call i1 %2008({ ptr, i160 } %2006, { ptr, i160 } %1970) #53
  br i1 %2009, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826.thread

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826.thread: ; preds = %._crit_edge.i1820, %1984, %1966
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2018

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826: ; preds = %._crit_edge.i1820
  %2010 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2011 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1981)
  %2012 = getelementptr i8, ptr %1997, i64 56
  %2013 = load ptr, ptr %2012, align 8
  %result.i.i1823 = call ptr %2013({ ptr, ptr, ptr, i32 } %1993, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2014 = call { ptr, i160 } %result.i.i1823({ ptr, ptr, ptr, i32 } %1993, { ptr, ptr, ptr, i32 } %1993, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1824 = extractvalue { ptr, i160 } %2014, 0
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2015 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %2016 = icmp ne ptr %.fca.0.extract22.i1824, @nil_typ
  %2017 = icmp ne ptr %.fca.0.extract22.i1824, null
  %.not63.i684 = and i1 %2016, %2017
  br i1 %.not63.i684, label %CuckooMap_get_keyK.exit698, label %2018

2018:                                             ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826.thread
  %2019 = add i32 %1972, 2127912214
  %2020 = shl i32 %1972, 12
  %2021 = add i32 %2019, %2020
  %2022 = ashr i32 %2021, 19
  %2023 = xor i32 %2021, %2022
  %2024 = xor i32 %2023, -949894596
  %2025 = add i32 %2024, 374761393
  %2026 = shl i32 %2024, 5
  %2027 = add i32 %2025, %2026
  %2028 = add i32 %2027, -744332180
  %2029 = shl i32 %2027, 9
  %2030 = xor i32 %2028, %2029
  %2031 = add i32 %2030, -42973499
  %2032 = shl i32 %2030, 3
  %2033 = add i32 %2031, %2032
  %2034 = ashr i32 %2033, 16
  %2035 = xor i32 %2033, %2034
  %2036 = xor i32 %2035, -1252372727
  %2037 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %2038 = load i32, ptr %88, align 8
  %2039 = add i32 %2038, -1
  %2040 = and i32 %2039, %2036
  %2041 = load ptr, ptr %90, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2042 = sext i32 %2040 to i64
  %2043 = shl nsw i64 %2042, 5
  %2044 = getelementptr i8, ptr %2041, i64 %2043
  %2045 = load ptr, ptr %2044, align 8
  %2046 = icmp ne ptr %2045, @nil_typ
  %2047 = icmp ne ptr %2045, null
  %.not45.i1856 = and i1 %2046, %2047
  br i1 %.not45.i1856, label %2048, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1881

2048:                                             ; preds = %2018
  %2049 = getelementptr i8, ptr %2044, i64 8
  %2050 = load i64, ptr %2049, align 4
  %.sroa_idx.i1861 = getelementptr i8, ptr %2044, i64 16
  %2051 = load i64, ptr %.sroa_idx.i1861, align 4
  %2052 = inttoptr i64 %2050 to ptr
  %2053 = inttoptr i64 %2051 to ptr
  %hash_coef_ptr.i.i4.i1862 = getelementptr i8, ptr %2045, i64 8
  %tbl_size_ptr.i.i5.i1863 = getelementptr i8, ptr %2045, i64 16
  %offset_tbl_ptr.i.i6.i1864 = getelementptr i8, ptr %2045, i64 40
  %hash_coef.i.i7.i1865 = load i64, ptr %hash_coef_ptr.i.i4.i1862, align 4, !noalias !404
  %tbl_size.i.i8.i1866 = load i64, ptr %tbl_size_ptr.i.i5.i1863, align 4, !noalias !404
  %offset_tbl.i.i9.i1867 = load ptr, ptr %offset_tbl_ptr.i.i6.i1864, align 8, !noalias !404
  %product.i.i.i10.i1868 = mul i64 %hash_coef.i.i7.i1865, 4015701072841558310
  %shifted.i.i.i11.i1869 = lshr i64 %product.i.i.i10.i1868, 32
  %xored.i.i.i12.i1870 = xor i64 %shifted.i.i.i11.i1869, %product.i.i.i10.i1868
  %hash.i.i.i13.i1871 = and i64 %xored.i.i.i12.i1870, %tbl_size.i.i8.i1866
  %offset_ptr.i.i14.i1872 = getelementptr i32, ptr %offset_tbl.i.i9.i1867, i64 %hash.i.i.i13.i1871
  %offset.i.i15.i1873 = load i32, ptr %offset_ptr.i.i14.i1872, align 4, !noalias !404
  %2054 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2045, 0
  %2055 = insertvalue { ptr, ptr, ptr, i32 } %2054, ptr %2052, 1
  %2056 = insertvalue { ptr, ptr, ptr, i32 } %2055, ptr %2053, 2
  %2057 = insertvalue { ptr, ptr, ptr, i32 } %2056, i32 %offset.i.i15.i1873, 3
  %2058 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2059 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %2045) #40
  %2060 = sext i32 %offset.i.i15.i1873 to i64
  %2061 = getelementptr ptr, ptr %2045, i64 %2060
  %2062 = getelementptr i8, ptr %2061, i64 64
  %2063 = load ptr, ptr %2062, align 8
  %result.i2.i1874 = call ptr %2063({ ptr, ptr, ptr, i32 } %2057, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2064 = call i32 %result.i2.i1874({ ptr, ptr, ptr, i32 } %2057, { ptr, ptr, ptr, i32 } %2057, ptr nonnull align 8 %2) #53
  %2065 = icmp eq i32 %2064, %1972
  br i1 %2065, label %._crit_edge.i1875, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1881

._crit_edge.i1875:                                ; preds = %2048
  %2066 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2067 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %2045)
  %2068 = getelementptr i8, ptr %2061, i64 48
  %2069 = load ptr, ptr %2068, align 8
  %result.i1.i1876 = call ptr %2069({ ptr, ptr, ptr, i32 } %2057, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2070 = call { ptr, i160 } %result.i1.i1876({ ptr, ptr, ptr, i32 } %2057, { ptr, ptr, ptr, i32 } %2057, ptr nonnull align 8 %2) #53
  %2071 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %2072 = load ptr, ptr %87, align 8
  %2073 = call i1 %2072({ ptr, i160 } %2070, { ptr, i160 } %1970) #53
  br i1 %2073, label %2074, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1881

2074:                                             ; preds = %._crit_edge.i1875
  %2075 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2076 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %2045)
  %2077 = getelementptr i8, ptr %2061, i64 56
  %2078 = load ptr, ptr %2077, align 8
  %result.i.i1878 = call ptr %2078({ ptr, ptr, ptr, i32 } %2057, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  %2079 = call { ptr, i160 } %result.i.i1878({ ptr, ptr, ptr, i32 } %2057, { ptr, ptr, ptr, i32 } %2057, ptr nonnull align 8 %2) #53
  %.fca.0.extract22.i1879 = extractvalue { ptr, i160 } %2079, 0
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1881

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1881: ; preds = %2074, %._crit_edge.i1875, %2048, %2018
  %.reg2mem41.0.i1858 = phi ptr [ %.fca.0.extract22.i1879, %2074 ], [ @nil_typ, %._crit_edge.i1875 ], [ @nil_typ, %2018 ], [ @nil_typ, %2048 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2080 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i691 = icmp eq ptr %.reg2mem41.0.i1858, null
  %2081 = select i1 %.not.i691, ptr @nil_typ, ptr %.reg2mem41.0.i1858
  br label %CuckooMap_get_keyK.exit698

CuckooMap_get_keyK.exit698:                       ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1881, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826
  %.reg2mem56.0.i692 = phi ptr [ %2081, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1881 ], [ %.fca.0.extract22.i1824, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit1826 ]
  %2082 = icmp eq ptr %.reg2mem56.0.i692, @nil_typ
  %2083 = icmp eq ptr %.reg2mem56.0.i692, null
  %.not393.not = or i1 %2082, %2083
  %spec.select395 = select i1 %.not393.not, i1 %spec.select396, i1 false
  br label %._crit_edge.lr.ph.i2088

._crit_edge.lr.ph.i2088:                          ; preds = %CuckooMap_get_keyK.exit698, %._crit_edge8
  %.6 = phi i1 [ %spec.select396, %._crit_edge8 ], [ %spec.select395, %CuckooMap_get_keyK.exit698 ]
  %2084 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2085 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2086 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i.i2087.h2s3884, align 16
  %2087 = sub i64 %1960, %1808
  %2088 = getelementptr inbounds i8, ptr %result.i.i2087.h2s3884, i64 13
  store i8 0, ptr %2088, align 1
  %puts.i866 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(14) %result.i.i2087.h2s3884) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i.i.i.h2s3882, align 16
  %2089 = getelementptr inbounds i8, ptr %result.i.i.i.h2s3882, i64 14
  store i8 0, ptr %2089, align 2
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.h2s3882) #53
  %2090 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0384) #55
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i.i304.i.h2s3880, align 16
  %2091 = getelementptr inbounds i8, ptr %result.i.i304.i.h2s3880, i64 14
  store i8 0, ptr %2091, align 2
  %puts.i229.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.h2s3880) #53
  %2092 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2087) #55
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i.i324.i.h2s3878, align 4
  %2093 = getelementptr inbounds i8, ptr %result.i.i324.i.h2s3878, i64 3
  store i8 0, ptr %2093, align 1
  %puts.i249.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.h2s3878) #53
  br i1 %1815, label %._crit_edge.lr.ph.i345.i, label %._crit_edge.lr.ph.i2108

._crit_edge.lr.ph.i345.i:                         ; preds = %._crit_edge.lr.ph.i2088
  %2094 = zext nneg i32 %.0384 to i64
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i.i344.i.h2s3876, align 16
  %2095 = mul i64 %2087, 1000000
  %2096 = sdiv i64 %2095, %2094
  %2097 = getelementptr inbounds i8, ptr %result.i.i344.i.h2s3876, i64 15
  store i8 0, ptr %2097, align 1
  %puts.i269.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.h2s3876) #53
  %2098 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2096) #55
  %2099 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i.i364.i.h2s3874, align 4
  %2100 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %2101 = getelementptr inbounds i8, ptr %result.i.i364.i.h2s3874, i64 3
  store i8 0, ptr %2101, align 1
  %puts.i289.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.h2s3874) #53
  br label %._crit_edge.lr.ph.i2108

._crit_edge.lr.ph.i2108:                          ; preds = %._crit_edge.lr.ph.i345.i, %._crit_edge.lr.ph.i2088
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2103 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i.i2107.h2s3872, align 1
  %2104 = getelementptr inbounds i8, ptr %result.i.i2107.h2s3872, i64 18
  store i8 0, ptr %2104, align 1
  %puts.i886 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i2107.h2s3872) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %. = select i1 %.6, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.433 = select i1 %.6, ptr %73, ptr %77
  %.434 = select i1 %.6, ptr %74, ptr %78
  %.435 = select i1 %.6, ptr %75, ptr %79
  %.436 = select i1 %.6, ptr %76, ptr %80
  store ptr @_parameterization_Bufferi8, ptr %.433, align 8
  %.433.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.6, ptr %73, ptr %77
  %.433.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.433.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.433.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.433.sroa.sel445.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.6, ptr %73, ptr %77
  %.433.sroa.sel445.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.433.sroa.sel445.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.433.sroa.sel445.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %2105 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.433)
  store ptr @buffer_typ, ptr %.434, align 8
  %.434.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.6, ptr %74, ptr %78
  %.434.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.434.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.434.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.434.sroa.sel440.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.6, ptr %74, ptr %78
  %.434.sroa.sel440.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.434.sroa.sel440.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.434.sroa.sel440.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %2106 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.434) #40
  store ptr @_parameterization_String, ptr %.435, align 8
  %2107 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.435)
  store ptr @String, ptr %.436, align 8
  %2108 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.436) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2109 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2110 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <4 x i8> %., ptr %result.i.i2127.h2s3871, align 4
  %2111 = getelementptr inbounds i8, ptr %result.i.i2127.h2s3871, i64 4
  store i8 0, ptr %2111, align 4
  %puts.i906 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i2127.h2s3871) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2112 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store <20 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %result.i.i2147.h2s3869, align 1
  %2114 = getelementptr inbounds i8, ptr %result.i.i2147.h2s3869, i64 20
  store i8 0, ptr %2114, align 1
  %puts.i926 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(21) %result.i.i2147.h2s3869) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2115 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0373.lcssa) #55
  %2116 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %2118 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %2) #40
  store i8 41, ptr %result.i.i2167.h2s3868, align 2
  %2119 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %2120 = getelementptr inbounds i8, ptr %result.i.i2167.h2s3868, i64 1
  store i8 0, ptr %2120, align 1
  %puts.i947 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %result.i.i2167.h2s3868) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  ret void
}

define noundef i32 @main() local_unnamed_addr #18 {
._crit_edge.lr.ph.i:
  %0 = alloca [0 x ptr], align 8
  %1 = alloca [1 x ptr], align 8
  %2 = alloca { ptr }, align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca { ptr }, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca { ptr }, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %oldProtect.i37.i = alloca i32, align 4
  %oldProtect.i.i10 = alloca i32, align 4
  %33 = alloca [3 x ptr], align 8
  %34 = alloca { ptr, ptr, ptr }, align 8
  %35 = alloca [1 x ptr], align 8
  %36 = alloca { ptr }, align 8
  %37 = alloca [3 x ptr], align 8
  %38 = alloca { ptr, ptr, ptr }, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %43 = alloca [1 x ptr], align 8
  %44 = alloca { ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca { ptr }, align 8
  %47 = alloca [1 x ptr], align 8
  %48 = alloca { ptr }, align 8
  %49 = alloca [1 x ptr], align 8
  %50 = alloca { ptr }, align 8
  %51 = alloca [1 x ptr], align 8
  %52 = alloca { ptr }, align 8
  %53 = alloca [1 x ptr], align 8
  %54 = alloca { ptr }, align 8
  %55 = alloca [1 x ptr], align 8
  %56 = alloca { ptr }, align 8
  %57 = alloca [1 x ptr], align 8
  %58 = alloca { ptr }, align 8
  %59 = alloca [1 x ptr], align 8
  %60 = alloca { ptr }, align 8
  %61 = alloca [1 x ptr], align 8
  %62 = alloca { ptr }, align 8
  %63 = alloca [1 x ptr], align 8
  %64 = alloca { ptr }, align 8
  %65 = alloca [1 x ptr], align 8
  %66 = alloca { ptr }, align 8
  %67 = alloca [1 x ptr], align 8
  %68 = alloca { ptr }, align 8
  %69 = alloca [1 x ptr], align 8
  %70 = alloca { ptr }, align 8
  %71 = alloca [1 x ptr], align 8
  %72 = alloca { ptr }, align 8
  %oldProtect.i33.i = alloca i32, align 4
  %oldProtect.i.i = alloca i32, align 4
  %73 = alloca [3 x ptr], align 8
  %74 = alloca { ptr, ptr, ptr }, align 8
  %75 = alloca [1 x ptr], align 8
  %76 = alloca { ptr }, align 8
  %77 = alloca [3 x ptr], align 8
  %78 = alloca { ptr, ptr, ptr }, align 8
  %79 = alloca [1 x ptr], align 8
  %80 = alloca { ptr }, align 8
  call void @setup_landing_pad()
  %result.i9 = call noalias nonnull dereferenceable(23) ptr @bump_malloc_wrapper(i64 noundef 23) #48
  store <22 x i8> <i8 45, i8 45, i8 45, i8 32, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %result.i9, align 1
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i = call noalias nonnull dereferenceable(23) ptr @bump_malloc_wrapper(i64 noundef 23) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(23) %result.i.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(23) %result.i9, i64 noundef 22, i1 noundef false)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %85 = getelementptr inbounds i8, ptr %result.i.i, i64 22
  store i8 0, ptr %85, align 1
  %puts.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(23) %result.i.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %73)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %74)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %75)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %76)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %77)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %78)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %79)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %80)
  %result.i31.i = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i31.i, align 8
  %86 = getelementptr inbounds i8, ptr %result.i31.i, i64 8
  store ptr @_parameterization_i32, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i31.i, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %87, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i31.i) #56
  %result.i30.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i)
  %result.i32.i = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i30.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i)
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i30.i, ptr noalias nofree noundef nonnull readnone @egohsgumaa, ptr noalias nofree noundef nonnull readnone @i32_hasher) #56
  %ret.i22.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i30.i) #47
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i30.i) #56
  %result.i29.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i33.i)
  %result.i34.i = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i29.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i33.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i33.i)
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i29.i, ptr noalias nofree noundef nonnull readnone @ewafwzhivv, ptr noalias nofree noundef nonnull readnone @i32_eq) #56
  %ret.i.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i29.i) #47
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i29.i) #56
  %91 = getelementptr inbounds i8, ptr %result.i31.i, i64 48
  store ptr %ret.i22.i, ptr %91, align 8
  %92 = getelementptr inbounds i8, ptr %result.i31.i, i64 56
  store ptr %ret.i.i, ptr %92, align 8
  %93 = getelementptr inbounds i8, ptr %result.i31.i, i64 40
  store i32 8, ptr %93, align 8
  %result.i1.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %94 = getelementptr inbounds i8, ptr %result.i31.i, i64 24
  store ptr %result.i1.i.i, ptr %94, align 8
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %95 = getelementptr inbounds i8, ptr %result.i31.i, i64 32
  store ptr %result.i.i.i, ptr %95, align 8
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %97 = getelementptr inbounds i8, ptr %result.i31.i, i64 44
  store i32 0, ptr %97, align 4
  %98 = call i64 @clock()
  %99 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i31.i, 1
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr undef, 2
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, i32 10, 3
  %102 = insertvalue { ptr, ptr, ptr, i32 } %99, i32 10, 3
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %CuckooMap_insert_keyK_valueV.exit.i, %._crit_edge.lr.ph.i
  %.066.i = phi i32 [ %103, %CuckooMap_insert_keyK_valueV.exit.i ], [ 0, %._crit_edge.lr.ph.i ]
  %103 = add nuw nsw i32 %.066.i, 1
  %.sroa.0138.0.insert.ext.i = zext nneg i32 %.066.i to i160
  %104 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0138.0.insert.ext.i, 1
  %.sroa.0135.0.insert.ext.i = zext nneg i32 %103 to i160
  %105 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0135.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %106 = load ptr, ptr %91, align 8
  %107 = call i32 %106({ ptr, i160 } %104) #53
  %108 = load i32, ptr %93, align 8
  %109 = add i32 %108, -1
  %110 = and i32 %109, %107
  %111 = load ptr, ptr %94, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %113 = sext i32 %110 to i64
  %114 = shl nsw i64 %113, 5
  %115 = getelementptr i8, ptr %111, i64 %114
  %116 = load ptr, ptr %115, align 8
  %117 = getelementptr i8, ptr %115, i64 8
  %118 = icmp ne ptr %116, @nil_typ
  %119 = icmp ne ptr %116, null
  %.not66.i.i = and i1 %118, %119
  br i1 %.not66.i.i, label %120, label %218

120:                                              ; preds = %._crit_edge.i
  %121 = load i64, ptr %117, align 4
  %.sroa_idx.i.i = getelementptr i8, ptr %115, i64 16
  %122 = load i64, ptr %.sroa_idx.i.i, align 4
  %123 = inttoptr i64 %121 to ptr
  %124 = inttoptr i64 %122 to ptr
  %hash_coef_ptr.i.i11.i.i = getelementptr i8, ptr %116, i64 8
  %tbl_size_ptr.i.i12.i.i = getelementptr i8, ptr %116, i64 16
  %offset_tbl_ptr.i.i13.i.i = getelementptr i8, ptr %116, i64 40
  %hash_coef.i.i14.i.i = load i64, ptr %hash_coef_ptr.i.i11.i.i, align 4, !noalias !407
  %tbl_size.i.i15.i.i = load i64, ptr %tbl_size_ptr.i.i12.i.i, align 4, !noalias !407
  %offset_tbl.i.i16.i.i = load ptr, ptr %offset_tbl_ptr.i.i13.i.i, align 8, !noalias !407
  %product.i.i.i17.i.i = mul i64 %hash_coef.i.i14.i.i, 4015701072841558310
  %shifted.i.i.i18.i.i = lshr i64 %product.i.i.i17.i.i, 32
  %xored.i.i.i19.i.i = xor i64 %shifted.i.i.i18.i.i, %product.i.i.i17.i.i
  %hash.i.i.i20.i.i = and i64 %xored.i.i.i19.i.i, %tbl_size.i.i15.i.i
  %offset_ptr.i.i21.i.i = getelementptr i32, ptr %offset_tbl.i.i16.i.i, i64 %hash.i.i.i20.i.i
  %offset.i.i22.i.i = load i32, ptr %offset_ptr.i.i21.i.i, align 4, !noalias !407
  %125 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %116, 0
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, ptr %123, 1
  %127 = insertvalue { ptr, ptr, ptr, i32 } %126, ptr %124, 2
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, i32 %offset.i.i22.i.i, 3
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %116) #40
  %131 = sext i32 %offset.i.i22.i.i to i64
  %132 = getelementptr ptr, ptr %116, i64 %131
  %133 = getelementptr i8, ptr %132, i64 64
  %134 = load ptr, ptr %133, align 8
  %result.i8.i.i = call ptr %134({ ptr, ptr, ptr, i32 } %128, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %135 = call i32 %result.i8.i.i({ ptr, ptr, ptr, i32 } %128, { ptr, ptr, ptr, i32 } %128, ptr nonnull align 8 %0) #53
  %136 = icmp eq i32 %135, %107
  br i1 %136, label %._crit_edge.i294.i, label %218

._crit_edge.i294.i:                               ; preds = %120
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %116)
  %139 = getelementptr i8, ptr %132, i64 48
  %140 = load ptr, ptr %139, align 8
  %result.i7.i.i = call ptr %140({ ptr, ptr, ptr, i32 } %128, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %141 = call { ptr, i160 } %result.i7.i.i({ ptr, ptr, ptr, i32 } %128, { ptr, ptr, ptr, i32 } %128, ptr nonnull align 8 %0) #53
  %142 = load ptr, ptr %92, align 8
  %143 = call i1 %142({ ptr, i160 } %141, { ptr, i160 } %104) #53
  br i1 %143, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i, label %218

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i: ; preds = %._crit_edge.i294.i
  %144 = load ptr, ptr %result.i31.i, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %146 = load ptr, ptr %86, align 8
  %147 = load ptr, ptr %144, align 8, !alias.scope !410
  %148 = getelementptr i8, ptr %147, i64 72
  %149 = load ptr, ptr %148, align 8, !alias.scope !410
  %result.i1.i.i.i = call { i64, i64 } %149(ptr nocapture nofree nonnull readonly align 8 %144) #44, !alias.scope !410
  %150 = extractvalue { i64, i64 } %result.i1.i.i.i, 0
  %151 = extractvalue { i64, i64 } %result.i1.i.i.i, 1
  %152 = urem i64 20, %151
  %153 = icmp eq i64 %152, 0
  %154 = sub i64 %151, %152
  %155 = select i1 %153, i64 0, i64 %154
  %156 = add i64 %150, 20
  %157 = add i64 %156, %155
  %158 = load ptr, ptr %146, align 8, !alias.scope !410
  %159 = getelementptr i8, ptr %158, i64 72
  %160 = load ptr, ptr %159, align 8, !alias.scope !410
  %result.i.i.i295.i = call { i64, i64 } %160(ptr nocapture nofree nonnull readonly align 8 %146) #44, !alias.scope !410
  %161 = extractvalue { i64, i64 } %result.i.i.i295.i, 0
  %162 = extractvalue { i64, i64 } %result.i.i.i295.i, 1
  %163 = call i64 @llvm.umax.i64(i64 %151, i64 %162) #41
  %164 = call i64 @llvm.umax.i64(i64 %163, i64 noundef 8) #41, !range !16
  %165 = urem i64 %157, %162
  %166 = icmp eq i64 %165, 0
  %167 = sub i64 %162, %165
  %168 = select i1 %166, i64 0, i64 %167
  %169 = add i64 %161, %157
  %170 = add i64 %169, %168
  %171 = urem i64 %170, %164
  %172 = icmp eq i64 %171, 0
  %173 = sub i64 %164, %171
  %174 = select i1 %172, i64 0, i64 %173
  %175 = add i64 %174, %170
  %result.i9.i.i = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %175) #48
  store ptr %144, ptr %result.i9.i.i, align 8
  %176 = getelementptr inbounds i8, ptr %result.i9.i.i, i64 8
  store ptr %146, ptr %176, align 8
  %177 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i.i)
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %179 = load ptr, ptr %144, align 8
  %180 = getelementptr i8, ptr %179, i64 72
  %181 = load ptr, ptr %180, align 8
  %result.i.i38.i.i = call { i64, i64 } %181(ptr nocapture nofree nonnull readonly align 8 %144) #44
  %182 = extractvalue { i64, i64 } %result.i.i38.i.i, 1
  %183 = urem i64 20, %182
  %184 = icmp eq i64 %183, 0
  %reass.sub863 = sub i64 %182, %183
  %185 = add i64 %reass.sub863, 20
  %186 = select i1 %184, i64 20, i64 %185
  %187 = getelementptr i8, ptr %result.i9.i.i, i64 %186
  %188 = getelementptr i8, ptr %179, i64 64
  %189 = load ptr, ptr %188, align 8
  call void %189({ ptr, i160 } %104, ptr nocapture nofree nonnull readonly align 8 %144, ptr nocapture nofree writeonly %187) #45
  %190 = load ptr, ptr %result.i9.i.i, align 8
  %191 = load ptr, ptr %190, align 8
  %192 = getelementptr i8, ptr %191, i64 72
  %193 = load ptr, ptr %192, align 8
  %result.i1.i39.i.i = call { i64, i64 } %193(ptr nocapture nofree nonnull readonly align 8 %190) #44
  %194 = extractvalue { i64, i64 } %result.i1.i39.i.i, 0
  %195 = extractvalue { i64, i64 } %result.i1.i39.i.i, 1
  %196 = urem i64 20, %195
  %197 = icmp eq i64 %196, 0
  %198 = sub i64 %195, %196
  %199 = select i1 %197, i64 0, i64 %198
  %200 = add i64 %194, 20
  %201 = add i64 %200, %199
  %202 = load ptr, ptr %176, align 8
  %203 = load ptr, ptr %202, align 8
  %204 = getelementptr i8, ptr %203, i64 72
  %205 = load ptr, ptr %204, align 8
  %result.i.i40.i.i = call { i64, i64 } %205(ptr nocapture nofree nonnull readonly align 8 %202) #44
  %206 = extractvalue { i64, i64 } %result.i.i40.i.i, 1
  %207 = urem i64 %201, %206
  %208 = icmp eq i64 %207, 0
  %209 = sub i64 %206, %207
  %210 = select i1 %208, i64 0, i64 %209
  %211 = getelementptr i8, ptr %result.i9.i.i, i64 %201
  %212 = getelementptr i8, ptr %211, i64 %210
  %213 = getelementptr i8, ptr %203, i64 64
  %214 = load ptr, ptr %213, align 8
  call void %214({ ptr, i160 } %105, ptr nocapture nofree nonnull readonly align 8 %202, ptr nocapture nofree writeonly %212) #45
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %216 = getelementptr inbounds i8, ptr %result.i9.i.i, i64 16
  store i32 %107, ptr %216, align 8
  store ptr @Entry, ptr %115, align 8
  %217 = ptrtoint ptr %result.i9.i.i to i64
  store i64 %217, ptr %117, align 4
  %.sroa_idx30.i.i = getelementptr i8, ptr %115, i64 24
  store i32 10, ptr %.sroa_idx30.i.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i

218:                                              ; preds = %._crit_edge.i294.i, %120, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %219 = add i32 %107, 2127912214
  %220 = shl i32 %107, 12
  %221 = add i32 %219, %220
  %222 = ashr i32 %221, 19
  %223 = xor i32 %221, %222
  %224 = xor i32 %223, -949894596
  %225 = add i32 %224, 374761393
  %226 = shl i32 %224, 5
  %227 = add i32 %225, %226
  %228 = add i32 %227, -744332180
  %229 = shl i32 %227, 9
  %230 = xor i32 %228, %229
  %231 = add i32 %230, -42973499
  %232 = shl i32 %230, 3
  %233 = add i32 %231, %232
  %234 = ashr i32 %233, 16
  %235 = xor i32 %233, %234
  %236 = xor i32 %235, -1252372727
  %237 = load i32, ptr %93, align 8
  %238 = add i32 %237, -1
  %239 = and i32 %238, %236
  %240 = load ptr, ptr %95, align 8
  %241 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %242 = sext i32 %239 to i64
  %243 = shl nsw i64 %242, 5
  %244 = getelementptr i8, ptr %240, i64 %243
  %245 = load ptr, ptr %244, align 8
  %246 = getelementptr i8, ptr %244, i64 8
  %247 = icmp ne ptr %245, @nil_typ
  %248 = icmp ne ptr %245, null
  %.not66.i325.i = and i1 %247, %248
  br i1 %.not66.i325.i, label %249, label %347

249:                                              ; preds = %218
  %250 = load i64, ptr %246, align 4
  %.sroa_idx.i327.i = getelementptr i8, ptr %244, i64 16
  %251 = load i64, ptr %.sroa_idx.i327.i, align 4
  %252 = inttoptr i64 %250 to ptr
  %253 = inttoptr i64 %251 to ptr
  %hash_coef_ptr.i.i11.i328.i = getelementptr i8, ptr %245, i64 8
  %tbl_size_ptr.i.i12.i329.i = getelementptr i8, ptr %245, i64 16
  %offset_tbl_ptr.i.i13.i330.i = getelementptr i8, ptr %245, i64 40
  %hash_coef.i.i14.i331.i = load i64, ptr %hash_coef_ptr.i.i11.i328.i, align 4, !noalias !413
  %tbl_size.i.i15.i332.i = load i64, ptr %tbl_size_ptr.i.i12.i329.i, align 4, !noalias !413
  %offset_tbl.i.i16.i333.i = load ptr, ptr %offset_tbl_ptr.i.i13.i330.i, align 8, !noalias !413
  %product.i.i.i17.i334.i = mul i64 %hash_coef.i.i14.i331.i, 4015701072841558310
  %shifted.i.i.i18.i335.i = lshr i64 %product.i.i.i17.i334.i, 32
  %xored.i.i.i19.i336.i = xor i64 %shifted.i.i.i18.i335.i, %product.i.i.i17.i334.i
  %hash.i.i.i20.i337.i = and i64 %xored.i.i.i19.i336.i, %tbl_size.i.i15.i332.i
  %offset_ptr.i.i21.i338.i = getelementptr i32, ptr %offset_tbl.i.i16.i333.i, i64 %hash.i.i.i20.i337.i
  %offset.i.i22.i339.i = load i32, ptr %offset_ptr.i.i21.i338.i, align 4, !noalias !413
  %254 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %245, 0
  %255 = insertvalue { ptr, ptr, ptr, i32 } %254, ptr %252, 1
  %256 = insertvalue { ptr, ptr, ptr, i32 } %255, ptr %253, 2
  %257 = insertvalue { ptr, ptr, ptr, i32 } %256, i32 %offset.i.i22.i339.i, 3
  %258 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %259 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %245) #40
  %260 = sext i32 %offset.i.i22.i339.i to i64
  %261 = getelementptr ptr, ptr %245, i64 %260
  %262 = getelementptr i8, ptr %261, i64 64
  %263 = load ptr, ptr %262, align 8
  %result.i8.i340.i = call ptr %263({ ptr, ptr, ptr, i32 } %257, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %264 = call i32 %result.i8.i340.i({ ptr, ptr, ptr, i32 } %257, { ptr, ptr, ptr, i32 } %257, ptr nonnull align 8 %0) #53
  %265 = icmp eq i32 %264, %107
  br i1 %265, label %._crit_edge.i341.i, label %347

._crit_edge.i341.i:                               ; preds = %249
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %267 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %245)
  %268 = getelementptr i8, ptr %261, i64 48
  %269 = load ptr, ptr %268, align 8
  %result.i7.i342.i = call ptr %269({ ptr, ptr, ptr, i32 } %257, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %270 = call { ptr, i160 } %result.i7.i342.i({ ptr, ptr, ptr, i32 } %257, { ptr, ptr, ptr, i32 } %257, ptr nonnull align 8 %0) #53
  %271 = load ptr, ptr %92, align 8
  %272 = call i1 %271({ ptr, i160 } %270, { ptr, i160 } %104) #53
  br i1 %272, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit354.i, label %347

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit354.i: ; preds = %._crit_edge.i341.i
  %273 = load ptr, ptr %result.i31.i, align 8
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %275 = load ptr, ptr %86, align 8
  %276 = load ptr, ptr %273, align 8, !alias.scope !416
  %277 = getelementptr i8, ptr %276, i64 72
  %278 = load ptr, ptr %277, align 8, !alias.scope !416
  %result.i1.i.i346.i = call { i64, i64 } %278(ptr nocapture nofree nonnull readonly align 8 %273) #44, !alias.scope !416
  %279 = extractvalue { i64, i64 } %result.i1.i.i346.i, 0
  %280 = extractvalue { i64, i64 } %result.i1.i.i346.i, 1
  %281 = urem i64 20, %280
  %282 = icmp eq i64 %281, 0
  %283 = sub i64 %280, %281
  %284 = select i1 %282, i64 0, i64 %283
  %285 = add i64 %279, 20
  %286 = add i64 %285, %284
  %287 = load ptr, ptr %275, align 8, !alias.scope !416
  %288 = getelementptr i8, ptr %287, i64 72
  %289 = load ptr, ptr %288, align 8, !alias.scope !416
  %result.i.i.i347.i = call { i64, i64 } %289(ptr nocapture nofree nonnull readonly align 8 %275) #44, !alias.scope !416
  %290 = extractvalue { i64, i64 } %result.i.i.i347.i, 0
  %291 = extractvalue { i64, i64 } %result.i.i.i347.i, 1
  %292 = call i64 @llvm.umax.i64(i64 %280, i64 %291) #41
  %293 = call i64 @llvm.umax.i64(i64 %292, i64 noundef 8) #41, !range !16
  %294 = urem i64 %286, %291
  %295 = icmp eq i64 %294, 0
  %296 = sub i64 %291, %294
  %297 = select i1 %295, i64 0, i64 %296
  %298 = add i64 %290, %286
  %299 = add i64 %298, %297
  %300 = urem i64 %299, %293
  %301 = icmp eq i64 %300, 0
  %302 = sub i64 %293, %300
  %303 = select i1 %301, i64 0, i64 %302
  %304 = add i64 %303, %299
  %result.i9.i348.i = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %304) #48
  store ptr %273, ptr %result.i9.i348.i, align 8
  %305 = getelementptr inbounds i8, ptr %result.i9.i348.i, i64 8
  store ptr %275, ptr %305, align 8
  %306 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i348.i)
  %307 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %308 = load ptr, ptr %273, align 8
  %309 = getelementptr i8, ptr %308, i64 72
  %310 = load ptr, ptr %309, align 8
  %result.i.i38.i349.i = call { i64, i64 } %310(ptr nocapture nofree nonnull readonly align 8 %273) #44
  %311 = extractvalue { i64, i64 } %result.i.i38.i349.i, 1
  %312 = urem i64 20, %311
  %313 = icmp eq i64 %312, 0
  %reass.sub862 = sub i64 %311, %312
  %314 = add i64 %reass.sub862, 20
  %315 = select i1 %313, i64 20, i64 %314
  %316 = getelementptr i8, ptr %result.i9.i348.i, i64 %315
  %317 = getelementptr i8, ptr %308, i64 64
  %318 = load ptr, ptr %317, align 8
  call void %318({ ptr, i160 } %104, ptr nocapture nofree nonnull readonly align 8 %273, ptr nocapture nofree writeonly %316) #45
  %319 = load ptr, ptr %result.i9.i348.i, align 8
  %320 = load ptr, ptr %319, align 8
  %321 = getelementptr i8, ptr %320, i64 72
  %322 = load ptr, ptr %321, align 8
  %result.i1.i39.i351.i = call { i64, i64 } %322(ptr nocapture nofree nonnull readonly align 8 %319) #44
  %323 = extractvalue { i64, i64 } %result.i1.i39.i351.i, 0
  %324 = extractvalue { i64, i64 } %result.i1.i39.i351.i, 1
  %325 = urem i64 20, %324
  %326 = icmp eq i64 %325, 0
  %327 = sub i64 %324, %325
  %328 = select i1 %326, i64 0, i64 %327
  %329 = add i64 %323, 20
  %330 = add i64 %329, %328
  %331 = load ptr, ptr %305, align 8
  %332 = load ptr, ptr %331, align 8
  %333 = getelementptr i8, ptr %332, i64 72
  %334 = load ptr, ptr %333, align 8
  %result.i.i40.i352.i = call { i64, i64 } %334(ptr nocapture nofree nonnull readonly align 8 %331) #44
  %335 = extractvalue { i64, i64 } %result.i.i40.i352.i, 1
  %336 = urem i64 %330, %335
  %337 = icmp eq i64 %336, 0
  %338 = sub i64 %335, %336
  %339 = select i1 %337, i64 0, i64 %338
  %340 = getelementptr i8, ptr %result.i9.i348.i, i64 %330
  %341 = getelementptr i8, ptr %340, i64 %339
  %342 = getelementptr i8, ptr %332, i64 64
  %343 = load ptr, ptr %342, align 8
  call void %343({ ptr, i160 } %105, ptr nocapture nofree nonnull readonly align 8 %331, ptr nocapture nofree writeonly %341) #45
  %344 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %345 = getelementptr inbounds i8, ptr %result.i9.i348.i, i64 16
  store i32 %107, ptr %345, align 8
  store ptr @Entry, ptr %244, align 8
  %346 = ptrtoint ptr %result.i9.i348.i to i64
  store i64 %346, ptr %246, align 4
  %.sroa_idx30.i353.i = getelementptr i8, ptr %244, i64 24
  store i32 10, ptr %.sroa_idx30.i353.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i

347:                                              ; preds = %._crit_edge.i341.i, %249, %218
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %348 = load i32, ptr %97, align 4
  %349 = load i32, ptr %93, align 8
  %.not.i.i = icmp slt i32 %348, %349
  br i1 %.not.i.i, label %._crit_edge.i.i, label %350

350:                                              ; preds = %347
  %351 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %352 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %353 = load ptr, ptr %94, align 8
  %354 = load ptr, ptr %95, align 8
  %355 = shl i32 %349, 1
  %spec.select.i.i = call i32 @llvm.smax.i32(i32 %355, i32 noundef 16) #40
  store i32 %spec.select.i.i, ptr %93, align 8
  %356 = zext nneg i32 %spec.select.i.i to i64
  %357 = shl nuw nsw i64 %356, 5
  %result.i5.i.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %357) #48
  store ptr %result.i5.i.i, ptr %94, align 8
  %result.i4.i370.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %357) #48
  store ptr %result.i4.i370.i, ptr %95, align 8
  store i32 0, ptr %97, align 4
  %358 = icmp sgt i32 %349, 0
  br i1 %358, label %.lr.ph.i.i, label %._crit_edge.i.i

.lr.ph.i.i:                                       ; preds = %350
  %wide.trip.count.i.i = zext nneg i32 %349 to i64
  br label %359

359:                                              ; preds = %._crit_edge.i757.i, %.lr.ph.i.i
  %indvars.iv.i756.i = phi i64 [ 0, %.lr.ph.i.i ], [ %indvars.iv.next.i758.i, %._crit_edge.i757.i ]
  %360 = shl nuw nsw i64 %indvars.iv.i756.i, 5
  %361 = getelementptr i8, ptr %353, i64 %360
  %362 = load ptr, ptr %361, align 8
  %363 = icmp ne ptr %362, @nil_typ
  %364 = icmp ne ptr %362, null
  %.not17.i.i = and i1 %363, %364
  br i1 %.not17.i.i, label %365, label %._crit_edge.i757.i

365:                                              ; preds = %359
  %366 = getelementptr i8, ptr %361, i64 8
  %367 = load i64, ptr %366, align 4
  %.sroa_idx.i760.i = getelementptr i8, ptr %361, i64 16
  %368 = load i64, ptr %.sroa_idx.i760.i, align 4
  %hash_coef_ptr.i.i6.i.i = getelementptr i8, ptr %362, i64 8
  %tbl_size_ptr.i.i7.i.i = getelementptr i8, ptr %362, i64 16
  %offset_tbl_ptr.i.i8.i.i = getelementptr i8, ptr %362, i64 40
  %369 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  %hash_coef.i.i21.i.i = load i64, ptr %hash_coef_ptr.i.i6.i.i, align 4, !noalias !419
  %tbl_size.i.i22.i.i = load i64, ptr %tbl_size_ptr.i.i7.i.i, align 4, !noalias !419
  %offset_tbl.i.i23.i.i = load ptr, ptr %offset_tbl_ptr.i.i8.i.i, align 8, !noalias !419
  %product.i.i.i24.i.i = mul i64 %hash_coef.i.i21.i.i, 4015701072841558310
  %shifted.i.i.i25.i.i = lshr i64 %product.i.i.i24.i.i, 32
  %xored.i.i.i26.i.i = xor i64 %shifted.i.i.i25.i.i, %product.i.i.i24.i.i
  %hash.i.i.i27.i.i = and i64 %xored.i.i.i26.i.i, %tbl_size.i.i22.i.i
  %offset_ptr.i.i28.i.i = getelementptr i32, ptr %offset_tbl.i.i23.i.i, i64 %hash.i.i.i27.i.i
  %offset.i.i29.i.i = load i32, ptr %offset_ptr.i.i28.i.i, align 4, !noalias !419
  %370 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %371 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %372 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %373

373:                                              ; preds = %.cont.i1047.i, %365
  %.0290.i1029.i = phi i32 [ 0, %365 ], [ %406, %.cont.i1047.i ]
  %.074289.i1030.i = phi i1 [ true, %365 ], [ %407, %.cont.i1047.i ]
  %.sroa.0.0288.i1031.i = phi ptr [ %362, %365 ], [ %396, %.cont.i1047.i ]
  %.sroa.6.0287.i1032.in.i = phi i64 [ %367, %365 ], [ %398, %.cont.i1047.i ]
  %.sroa.12.0286.i1033.in.i = phi i64 [ %368, %365 ], [ %399, %.cont.i1047.i ]
  %.sroa.17.0285.i1034.i = phi i32 [ %offset.i.i29.i.i, %365 ], [ %offset.i.i57.i1059.i, %.cont.i1047.i ]
  %.sroa.12.0286.i1033.i = inttoptr i64 %.sroa.12.0286.i1033.in.i to ptr
  %.sroa.6.0287.i1032.i = inttoptr i64 %.sroa.6.0287.i1032.in.i to ptr
  %374 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1031.i, 0
  %375 = insertvalue { ptr, ptr, ptr, i32 } %374, ptr %.sroa.6.0287.i1032.i, 1
  %376 = insertvalue { ptr, ptr, ptr, i32 } %375, ptr %.sroa.12.0286.i1033.i, 2
  %377 = insertvalue { ptr, ptr, ptr, i32 } %376, i32 %.sroa.17.0285.i1034.i, 3
  %378 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1031.i)
  %379 = sext i32 %.sroa.17.0285.i1034.i to i64
  %380 = getelementptr ptr, ptr %.sroa.0.0288.i1031.i, i64 %379
  %381 = getelementptr i8, ptr %380, i64 64
  %382 = load ptr, ptr %381, align 8
  %result.i15.i1035.i = call ptr %382({ ptr, ptr, ptr, i32 } %377, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %383 = call i32 %result.i15.i1035.i({ ptr, ptr, ptr, i32 } %377, { ptr, ptr, ptr, i32 } %377, ptr nonnull align 8 %0) #53
  %..i1036.i = select i1 %.074289.i1030.i, ptr %61, ptr %63
  %.188.i1037.i = select i1 %.074289.i1030.i, i64 104, i64 112
  %.189.i1038.i = select i1 %.074289.i1030.i, ptr %62, ptr %64
  %.190.i1039.i = select i1 %.074289.i1030.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1036.i, align 8
  %384 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1036.i)
  %385 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1037.i
  %386 = load ptr, ptr %385, align 8
  store ptr @i32_typ, ptr %.189.i1038.i, align 8
  %result.i14.i1040.i = call ptr %386({ ptr, ptr, ptr, i32 } %102, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1038.i) #46
  %387 = call i32 %result.i14.i1040.i({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull align 8 dereferenceable(8) %..i1036.i, i32 %383) #53
  %388 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %389 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1039.i
  %390 = load ptr, ptr %389, align 8
  %391 = load ptr, ptr %390, align 8
  %392 = call { ptr } %391(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i1041.i = extractvalue { ptr } %392, 0
  %393 = sext i32 %387 to i64
  %394 = shl nsw i64 %393, 5
  %395 = getelementptr i8, ptr %.fca.0.extract55.i1041.i, i64 %394
  %396 = load ptr, ptr %395, align 8
  %397 = getelementptr i8, ptr %395, i64 8
  %398 = load i64, ptr %397, align 4
  %.sroa_idx.i1042.i = getelementptr i8, ptr %395, i64 16
  %399 = load i64, ptr %.sroa_idx.i1042.i, align 4
  %400 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %401 = call { ptr } %391(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i1043.i = extractvalue { ptr } %401, 0
  %402 = getelementptr i8, ptr %.fca.0.extract52.i1043.i, i64 %394
  store ptr %.sroa.0.0288.i1031.i, ptr %402, align 8
  %403 = getelementptr i8, ptr %402, i64 8
  store i64 %.sroa.6.0287.i1032.in.i, ptr %403, align 4
  %.sroa_idx104.i1044.i = getelementptr i8, ptr %402, i64 16
  store i64 %.sroa.12.0286.i1033.in.i, ptr %.sroa_idx104.i1044.i, align 4
  %.sroa_idx105.i1045.i = getelementptr i8, ptr %402, i64 24
  store i32 %.sroa.17.0285.i1034.i, ptr %.sroa_idx105.i1045.i, align 4
  %404 = icmp ne ptr %396, @nil_typ
  %405 = icmp ne ptr %396, null
  %.not94.i1046.i = and i1 %404, %405
  br i1 %.not94.i1046.i, label %.cont.i1047.i, label %410

.cont.i1047.i:                                    ; preds = %373
  %406 = add nuw nsw i32 %.0290.i1029.i, 1
  %407 = xor i1 %.074289.i1030.i, true
  %hash_coef_ptr.i.i46.i1048.i = getelementptr i8, ptr %396, i64 8
  %tbl_size_ptr.i.i47.i1049.i = getelementptr i8, ptr %396, i64 16
  %offset_tbl_ptr.i.i48.i1050.i = getelementptr i8, ptr %396, i64 40
  %hash_coef.i.i49.i1051.i = load i64, ptr %hash_coef_ptr.i.i46.i1048.i, align 4
  %tbl_size.i.i50.i1052.i = load i64, ptr %tbl_size_ptr.i.i47.i1049.i, align 4
  %offset_tbl.i.i51.i1053.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1050.i, align 8
  %product.i.i.i52.i1054.i = mul i64 %hash_coef.i.i49.i1051.i, 4015701072841558310
  %shifted.i.i.i53.i1055.i = lshr i64 %product.i.i.i52.i1054.i, 32
  %xored.i.i.i54.i1056.i = xor i64 %shifted.i.i.i53.i1055.i, %product.i.i.i52.i1054.i
  %hash.i.i.i55.i1057.i = and i64 %xored.i.i.i54.i1056.i, %tbl_size.i.i50.i1052.i
  %offset_ptr.i.i56.i1058.i = getelementptr i32, ptr %offset_tbl.i.i51.i1053.i, i64 %hash.i.i.i55.i1057.i
  %offset.i.i57.i1059.i = load i32, ptr %offset_ptr.i.i56.i1058.i, align 4
  %408 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %409 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1060.i = icmp eq i32 %406, 100
  br i1 %exitcond.not.i1060.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062.i, label %373

410:                                              ; preds = %373
  %411 = load i32, ptr %97, align 4
  %412 = add i32 %411, 1
  %413 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %412, ptr %97, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062.i: ; preds = %410, %.cont.i1047.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %63)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %64)
  br label %._crit_edge.i757.i

._crit_edge.i757.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1062.i, %359
  %indvars.iv.next.i758.i = add nuw nsw i64 %indvars.iv.i756.i, 1
  %exitcond.not.i759.i = icmp eq i64 %indvars.iv.next.i758.i, %wide.trip.count.i.i
  br i1 %exitcond.not.i759.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i, label %359

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i: ; preds = %._crit_edge.i779.i, %._crit_edge.i757.i
  %indvars.iv.i777.i = phi i64 [ %indvars.iv.next.i780.i, %._crit_edge.i779.i ], [ 0, %._crit_edge.i757.i ]
  %414 = shl nuw nsw i64 %indvars.iv.i777.i, 5
  %415 = getelementptr i8, ptr %354, i64 %414
  %416 = load ptr, ptr %415, align 8
  %417 = icmp ne ptr %416, @nil_typ
  %418 = icmp ne ptr %416, null
  %.not17.i778.i = and i1 %417, %418
  br i1 %.not17.i778.i, label %419, label %._crit_edge.i779.i

419:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i
  %420 = getelementptr i8, ptr %415, i64 8
  %421 = load i64, ptr %420, align 4
  %.sroa_idx.i782.i = getelementptr i8, ptr %415, i64 16
  %422 = load i64, ptr %.sroa_idx.i782.i, align 4
  %hash_coef_ptr.i.i6.i783.i = getelementptr i8, ptr %416, i64 8
  %tbl_size_ptr.i.i7.i784.i = getelementptr i8, ptr %416, i64 16
  %offset_tbl_ptr.i.i8.i785.i = getelementptr i8, ptr %416, i64 40
  %423 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  %hash_coef.i.i21.i1080.i = load i64, ptr %hash_coef_ptr.i.i6.i783.i, align 4, !noalias !422
  %tbl_size.i.i22.i1081.i = load i64, ptr %tbl_size_ptr.i.i7.i784.i, align 4, !noalias !422
  %offset_tbl.i.i23.i1082.i = load ptr, ptr %offset_tbl_ptr.i.i8.i785.i, align 8, !noalias !422
  %product.i.i.i24.i1083.i = mul i64 %hash_coef.i.i21.i1080.i, 4015701072841558310
  %shifted.i.i.i25.i1084.i = lshr i64 %product.i.i.i24.i1083.i, 32
  %xored.i.i.i26.i1085.i = xor i64 %shifted.i.i.i25.i1084.i, %product.i.i.i24.i1083.i
  %hash.i.i.i27.i1086.i = and i64 %xored.i.i.i26.i1085.i, %tbl_size.i.i22.i1081.i
  %offset_ptr.i.i28.i1087.i = getelementptr i32, ptr %offset_tbl.i.i23.i1082.i, i64 %hash.i.i.i27.i1086.i
  %offset.i.i29.i1088.i = load i32, ptr %offset_ptr.i.i28.i1087.i, align 4, !noalias !422
  %424 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %425 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %426 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %427

427:                                              ; preds = %.cont.i1111.i, %419
  %.0290.i1089.i = phi i32 [ 0, %419 ], [ %460, %.cont.i1111.i ]
  %.074289.i1090.i = phi i1 [ true, %419 ], [ %461, %.cont.i1111.i ]
  %.sroa.0.0288.i1091.i = phi ptr [ %416, %419 ], [ %450, %.cont.i1111.i ]
  %.sroa.6.0287.i1092.in.i = phi i64 [ %421, %419 ], [ %452, %.cont.i1111.i ]
  %.sroa.12.0286.i1093.in.i = phi i64 [ %422, %419 ], [ %453, %.cont.i1111.i ]
  %.sroa.17.0285.i1094.i = phi i32 [ %offset.i.i29.i1088.i, %419 ], [ %offset.i.i57.i1123.i, %.cont.i1111.i ]
  %.sroa.12.0286.i1093.i = inttoptr i64 %.sroa.12.0286.i1093.in.i to ptr
  %.sroa.6.0287.i1092.i = inttoptr i64 %.sroa.6.0287.i1092.in.i to ptr
  %428 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1091.i, 0
  %429 = insertvalue { ptr, ptr, ptr, i32 } %428, ptr %.sroa.6.0287.i1092.i, 1
  %430 = insertvalue { ptr, ptr, ptr, i32 } %429, ptr %.sroa.12.0286.i1093.i, 2
  %431 = insertvalue { ptr, ptr, ptr, i32 } %430, i32 %.sroa.17.0285.i1094.i, 3
  %432 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1091.i)
  %433 = sext i32 %.sroa.17.0285.i1094.i to i64
  %434 = getelementptr ptr, ptr %.sroa.0.0288.i1091.i, i64 %433
  %435 = getelementptr i8, ptr %434, i64 64
  %436 = load ptr, ptr %435, align 8
  %result.i15.i1095.i = call ptr %436({ ptr, ptr, ptr, i32 } %431, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %437 = call i32 %result.i15.i1095.i({ ptr, ptr, ptr, i32 } %431, { ptr, ptr, ptr, i32 } %431, ptr nonnull align 8 %0) #53
  %..i1096.i = select i1 %.074289.i1090.i, ptr %57, ptr %59
  %.188.i1097.i = select i1 %.074289.i1090.i, i64 104, i64 112
  %.189.i1098.i = select i1 %.074289.i1090.i, ptr %58, ptr %60
  %.190.i1099.i = select i1 %.074289.i1090.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1096.i, align 8
  %438 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1096.i)
  %439 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1097.i
  %440 = load ptr, ptr %439, align 8
  store ptr @i32_typ, ptr %.189.i1098.i, align 8
  %result.i14.i1100.i = call ptr %440({ ptr, ptr, ptr, i32 } %102, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1098.i) #46
  %441 = call i32 %result.i14.i1100.i({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull align 8 dereferenceable(8) %..i1096.i, i32 %437) #53
  %442 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %443 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1099.i
  %444 = load ptr, ptr %443, align 8
  %445 = load ptr, ptr %444, align 8
  %446 = call { ptr } %445(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i1101.i = extractvalue { ptr } %446, 0
  %447 = sext i32 %441 to i64
  %448 = shl nsw i64 %447, 5
  %449 = getelementptr i8, ptr %.fca.0.extract55.i1101.i, i64 %448
  %450 = load ptr, ptr %449, align 8
  %451 = getelementptr i8, ptr %449, i64 8
  %452 = load i64, ptr %451, align 4
  %.sroa_idx.i1102.i = getelementptr i8, ptr %449, i64 16
  %453 = load i64, ptr %.sroa_idx.i1102.i, align 4
  %454 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %455 = call { ptr } %445(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i1103.i = extractvalue { ptr } %455, 0
  %456 = getelementptr i8, ptr %.fca.0.extract52.i1103.i, i64 %448
  store ptr %.sroa.0.0288.i1091.i, ptr %456, align 8
  %457 = getelementptr i8, ptr %456, i64 8
  store i64 %.sroa.6.0287.i1092.in.i, ptr %457, align 4
  %.sroa_idx104.i1104.i = getelementptr i8, ptr %456, i64 16
  store i64 %.sroa.12.0286.i1093.in.i, ptr %.sroa_idx104.i1104.i, align 4
  %.sroa_idx105.i1105.i = getelementptr i8, ptr %456, i64 24
  store i32 %.sroa.17.0285.i1094.i, ptr %.sroa_idx105.i1105.i, align 4
  %458 = icmp ne ptr %450, @nil_typ
  %459 = icmp ne ptr %450, null
  %.not94.i1106.i = and i1 %458, %459
  br i1 %.not94.i1106.i, label %.cont.i1111.i, label %464

.cont.i1111.i:                                    ; preds = %427
  %460 = add nuw nsw i32 %.0290.i1089.i, 1
  %461 = xor i1 %.074289.i1090.i, true
  %hash_coef_ptr.i.i46.i1112.i = getelementptr i8, ptr %450, i64 8
  %tbl_size_ptr.i.i47.i1113.i = getelementptr i8, ptr %450, i64 16
  %offset_tbl_ptr.i.i48.i1114.i = getelementptr i8, ptr %450, i64 40
  %hash_coef.i.i49.i1115.i = load i64, ptr %hash_coef_ptr.i.i46.i1112.i, align 4
  %tbl_size.i.i50.i1116.i = load i64, ptr %tbl_size_ptr.i.i47.i1113.i, align 4
  %offset_tbl.i.i51.i1117.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1114.i, align 8
  %product.i.i.i52.i1118.i = mul i64 %hash_coef.i.i49.i1115.i, 4015701072841558310
  %shifted.i.i.i53.i1119.i = lshr i64 %product.i.i.i52.i1118.i, 32
  %xored.i.i.i54.i1120.i = xor i64 %shifted.i.i.i53.i1119.i, %product.i.i.i52.i1118.i
  %hash.i.i.i55.i1121.i = and i64 %xored.i.i.i54.i1120.i, %tbl_size.i.i50.i1116.i
  %offset_ptr.i.i56.i1122.i = getelementptr i32, ptr %offset_tbl.i.i51.i1117.i, i64 %hash.i.i.i55.i1121.i
  %offset.i.i57.i1123.i = load i32, ptr %offset_ptr.i.i56.i1122.i, align 4
  %462 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %463 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1124.i = icmp eq i32 %460, 100
  br i1 %exitcond.not.i1124.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133.i, label %427

464:                                              ; preds = %427
  %465 = load i32, ptr %97, align 4
  %466 = add i32 %465, 1
  %467 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %466, ptr %97, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133.i: ; preds = %464, %.cont.i1111.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %59)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  br label %._crit_edge.i779.i

._crit_edge.i779.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1133.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i
  %indvars.iv.next.i780.i = add nuw nsw i64 %indvars.iv.i777.i, 1
  %exitcond.not.i781.i = icmp eq i64 %indvars.iv.next.i780.i, %wide.trip.count.i.i
  br i1 %exitcond.not.i781.i, label %._crit_edge.i.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i

._crit_edge.i.i:                                  ; preds = %._crit_edge.i779.i, %350, %347
  %468 = load ptr, ptr %result.i31.i, align 8
  %469 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %470 = load ptr, ptr %86, align 8
  %471 = load ptr, ptr %468, align 8
  %472 = getelementptr i8, ptr %471, i64 72
  %473 = load ptr, ptr %472, align 8
  %result.i1.i.i90.i = call { i64, i64 } %473(ptr nocapture nofree nonnull readonly align 8 %468) #44
  %474 = extractvalue { i64, i64 } %result.i1.i.i90.i, 0
  %475 = extractvalue { i64, i64 } %result.i1.i.i90.i, 1
  %476 = urem i64 20, %475
  %477 = icmp eq i64 %476, 0
  %478 = sub i64 %475, %476
  %479 = select i1 %477, i64 0, i64 %478
  %480 = add i64 %474, 20
  %481 = add i64 %480, %479
  %482 = load ptr, ptr %470, align 8
  %483 = getelementptr i8, ptr %482, i64 72
  %484 = load ptr, ptr %483, align 8
  %result.i.i.i91.i = call { i64, i64 } %484(ptr nocapture nofree nonnull readonly align 8 %470) #44
  %485 = extractvalue { i64, i64 } %result.i.i.i91.i, 0
  %486 = extractvalue { i64, i64 } %result.i.i.i91.i, 1
  %487 = call i64 @llvm.umax.i64(i64 %475, i64 %486) #41
  %488 = call i64 @llvm.umax.i64(i64 %487, i64 noundef 8) #41, !range !16
  %489 = urem i64 %481, %486
  %490 = icmp eq i64 %489, 0
  %491 = sub i64 %486, %489
  %492 = select i1 %490, i64 0, i64 %491
  %493 = add i64 %485, %481
  %494 = add i64 %493, %492
  %495 = urem i64 %494, %488
  %496 = icmp eq i64 %495, 0
  %497 = sub i64 %488, %495
  %498 = select i1 %496, i64 0, i64 %497
  %499 = add i64 %498, %494
  %result.i22.i92.i = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %499) #48
  store ptr %468, ptr %result.i22.i92.i, align 8
  %500 = getelementptr inbounds i8, ptr %result.i22.i92.i, i64 8
  store ptr %470, ptr %500, align 8
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i92.i)
  %502 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %503 = load ptr, ptr %468, align 8
  %504 = getelementptr i8, ptr %503, i64 72
  %505 = load ptr, ptr %504, align 8
  %result.i.i127.i.i = call { i64, i64 } %505(ptr nocapture nofree nonnull readonly align 8 %468) #44
  %506 = extractvalue { i64, i64 } %result.i.i127.i.i, 1
  %507 = urem i64 20, %506
  %508 = icmp eq i64 %507, 0
  %reass.sub861 = sub i64 %506, %507
  %509 = add i64 %reass.sub861, 20
  %510 = select i1 %508, i64 20, i64 %509
  %511 = getelementptr i8, ptr %result.i22.i92.i, i64 %510
  %512 = getelementptr i8, ptr %503, i64 64
  %513 = load ptr, ptr %512, align 8
  call void %513({ ptr, i160 } %104, ptr nocapture nofree nonnull readonly align 8 %468, ptr nocapture nofree writeonly %511) #45
  %514 = load ptr, ptr %result.i22.i92.i, align 8
  %515 = load ptr, ptr %514, align 8
  %516 = getelementptr i8, ptr %515, i64 72
  %517 = load ptr, ptr %516, align 8
  %result.i1.i128.i.i = call { i64, i64 } %517(ptr nocapture nofree nonnull readonly align 8 %514) #44
  %518 = extractvalue { i64, i64 } %result.i1.i128.i.i, 0
  %519 = extractvalue { i64, i64 } %result.i1.i128.i.i, 1
  %520 = urem i64 20, %519
  %521 = icmp eq i64 %520, 0
  %522 = sub i64 %519, %520
  %523 = select i1 %521, i64 0, i64 %522
  %524 = add i64 %518, 20
  %525 = add i64 %524, %523
  %526 = load ptr, ptr %500, align 8
  %527 = load ptr, ptr %526, align 8
  %528 = getelementptr i8, ptr %527, i64 72
  %529 = load ptr, ptr %528, align 8
  %result.i.i129.i.i = call { i64, i64 } %529(ptr nocapture nofree nonnull readonly align 8 %526) #44
  %530 = extractvalue { i64, i64 } %result.i.i129.i.i, 1
  %531 = urem i64 %525, %530
  %532 = icmp eq i64 %531, 0
  %533 = sub i64 %530, %531
  %534 = select i1 %532, i64 0, i64 %533
  %535 = getelementptr i8, ptr %result.i22.i92.i, i64 %525
  %536 = getelementptr i8, ptr %535, i64 %534
  %537 = getelementptr i8, ptr %527, i64 64
  %538 = load ptr, ptr %537, align 8
  call void %538({ ptr, i160 } %105, ptr nocapture nofree nonnull readonly align 8 %526, ptr nocapture nofree writeonly %536) #45
  %539 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %540 = getelementptr inbounds i8, ptr %result.i22.i92.i, i64 16
  store i32 %107, ptr %540, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %69)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %70)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %71)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %72)
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %542 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %543 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %544

544:                                              ; preds = %.cont.i.i, %._crit_edge.i.i
  %.0290.i.i = phi i32 [ 0, %._crit_edge.i.i ], [ %579, %.cont.i.i ]
  %.074289.i.i = phi i1 [ true, %._crit_edge.i.i ], [ %580, %.cont.i.i ]
  %.sroa.0.0288.i.i = phi ptr [ @Entry, %._crit_edge.i.i ], [ %567, %.cont.i.i ]
  %.sroa.6.0287.i.i = phi ptr [ %result.i22.i92.i, %._crit_edge.i.i ], [ %581, %.cont.i.i ]
  %.sroa.12.0286.i.i = phi ptr [ undef, %._crit_edge.i.i ], [ %582, %.cont.i.i ]
  %.sroa.17.0285.i.i = phi i32 [ 10, %._crit_edge.i.i ], [ %offset.i.i57.i.i, %.cont.i.i ]
  %545 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i.i, 0
  %546 = insertvalue { ptr, ptr, ptr, i32 } %545, ptr %.sroa.6.0287.i.i, 1
  %547 = insertvalue { ptr, ptr, ptr, i32 } %546, ptr %.sroa.12.0286.i.i, 2
  %548 = insertvalue { ptr, ptr, ptr, i32 } %547, i32 %.sroa.17.0285.i.i, 3
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i.i)
  %550 = sext i32 %.sroa.17.0285.i.i to i64
  %551 = getelementptr ptr, ptr %.sroa.0.0288.i.i, i64 %550
  %552 = getelementptr i8, ptr %551, i64 64
  %553 = load ptr, ptr %552, align 8
  %result.i15.i.i = call ptr %553({ ptr, ptr, ptr, i32 } %548, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %554 = call i32 %result.i15.i.i({ ptr, ptr, ptr, i32 } %548, { ptr, ptr, ptr, i32 } %548, ptr nonnull align 8 %0) #53
  %..i.i = select i1 %.074289.i.i, ptr %69, ptr %71
  %.188.i.i = select i1 %.074289.i.i, i64 104, i64 112
  %.189.i.i = select i1 %.074289.i.i, ptr %70, ptr %72
  %.190.i.i = select i1 %.074289.i.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i.i, align 8
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i.i)
  %556 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i.i
  %557 = load ptr, ptr %556, align 8
  store ptr @i32_typ, ptr %.189.i.i, align 8
  %result.i14.i.i = call ptr %557({ ptr, ptr, ptr, i32 } %101, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i.i) #46
  %558 = call i32 %result.i14.i.i({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr nonnull align 8 dereferenceable(8) %..i.i, i32 %554) #53
  %559 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %560 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i.i
  %561 = load ptr, ptr %560, align 8
  %562 = load ptr, ptr %561, align 8
  %563 = call { ptr } %562(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i.i = extractvalue { ptr } %563, 0
  %564 = sext i32 %558 to i64
  %565 = shl nsw i64 %564, 5
  %566 = getelementptr i8, ptr %.fca.0.extract55.i.i, i64 %565
  %567 = load ptr, ptr %566, align 8
  %568 = getelementptr i8, ptr %566, i64 8
  %569 = load i64, ptr %568, align 4
  %.sroa_idx.i389.i = getelementptr i8, ptr %566, i64 16
  %570 = load i64, ptr %.sroa_idx.i389.i, align 4
  %571 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %572 = call { ptr } %562(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i.i = extractvalue { ptr } %572, 0
  %573 = getelementptr i8, ptr %.fca.0.extract52.i.i, i64 %565
  store ptr %.sroa.0.0288.i.i, ptr %573, align 8
  %574 = getelementptr i8, ptr %573, i64 8
  %575 = ptrtoint ptr %.sroa.6.0287.i.i to i64
  %576 = ptrtoint ptr %.sroa.12.0286.i.i to i64
  store i64 %575, ptr %574, align 4
  %.sroa_idx104.i.i = getelementptr i8, ptr %573, i64 16
  store i64 %576, ptr %.sroa_idx104.i.i, align 4
  %.sroa_idx105.i.i = getelementptr i8, ptr %573, i64 24
  store i32 %.sroa.17.0285.i.i, ptr %.sroa_idx105.i.i, align 4
  %577 = icmp ne ptr %567, @nil_typ
  %578 = icmp ne ptr %567, null
  %.not94.i.i = and i1 %577, %578
  br i1 %.not94.i.i, label %.cont.i.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i

.cont.i.i:                                        ; preds = %544
  %579 = add nuw nsw i32 %.0290.i.i, 1
  %580 = xor i1 %.074289.i.i, true
  %581 = inttoptr i64 %569 to ptr
  %582 = inttoptr i64 %570 to ptr
  %hash_coef_ptr.i.i46.i.i = getelementptr i8, ptr %567, i64 8
  %tbl_size_ptr.i.i47.i.i = getelementptr i8, ptr %567, i64 16
  %offset_tbl_ptr.i.i48.i.i = getelementptr i8, ptr %567, i64 40
  %hash_coef.i.i49.i.i = load i64, ptr %hash_coef_ptr.i.i46.i.i, align 4
  %tbl_size.i.i50.i.i = load i64, ptr %tbl_size_ptr.i.i47.i.i, align 4
  %offset_tbl.i.i51.i.i = load ptr, ptr %offset_tbl_ptr.i.i48.i.i, align 8
  %product.i.i.i52.i.i = mul i64 %hash_coef.i.i49.i.i, 4015701072841558310
  %shifted.i.i.i53.i.i = lshr i64 %product.i.i.i52.i.i, 32
  %xored.i.i.i54.i.i = xor i64 %shifted.i.i.i53.i.i, %product.i.i.i52.i.i
  %hash.i.i.i55.i.i = and i64 %xored.i.i.i54.i.i, %tbl_size.i.i50.i.i
  %offset_ptr.i.i56.i.i = getelementptr i32, ptr %offset_tbl.i.i51.i.i, i64 %hash.i.i.i55.i.i
  %offset.i.i57.i.i = load i32, ptr %offset_ptr.i.i56.i.i, align 4
  %583 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %584 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i.i = icmp eq i32 %579, 100
  br i1 %exitcond.not.i.i, label %588, label %544

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i: ; preds = %544
  %585 = load i32, ptr %97, align 4
  %586 = add i32 %585, 1
  %587 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %586, ptr %97, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %69)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %70)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %71)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %72)
  br label %CuckooMap_insert_keyK_valueV.exit.i

588:                                              ; preds = %.cont.i.i
  %hash_coef_ptr.i.i46.i.i.le = getelementptr i8, ptr %567, i64 8
  %tbl_size_ptr.i.i47.i.i.le = getelementptr i8, ptr %567, i64 16
  %offset_tbl_ptr.i.i48.i.i.le = getelementptr i8, ptr %567, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %69)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %70)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %71)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %72)
  %589 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %590 = load ptr, ptr %94, align 8
  %591 = load ptr, ptr %95, align 8
  %592 = load i32, ptr %93, align 8
  %593 = shl i32 %592, 1
  %spec.select.i407.i = call i32 @llvm.smax.i32(i32 %593, i32 noundef 16) #40
  store i32 %spec.select.i407.i, ptr %93, align 8
  %594 = zext nneg i32 %spec.select.i407.i to i64
  %595 = shl nuw nsw i64 %594, 5
  %result.i5.i408.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %595) #48
  store ptr %result.i5.i408.i, ptr %94, align 8
  %result.i4.i409.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %595) #48
  store ptr %result.i4.i409.i, ptr %95, align 8
  store i32 0, ptr %97, align 4
  %596 = icmp sgt i32 %592, 0
  br i1 %596, label %.lr.ph.i801.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i

.lr.ph.i801.i:                                    ; preds = %588
  %wide.trip.count.i814.i = zext nneg i32 %592 to i64
  br label %597

597:                                              ; preds = %._crit_edge.i817.i, %.lr.ph.i801.i
  %indvars.iv.i815.i = phi i64 [ 0, %.lr.ph.i801.i ], [ %indvars.iv.next.i818.i, %._crit_edge.i817.i ]
  %598 = shl nuw nsw i64 %indvars.iv.i815.i, 5
  %599 = getelementptr i8, ptr %590, i64 %598
  %600 = load ptr, ptr %599, align 8
  %601 = icmp ne ptr %600, @nil_typ
  %602 = icmp ne ptr %600, null
  %.not17.i816.i = and i1 %601, %602
  br i1 %.not17.i816.i, label %603, label %._crit_edge.i817.i

603:                                              ; preds = %597
  %604 = getelementptr i8, ptr %599, i64 8
  %605 = load i64, ptr %604, align 4
  %.sroa_idx.i820.i = getelementptr i8, ptr %599, i64 16
  %606 = load i64, ptr %.sroa_idx.i820.i, align 4
  %hash_coef_ptr.i.i6.i821.i = getelementptr i8, ptr %600, i64 8
  %tbl_size_ptr.i.i7.i822.i = getelementptr i8, ptr %600, i64 16
  %offset_tbl_ptr.i.i8.i823.i = getelementptr i8, ptr %600, i64 40
  %607 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  %hash_coef.i.i21.i1151.i = load i64, ptr %hash_coef_ptr.i.i6.i821.i, align 4, !noalias !425
  %tbl_size.i.i22.i1152.i = load i64, ptr %tbl_size_ptr.i.i7.i822.i, align 4, !noalias !425
  %offset_tbl.i.i23.i1153.i = load ptr, ptr %offset_tbl_ptr.i.i8.i823.i, align 8, !noalias !425
  %product.i.i.i24.i1154.i = mul i64 %hash_coef.i.i21.i1151.i, 4015701072841558310
  %shifted.i.i.i25.i1155.i = lshr i64 %product.i.i.i24.i1154.i, 32
  %xored.i.i.i26.i1156.i = xor i64 %shifted.i.i.i25.i1155.i, %product.i.i.i24.i1154.i
  %hash.i.i.i27.i1157.i = and i64 %xored.i.i.i26.i1156.i, %tbl_size.i.i22.i1152.i
  %offset_ptr.i.i28.i1158.i = getelementptr i32, ptr %offset_tbl.i.i23.i1153.i, i64 %hash.i.i.i27.i1157.i
  %offset.i.i29.i1159.i = load i32, ptr %offset_ptr.i.i28.i1158.i, align 4, !noalias !425
  %608 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %609 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %610 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %611

611:                                              ; preds = %.cont.i1182.i, %603
  %.0290.i1160.i = phi i32 [ 0, %603 ], [ %644, %.cont.i1182.i ]
  %.074289.i1161.i = phi i1 [ true, %603 ], [ %645, %.cont.i1182.i ]
  %.sroa.0.0288.i1162.i = phi ptr [ %600, %603 ], [ %634, %.cont.i1182.i ]
  %.sroa.6.0287.i1163.in.i = phi i64 [ %605, %603 ], [ %636, %.cont.i1182.i ]
  %.sroa.12.0286.i1164.in.i = phi i64 [ %606, %603 ], [ %637, %.cont.i1182.i ]
  %.sroa.17.0285.i1165.i = phi i32 [ %offset.i.i29.i1159.i, %603 ], [ %offset.i.i57.i1194.i, %.cont.i1182.i ]
  %.sroa.12.0286.i1164.i = inttoptr i64 %.sroa.12.0286.i1164.in.i to ptr
  %.sroa.6.0287.i1163.i = inttoptr i64 %.sroa.6.0287.i1163.in.i to ptr
  %612 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1162.i, 0
  %613 = insertvalue { ptr, ptr, ptr, i32 } %612, ptr %.sroa.6.0287.i1163.i, 1
  %614 = insertvalue { ptr, ptr, ptr, i32 } %613, ptr %.sroa.12.0286.i1164.i, 2
  %615 = insertvalue { ptr, ptr, ptr, i32 } %614, i32 %.sroa.17.0285.i1165.i, 3
  %616 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1162.i)
  %617 = sext i32 %.sroa.17.0285.i1165.i to i64
  %618 = getelementptr ptr, ptr %.sroa.0.0288.i1162.i, i64 %617
  %619 = getelementptr i8, ptr %618, i64 64
  %620 = load ptr, ptr %619, align 8
  %result.i15.i1166.i = call ptr %620({ ptr, ptr, ptr, i32 } %615, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %621 = call i32 %result.i15.i1166.i({ ptr, ptr, ptr, i32 } %615, { ptr, ptr, ptr, i32 } %615, ptr nonnull align 8 %0) #53
  %..i1167.i = select i1 %.074289.i1161.i, ptr %53, ptr %55
  %.188.i1168.i = select i1 %.074289.i1161.i, i64 104, i64 112
  %.189.i1169.i = select i1 %.074289.i1161.i, ptr %54, ptr %56
  %.190.i1170.i = select i1 %.074289.i1161.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1167.i, align 8
  %622 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1167.i)
  %623 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1168.i
  %624 = load ptr, ptr %623, align 8
  store ptr @i32_typ, ptr %.189.i1169.i, align 8
  %result.i14.i1171.i = call ptr %624({ ptr, ptr, ptr, i32 } %102, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1169.i) #46
  %625 = call i32 %result.i14.i1171.i({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull align 8 dereferenceable(8) %..i1167.i, i32 %621) #53
  %626 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %627 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1170.i
  %628 = load ptr, ptr %627, align 8
  %629 = load ptr, ptr %628, align 8
  %630 = call { ptr } %629(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i1172.i = extractvalue { ptr } %630, 0
  %631 = sext i32 %625 to i64
  %632 = shl nsw i64 %631, 5
  %633 = getelementptr i8, ptr %.fca.0.extract55.i1172.i, i64 %632
  %634 = load ptr, ptr %633, align 8
  %635 = getelementptr i8, ptr %633, i64 8
  %636 = load i64, ptr %635, align 4
  %.sroa_idx.i1173.i = getelementptr i8, ptr %633, i64 16
  %637 = load i64, ptr %.sroa_idx.i1173.i, align 4
  %638 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %639 = call { ptr } %629(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i1174.i = extractvalue { ptr } %639, 0
  %640 = getelementptr i8, ptr %.fca.0.extract52.i1174.i, i64 %632
  store ptr %.sroa.0.0288.i1162.i, ptr %640, align 8
  %641 = getelementptr i8, ptr %640, i64 8
  store i64 %.sroa.6.0287.i1163.in.i, ptr %641, align 4
  %.sroa_idx104.i1175.i = getelementptr i8, ptr %640, i64 16
  store i64 %.sroa.12.0286.i1164.in.i, ptr %.sroa_idx104.i1175.i, align 4
  %.sroa_idx105.i1176.i = getelementptr i8, ptr %640, i64 24
  store i32 %.sroa.17.0285.i1165.i, ptr %.sroa_idx105.i1176.i, align 4
  %642 = icmp ne ptr %634, @nil_typ
  %643 = icmp ne ptr %634, null
  %.not94.i1177.i = and i1 %642, %643
  br i1 %.not94.i1177.i, label %.cont.i1182.i, label %648

.cont.i1182.i:                                    ; preds = %611
  %644 = add nuw nsw i32 %.0290.i1160.i, 1
  %645 = xor i1 %.074289.i1161.i, true
  %hash_coef_ptr.i.i46.i1183.i = getelementptr i8, ptr %634, i64 8
  %tbl_size_ptr.i.i47.i1184.i = getelementptr i8, ptr %634, i64 16
  %offset_tbl_ptr.i.i48.i1185.i = getelementptr i8, ptr %634, i64 40
  %hash_coef.i.i49.i1186.i = load i64, ptr %hash_coef_ptr.i.i46.i1183.i, align 4
  %tbl_size.i.i50.i1187.i = load i64, ptr %tbl_size_ptr.i.i47.i1184.i, align 4
  %offset_tbl.i.i51.i1188.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1185.i, align 8
  %product.i.i.i52.i1189.i = mul i64 %hash_coef.i.i49.i1186.i, 4015701072841558310
  %shifted.i.i.i53.i1190.i = lshr i64 %product.i.i.i52.i1189.i, 32
  %xored.i.i.i54.i1191.i = xor i64 %shifted.i.i.i53.i1190.i, %product.i.i.i52.i1189.i
  %hash.i.i.i55.i1192.i = and i64 %xored.i.i.i54.i1191.i, %tbl_size.i.i50.i1187.i
  %offset_ptr.i.i56.i1193.i = getelementptr i32, ptr %offset_tbl.i.i51.i1188.i, i64 %hash.i.i.i55.i1192.i
  %offset.i.i57.i1194.i = load i32, ptr %offset_ptr.i.i56.i1193.i, align 4
  %646 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %647 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1195.i = icmp eq i32 %644, 100
  br i1 %exitcond.not.i1195.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204.i, label %611

648:                                              ; preds = %611
  %649 = load i32, ptr %97, align 4
  %650 = add i32 %649, 1
  %651 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %650, ptr %97, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204.i: ; preds = %648, %.cont.i1182.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %54)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %56)
  br label %._crit_edge.i817.i

._crit_edge.i817.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1204.i, %597
  %indvars.iv.next.i818.i = add nuw nsw i64 %indvars.iv.i815.i, 1
  %exitcond.not.i819.i = icmp eq i64 %indvars.iv.next.i818.i, %wide.trip.count.i814.i
  br i1 %exitcond.not.i819.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837.i, label %597

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837.i: ; preds = %._crit_edge.i855.i, %._crit_edge.i817.i
  %indvars.iv.i853.i = phi i64 [ %indvars.iv.next.i856.i, %._crit_edge.i855.i ], [ 0, %._crit_edge.i817.i ]
  %652 = shl nuw nsw i64 %indvars.iv.i853.i, 5
  %653 = getelementptr i8, ptr %591, i64 %652
  %654 = load ptr, ptr %653, align 8
  %655 = icmp ne ptr %654, @nil_typ
  %656 = icmp ne ptr %654, null
  %.not17.i854.i = and i1 %655, %656
  br i1 %.not17.i854.i, label %657, label %._crit_edge.i855.i

657:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837.i
  %658 = getelementptr i8, ptr %653, i64 8
  %659 = load i64, ptr %658, align 4
  %.sroa_idx.i858.i = getelementptr i8, ptr %653, i64 16
  %660 = load i64, ptr %.sroa_idx.i858.i, align 4
  %hash_coef_ptr.i.i6.i859.i = getelementptr i8, ptr %654, i64 8
  %tbl_size_ptr.i.i7.i860.i = getelementptr i8, ptr %654, i64 16
  %offset_tbl_ptr.i.i8.i861.i = getelementptr i8, ptr %654, i64 40
  %661 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  %hash_coef.i.i21.i1222.i = load i64, ptr %hash_coef_ptr.i.i6.i859.i, align 4, !noalias !428
  %tbl_size.i.i22.i1223.i = load i64, ptr %tbl_size_ptr.i.i7.i860.i, align 4, !noalias !428
  %offset_tbl.i.i23.i1224.i = load ptr, ptr %offset_tbl_ptr.i.i8.i861.i, align 8, !noalias !428
  %product.i.i.i24.i1225.i = mul i64 %hash_coef.i.i21.i1222.i, 4015701072841558310
  %shifted.i.i.i25.i1226.i = lshr i64 %product.i.i.i24.i1225.i, 32
  %xored.i.i.i26.i1227.i = xor i64 %shifted.i.i.i25.i1226.i, %product.i.i.i24.i1225.i
  %hash.i.i.i27.i1228.i = and i64 %xored.i.i.i26.i1227.i, %tbl_size.i.i22.i1223.i
  %offset_ptr.i.i28.i1229.i = getelementptr i32, ptr %offset_tbl.i.i23.i1224.i, i64 %hash.i.i.i27.i1228.i
  %offset.i.i29.i1230.i = load i32, ptr %offset_ptr.i.i28.i1229.i, align 4, !noalias !428
  %662 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %663 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %664 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %665

665:                                              ; preds = %.cont.i1253.i, %657
  %.0290.i1231.i = phi i32 [ 0, %657 ], [ %698, %.cont.i1253.i ]
  %.074289.i1232.i = phi i1 [ true, %657 ], [ %699, %.cont.i1253.i ]
  %.sroa.0.0288.i1233.i = phi ptr [ %654, %657 ], [ %688, %.cont.i1253.i ]
  %.sroa.6.0287.i1234.in.i = phi i64 [ %659, %657 ], [ %690, %.cont.i1253.i ]
  %.sroa.12.0286.i1235.in.i = phi i64 [ %660, %657 ], [ %691, %.cont.i1253.i ]
  %.sroa.17.0285.i1236.i = phi i32 [ %offset.i.i29.i1230.i, %657 ], [ %offset.i.i57.i1265.i, %.cont.i1253.i ]
  %.sroa.12.0286.i1235.i = inttoptr i64 %.sroa.12.0286.i1235.in.i to ptr
  %.sroa.6.0287.i1234.i = inttoptr i64 %.sroa.6.0287.i1234.in.i to ptr
  %666 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1233.i, 0
  %667 = insertvalue { ptr, ptr, ptr, i32 } %666, ptr %.sroa.6.0287.i1234.i, 1
  %668 = insertvalue { ptr, ptr, ptr, i32 } %667, ptr %.sroa.12.0286.i1235.i, 2
  %669 = insertvalue { ptr, ptr, ptr, i32 } %668, i32 %.sroa.17.0285.i1236.i, 3
  %670 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1233.i)
  %671 = sext i32 %.sroa.17.0285.i1236.i to i64
  %672 = getelementptr ptr, ptr %.sroa.0.0288.i1233.i, i64 %671
  %673 = getelementptr i8, ptr %672, i64 64
  %674 = load ptr, ptr %673, align 8
  %result.i15.i1237.i = call ptr %674({ ptr, ptr, ptr, i32 } %669, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %675 = call i32 %result.i15.i1237.i({ ptr, ptr, ptr, i32 } %669, { ptr, ptr, ptr, i32 } %669, ptr nonnull align 8 %0) #53
  %..i1238.i = select i1 %.074289.i1232.i, ptr %49, ptr %51
  %.188.i1239.i = select i1 %.074289.i1232.i, i64 104, i64 112
  %.189.i1240.i = select i1 %.074289.i1232.i, ptr %50, ptr %52
  %.190.i1241.i = select i1 %.074289.i1232.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1238.i, align 8
  %676 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1238.i)
  %677 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1239.i
  %678 = load ptr, ptr %677, align 8
  store ptr @i32_typ, ptr %.189.i1240.i, align 8
  %result.i14.i1242.i = call ptr %678({ ptr, ptr, ptr, i32 } %102, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1240.i) #46
  %679 = call i32 %result.i14.i1242.i({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull align 8 dereferenceable(8) %..i1238.i, i32 %675) #53
  %680 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %681 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1241.i
  %682 = load ptr, ptr %681, align 8
  %683 = load ptr, ptr %682, align 8
  %684 = call { ptr } %683(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i1243.i = extractvalue { ptr } %684, 0
  %685 = sext i32 %679 to i64
  %686 = shl nsw i64 %685, 5
  %687 = getelementptr i8, ptr %.fca.0.extract55.i1243.i, i64 %686
  %688 = load ptr, ptr %687, align 8
  %689 = getelementptr i8, ptr %687, i64 8
  %690 = load i64, ptr %689, align 4
  %.sroa_idx.i1244.i = getelementptr i8, ptr %687, i64 16
  %691 = load i64, ptr %.sroa_idx.i1244.i, align 4
  %692 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %693 = call { ptr } %683(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i1245.i = extractvalue { ptr } %693, 0
  %694 = getelementptr i8, ptr %.fca.0.extract52.i1245.i, i64 %686
  store ptr %.sroa.0.0288.i1233.i, ptr %694, align 8
  %695 = getelementptr i8, ptr %694, i64 8
  store i64 %.sroa.6.0287.i1234.in.i, ptr %695, align 4
  %.sroa_idx104.i1246.i = getelementptr i8, ptr %694, i64 16
  store i64 %.sroa.12.0286.i1235.in.i, ptr %.sroa_idx104.i1246.i, align 4
  %.sroa_idx105.i1247.i = getelementptr i8, ptr %694, i64 24
  store i32 %.sroa.17.0285.i1236.i, ptr %.sroa_idx105.i1247.i, align 4
  %696 = icmp ne ptr %688, @nil_typ
  %697 = icmp ne ptr %688, null
  %.not94.i1248.i = and i1 %696, %697
  br i1 %.not94.i1248.i, label %.cont.i1253.i, label %702

.cont.i1253.i:                                    ; preds = %665
  %698 = add nuw nsw i32 %.0290.i1231.i, 1
  %699 = xor i1 %.074289.i1232.i, true
  %hash_coef_ptr.i.i46.i1254.i = getelementptr i8, ptr %688, i64 8
  %tbl_size_ptr.i.i47.i1255.i = getelementptr i8, ptr %688, i64 16
  %offset_tbl_ptr.i.i48.i1256.i = getelementptr i8, ptr %688, i64 40
  %hash_coef.i.i49.i1257.i = load i64, ptr %hash_coef_ptr.i.i46.i1254.i, align 4
  %tbl_size.i.i50.i1258.i = load i64, ptr %tbl_size_ptr.i.i47.i1255.i, align 4
  %offset_tbl.i.i51.i1259.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1256.i, align 8
  %product.i.i.i52.i1260.i = mul i64 %hash_coef.i.i49.i1257.i, 4015701072841558310
  %shifted.i.i.i53.i1261.i = lshr i64 %product.i.i.i52.i1260.i, 32
  %xored.i.i.i54.i1262.i = xor i64 %shifted.i.i.i53.i1261.i, %product.i.i.i52.i1260.i
  %hash.i.i.i55.i1263.i = and i64 %xored.i.i.i54.i1262.i, %tbl_size.i.i50.i1258.i
  %offset_ptr.i.i56.i1264.i = getelementptr i32, ptr %offset_tbl.i.i51.i1259.i, i64 %hash.i.i.i55.i1263.i
  %offset.i.i57.i1265.i = load i32, ptr %offset_ptr.i.i56.i1264.i, align 4
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1266.i = icmp eq i32 %698, 100
  br i1 %exitcond.not.i1266.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275.i, label %665

702:                                              ; preds = %665
  %703 = load i32, ptr %97, align 4
  %704 = add i32 %703, 1
  %705 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %704, ptr %97, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275.i: ; preds = %702, %.cont.i1253.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %49)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %50)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  br label %._crit_edge.i855.i

._crit_edge.i855.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1275.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837.i
  %indvars.iv.next.i856.i = add nuw nsw i64 %indvars.iv.i853.i, 1
  %exitcond.not.i857.i = icmp eq i64 %indvars.iv.next.i856.i, %wide.trip.count.i814.i
  br i1 %exitcond.not.i857.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit837.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i: ; preds = %._crit_edge.i855.i, %588
  %706 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %68)
  %hash_coef.i.i21.i433.i = load i64, ptr %hash_coef_ptr.i.i46.i.i.le, align 4, !noalias !431
  %tbl_size.i.i22.i434.i = load i64, ptr %tbl_size_ptr.i.i47.i.i.le, align 4, !noalias !431
  %offset_tbl.i.i23.i435.i = load ptr, ptr %offset_tbl_ptr.i.i48.i.i.le, align 8, !noalias !431
  %product.i.i.i24.i436.i = mul i64 %hash_coef.i.i21.i433.i, 4015701072841558310
  %shifted.i.i.i25.i437.i = lshr i64 %product.i.i.i24.i436.i, 32
  %xored.i.i.i26.i438.i = xor i64 %shifted.i.i.i25.i437.i, %product.i.i.i24.i436.i
  %hash.i.i.i27.i439.i = and i64 %xored.i.i.i26.i438.i, %tbl_size.i.i22.i434.i
  %offset_ptr.i.i28.i440.i = getelementptr i32, ptr %offset_tbl.i.i23.i435.i, i64 %hash.i.i.i27.i439.i
  %offset.i.i29.i441.i = load i32, ptr %offset_ptr.i.i28.i440.i, align 4, !noalias !431
  %707 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %708 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %709 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %710

710:                                              ; preds = %.cont.i465.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i
  %.0290.i443.i = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i ], [ %743, %.cont.i465.i ]
  %.074289.i444.i = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i ], [ %744, %.cont.i465.i ]
  %.sroa.0.0288.i445.i = phi ptr [ %567, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i ], [ %733, %.cont.i465.i ]
  %.sroa.6.0287.i446.in.i = phi i64 [ %569, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i ], [ %735, %.cont.i465.i ]
  %.sroa.12.0286.i447.in.i = phi i64 [ %570, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i ], [ %736, %.cont.i465.i ]
  %.sroa.17.0285.i448.i = phi i32 [ %offset.i.i29.i441.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit875.i ], [ %offset.i.i57.i477.i, %.cont.i465.i ]
  %.sroa.12.0286.i447.i = inttoptr i64 %.sroa.12.0286.i447.in.i to ptr
  %.sroa.6.0287.i446.i = inttoptr i64 %.sroa.6.0287.i446.in.i to ptr
  %711 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i445.i, 0
  %712 = insertvalue { ptr, ptr, ptr, i32 } %711, ptr %.sroa.6.0287.i446.i, 1
  %713 = insertvalue { ptr, ptr, ptr, i32 } %712, ptr %.sroa.12.0286.i447.i, 2
  %714 = insertvalue { ptr, ptr, ptr, i32 } %713, i32 %.sroa.17.0285.i448.i, 3
  %715 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i445.i)
  %716 = sext i32 %.sroa.17.0285.i448.i to i64
  %717 = getelementptr ptr, ptr %.sroa.0.0288.i445.i, i64 %716
  %718 = getelementptr i8, ptr %717, i64 64
  %719 = load ptr, ptr %718, align 8
  %result.i15.i449.i = call ptr %719({ ptr, ptr, ptr, i32 } %714, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %720 = call i32 %result.i15.i449.i({ ptr, ptr, ptr, i32 } %714, { ptr, ptr, ptr, i32 } %714, ptr nonnull align 8 %0) #53
  %..i450.i = select i1 %.074289.i444.i, ptr %65, ptr %67
  %.188.i451.i = select i1 %.074289.i444.i, i64 104, i64 112
  %.189.i452.i = select i1 %.074289.i444.i, ptr %66, ptr %68
  %.190.i453.i = select i1 %.074289.i444.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i450.i, align 8
  %721 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i450.i)
  %722 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i451.i
  %723 = load ptr, ptr %722, align 8
  store ptr @i32_typ, ptr %.189.i452.i, align 8
  %result.i14.i454.i = call ptr %723({ ptr, ptr, ptr, i32 } %101, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i452.i) #46
  %724 = call i32 %result.i14.i454.i({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr nonnull align 8 dereferenceable(8) %..i450.i, i32 %720) #53
  %725 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %726 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i453.i
  %727 = load ptr, ptr %726, align 8
  %728 = load ptr, ptr %727, align 8
  %729 = call { ptr } %728(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i455.i = extractvalue { ptr } %729, 0
  %730 = sext i32 %724 to i64
  %731 = shl nsw i64 %730, 5
  %732 = getelementptr i8, ptr %.fca.0.extract55.i455.i, i64 %731
  %733 = load ptr, ptr %732, align 8
  %734 = getelementptr i8, ptr %732, i64 8
  %735 = load i64, ptr %734, align 4
  %.sroa_idx.i456.i = getelementptr i8, ptr %732, i64 16
  %736 = load i64, ptr %.sroa_idx.i456.i, align 4
  %737 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %738 = call { ptr } %728(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i457.i = extractvalue { ptr } %738, 0
  %739 = getelementptr i8, ptr %.fca.0.extract52.i457.i, i64 %731
  store ptr %.sroa.0.0288.i445.i, ptr %739, align 8
  %740 = getelementptr i8, ptr %739, i64 8
  store i64 %.sroa.6.0287.i446.in.i, ptr %740, align 4
  %.sroa_idx104.i458.i = getelementptr i8, ptr %739, i64 16
  store i64 %.sroa.12.0286.i447.in.i, ptr %.sroa_idx104.i458.i, align 4
  %.sroa_idx105.i459.i = getelementptr i8, ptr %739, i64 24
  store i32 %.sroa.17.0285.i448.i, ptr %.sroa_idx105.i459.i, align 4
  %741 = icmp ne ptr %733, @nil_typ
  %742 = icmp ne ptr %733, null
  %.not94.i460.i = and i1 %741, %742
  br i1 %.not94.i460.i, label %.cont.i465.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit487.i

.cont.i465.i:                                     ; preds = %710
  %743 = add nuw nsw i32 %.0290.i443.i, 1
  %744 = xor i1 %.074289.i444.i, true
  %hash_coef_ptr.i.i46.i466.i = getelementptr i8, ptr %733, i64 8
  %tbl_size_ptr.i.i47.i467.i = getelementptr i8, ptr %733, i64 16
  %offset_tbl_ptr.i.i48.i468.i = getelementptr i8, ptr %733, i64 40
  %hash_coef.i.i49.i469.i = load i64, ptr %hash_coef_ptr.i.i46.i466.i, align 4
  %tbl_size.i.i50.i470.i = load i64, ptr %tbl_size_ptr.i.i47.i467.i, align 4
  %offset_tbl.i.i51.i471.i = load ptr, ptr %offset_tbl_ptr.i.i48.i468.i, align 8
  %product.i.i.i52.i472.i = mul i64 %hash_coef.i.i49.i469.i, 4015701072841558310
  %shifted.i.i.i53.i473.i = lshr i64 %product.i.i.i52.i472.i, 32
  %xored.i.i.i54.i474.i = xor i64 %shifted.i.i.i53.i473.i, %product.i.i.i52.i472.i
  %hash.i.i.i55.i475.i = and i64 %xored.i.i.i54.i474.i, %tbl_size.i.i50.i470.i
  %offset_ptr.i.i56.i476.i = getelementptr i32, ptr %offset_tbl.i.i51.i471.i, i64 %hash.i.i.i55.i475.i
  %offset.i.i57.i477.i = load i32, ptr %offset_ptr.i.i56.i476.i, align 4
  %745 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %746 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i478.i = icmp eq i32 %743, 100
  br i1 %exitcond.not.i478.i, label %750, label %710

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit487.i: ; preds = %710
  %747 = load i32, ptr %97, align 4
  %748 = add i32 %747, 1
  %749 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %748, ptr %97, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %68)
  br label %CuckooMap_insert_keyK_valueV.exit.i

750:                                              ; preds = %.cont.i465.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %65)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %68)
  %751 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %752 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %753 = load ptr, ptr %94, align 8
  %754 = load ptr, ptr %95, align 8
  %755 = load i32, ptr %93, align 8
  %756 = shl i32 %755, 1
  %spec.select.i504.i = call i32 @llvm.smax.i32(i32 %756, i32 noundef 16) #40
  store i32 %spec.select.i504.i, ptr %93, align 8
  %757 = zext nneg i32 %spec.select.i504.i to i64
  %758 = shl nuw nsw i64 %757, 5
  %result.i5.i505.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %758) #48
  store ptr %result.i5.i505.i, ptr %94, align 8
  %result.i4.i506.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %758) #48
  store ptr %result.i4.i506.i, ptr %95, align 8
  store i32 0, ptr %97, align 4
  %759 = icmp sgt i32 %755, 0
  br i1 %759, label %.lr.ph.i877.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.thread.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.thread.i: ; preds = %750
  %760 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit.i

.lr.ph.i877.i:                                    ; preds = %750
  %wide.trip.count.i890.i = zext nneg i32 %755 to i64
  br label %761

761:                                              ; preds = %._crit_edge.i893.i, %.lr.ph.i877.i
  %indvars.iv.i891.i = phi i64 [ 0, %.lr.ph.i877.i ], [ %indvars.iv.next.i894.i, %._crit_edge.i893.i ]
  %762 = shl nuw nsw i64 %indvars.iv.i891.i, 5
  %763 = getelementptr i8, ptr %753, i64 %762
  %764 = load ptr, ptr %763, align 8
  %765 = icmp ne ptr %764, @nil_typ
  %766 = icmp ne ptr %764, null
  %.not17.i892.i = and i1 %765, %766
  br i1 %.not17.i892.i, label %767, label %._crit_edge.i893.i

767:                                              ; preds = %761
  %768 = getelementptr i8, ptr %763, i64 8
  %769 = load i64, ptr %768, align 4
  %.sroa_idx.i896.i = getelementptr i8, ptr %763, i64 16
  %770 = load i64, ptr %.sroa_idx.i896.i, align 4
  %hash_coef_ptr.i.i6.i897.i = getelementptr i8, ptr %764, i64 8
  %tbl_size_ptr.i.i7.i898.i = getelementptr i8, ptr %764, i64 16
  %offset_tbl_ptr.i.i8.i899.i = getelementptr i8, ptr %764, i64 40
  %771 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  %hash_coef.i.i21.i1293.i = load i64, ptr %hash_coef_ptr.i.i6.i897.i, align 4, !noalias !434
  %tbl_size.i.i22.i1294.i = load i64, ptr %tbl_size_ptr.i.i7.i898.i, align 4, !noalias !434
  %offset_tbl.i.i23.i1295.i = load ptr, ptr %offset_tbl_ptr.i.i8.i899.i, align 8, !noalias !434
  %product.i.i.i24.i1296.i = mul i64 %hash_coef.i.i21.i1293.i, 4015701072841558310
  %shifted.i.i.i25.i1297.i = lshr i64 %product.i.i.i24.i1296.i, 32
  %xored.i.i.i26.i1298.i = xor i64 %shifted.i.i.i25.i1297.i, %product.i.i.i24.i1296.i
  %hash.i.i.i27.i1299.i = and i64 %xored.i.i.i26.i1298.i, %tbl_size.i.i22.i1294.i
  %offset_ptr.i.i28.i1300.i = getelementptr i32, ptr %offset_tbl.i.i23.i1295.i, i64 %hash.i.i.i27.i1299.i
  %offset.i.i29.i1301.i = load i32, ptr %offset_ptr.i.i28.i1300.i, align 4, !noalias !434
  %772 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %774 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %775

775:                                              ; preds = %.cont.i1324.i, %767
  %.0290.i1302.i = phi i32 [ 0, %767 ], [ %808, %.cont.i1324.i ]
  %.074289.i1303.i = phi i1 [ true, %767 ], [ %809, %.cont.i1324.i ]
  %.sroa.0.0288.i1304.i = phi ptr [ %764, %767 ], [ %798, %.cont.i1324.i ]
  %.sroa.6.0287.i1305.in.i = phi i64 [ %769, %767 ], [ %800, %.cont.i1324.i ]
  %.sroa.12.0286.i1306.in.i = phi i64 [ %770, %767 ], [ %801, %.cont.i1324.i ]
  %.sroa.17.0285.i1307.i = phi i32 [ %offset.i.i29.i1301.i, %767 ], [ %offset.i.i57.i1336.i, %.cont.i1324.i ]
  %.sroa.12.0286.i1306.i = inttoptr i64 %.sroa.12.0286.i1306.in.i to ptr
  %.sroa.6.0287.i1305.i = inttoptr i64 %.sroa.6.0287.i1305.in.i to ptr
  %776 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1304.i, 0
  %777 = insertvalue { ptr, ptr, ptr, i32 } %776, ptr %.sroa.6.0287.i1305.i, 1
  %778 = insertvalue { ptr, ptr, ptr, i32 } %777, ptr %.sroa.12.0286.i1306.i, 2
  %779 = insertvalue { ptr, ptr, ptr, i32 } %778, i32 %.sroa.17.0285.i1307.i, 3
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1304.i)
  %781 = sext i32 %.sroa.17.0285.i1307.i to i64
  %782 = getelementptr ptr, ptr %.sroa.0.0288.i1304.i, i64 %781
  %783 = getelementptr i8, ptr %782, i64 64
  %784 = load ptr, ptr %783, align 8
  %result.i15.i1308.i = call ptr %784({ ptr, ptr, ptr, i32 } %779, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %785 = call i32 %result.i15.i1308.i({ ptr, ptr, ptr, i32 } %779, { ptr, ptr, ptr, i32 } %779, ptr nonnull align 8 %0) #53
  %..i1309.i = select i1 %.074289.i1303.i, ptr %45, ptr %47
  %.188.i1310.i = select i1 %.074289.i1303.i, i64 104, i64 112
  %.189.i1311.i = select i1 %.074289.i1303.i, ptr %46, ptr %48
  %.190.i1312.i = select i1 %.074289.i1303.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1309.i, align 8
  %786 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1309.i)
  %787 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1310.i
  %788 = load ptr, ptr %787, align 8
  store ptr @i32_typ, ptr %.189.i1311.i, align 8
  %result.i14.i1313.i = call ptr %788({ ptr, ptr, ptr, i32 } %102, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1311.i) #46
  %789 = call i32 %result.i14.i1313.i({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull align 8 dereferenceable(8) %..i1309.i, i32 %785) #53
  %790 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %791 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1312.i
  %792 = load ptr, ptr %791, align 8
  %793 = load ptr, ptr %792, align 8
  %794 = call { ptr } %793(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i1314.i = extractvalue { ptr } %794, 0
  %795 = sext i32 %789 to i64
  %796 = shl nsw i64 %795, 5
  %797 = getelementptr i8, ptr %.fca.0.extract55.i1314.i, i64 %796
  %798 = load ptr, ptr %797, align 8
  %799 = getelementptr i8, ptr %797, i64 8
  %800 = load i64, ptr %799, align 4
  %.sroa_idx.i1315.i = getelementptr i8, ptr %797, i64 16
  %801 = load i64, ptr %.sroa_idx.i1315.i, align 4
  %802 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %803 = call { ptr } %793(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i1316.i = extractvalue { ptr } %803, 0
  %804 = getelementptr i8, ptr %.fca.0.extract52.i1316.i, i64 %796
  store ptr %.sroa.0.0288.i1304.i, ptr %804, align 8
  %805 = getelementptr i8, ptr %804, i64 8
  store i64 %.sroa.6.0287.i1305.in.i, ptr %805, align 4
  %.sroa_idx104.i1317.i = getelementptr i8, ptr %804, i64 16
  store i64 %.sroa.12.0286.i1306.in.i, ptr %.sroa_idx104.i1317.i, align 4
  %.sroa_idx105.i1318.i = getelementptr i8, ptr %804, i64 24
  store i32 %.sroa.17.0285.i1307.i, ptr %.sroa_idx105.i1318.i, align 4
  %806 = icmp ne ptr %798, @nil_typ
  %807 = icmp ne ptr %798, null
  %.not94.i1319.i = and i1 %806, %807
  br i1 %.not94.i1319.i, label %.cont.i1324.i, label %812

.cont.i1324.i:                                    ; preds = %775
  %808 = add nuw nsw i32 %.0290.i1302.i, 1
  %809 = xor i1 %.074289.i1303.i, true
  %hash_coef_ptr.i.i46.i1325.i = getelementptr i8, ptr %798, i64 8
  %tbl_size_ptr.i.i47.i1326.i = getelementptr i8, ptr %798, i64 16
  %offset_tbl_ptr.i.i48.i1327.i = getelementptr i8, ptr %798, i64 40
  %hash_coef.i.i49.i1328.i = load i64, ptr %hash_coef_ptr.i.i46.i1325.i, align 4
  %tbl_size.i.i50.i1329.i = load i64, ptr %tbl_size_ptr.i.i47.i1326.i, align 4
  %offset_tbl.i.i51.i1330.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1327.i, align 8
  %product.i.i.i52.i1331.i = mul i64 %hash_coef.i.i49.i1328.i, 4015701072841558310
  %shifted.i.i.i53.i1332.i = lshr i64 %product.i.i.i52.i1331.i, 32
  %xored.i.i.i54.i1333.i = xor i64 %shifted.i.i.i53.i1332.i, %product.i.i.i52.i1331.i
  %hash.i.i.i55.i1334.i = and i64 %xored.i.i.i54.i1333.i, %tbl_size.i.i50.i1329.i
  %offset_ptr.i.i56.i1335.i = getelementptr i32, ptr %offset_tbl.i.i51.i1330.i, i64 %hash.i.i.i55.i1334.i
  %offset.i.i57.i1336.i = load i32, ptr %offset_ptr.i.i56.i1335.i, align 4
  %810 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %811 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1337.i = icmp eq i32 %808, 100
  br i1 %exitcond.not.i1337.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346.i, label %775

812:                                              ; preds = %775
  %813 = load i32, ptr %97, align 4
  %814 = add i32 %813, 1
  %815 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %814, ptr %97, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346.i: ; preds = %812, %.cont.i1324.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %45)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %46)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %47)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %48)
  br label %._crit_edge.i893.i

._crit_edge.i893.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1346.i, %761
  %indvars.iv.next.i894.i = add nuw nsw i64 %indvars.iv.i891.i, 1
  %exitcond.not.i895.i = icmp eq i64 %indvars.iv.next.i894.i, %wide.trip.count.i890.i
  br i1 %exitcond.not.i895.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.i, label %761

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.i: ; preds = %._crit_edge.i893.i
  %816 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %817

817:                                              ; preds = %._crit_edge.i931.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.i
  %indvars.iv.i929.i = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.i ], [ %indvars.iv.next.i932.i, %._crit_edge.i931.i ]
  %818 = shl nuw nsw i64 %indvars.iv.i929.i, 5
  %819 = getelementptr i8, ptr %754, i64 %818
  %820 = load ptr, ptr %819, align 8
  %821 = icmp ne ptr %820, @nil_typ
  %822 = icmp ne ptr %820, null
  %.not17.i930.i = and i1 %821, %822
  br i1 %.not17.i930.i, label %823, label %._crit_edge.i931.i

823:                                              ; preds = %817
  %824 = getelementptr i8, ptr %819, i64 8
  %825 = load i64, ptr %824, align 4
  %.sroa_idx.i934.i = getelementptr i8, ptr %819, i64 16
  %826 = load i64, ptr %.sroa_idx.i934.i, align 4
  %hash_coef_ptr.i.i6.i935.i = getelementptr i8, ptr %820, i64 8
  %tbl_size_ptr.i.i7.i936.i = getelementptr i8, ptr %820, i64 16
  %offset_tbl_ptr.i.i8.i937.i = getelementptr i8, ptr %820, i64 40
  %827 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  %hash_coef.i.i21.i1364.i = load i64, ptr %hash_coef_ptr.i.i6.i935.i, align 4, !noalias !437
  %tbl_size.i.i22.i1365.i = load i64, ptr %tbl_size_ptr.i.i7.i936.i, align 4, !noalias !437
  %offset_tbl.i.i23.i1366.i = load ptr, ptr %offset_tbl_ptr.i.i8.i937.i, align 8, !noalias !437
  %product.i.i.i24.i1367.i = mul i64 %hash_coef.i.i21.i1364.i, 4015701072841558310
  %shifted.i.i.i25.i1368.i = lshr i64 %product.i.i.i24.i1367.i, 32
  %xored.i.i.i26.i1369.i = xor i64 %shifted.i.i.i25.i1368.i, %product.i.i.i24.i1367.i
  %hash.i.i.i27.i1370.i = and i64 %xored.i.i.i26.i1369.i, %tbl_size.i.i22.i1365.i
  %offset_ptr.i.i28.i1371.i = getelementptr i32, ptr %offset_tbl.i.i23.i1366.i, i64 %hash.i.i.i27.i1370.i
  %offset.i.i29.i1372.i = load i32, ptr %offset_ptr.i.i28.i1371.i, align 4, !noalias !437
  %828 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %830 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %831

831:                                              ; preds = %.cont.i1395.i, %823
  %.0290.i1373.i = phi i32 [ 0, %823 ], [ %864, %.cont.i1395.i ]
  %.074289.i1374.i = phi i1 [ true, %823 ], [ %865, %.cont.i1395.i ]
  %.sroa.0.0288.i1375.i = phi ptr [ %820, %823 ], [ %854, %.cont.i1395.i ]
  %.sroa.6.0287.i1376.in.i = phi i64 [ %825, %823 ], [ %856, %.cont.i1395.i ]
  %.sroa.12.0286.i1377.in.i = phi i64 [ %826, %823 ], [ %857, %.cont.i1395.i ]
  %.sroa.17.0285.i1378.i = phi i32 [ %offset.i.i29.i1372.i, %823 ], [ %offset.i.i57.i1407.i, %.cont.i1395.i ]
  %.sroa.12.0286.i1377.i = inttoptr i64 %.sroa.12.0286.i1377.in.i to ptr
  %.sroa.6.0287.i1376.i = inttoptr i64 %.sroa.6.0287.i1376.in.i to ptr
  %832 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1375.i, 0
  %833 = insertvalue { ptr, ptr, ptr, i32 } %832, ptr %.sroa.6.0287.i1376.i, 1
  %834 = insertvalue { ptr, ptr, ptr, i32 } %833, ptr %.sroa.12.0286.i1377.i, 2
  %835 = insertvalue { ptr, ptr, ptr, i32 } %834, i32 %.sroa.17.0285.i1378.i, 3
  %836 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1375.i)
  %837 = sext i32 %.sroa.17.0285.i1378.i to i64
  %838 = getelementptr ptr, ptr %.sroa.0.0288.i1375.i, i64 %837
  %839 = getelementptr i8, ptr %838, i64 64
  %840 = load ptr, ptr %839, align 8
  %result.i15.i1379.i = call ptr %840({ ptr, ptr, ptr, i32 } %835, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %841 = call i32 %result.i15.i1379.i({ ptr, ptr, ptr, i32 } %835, { ptr, ptr, ptr, i32 } %835, ptr nonnull align 8 %0) #53
  %..i1380.i = select i1 %.074289.i1374.i, ptr %41, ptr %43
  %.188.i1381.i = select i1 %.074289.i1374.i, i64 104, i64 112
  %.189.i1382.i = select i1 %.074289.i1374.i, ptr %42, ptr %44
  %.190.i1383.i = select i1 %.074289.i1374.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1380.i, align 8
  %842 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1380.i)
  %843 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1381.i
  %844 = load ptr, ptr %843, align 8
  store ptr @i32_typ, ptr %.189.i1382.i, align 8
  %result.i14.i1384.i = call ptr %844({ ptr, ptr, ptr, i32 } %102, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1382.i) #46
  %845 = call i32 %result.i14.i1384.i({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull align 8 dereferenceable(8) %..i1380.i, i32 %841) #53
  %846 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %847 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1383.i
  %848 = load ptr, ptr %847, align 8
  %849 = load ptr, ptr %848, align 8
  %850 = call { ptr } %849(ptr nonnull %result.i31.i) #43
  %.fca.0.extract55.i1385.i = extractvalue { ptr } %850, 0
  %851 = sext i32 %845 to i64
  %852 = shl nsw i64 %851, 5
  %853 = getelementptr i8, ptr %.fca.0.extract55.i1385.i, i64 %852
  %854 = load ptr, ptr %853, align 8
  %855 = getelementptr i8, ptr %853, i64 8
  %856 = load i64, ptr %855, align 4
  %.sroa_idx.i1386.i = getelementptr i8, ptr %853, i64 16
  %857 = load i64, ptr %.sroa_idx.i1386.i, align 4
  %858 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %859 = call { ptr } %849(ptr nonnull %result.i31.i) #43
  %.fca.0.extract52.i1387.i = extractvalue { ptr } %859, 0
  %860 = getelementptr i8, ptr %.fca.0.extract52.i1387.i, i64 %852
  store ptr %.sroa.0.0288.i1375.i, ptr %860, align 8
  %861 = getelementptr i8, ptr %860, i64 8
  store i64 %.sroa.6.0287.i1376.in.i, ptr %861, align 4
  %.sroa_idx104.i1388.i = getelementptr i8, ptr %860, i64 16
  store i64 %.sroa.12.0286.i1377.in.i, ptr %.sroa_idx104.i1388.i, align 4
  %.sroa_idx105.i1389.i = getelementptr i8, ptr %860, i64 24
  store i32 %.sroa.17.0285.i1378.i, ptr %.sroa_idx105.i1389.i, align 4
  %862 = icmp ne ptr %854, @nil_typ
  %863 = icmp ne ptr %854, null
  %.not94.i1390.i = and i1 %862, %863
  br i1 %.not94.i1390.i, label %.cont.i1395.i, label %868

.cont.i1395.i:                                    ; preds = %831
  %864 = add nuw nsw i32 %.0290.i1373.i, 1
  %865 = xor i1 %.074289.i1374.i, true
  %hash_coef_ptr.i.i46.i1396.i = getelementptr i8, ptr %854, i64 8
  %tbl_size_ptr.i.i47.i1397.i = getelementptr i8, ptr %854, i64 16
  %offset_tbl_ptr.i.i48.i1398.i = getelementptr i8, ptr %854, i64 40
  %hash_coef.i.i49.i1399.i = load i64, ptr %hash_coef_ptr.i.i46.i1396.i, align 4
  %tbl_size.i.i50.i1400.i = load i64, ptr %tbl_size_ptr.i.i47.i1397.i, align 4
  %offset_tbl.i.i51.i1401.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1398.i, align 8
  %product.i.i.i52.i1402.i = mul i64 %hash_coef.i.i49.i1399.i, 4015701072841558310
  %shifted.i.i.i53.i1403.i = lshr i64 %product.i.i.i52.i1402.i, 32
  %xored.i.i.i54.i1404.i = xor i64 %shifted.i.i.i53.i1403.i, %product.i.i.i52.i1402.i
  %hash.i.i.i55.i1405.i = and i64 %xored.i.i.i54.i1404.i, %tbl_size.i.i50.i1400.i
  %offset_ptr.i.i56.i1406.i = getelementptr i32, ptr %offset_tbl.i.i51.i1401.i, i64 %hash.i.i.i55.i1405.i
  %offset.i.i57.i1407.i = load i32, ptr %offset_ptr.i.i56.i1406.i, align 4
  %866 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %867 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1408.i = icmp eq i32 %864, 100
  br i1 %exitcond.not.i1408.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417.i, label %831

868:                                              ; preds = %831
  %869 = load i32, ptr %97, align 4
  %870 = add i32 %869, 1
  %871 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %870, ptr %97, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417.i: ; preds = %868, %.cont.i1395.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %44)
  br label %._crit_edge.i931.i

._crit_edge.i931.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1417.i, %817
  %indvars.iv.next.i932.i = add nuw nsw i64 %indvars.iv.i929.i, 1
  %exitcond.not.i933.i = icmp eq i64 %indvars.iv.next.i932.i, %wide.trip.count.i890.i
  br i1 %exitcond.not.i933.i, label %CuckooMap_insert_keyK_valueV.exit.i, label %817

CuckooMap_insert_keyK_valueV.exit.i:              ; preds = %._crit_edge.i931.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit913.thread.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit487.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit354.i, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %exitcond.not.i = icmp eq i32 %103, 1000000
  br i1 %exitcond.not.i, label %._crit_edge2.i, label %._crit_edge.i

._crit_edge2.i:                                   ; preds = %CuckooMap_insert_keyK_valueV.exit.i
  %872 = call i64 @clock()
  %873 = load ptr, ptr %91, align 8
  %874 = call i32 %873({ ptr, i160 } { ptr @i32_typ, i160 999999 }) #53
  %875 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %876 = load i32, ptr %93, align 8
  %877 = add i32 %876, -1
  %878 = and i32 %877, %874
  %879 = load ptr, ptr %94, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %880 = sext i32 %878 to i64
  %881 = shl nsw i64 %880, 5
  %882 = getelementptr i8, ptr %879, i64 %881
  %883 = load ptr, ptr %882, align 8
  %884 = icmp ne ptr %883, @nil_typ
  %885 = icmp ne ptr %883, null
  %.not45.i.i = and i1 %884, %885
  br i1 %.not45.i.i, label %886, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i

886:                                              ; preds = %._crit_edge2.i
  %887 = getelementptr i8, ptr %882, i64 8
  %888 = load i64, ptr %887, align 4
  %.sroa_idx.i552.i = getelementptr i8, ptr %882, i64 16
  %889 = load i64, ptr %.sroa_idx.i552.i, align 4
  %890 = inttoptr i64 %888 to ptr
  %891 = inttoptr i64 %889 to ptr
  %hash_coef_ptr.i.i4.i.i = getelementptr i8, ptr %883, i64 8
  %tbl_size_ptr.i.i5.i.i = getelementptr i8, ptr %883, i64 16
  %offset_tbl_ptr.i.i6.i.i = getelementptr i8, ptr %883, i64 40
  %hash_coef.i.i7.i.i = load i64, ptr %hash_coef_ptr.i.i4.i.i, align 4, !noalias !440
  %tbl_size.i.i8.i.i = load i64, ptr %tbl_size_ptr.i.i5.i.i, align 4, !noalias !440
  %offset_tbl.i.i9.i.i = load ptr, ptr %offset_tbl_ptr.i.i6.i.i, align 8, !noalias !440
  %product.i.i.i10.i.i = mul i64 %hash_coef.i.i7.i.i, 4015701072841558310
  %shifted.i.i.i11.i.i = lshr i64 %product.i.i.i10.i.i, 32
  %xored.i.i.i12.i.i = xor i64 %shifted.i.i.i11.i.i, %product.i.i.i10.i.i
  %hash.i.i.i13.i.i = and i64 %xored.i.i.i12.i.i, %tbl_size.i.i8.i.i
  %offset_ptr.i.i14.i.i = getelementptr i32, ptr %offset_tbl.i.i9.i.i, i64 %hash.i.i.i13.i.i
  %offset.i.i15.i.i = load i32, ptr %offset_ptr.i.i14.i.i, align 4, !noalias !440
  %892 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %883, 0
  %893 = insertvalue { ptr, ptr, ptr, i32 } %892, ptr %890, 1
  %894 = insertvalue { ptr, ptr, ptr, i32 } %893, ptr %891, 2
  %895 = insertvalue { ptr, ptr, ptr, i32 } %894, i32 %offset.i.i15.i.i, 3
  %896 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %897 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %883) #40
  %898 = sext i32 %offset.i.i15.i.i to i64
  %899 = getelementptr ptr, ptr %883, i64 %898
  %900 = getelementptr i8, ptr %899, i64 64
  %901 = load ptr, ptr %900, align 8
  %result.i2.i553.i = call ptr %901({ ptr, ptr, ptr, i32 } %895, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %902 = call i32 %result.i2.i553.i({ ptr, ptr, ptr, i32 } %895, { ptr, ptr, ptr, i32 } %895, ptr nonnull align 8 %0) #53
  %903 = icmp eq i32 %902, %874
  br i1 %903, label %._crit_edge.i554.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i

._crit_edge.i554.i:                               ; preds = %886
  %904 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %905 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %883)
  %906 = getelementptr i8, ptr %899, i64 48
  %907 = load ptr, ptr %906, align 8
  %result.i1.i555.i = call ptr %907({ ptr, ptr, ptr, i32 } %895, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %908 = call { ptr, i160 } %result.i1.i555.i({ ptr, ptr, ptr, i32 } %895, { ptr, ptr, ptr, i32 } %895, ptr nonnull align 8 %0) #53
  %909 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %910 = load ptr, ptr %92, align 8
  %911 = call i1 %910({ ptr, i160 } %908, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #53
  br i1 %911, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i: ; preds = %._crit_edge.i554.i, %886, %._crit_edge2.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %919

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i: ; preds = %._crit_edge.i554.i
  %912 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %913 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %883)
  %914 = getelementptr i8, ptr %899, i64 56
  %915 = load ptr, ptr %914, align 8
  %result.i.i556.i = call ptr %915({ ptr, ptr, ptr, i32 } %895, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %916 = call { ptr, i160 } %result.i.i556.i({ ptr, ptr, ptr, i32 } %895, { ptr, ptr, ptr, i32 } %895, ptr nonnull align 8 %0) #53
  %.fca.0.extract22.i.i = extractvalue { ptr, i160 } %916, 0
  %.fca.1.extract23.i.i = extractvalue { ptr, i160 } %916, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %917 = icmp ne ptr %.fca.0.extract22.i.i, @nil_typ
  %918 = icmp ne ptr %.fca.0.extract22.i.i, null
  %.not63.i.i = and i1 %917, %918
  %extract.t643.i = trunc i160 %.fca.1.extract23.i.i to i32
  br i1 %.not63.i.i, label %CuckooMap_get_keyK.exit.i, label %919

919:                                              ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i
  %920 = add i32 %874, 2127912214
  %921 = shl i32 %874, 12
  %922 = add i32 %920, %921
  %923 = ashr i32 %922, 19
  %924 = xor i32 %922, %923
  %925 = xor i32 %924, -949894596
  %926 = add i32 %925, 374761393
  %927 = shl i32 %925, 5
  %928 = add i32 %926, %927
  %929 = add i32 %928, -744332180
  %930 = shl i32 %928, 9
  %931 = xor i32 %929, %930
  %932 = add i32 %931, -42973499
  %933 = shl i32 %931, 3
  %934 = add i32 %932, %933
  %935 = ashr i32 %934, 16
  %936 = xor i32 %934, %935
  %937 = xor i32 %936, -1252372727
  %938 = load i32, ptr %93, align 8
  %939 = add i32 %938, -1
  %940 = and i32 %939, %937
  %941 = load ptr, ptr %95, align 8
  %942 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %943 = sext i32 %940 to i64
  %944 = shl nsw i64 %943, 5
  %945 = getelementptr i8, ptr %941, i64 %944
  %946 = load ptr, ptr %945, align 8
  %947 = icmp ne ptr %946, @nil_typ
  %948 = icmp ne ptr %946, null
  %.not45.i587.i = and i1 %947, %948
  br i1 %.not45.i587.i, label %949, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i

949:                                              ; preds = %919
  %950 = getelementptr i8, ptr %945, i64 8
  %951 = load i64, ptr %950, align 4
  %.sroa_idx.i592.i = getelementptr i8, ptr %945, i64 16
  %952 = load i64, ptr %.sroa_idx.i592.i, align 4
  %953 = inttoptr i64 %951 to ptr
  %954 = inttoptr i64 %952 to ptr
  %hash_coef_ptr.i.i4.i593.i = getelementptr i8, ptr %946, i64 8
  %tbl_size_ptr.i.i5.i594.i = getelementptr i8, ptr %946, i64 16
  %offset_tbl_ptr.i.i6.i595.i = getelementptr i8, ptr %946, i64 40
  %hash_coef.i.i7.i596.i = load i64, ptr %hash_coef_ptr.i.i4.i593.i, align 4, !noalias !443
  %tbl_size.i.i8.i597.i = load i64, ptr %tbl_size_ptr.i.i5.i594.i, align 4, !noalias !443
  %offset_tbl.i.i9.i598.i = load ptr, ptr %offset_tbl_ptr.i.i6.i595.i, align 8, !noalias !443
  %product.i.i.i10.i599.i = mul i64 %hash_coef.i.i7.i596.i, 4015701072841558310
  %shifted.i.i.i11.i600.i = lshr i64 %product.i.i.i10.i599.i, 32
  %xored.i.i.i12.i601.i = xor i64 %shifted.i.i.i11.i600.i, %product.i.i.i10.i599.i
  %hash.i.i.i13.i602.i = and i64 %xored.i.i.i12.i601.i, %tbl_size.i.i8.i597.i
  %offset_ptr.i.i14.i603.i = getelementptr i32, ptr %offset_tbl.i.i9.i598.i, i64 %hash.i.i.i13.i602.i
  %offset.i.i15.i604.i = load i32, ptr %offset_ptr.i.i14.i603.i, align 4, !noalias !443
  %955 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %946, 0
  %956 = insertvalue { ptr, ptr, ptr, i32 } %955, ptr %953, 1
  %957 = insertvalue { ptr, ptr, ptr, i32 } %956, ptr %954, 2
  %958 = insertvalue { ptr, ptr, ptr, i32 } %957, i32 %offset.i.i15.i604.i, 3
  %959 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %960 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %946) #40
  %961 = sext i32 %offset.i.i15.i604.i to i64
  %962 = getelementptr ptr, ptr %946, i64 %961
  %963 = getelementptr i8, ptr %962, i64 64
  %964 = load ptr, ptr %963, align 8
  %result.i2.i605.i = call ptr %964({ ptr, ptr, ptr, i32 } %958, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %965 = call i32 %result.i2.i605.i({ ptr, ptr, ptr, i32 } %958, { ptr, ptr, ptr, i32 } %958, ptr nonnull align 8 %0) #53
  %966 = icmp eq i32 %965, %874
  br i1 %966, label %._crit_edge.i606.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i

._crit_edge.i606.i:                               ; preds = %949
  %967 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %968 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %946)
  %969 = getelementptr i8, ptr %962, i64 48
  %970 = load ptr, ptr %969, align 8
  %result.i1.i607.i = call ptr %970({ ptr, ptr, ptr, i32 } %958, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %971 = call { ptr, i160 } %result.i1.i607.i({ ptr, ptr, ptr, i32 } %958, { ptr, ptr, ptr, i32 } %958, ptr nonnull align 8 %0) #53
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %973 = load ptr, ptr %92, align 8
  %974 = call i1 %973({ ptr, i160 } %971, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #53
  br i1 %974, label %975, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i

975:                                              ; preds = %._crit_edge.i606.i
  %976 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %946)
  %978 = getelementptr i8, ptr %962, i64 56
  %979 = load ptr, ptr %978, align 8
  %result.i.i609.i = call ptr %979({ ptr, ptr, ptr, i32 } %958, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %980 = call { ptr, i160 } %result.i.i609.i({ ptr, ptr, ptr, i32 } %958, { ptr, ptr, ptr, i32 } %958, ptr nonnull align 8 %0) #53
  %.fca.0.extract22.i610.i = extractvalue { ptr, i160 } %980, 0
  %.fca.1.extract23.i611.i = extractvalue { ptr, i160 } %980, 1
  %981 = trunc i160 %.fca.1.extract23.i611.i to i32
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i: ; preds = %975, %._crit_edge.i606.i, %949, %919
  %.reg2mem43.sroa.3.0.i588.i = phi i32 [ %981, %975 ], [ poison, %._crit_edge.i606.i ], [ poison, %919 ], [ poison, %949 ]
  %.reg2mem41.0.i589.i = phi ptr [ %.fca.0.extract22.i610.i, %975 ], [ @nil_typ, %._crit_edge.i606.i ], [ @nil_typ, %919 ], [ @nil_typ, %949 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %.not.i117.i = icmp eq ptr %.reg2mem41.0.i589.i, null
  %982 = select i1 %.not.i117.i, ptr @nil_typ, ptr %.reg2mem41.0.i589.i
  br label %CuckooMap_get_keyK.exit.i

CuckooMap_get_keyK.exit.i:                        ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i
  %.not63.i642.off0.i = phi i32 [ %.reg2mem43.sroa.3.0.i588.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i ], [ %extract.t643.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i ]
  %.reg2mem56.0.i.i = phi ptr [ %982, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit612.i ], [ %.fca.0.extract22.i.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i ]
  %983 = icmp ne ptr %.reg2mem56.0.i.i, @nil_typ
  %984 = icmp ne ptr %.reg2mem56.0.i.i, null
  %.not150.i = and i1 %983, %984
  br i1 %.not150.i, label %._crit_edge3.i, label %benchmark_insert_sequential.exit

._crit_edge3.i:                                   ; preds = %CuckooMap_get_keyK.exit.i
  %.not154.i = icmp eq i32 %.not63.i642.off0.i, 1000000
  br label %benchmark_insert_sequential.exit

benchmark_insert_sequential.exit:                 ; preds = %._crit_edge3.i, %CuckooMap_get_keyK.exit.i
  %.3.i = phi i1 [ %.not154.i, %._crit_edge3.i ], [ false, %CuckooMap_get_keyK.exit.i ]
  %985 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %987 = load i32, ptr %97, align 4
  %.not155.i = icmp eq i32 %987, 1000000
  %988 = select i1 %.not155.i, i1 %.3.i, i1 false
  %result.i28.i = call noalias nonnull dereferenceable(18) ptr @bump_malloc_wrapper(i64 noundef 18) #48
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i28.i, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %989 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i672.i = call noalias nonnull dereferenceable(18) ptr @bump_malloc_wrapper(i64 noundef 18) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(18) %result.i.i672.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(18) %result.i28.i, i64 noundef 17, i1 noundef false)
  %991 = sub i64 %872, %98
  %992 = getelementptr inbounds i8, ptr %result.i.i672.i, i64 17
  store i8 0, ptr %992, align 1
  %puts.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(18) %result.i.i672.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %result.i28.i.i = call noalias nonnull dereferenceable(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i28.i.i, align 1
  %result.i.i.i.i = call noalias nonnull dereferenceable(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(15) %result.i.i.i.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(15) %result.i28.i.i, i64 noundef 14, i1 noundef false)
  %993 = getelementptr inbounds i8, ptr %result.i.i.i.i, i64 14
  store i8 0, ptr %993, align 1
  %puts.i.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.i) #53
  %994 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 noundef 1000000) #55
  %result.i26.i.i = call noalias nonnull dereferenceable(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i26.i.i, align 1
  %result.i.i304.i.i = call noalias nonnull dereferenceable(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(15) %result.i.i304.i.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(15) %result.i26.i.i, i64 noundef 14, i1 noundef false)
  %995 = getelementptr inbounds i8, ptr %result.i.i304.i.i, i64 14
  store i8 0, ptr %995, align 1
  %puts.i229.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.i) #53
  %996 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %991) #55
  %result.i24.i.i = call noalias nonnull dereferenceable(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i24.i.i, align 1
  %result.i.i324.i.i = call noalias nonnull dereferenceable(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(4) %result.i.i324.i.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(4) %result.i24.i.i, i64 noundef 3, i1 noundef false)
  %997 = getelementptr inbounds i8, ptr %result.i.i324.i.i, i64 3
  store i8 0, ptr %997, align 1
  %puts.i249.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.i) #53
  %result.i22.i.i = call noalias nonnull dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i22.i.i, align 1
  %result.i.i344.i.i = call noalias nonnull dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(16) %result.i.i344.i.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(16) %result.i22.i.i, i64 noundef 15, i1 noundef false)
  %998 = mul i64 %991, 1000000
  %999 = sdiv i64 %998, 1000000
  %1000 = getelementptr inbounds i8, ptr %result.i.i344.i.i, i64 15
  store i8 0, ptr %1000, align 1
  %puts.i269.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.i) #53
  %1001 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %999) #55
  %result.i20.i.i = call noalias nonnull dereferenceable(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i20.i.i, align 1
  %result.i.i364.i.i = call noalias nonnull dereferenceable(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(4) %result.i.i364.i.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(4) %result.i20.i.i, i64 noundef 3, i1 noundef false)
  %1002 = getelementptr inbounds i8, ptr %result.i.i364.i.i, i64 3
  store i8 0, ptr %1002, align 1
  %puts.i289.i.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.i) #53
  %result.i26.i = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #48
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i26.i, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1003 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1004 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i687.i = call noalias nonnull dereferenceable(19) ptr @bump_malloc_wrapper(i64 noundef 19) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture nofree noundef nonnull writeonly align 1 dereferenceable(19) %result.i.i687.i, ptr noalias nocapture nofree noundef nonnull readonly align 1 dereferenceable(19) %result.i26.i, i64 noundef 18, i1 noundef false)
  %1005 = getelementptr inbounds i8, ptr %result.i.i687.i, i64 18
  store i8 0, ptr %1005, align 1
  %puts.i229.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i687.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %..i = select i1 %988, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.191.i = select i1 %988, ptr %73, ptr %77
  %.192.i = select i1 %988, ptr %74, ptr %78
  %.193.i = select i1 %988, ptr %75, ptr %79
  %.194.i = select i1 %988, ptr %76, ptr %80
  store ptr @_parameterization_Bufferi8, ptr %.191.i, align 8
  %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %988, ptr %73, ptr %77
  %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.191.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %988, ptr %73, ptr %77
  %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.191.sroa.sel203.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1006 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.191.i)
  store ptr @buffer_typ, ptr %.192.i, align 8
  %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %988, ptr %74, ptr %78
  %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.192.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %988, ptr %74, ptr %78
  %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.192.sroa.sel198.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1007 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.192.i) #40
  store ptr @_parameterization_String, ptr %.193.i, align 8
  %1008 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.193.i)
  %1009 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %.194.i, align 8
  %1010 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.194.i) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1011 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1012 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i707.i = call noalias nonnull dereferenceable(5) ptr @bump_malloc_wrapper(i64 noundef 5) #48
  store <4 x i8> %..i, ptr %result.i.i707.i, align 1
  %1013 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1014 = getelementptr inbounds i8, ptr %result.i.i707.i, i64 4
  store i8 0, ptr %1014, align 1
  %puts.i250.i = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i707.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %73)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %74)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %75)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %76)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %77)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %78)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %79)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(8) %80)
  call void @benchmark_insert_random(i32 noundef 1000000)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %33)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %37)
  call void @llvm.lifetime.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %38)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  %result.i35.i = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_wrapper(i64 noundef 64) #48
  store ptr @_parameterization_i32, ptr %result.i35.i, align 8
  %1015 = getelementptr inbounds i8, ptr %result.i35.i, i64 8
  store ptr @_parameterization_i32, ptr %1015, align 8
  %1016 = getelementptr inbounds i8, ptr %result.i35.i, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %1016, align 8
  %1017 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(64) %result.i35.i) #56
  %result.i34.i11 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i10)
  %result.i36.i = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i34.i11, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i10) #53
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i10)
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i34.i11, ptr noalias nofree noundef nonnull readnone @drgmnjsbrc, ptr noalias nofree noundef nonnull readnone @i32_hasher) #56
  %ret.i24.i = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i34.i11) #47
  %1018 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i34.i11) #56
  %result.i33.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  call void @llvm.lifetime.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i37.i)
  %result.i38.i = call i32 @VirtualProtect(ptr nofree noundef dereferenceable_or_null(24) %result.i33.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i37.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i37.i)
  call void @llvm.init.trampoline(ptr nocapture nofree noundef writeonly dereferenceable_or_null(24) %result.i33.i, ptr noalias nofree noundef nonnull readnone @uvhofywczn, ptr noalias nofree noundef nonnull readnone @i32_eq) #56
  %ret.i.i12 = call ptr @llvm.adjust.trampoline(ptr nofree noundef readonly dereferenceable_or_null(24) %result.i33.i) #47
  %1019 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef dereferenceable_or_null(24) %result.i33.i) #56
  %1020 = getelementptr inbounds i8, ptr %result.i35.i, i64 48
  store ptr %ret.i24.i, ptr %1020, align 8
  %1021 = getelementptr inbounds i8, ptr %result.i35.i, i64 56
  store ptr %ret.i.i12, ptr %1021, align 8
  %1022 = getelementptr inbounds i8, ptr %result.i35.i, i64 40
  store i32 8, ptr %1022, align 8
  %result.i1.i.i13 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %1023 = getelementptr inbounds i8, ptr %result.i35.i, i64 24
  store ptr %result.i1.i.i13, ptr %1023, align 8
  %result.i.i.i14 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %1024 = getelementptr inbounds i8, ptr %result.i35.i, i64 32
  store ptr %result.i.i.i14, ptr %1024, align 8
  %1025 = getelementptr inbounds i8, ptr %result.i35.i, i64 44
  store i32 0, ptr %1025, align 4
  %1026 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i35.i, 1
  %1027 = insertvalue { ptr, ptr, ptr, i32 } %1026, ptr undef, 2
  %1028 = insertvalue { ptr, ptr, ptr, i32 } %1027, i32 10, 3
  %1029 = insertvalue { ptr, ptr, ptr, i32 } %1026, i32 10, 3
  br label %._crit_edge.i15

._crit_edge.i15:                                  ; preds = %CuckooMap_insert_keyK_valueV.exit.i42, %benchmark_insert_sequential.exit
  %indvars.iv.i = phi i64 [ 0, %benchmark_insert_sequential.exit ], [ %indvars.iv.next.i, %CuckooMap_insert_keyK_valueV.exit.i42 ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %.sroa.0142.0.insert.ext.i = zext nneg i64 %indvars.iv.i to i160
  %1030 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0142.0.insert.ext.i, 1
  %.sroa.0139.0.insert.ext.i = zext nneg i64 %indvars.iv.next.i to i160
  %1031 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0139.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1032 = load ptr, ptr %1020, align 8
  %1033 = call i32 %1032({ ptr, i160 } %1030) #53
  %1034 = load i32, ptr %1022, align 8
  %1035 = add i32 %1034, -1
  %1036 = and i32 %1035, %1033
  %1037 = load ptr, ptr %1023, align 8
  %1038 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1039 = sext i32 %1036 to i64
  %1040 = shl nsw i64 %1039, 5
  %1041 = getelementptr i8, ptr %1037, i64 %1040
  %1042 = load ptr, ptr %1041, align 8
  %1043 = getelementptr i8, ptr %1041, i64 8
  %1044 = icmp ne ptr %1042, @nil_typ
  %1045 = icmp ne ptr %1042, null
  %.not66.i.i16 = and i1 %1044, %1045
  br i1 %.not66.i.i16, label %1046, label %1144

1046:                                             ; preds = %._crit_edge.i15
  %1047 = load i64, ptr %1043, align 4
  %.sroa_idx.i.i120 = getelementptr i8, ptr %1041, i64 16
  %1048 = load i64, ptr %.sroa_idx.i.i120, align 4
  %1049 = inttoptr i64 %1047 to ptr
  %1050 = inttoptr i64 %1048 to ptr
  %hash_coef_ptr.i.i11.i.i121 = getelementptr i8, ptr %1042, i64 8
  %tbl_size_ptr.i.i12.i.i122 = getelementptr i8, ptr %1042, i64 16
  %offset_tbl_ptr.i.i13.i.i123 = getelementptr i8, ptr %1042, i64 40
  %hash_coef.i.i14.i.i124 = load i64, ptr %hash_coef_ptr.i.i11.i.i121, align 4, !noalias !446
  %tbl_size.i.i15.i.i125 = load i64, ptr %tbl_size_ptr.i.i12.i.i122, align 4, !noalias !446
  %offset_tbl.i.i16.i.i126 = load ptr, ptr %offset_tbl_ptr.i.i13.i.i123, align 8, !noalias !446
  %product.i.i.i17.i.i127 = mul i64 %hash_coef.i.i14.i.i124, 4015701072841558310
  %shifted.i.i.i18.i.i128 = lshr i64 %product.i.i.i17.i.i127, 32
  %xored.i.i.i19.i.i129 = xor i64 %shifted.i.i.i18.i.i128, %product.i.i.i17.i.i127
  %hash.i.i.i20.i.i130 = and i64 %xored.i.i.i19.i.i129, %tbl_size.i.i15.i.i125
  %offset_ptr.i.i21.i.i131 = getelementptr i32, ptr %offset_tbl.i.i16.i.i126, i64 %hash.i.i.i20.i.i130
  %offset.i.i22.i.i132 = load i32, ptr %offset_ptr.i.i21.i.i131, align 4, !noalias !446
  %1051 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1042, 0
  %1052 = insertvalue { ptr, ptr, ptr, i32 } %1051, ptr %1049, 1
  %1053 = insertvalue { ptr, ptr, ptr, i32 } %1052, ptr %1050, 2
  %1054 = insertvalue { ptr, ptr, ptr, i32 } %1053, i32 %offset.i.i22.i.i132, 3
  %1055 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1056 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1042) #40
  %1057 = sext i32 %offset.i.i22.i.i132 to i64
  %1058 = getelementptr ptr, ptr %1042, i64 %1057
  %1059 = getelementptr i8, ptr %1058, i64 64
  %1060 = load ptr, ptr %1059, align 8
  %result.i8.i.i133 = call ptr %1060({ ptr, ptr, ptr, i32 } %1054, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1061 = call i32 %result.i8.i.i133({ ptr, ptr, ptr, i32 } %1054, { ptr, ptr, ptr, i32 } %1054, ptr nonnull align 8 %0) #53
  %1062 = icmp eq i32 %1061, %1033
  br i1 %1062, label %._crit_edge.i364.i, label %1144

._crit_edge.i364.i:                               ; preds = %1046
  %1063 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1064 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1042)
  %1065 = getelementptr i8, ptr %1058, i64 48
  %1066 = load ptr, ptr %1065, align 8
  %result.i7.i.i134 = call ptr %1066({ ptr, ptr, ptr, i32 } %1054, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1067 = call { ptr, i160 } %result.i7.i.i134({ ptr, ptr, ptr, i32 } %1054, { ptr, ptr, ptr, i32 } %1054, ptr nonnull align 8 %0) #53
  %1068 = load ptr, ptr %1021, align 8
  %1069 = call i1 %1068({ ptr, i160 } %1067, { ptr, i160 } %1030) #53
  br i1 %1069, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i135, label %1144

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i135: ; preds = %._crit_edge.i364.i
  %1070 = load ptr, ptr %result.i35.i, align 8
  %1071 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1072 = load ptr, ptr %1015, align 8
  %1073 = load ptr, ptr %1070, align 8, !alias.scope !449
  %1074 = getelementptr i8, ptr %1073, i64 72
  %1075 = load ptr, ptr %1074, align 8, !alias.scope !449
  %result.i1.i.i.i136 = call { i64, i64 } %1075(ptr nocapture nofree nonnull readonly align 8 %1070) #44, !alias.scope !449
  %1076 = extractvalue { i64, i64 } %result.i1.i.i.i136, 0
  %1077 = extractvalue { i64, i64 } %result.i1.i.i.i136, 1
  %1078 = urem i64 20, %1077
  %1079 = icmp eq i64 %1078, 0
  %1080 = sub i64 %1077, %1078
  %1081 = select i1 %1079, i64 0, i64 %1080
  %1082 = add i64 %1076, 20
  %1083 = add i64 %1082, %1081
  %1084 = load ptr, ptr %1072, align 8, !alias.scope !449
  %1085 = getelementptr i8, ptr %1084, i64 72
  %1086 = load ptr, ptr %1085, align 8, !alias.scope !449
  %result.i.i.i365.i = call { i64, i64 } %1086(ptr nocapture nofree nonnull readonly align 8 %1072) #44, !alias.scope !449
  %1087 = extractvalue { i64, i64 } %result.i.i.i365.i, 0
  %1088 = extractvalue { i64, i64 } %result.i.i.i365.i, 1
  %1089 = call i64 @llvm.umax.i64(i64 %1077, i64 %1088) #41
  %1090 = call i64 @llvm.umax.i64(i64 %1089, i64 noundef 8) #41, !range !16
  %1091 = urem i64 %1083, %1088
  %1092 = icmp eq i64 %1091, 0
  %1093 = sub i64 %1088, %1091
  %1094 = select i1 %1092, i64 0, i64 %1093
  %1095 = add i64 %1087, %1083
  %1096 = add i64 %1095, %1094
  %1097 = urem i64 %1096, %1090
  %1098 = icmp eq i64 %1097, 0
  %1099 = sub i64 %1090, %1097
  %1100 = select i1 %1098, i64 0, i64 %1099
  %1101 = add i64 %1100, %1096
  %result.i9.i.i137 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %1101) #48
  store ptr %1070, ptr %result.i9.i.i137, align 8
  %1102 = getelementptr inbounds i8, ptr %result.i9.i.i137, i64 8
  store ptr %1072, ptr %1102, align 8
  %1103 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i.i137)
  %1104 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1105 = load ptr, ptr %1070, align 8
  %1106 = getelementptr i8, ptr %1105, i64 72
  %1107 = load ptr, ptr %1106, align 8
  %result.i.i38.i.i138 = call { i64, i64 } %1107(ptr nocapture nofree nonnull readonly align 8 %1070) #44
  %1108 = extractvalue { i64, i64 } %result.i.i38.i.i138, 1
  %1109 = urem i64 20, %1108
  %1110 = icmp eq i64 %1109, 0
  %reass.sub866 = sub i64 %1108, %1109
  %1111 = add i64 %reass.sub866, 20
  %1112 = select i1 %1110, i64 20, i64 %1111
  %1113 = getelementptr i8, ptr %result.i9.i.i137, i64 %1112
  %1114 = getelementptr i8, ptr %1105, i64 64
  %1115 = load ptr, ptr %1114, align 8
  call void %1115({ ptr, i160 } %1030, ptr nocapture nofree nonnull readonly align 8 %1070, ptr nocapture nofree writeonly %1113) #45
  %1116 = load ptr, ptr %result.i9.i.i137, align 8
  %1117 = load ptr, ptr %1116, align 8
  %1118 = getelementptr i8, ptr %1117, i64 72
  %1119 = load ptr, ptr %1118, align 8
  %result.i1.i39.i.i139 = call { i64, i64 } %1119(ptr nocapture nofree nonnull readonly align 8 %1116) #44
  %1120 = extractvalue { i64, i64 } %result.i1.i39.i.i139, 0
  %1121 = extractvalue { i64, i64 } %result.i1.i39.i.i139, 1
  %1122 = urem i64 20, %1121
  %1123 = icmp eq i64 %1122, 0
  %1124 = sub i64 %1121, %1122
  %1125 = select i1 %1123, i64 0, i64 %1124
  %1126 = add i64 %1120, 20
  %1127 = add i64 %1126, %1125
  %1128 = load ptr, ptr %1102, align 8
  %1129 = load ptr, ptr %1128, align 8
  %1130 = getelementptr i8, ptr %1129, i64 72
  %1131 = load ptr, ptr %1130, align 8
  %result.i.i40.i.i140 = call { i64, i64 } %1131(ptr nocapture nofree nonnull readonly align 8 %1128) #44
  %1132 = extractvalue { i64, i64 } %result.i.i40.i.i140, 1
  %1133 = urem i64 %1127, %1132
  %1134 = icmp eq i64 %1133, 0
  %1135 = sub i64 %1132, %1133
  %1136 = select i1 %1134, i64 0, i64 %1135
  %1137 = getelementptr i8, ptr %result.i9.i.i137, i64 %1127
  %1138 = getelementptr i8, ptr %1137, i64 %1136
  %1139 = getelementptr i8, ptr %1129, i64 64
  %1140 = load ptr, ptr %1139, align 8
  call void %1140({ ptr, i160 } %1031, ptr nocapture nofree nonnull readonly align 8 %1128, ptr nocapture nofree writeonly %1138) #45
  %1141 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1142 = getelementptr inbounds i8, ptr %result.i9.i.i137, i64 16
  store i32 %1033, ptr %1142, align 8
  store ptr @Entry, ptr %1041, align 8
  %1143 = ptrtoint ptr %result.i9.i.i137 to i64
  store i64 %1143, ptr %1043, align 4
  %.sroa_idx30.i.i141 = getelementptr i8, ptr %1041, i64 24
  store i32 10, ptr %.sroa_idx30.i.i141, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i42

1144:                                             ; preds = %._crit_edge.i364.i, %1046, %._crit_edge.i15
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1145 = add i32 %1033, 2127912214
  %1146 = shl i32 %1033, 12
  %1147 = add i32 %1145, %1146
  %1148 = ashr i32 %1147, 19
  %1149 = xor i32 %1147, %1148
  %1150 = xor i32 %1149, -949894596
  %1151 = add i32 %1150, 374761393
  %1152 = shl i32 %1150, 5
  %1153 = add i32 %1151, %1152
  %1154 = add i32 %1153, -744332180
  %1155 = shl i32 %1153, 9
  %1156 = xor i32 %1154, %1155
  %1157 = add i32 %1156, -42973499
  %1158 = shl i32 %1156, 3
  %1159 = add i32 %1157, %1158
  %1160 = ashr i32 %1159, 16
  %1161 = xor i32 %1159, %1160
  %1162 = xor i32 %1161, -1252372727
  %1163 = load i32, ptr %1022, align 8
  %1164 = add i32 %1163, -1
  %1165 = and i32 %1164, %1162
  %1166 = load ptr, ptr %1024, align 8
  %1167 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1168 = sext i32 %1165 to i64
  %1169 = shl nsw i64 %1168, 5
  %1170 = getelementptr i8, ptr %1166, i64 %1169
  %1171 = load ptr, ptr %1170, align 8
  %1172 = getelementptr i8, ptr %1170, i64 8
  %1173 = icmp ne ptr %1171, @nil_typ
  %1174 = icmp ne ptr %1171, null
  %.not66.i395.i = and i1 %1173, %1174
  br i1 %.not66.i395.i, label %1175, label %1273

1175:                                             ; preds = %1144
  %1176 = load i64, ptr %1172, align 4
  %.sroa_idx.i397.i = getelementptr i8, ptr %1170, i64 16
  %1177 = load i64, ptr %.sroa_idx.i397.i, align 4
  %1178 = inttoptr i64 %1176 to ptr
  %1179 = inttoptr i64 %1177 to ptr
  %hash_coef_ptr.i.i11.i398.i = getelementptr i8, ptr %1171, i64 8
  %tbl_size_ptr.i.i12.i399.i = getelementptr i8, ptr %1171, i64 16
  %offset_tbl_ptr.i.i13.i400.i = getelementptr i8, ptr %1171, i64 40
  %hash_coef.i.i14.i401.i = load i64, ptr %hash_coef_ptr.i.i11.i398.i, align 4, !noalias !452
  %tbl_size.i.i15.i402.i = load i64, ptr %tbl_size_ptr.i.i12.i399.i, align 4, !noalias !452
  %offset_tbl.i.i16.i403.i = load ptr, ptr %offset_tbl_ptr.i.i13.i400.i, align 8, !noalias !452
  %product.i.i.i17.i404.i = mul i64 %hash_coef.i.i14.i401.i, 4015701072841558310
  %shifted.i.i.i18.i405.i = lshr i64 %product.i.i.i17.i404.i, 32
  %xored.i.i.i19.i406.i = xor i64 %shifted.i.i.i18.i405.i, %product.i.i.i17.i404.i
  %hash.i.i.i20.i407.i = and i64 %xored.i.i.i19.i406.i, %tbl_size.i.i15.i402.i
  %offset_ptr.i.i21.i408.i = getelementptr i32, ptr %offset_tbl.i.i16.i403.i, i64 %hash.i.i.i20.i407.i
  %offset.i.i22.i409.i = load i32, ptr %offset_ptr.i.i21.i408.i, align 4, !noalias !452
  %1180 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1171, 0
  %1181 = insertvalue { ptr, ptr, ptr, i32 } %1180, ptr %1178, 1
  %1182 = insertvalue { ptr, ptr, ptr, i32 } %1181, ptr %1179, 2
  %1183 = insertvalue { ptr, ptr, ptr, i32 } %1182, i32 %offset.i.i22.i409.i, 3
  %1184 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1185 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1171) #40
  %1186 = sext i32 %offset.i.i22.i409.i to i64
  %1187 = getelementptr ptr, ptr %1171, i64 %1186
  %1188 = getelementptr i8, ptr %1187, i64 64
  %1189 = load ptr, ptr %1188, align 8
  %result.i8.i410.i = call ptr %1189({ ptr, ptr, ptr, i32 } %1183, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1190 = call i32 %result.i8.i410.i({ ptr, ptr, ptr, i32 } %1183, { ptr, ptr, ptr, i32 } %1183, ptr nonnull align 8 %0) #53
  %1191 = icmp eq i32 %1190, %1033
  br i1 %1191, label %._crit_edge.i411.i, label %1273

._crit_edge.i411.i:                               ; preds = %1175
  %1192 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1193 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1171)
  %1194 = getelementptr i8, ptr %1187, i64 48
  %1195 = load ptr, ptr %1194, align 8
  %result.i7.i412.i = call ptr %1195({ ptr, ptr, ptr, i32 } %1183, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1196 = call { ptr, i160 } %result.i7.i412.i({ ptr, ptr, ptr, i32 } %1183, { ptr, ptr, ptr, i32 } %1183, ptr nonnull align 8 %0) #53
  %1197 = load ptr, ptr %1021, align 8
  %1198 = call i1 %1197({ ptr, i160 } %1196, { ptr, i160 } %1030) #53
  br i1 %1198, label %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit424.i, label %1273

CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit424.i: ; preds = %._crit_edge.i411.i
  %1199 = load ptr, ptr %result.i35.i, align 8
  %1200 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1201 = load ptr, ptr %1015, align 8
  %1202 = load ptr, ptr %1199, align 8, !alias.scope !455
  %1203 = getelementptr i8, ptr %1202, i64 72
  %1204 = load ptr, ptr %1203, align 8, !alias.scope !455
  %result.i1.i.i416.i = call { i64, i64 } %1204(ptr nocapture nofree nonnull readonly align 8 %1199) #44, !alias.scope !455
  %1205 = extractvalue { i64, i64 } %result.i1.i.i416.i, 0
  %1206 = extractvalue { i64, i64 } %result.i1.i.i416.i, 1
  %1207 = urem i64 20, %1206
  %1208 = icmp eq i64 %1207, 0
  %1209 = sub i64 %1206, %1207
  %1210 = select i1 %1208, i64 0, i64 %1209
  %1211 = add i64 %1205, 20
  %1212 = add i64 %1211, %1210
  %1213 = load ptr, ptr %1201, align 8, !alias.scope !455
  %1214 = getelementptr i8, ptr %1213, i64 72
  %1215 = load ptr, ptr %1214, align 8, !alias.scope !455
  %result.i.i.i417.i = call { i64, i64 } %1215(ptr nocapture nofree nonnull readonly align 8 %1201) #44, !alias.scope !455
  %1216 = extractvalue { i64, i64 } %result.i.i.i417.i, 0
  %1217 = extractvalue { i64, i64 } %result.i.i.i417.i, 1
  %1218 = call i64 @llvm.umax.i64(i64 %1206, i64 %1217) #41
  %1219 = call i64 @llvm.umax.i64(i64 %1218, i64 noundef 8) #41, !range !16
  %1220 = urem i64 %1212, %1217
  %1221 = icmp eq i64 %1220, 0
  %1222 = sub i64 %1217, %1220
  %1223 = select i1 %1221, i64 0, i64 %1222
  %1224 = add i64 %1216, %1212
  %1225 = add i64 %1224, %1223
  %1226 = urem i64 %1225, %1219
  %1227 = icmp eq i64 %1226, 0
  %1228 = sub i64 %1219, %1226
  %1229 = select i1 %1227, i64 0, i64 %1228
  %1230 = add i64 %1229, %1225
  %result.i9.i418.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %1230) #48
  store ptr %1199, ptr %result.i9.i418.i, align 8
  %1231 = getelementptr inbounds i8, ptr %result.i9.i418.i, i64 8
  store ptr %1201, ptr %1231, align 8
  %1232 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9.i418.i)
  %1233 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1234 = load ptr, ptr %1199, align 8
  %1235 = getelementptr i8, ptr %1234, i64 72
  %1236 = load ptr, ptr %1235, align 8
  %result.i.i38.i419.i = call { i64, i64 } %1236(ptr nocapture nofree nonnull readonly align 8 %1199) #44
  %1237 = extractvalue { i64, i64 } %result.i.i38.i419.i, 1
  %1238 = urem i64 20, %1237
  %1239 = icmp eq i64 %1238, 0
  %reass.sub865 = sub i64 %1237, %1238
  %1240 = add i64 %reass.sub865, 20
  %1241 = select i1 %1239, i64 20, i64 %1240
  %1242 = getelementptr i8, ptr %result.i9.i418.i, i64 %1241
  %1243 = getelementptr i8, ptr %1234, i64 64
  %1244 = load ptr, ptr %1243, align 8
  call void %1244({ ptr, i160 } %1030, ptr nocapture nofree nonnull readonly align 8 %1199, ptr nocapture nofree writeonly %1242) #45
  %1245 = load ptr, ptr %result.i9.i418.i, align 8
  %1246 = load ptr, ptr %1245, align 8
  %1247 = getelementptr i8, ptr %1246, i64 72
  %1248 = load ptr, ptr %1247, align 8
  %result.i1.i39.i421.i = call { i64, i64 } %1248(ptr nocapture nofree nonnull readonly align 8 %1245) #44
  %1249 = extractvalue { i64, i64 } %result.i1.i39.i421.i, 0
  %1250 = extractvalue { i64, i64 } %result.i1.i39.i421.i, 1
  %1251 = urem i64 20, %1250
  %1252 = icmp eq i64 %1251, 0
  %1253 = sub i64 %1250, %1251
  %1254 = select i1 %1252, i64 0, i64 %1253
  %1255 = add i64 %1249, 20
  %1256 = add i64 %1255, %1254
  %1257 = load ptr, ptr %1231, align 8
  %1258 = load ptr, ptr %1257, align 8
  %1259 = getelementptr i8, ptr %1258, i64 72
  %1260 = load ptr, ptr %1259, align 8
  %result.i.i40.i422.i = call { i64, i64 } %1260(ptr nocapture nofree nonnull readonly align 8 %1257) #44
  %1261 = extractvalue { i64, i64 } %result.i.i40.i422.i, 1
  %1262 = urem i64 %1256, %1261
  %1263 = icmp eq i64 %1262, 0
  %1264 = sub i64 %1261, %1262
  %1265 = select i1 %1263, i64 0, i64 %1264
  %1266 = getelementptr i8, ptr %result.i9.i418.i, i64 %1256
  %1267 = getelementptr i8, ptr %1266, i64 %1265
  %1268 = getelementptr i8, ptr %1258, i64 64
  %1269 = load ptr, ptr %1268, align 8
  call void %1269({ ptr, i160 } %1031, ptr nocapture nofree nonnull readonly align 8 %1257, ptr nocapture nofree writeonly %1267) #45
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1271 = getelementptr inbounds i8, ptr %result.i9.i418.i, i64 16
  store i32 %1033, ptr %1271, align 8
  store ptr @Entry, ptr %1170, align 8
  %1272 = ptrtoint ptr %result.i9.i418.i to i64
  store i64 %1272, ptr %1172, align 4
  %.sroa_idx30.i423.i = getelementptr i8, ptr %1170, i64 24
  store i32 10, ptr %.sroa_idx30.i423.i, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i42

1273:                                             ; preds = %._crit_edge.i411.i, %1175, %1144
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1274 = load i32, ptr %1025, align 4
  %1275 = load i32, ptr %1022, align 8
  %.not.i.i17 = icmp slt i32 %1274, %1275
  br i1 %.not.i.i17, label %._crit_edge.i.i20, label %1276

1276:                                             ; preds = %1273
  %1277 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1278 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1279 = load ptr, ptr %1023, align 8
  %1280 = load ptr, ptr %1024, align 8
  %1281 = shl i32 %1275, 1
  %spec.select.i.i18 = call i32 @llvm.smax.i32(i32 %1281, i32 noundef 16) #40
  store i32 %spec.select.i.i18, ptr %1022, align 8
  %1282 = zext nneg i32 %spec.select.i.i18 to i64
  %1283 = shl nuw nsw i64 %1282, 5
  %result.i5.i.i19 = call noalias ptr @bump_malloc_wrapper(i64 noundef %1283) #48
  store ptr %result.i5.i.i19, ptr %1023, align 8
  %result.i4.i440.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %1283) #48
  store ptr %result.i4.i440.i, ptr %1024, align 8
  store i32 0, ptr %1025, align 4
  %1284 = icmp sgt i32 %1275, 0
  br i1 %1284, label %.lr.ph.i.i103, label %._crit_edge.i.i20

.lr.ph.i.i103:                                    ; preds = %1276
  %wide.trip.count.i.i104 = zext nneg i32 %1275 to i64
  br label %1285

1285:                                             ; preds = %._crit_edge.i852.i, %.lr.ph.i.i103
  %indvars.iv.i851.i = phi i64 [ 0, %.lr.ph.i.i103 ], [ %indvars.iv.next.i853.i, %._crit_edge.i852.i ]
  %1286 = shl nuw nsw i64 %indvars.iv.i851.i, 5
  %1287 = getelementptr i8, ptr %1279, i64 %1286
  %1288 = load ptr, ptr %1287, align 8
  %1289 = icmp ne ptr %1288, @nil_typ
  %1290 = icmp ne ptr %1288, null
  %.not17.i.i105 = and i1 %1289, %1290
  br i1 %.not17.i.i105, label %1291, label %._crit_edge.i852.i

1291:                                             ; preds = %1285
  %1292 = getelementptr i8, ptr %1287, i64 8
  %1293 = load i64, ptr %1292, align 4
  %.sroa_idx.i855.i = getelementptr i8, ptr %1287, i64 16
  %1294 = load i64, ptr %.sroa_idx.i855.i, align 4
  %hash_coef_ptr.i.i6.i.i107 = getelementptr i8, ptr %1288, i64 8
  %tbl_size_ptr.i.i7.i.i108 = getelementptr i8, ptr %1288, i64 16
  %offset_tbl_ptr.i.i8.i.i109 = getelementptr i8, ptr %1288, i64 40
  %1295 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %hash_coef.i.i21.i.i110 = load i64, ptr %hash_coef_ptr.i.i6.i.i107, align 4, !noalias !458
  %tbl_size.i.i22.i.i111 = load i64, ptr %tbl_size_ptr.i.i7.i.i108, align 4, !noalias !458
  %offset_tbl.i.i23.i.i112 = load ptr, ptr %offset_tbl_ptr.i.i8.i.i109, align 8, !noalias !458
  %product.i.i.i24.i.i113 = mul i64 %hash_coef.i.i21.i.i110, 4015701072841558310
  %shifted.i.i.i25.i.i114 = lshr i64 %product.i.i.i24.i.i113, 32
  %xored.i.i.i26.i.i115 = xor i64 %shifted.i.i.i25.i.i114, %product.i.i.i24.i.i113
  %hash.i.i.i27.i.i116 = and i64 %xored.i.i.i26.i.i115, %tbl_size.i.i22.i.i111
  %offset_ptr.i.i28.i.i117 = getelementptr i32, ptr %offset_tbl.i.i23.i.i112, i64 %hash.i.i.i27.i.i116
  %offset.i.i29.i.i118 = load i32, ptr %offset_ptr.i.i28.i.i117, align 4, !noalias !458
  %1296 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1297 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1298 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1299

1299:                                             ; preds = %.cont.i1146.i, %1291
  %.0290.i1128.i = phi i32 [ 0, %1291 ], [ %1332, %.cont.i1146.i ]
  %.074289.i1129.i = phi i1 [ true, %1291 ], [ %1333, %.cont.i1146.i ]
  %.sroa.0.0288.i1130.i = phi ptr [ %1288, %1291 ], [ %1322, %.cont.i1146.i ]
  %.sroa.6.0287.i1131.in.i = phi i64 [ %1293, %1291 ], [ %1324, %.cont.i1146.i ]
  %.sroa.12.0286.i1132.in.i = phi i64 [ %1294, %1291 ], [ %1325, %.cont.i1146.i ]
  %.sroa.17.0285.i1133.i = phi i32 [ %offset.i.i29.i.i118, %1291 ], [ %offset.i.i57.i1158.i, %.cont.i1146.i ]
  %.sroa.12.0286.i1132.i = inttoptr i64 %.sroa.12.0286.i1132.in.i to ptr
  %.sroa.6.0287.i1131.i = inttoptr i64 %.sroa.6.0287.i1131.in.i to ptr
  %1300 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1130.i, 0
  %1301 = insertvalue { ptr, ptr, ptr, i32 } %1300, ptr %.sroa.6.0287.i1131.i, 1
  %1302 = insertvalue { ptr, ptr, ptr, i32 } %1301, ptr %.sroa.12.0286.i1132.i, 2
  %1303 = insertvalue { ptr, ptr, ptr, i32 } %1302, i32 %.sroa.17.0285.i1133.i, 3
  %1304 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1130.i)
  %1305 = sext i32 %.sroa.17.0285.i1133.i to i64
  %1306 = getelementptr ptr, ptr %.sroa.0.0288.i1130.i, i64 %1305
  %1307 = getelementptr i8, ptr %1306, i64 64
  %1308 = load ptr, ptr %1307, align 8
  %result.i15.i1134.i = call ptr %1308({ ptr, ptr, ptr, i32 } %1303, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1309 = call i32 %result.i15.i1134.i({ ptr, ptr, ptr, i32 } %1303, { ptr, ptr, ptr, i32 } %1303, ptr nonnull align 8 %0) #53
  %..i1135.i = select i1 %.074289.i1129.i, ptr %21, ptr %23
  %.188.i1136.i = select i1 %.074289.i1129.i, i64 104, i64 112
  %.189.i1137.i = select i1 %.074289.i1129.i, ptr %22, ptr %24
  %.190.i1138.i = select i1 %.074289.i1129.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1135.i, align 8
  %1310 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1135.i)
  %1311 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1136.i
  %1312 = load ptr, ptr %1311, align 8
  store ptr @i32_typ, ptr %.189.i1137.i, align 8
  %result.i14.i1139.i = call ptr %1312({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1137.i) #46
  %1313 = call i32 %result.i14.i1139.i({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 dereferenceable(8) %..i1135.i, i32 %1309) #53
  %1314 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1315 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1138.i
  %1316 = load ptr, ptr %1315, align 8
  %1317 = load ptr, ptr %1316, align 8
  %1318 = call { ptr } %1317(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i1140.i = extractvalue { ptr } %1318, 0
  %1319 = sext i32 %1313 to i64
  %1320 = shl nsw i64 %1319, 5
  %1321 = getelementptr i8, ptr %.fca.0.extract55.i1140.i, i64 %1320
  %1322 = load ptr, ptr %1321, align 8
  %1323 = getelementptr i8, ptr %1321, i64 8
  %1324 = load i64, ptr %1323, align 4
  %.sroa_idx.i1141.i = getelementptr i8, ptr %1321, i64 16
  %1325 = load i64, ptr %.sroa_idx.i1141.i, align 4
  %1326 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1327 = call { ptr } %1317(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i1142.i = extractvalue { ptr } %1327, 0
  %1328 = getelementptr i8, ptr %.fca.0.extract52.i1142.i, i64 %1320
  store ptr %.sroa.0.0288.i1130.i, ptr %1328, align 8
  %1329 = getelementptr i8, ptr %1328, i64 8
  store i64 %.sroa.6.0287.i1131.in.i, ptr %1329, align 4
  %.sroa_idx104.i1143.i = getelementptr i8, ptr %1328, i64 16
  store i64 %.sroa.12.0286.i1132.in.i, ptr %.sroa_idx104.i1143.i, align 4
  %.sroa_idx105.i1144.i = getelementptr i8, ptr %1328, i64 24
  store i32 %.sroa.17.0285.i1133.i, ptr %.sroa_idx105.i1144.i, align 4
  %1330 = icmp ne ptr %1322, @nil_typ
  %1331 = icmp ne ptr %1322, null
  %.not94.i1145.i = and i1 %1330, %1331
  br i1 %.not94.i1145.i, label %.cont.i1146.i, label %1336

.cont.i1146.i:                                    ; preds = %1299
  %1332 = add nuw nsw i32 %.0290.i1128.i, 1
  %1333 = xor i1 %.074289.i1129.i, true
  %hash_coef_ptr.i.i46.i1147.i = getelementptr i8, ptr %1322, i64 8
  %tbl_size_ptr.i.i47.i1148.i = getelementptr i8, ptr %1322, i64 16
  %offset_tbl_ptr.i.i48.i1149.i = getelementptr i8, ptr %1322, i64 40
  %hash_coef.i.i49.i1150.i = load i64, ptr %hash_coef_ptr.i.i46.i1147.i, align 4
  %tbl_size.i.i50.i1151.i = load i64, ptr %tbl_size_ptr.i.i47.i1148.i, align 4
  %offset_tbl.i.i51.i1152.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1149.i, align 8
  %product.i.i.i52.i1153.i = mul i64 %hash_coef.i.i49.i1150.i, 4015701072841558310
  %shifted.i.i.i53.i1154.i = lshr i64 %product.i.i.i52.i1153.i, 32
  %xored.i.i.i54.i1155.i = xor i64 %shifted.i.i.i53.i1154.i, %product.i.i.i52.i1153.i
  %hash.i.i.i55.i1156.i = and i64 %xored.i.i.i54.i1155.i, %tbl_size.i.i50.i1151.i
  %offset_ptr.i.i56.i1157.i = getelementptr i32, ptr %offset_tbl.i.i51.i1152.i, i64 %hash.i.i.i55.i1156.i
  %offset.i.i57.i1158.i = load i32, ptr %offset_ptr.i.i56.i1157.i, align 4
  %1334 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1335 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1159.i = icmp eq i32 %1332, 100
  br i1 %exitcond.not.i1159.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i, label %1299

1336:                                             ; preds = %1299
  %1337 = load i32, ptr %1025, align 4
  %1338 = add i32 %1337, 1
  %1339 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1338, ptr %1025, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i: ; preds = %1336, %.cont.i1146.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  br label %._crit_edge.i852.i

._crit_edge.i852.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i, %1285
  %indvars.iv.next.i853.i = add nuw nsw i64 %indvars.iv.i851.i, 1
  %exitcond.not.i854.i = icmp eq i64 %indvars.iv.next.i853.i, %wide.trip.count.i.i104
  br i1 %exitcond.not.i854.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i106, label %1285

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i106: ; preds = %._crit_edge.i874.i, %._crit_edge.i852.i
  %indvars.iv.i872.i = phi i64 [ %indvars.iv.next.i875.i, %._crit_edge.i874.i ], [ 0, %._crit_edge.i852.i ]
  %1340 = shl nuw nsw i64 %indvars.iv.i872.i, 5
  %1341 = getelementptr i8, ptr %1280, i64 %1340
  %1342 = load ptr, ptr %1341, align 8
  %1343 = icmp ne ptr %1342, @nil_typ
  %1344 = icmp ne ptr %1342, null
  %.not17.i873.i = and i1 %1343, %1344
  br i1 %.not17.i873.i, label %1345, label %._crit_edge.i874.i

1345:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i106
  %1346 = getelementptr i8, ptr %1341, i64 8
  %1347 = load i64, ptr %1346, align 4
  %.sroa_idx.i877.i = getelementptr i8, ptr %1341, i64 16
  %1348 = load i64, ptr %.sroa_idx.i877.i, align 4
  %hash_coef_ptr.i.i6.i878.i = getelementptr i8, ptr %1342, i64 8
  %tbl_size_ptr.i.i7.i879.i = getelementptr i8, ptr %1342, i64 16
  %offset_tbl_ptr.i.i8.i880.i = getelementptr i8, ptr %1342, i64 40
  %1349 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  %hash_coef.i.i21.i1179.i = load i64, ptr %hash_coef_ptr.i.i6.i878.i, align 4, !noalias !461
  %tbl_size.i.i22.i1180.i = load i64, ptr %tbl_size_ptr.i.i7.i879.i, align 4, !noalias !461
  %offset_tbl.i.i23.i1181.i = load ptr, ptr %offset_tbl_ptr.i.i8.i880.i, align 8, !noalias !461
  %product.i.i.i24.i1182.i = mul i64 %hash_coef.i.i21.i1179.i, 4015701072841558310
  %shifted.i.i.i25.i1183.i = lshr i64 %product.i.i.i24.i1182.i, 32
  %xored.i.i.i26.i1184.i = xor i64 %shifted.i.i.i25.i1183.i, %product.i.i.i24.i1182.i
  %hash.i.i.i27.i1185.i = and i64 %xored.i.i.i26.i1184.i, %tbl_size.i.i22.i1180.i
  %offset_ptr.i.i28.i1186.i = getelementptr i32, ptr %offset_tbl.i.i23.i1181.i, i64 %hash.i.i.i27.i1185.i
  %offset.i.i29.i1187.i = load i32, ptr %offset_ptr.i.i28.i1186.i, align 4, !noalias !461
  %1350 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1351 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1352 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1353

1353:                                             ; preds = %.cont.i1210.i, %1345
  %.0290.i1188.i = phi i32 [ 0, %1345 ], [ %1386, %.cont.i1210.i ]
  %.074289.i1189.i = phi i1 [ true, %1345 ], [ %1387, %.cont.i1210.i ]
  %.sroa.0.0288.i1190.i = phi ptr [ %1342, %1345 ], [ %1376, %.cont.i1210.i ]
  %.sroa.6.0287.i1191.in.i = phi i64 [ %1347, %1345 ], [ %1378, %.cont.i1210.i ]
  %.sroa.12.0286.i1192.in.i = phi i64 [ %1348, %1345 ], [ %1379, %.cont.i1210.i ]
  %.sroa.17.0285.i1193.i = phi i32 [ %offset.i.i29.i1187.i, %1345 ], [ %offset.i.i57.i1222.i, %.cont.i1210.i ]
  %.sroa.12.0286.i1192.i = inttoptr i64 %.sroa.12.0286.i1192.in.i to ptr
  %.sroa.6.0287.i1191.i = inttoptr i64 %.sroa.6.0287.i1191.in.i to ptr
  %1354 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1190.i, 0
  %1355 = insertvalue { ptr, ptr, ptr, i32 } %1354, ptr %.sroa.6.0287.i1191.i, 1
  %1356 = insertvalue { ptr, ptr, ptr, i32 } %1355, ptr %.sroa.12.0286.i1192.i, 2
  %1357 = insertvalue { ptr, ptr, ptr, i32 } %1356, i32 %.sroa.17.0285.i1193.i, 3
  %1358 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1190.i)
  %1359 = sext i32 %.sroa.17.0285.i1193.i to i64
  %1360 = getelementptr ptr, ptr %.sroa.0.0288.i1190.i, i64 %1359
  %1361 = getelementptr i8, ptr %1360, i64 64
  %1362 = load ptr, ptr %1361, align 8
  %result.i15.i1194.i = call ptr %1362({ ptr, ptr, ptr, i32 } %1357, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1363 = call i32 %result.i15.i1194.i({ ptr, ptr, ptr, i32 } %1357, { ptr, ptr, ptr, i32 } %1357, ptr nonnull align 8 %0) #53
  %..i1195.i = select i1 %.074289.i1189.i, ptr %17, ptr %19
  %.188.i1196.i = select i1 %.074289.i1189.i, i64 104, i64 112
  %.189.i1197.i = select i1 %.074289.i1189.i, ptr %18, ptr %20
  %.190.i1198.i = select i1 %.074289.i1189.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1195.i, align 8
  %1364 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1195.i)
  %1365 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1196.i
  %1366 = load ptr, ptr %1365, align 8
  store ptr @i32_typ, ptr %.189.i1197.i, align 8
  %result.i14.i1199.i = call ptr %1366({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1197.i) #46
  %1367 = call i32 %result.i14.i1199.i({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 dereferenceable(8) %..i1195.i, i32 %1363) #53
  %1368 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1369 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1198.i
  %1370 = load ptr, ptr %1369, align 8
  %1371 = load ptr, ptr %1370, align 8
  %1372 = call { ptr } %1371(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i1200.i = extractvalue { ptr } %1372, 0
  %1373 = sext i32 %1367 to i64
  %1374 = shl nsw i64 %1373, 5
  %1375 = getelementptr i8, ptr %.fca.0.extract55.i1200.i, i64 %1374
  %1376 = load ptr, ptr %1375, align 8
  %1377 = getelementptr i8, ptr %1375, i64 8
  %1378 = load i64, ptr %1377, align 4
  %.sroa_idx.i1201.i = getelementptr i8, ptr %1375, i64 16
  %1379 = load i64, ptr %.sroa_idx.i1201.i, align 4
  %1380 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1381 = call { ptr } %1371(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i1202.i = extractvalue { ptr } %1381, 0
  %1382 = getelementptr i8, ptr %.fca.0.extract52.i1202.i, i64 %1374
  store ptr %.sroa.0.0288.i1190.i, ptr %1382, align 8
  %1383 = getelementptr i8, ptr %1382, i64 8
  store i64 %.sroa.6.0287.i1191.in.i, ptr %1383, align 4
  %.sroa_idx104.i1203.i = getelementptr i8, ptr %1382, i64 16
  store i64 %.sroa.12.0286.i1192.in.i, ptr %.sroa_idx104.i1203.i, align 4
  %.sroa_idx105.i1204.i = getelementptr i8, ptr %1382, i64 24
  store i32 %.sroa.17.0285.i1193.i, ptr %.sroa_idx105.i1204.i, align 4
  %1384 = icmp ne ptr %1376, @nil_typ
  %1385 = icmp ne ptr %1376, null
  %.not94.i1205.i = and i1 %1384, %1385
  br i1 %.not94.i1205.i, label %.cont.i1210.i, label %1390

.cont.i1210.i:                                    ; preds = %1353
  %1386 = add nuw nsw i32 %.0290.i1188.i, 1
  %1387 = xor i1 %.074289.i1189.i, true
  %hash_coef_ptr.i.i46.i1211.i = getelementptr i8, ptr %1376, i64 8
  %tbl_size_ptr.i.i47.i1212.i = getelementptr i8, ptr %1376, i64 16
  %offset_tbl_ptr.i.i48.i1213.i = getelementptr i8, ptr %1376, i64 40
  %hash_coef.i.i49.i1214.i = load i64, ptr %hash_coef_ptr.i.i46.i1211.i, align 4
  %tbl_size.i.i50.i1215.i = load i64, ptr %tbl_size_ptr.i.i47.i1212.i, align 4
  %offset_tbl.i.i51.i1216.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1213.i, align 8
  %product.i.i.i52.i1217.i = mul i64 %hash_coef.i.i49.i1214.i, 4015701072841558310
  %shifted.i.i.i53.i1218.i = lshr i64 %product.i.i.i52.i1217.i, 32
  %xored.i.i.i54.i1219.i = xor i64 %shifted.i.i.i53.i1218.i, %product.i.i.i52.i1217.i
  %hash.i.i.i55.i1220.i = and i64 %xored.i.i.i54.i1219.i, %tbl_size.i.i50.i1215.i
  %offset_ptr.i.i56.i1221.i = getelementptr i32, ptr %offset_tbl.i.i51.i1216.i, i64 %hash.i.i.i55.i1220.i
  %offset.i.i57.i1222.i = load i32, ptr %offset_ptr.i.i56.i1221.i, align 4
  %1388 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1389 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1223.i = icmp eq i32 %1386, 100
  br i1 %exitcond.not.i1223.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232.i, label %1353

1390:                                             ; preds = %1353
  %1391 = load i32, ptr %1025, align 4
  %1392 = add i32 %1391, 1
  %1393 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1392, ptr %1025, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232.i: ; preds = %1390, %.cont.i1210.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  br label %._crit_edge.i874.i

._crit_edge.i874.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1232.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i106
  %indvars.iv.next.i875.i = add nuw nsw i64 %indvars.iv.i872.i, 1
  %exitcond.not.i876.i = icmp eq i64 %indvars.iv.next.i875.i, %wide.trip.count.i.i104
  br i1 %exitcond.not.i876.i, label %._crit_edge.i.i20, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit.i106

._crit_edge.i.i20:                                ; preds = %._crit_edge.i874.i, %1276, %1273
  %1394 = load ptr, ptr %result.i35.i, align 8
  %1395 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1396 = load ptr, ptr %1015, align 8
  %1397 = load ptr, ptr %1394, align 8
  %1398 = getelementptr i8, ptr %1397, i64 72
  %1399 = load ptr, ptr %1398, align 8
  %result.i1.i.i156.i = call { i64, i64 } %1399(ptr nocapture nofree nonnull readonly align 8 %1394) #44
  %1400 = extractvalue { i64, i64 } %result.i1.i.i156.i, 0
  %1401 = extractvalue { i64, i64 } %result.i1.i.i156.i, 1
  %1402 = urem i64 20, %1401
  %1403 = icmp eq i64 %1402, 0
  %1404 = sub i64 %1401, %1402
  %1405 = select i1 %1403, i64 0, i64 %1404
  %1406 = add i64 %1400, 20
  %1407 = add i64 %1406, %1405
  %1408 = load ptr, ptr %1396, align 8
  %1409 = getelementptr i8, ptr %1408, i64 72
  %1410 = load ptr, ptr %1409, align 8
  %result.i.i.i157.i = call { i64, i64 } %1410(ptr nocapture nofree nonnull readonly align 8 %1396) #44
  %1411 = extractvalue { i64, i64 } %result.i.i.i157.i, 0
  %1412 = extractvalue { i64, i64 } %result.i.i.i157.i, 1
  %1413 = call i64 @llvm.umax.i64(i64 %1401, i64 %1412) #41
  %1414 = call i64 @llvm.umax.i64(i64 %1413, i64 noundef 8) #41, !range !16
  %1415 = urem i64 %1407, %1412
  %1416 = icmp eq i64 %1415, 0
  %1417 = sub i64 %1412, %1415
  %1418 = select i1 %1416, i64 0, i64 %1417
  %1419 = add i64 %1411, %1407
  %1420 = add i64 %1419, %1418
  %1421 = urem i64 %1420, %1414
  %1422 = icmp eq i64 %1421, 0
  %1423 = sub i64 %1414, %1421
  %1424 = select i1 %1422, i64 0, i64 %1423
  %1425 = add i64 %1424, %1420
  %result.i22.i158.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %1425) #48
  store ptr %1394, ptr %result.i22.i158.i, align 8
  %1426 = getelementptr inbounds i8, ptr %result.i22.i158.i, i64 8
  store ptr %1396, ptr %1426, align 8
  %1427 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22.i158.i)
  %1428 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1429 = load ptr, ptr %1394, align 8
  %1430 = getelementptr i8, ptr %1429, i64 72
  %1431 = load ptr, ptr %1430, align 8
  %result.i.i127.i.i21 = call { i64, i64 } %1431(ptr nocapture nofree nonnull readonly align 8 %1394) #44
  %1432 = extractvalue { i64, i64 } %result.i.i127.i.i21, 1
  %1433 = urem i64 20, %1432
  %1434 = icmp eq i64 %1433, 0
  %reass.sub864 = sub i64 %1432, %1433
  %1435 = add i64 %reass.sub864, 20
  %1436 = select i1 %1434, i64 20, i64 %1435
  %1437 = getelementptr i8, ptr %result.i22.i158.i, i64 %1436
  %1438 = getelementptr i8, ptr %1429, i64 64
  %1439 = load ptr, ptr %1438, align 8
  call void %1439({ ptr, i160 } %1030, ptr nocapture nofree nonnull readonly align 8 %1394, ptr nocapture nofree writeonly %1437) #45
  %1440 = load ptr, ptr %result.i22.i158.i, align 8
  %1441 = load ptr, ptr %1440, align 8
  %1442 = getelementptr i8, ptr %1441, i64 72
  %1443 = load ptr, ptr %1442, align 8
  %result.i1.i128.i.i22 = call { i64, i64 } %1443(ptr nocapture nofree nonnull readonly align 8 %1440) #44
  %1444 = extractvalue { i64, i64 } %result.i1.i128.i.i22, 0
  %1445 = extractvalue { i64, i64 } %result.i1.i128.i.i22, 1
  %1446 = urem i64 20, %1445
  %1447 = icmp eq i64 %1446, 0
  %1448 = sub i64 %1445, %1446
  %1449 = select i1 %1447, i64 0, i64 %1448
  %1450 = add i64 %1444, 20
  %1451 = add i64 %1450, %1449
  %1452 = load ptr, ptr %1426, align 8
  %1453 = load ptr, ptr %1452, align 8
  %1454 = getelementptr i8, ptr %1453, i64 72
  %1455 = load ptr, ptr %1454, align 8
  %result.i.i129.i.i23 = call { i64, i64 } %1455(ptr nocapture nofree nonnull readonly align 8 %1452) #44
  %1456 = extractvalue { i64, i64 } %result.i.i129.i.i23, 1
  %1457 = urem i64 %1451, %1456
  %1458 = icmp eq i64 %1457, 0
  %1459 = sub i64 %1456, %1457
  %1460 = select i1 %1458, i64 0, i64 %1459
  %1461 = getelementptr i8, ptr %result.i22.i158.i, i64 %1451
  %1462 = getelementptr i8, ptr %1461, i64 %1460
  %1463 = getelementptr i8, ptr %1453, i64 64
  %1464 = load ptr, ptr %1463, align 8
  call void %1464({ ptr, i160 } %1031, ptr nocapture nofree nonnull readonly align 8 %1452, ptr nocapture nofree writeonly %1462) #45
  %1465 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %1466 = getelementptr inbounds i8, ptr %result.i22.i158.i, i64 16
  store i32 %1033, ptr %1466, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  %1467 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1468 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1469 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1470

1470:                                             ; preds = %.cont.i.i86, %._crit_edge.i.i20
  %.0290.i.i24 = phi i32 [ 0, %._crit_edge.i.i20 ], [ %1505, %.cont.i.i86 ]
  %.074289.i.i25 = phi i1 [ true, %._crit_edge.i.i20 ], [ %1506, %.cont.i.i86 ]
  %.sroa.0.0288.i.i26 = phi ptr [ @Entry, %._crit_edge.i.i20 ], [ %1493, %.cont.i.i86 ]
  %.sroa.6.0287.i.i27 = phi ptr [ %result.i22.i158.i, %._crit_edge.i.i20 ], [ %1507, %.cont.i.i86 ]
  %.sroa.12.0286.i.i28 = phi ptr [ undef, %._crit_edge.i.i20 ], [ %1508, %.cont.i.i86 ]
  %.sroa.17.0285.i.i29 = phi i32 [ 10, %._crit_edge.i.i20 ], [ %offset.i.i57.i.i98, %.cont.i.i86 ]
  %1471 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i.i26, 0
  %1472 = insertvalue { ptr, ptr, ptr, i32 } %1471, ptr %.sroa.6.0287.i.i27, 1
  %1473 = insertvalue { ptr, ptr, ptr, i32 } %1472, ptr %.sroa.12.0286.i.i28, 2
  %1474 = insertvalue { ptr, ptr, ptr, i32 } %1473, i32 %.sroa.17.0285.i.i29, 3
  %1475 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i.i26)
  %1476 = sext i32 %.sroa.17.0285.i.i29 to i64
  %1477 = getelementptr ptr, ptr %.sroa.0.0288.i.i26, i64 %1476
  %1478 = getelementptr i8, ptr %1477, i64 64
  %1479 = load ptr, ptr %1478, align 8
  %result.i15.i.i30 = call ptr %1479({ ptr, ptr, ptr, i32 } %1474, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1480 = call i32 %result.i15.i.i30({ ptr, ptr, ptr, i32 } %1474, { ptr, ptr, ptr, i32 } %1474, ptr nonnull align 8 %0) #53
  %..i.i31 = select i1 %.074289.i.i25, ptr %29, ptr %31
  %.188.i.i32 = select i1 %.074289.i.i25, i64 104, i64 112
  %.189.i.i33 = select i1 %.074289.i.i25, ptr %30, ptr %32
  %.190.i.i34 = select i1 %.074289.i.i25, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i.i31, align 8
  %1481 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i.i31)
  %1482 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i.i32
  %1483 = load ptr, ptr %1482, align 8
  store ptr @i32_typ, ptr %.189.i.i33, align 8
  %result.i14.i.i35 = call ptr %1483({ ptr, ptr, ptr, i32 } %1028, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i.i33) #46
  %1484 = call i32 %result.i14.i.i35({ ptr, ptr, ptr, i32 } %1028, { ptr, ptr, ptr, i32 } %1028, ptr nonnull align 8 dereferenceable(8) %..i.i31, i32 %1480) #53
  %1485 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1486 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i.i34
  %1487 = load ptr, ptr %1486, align 8
  %1488 = load ptr, ptr %1487, align 8
  %1489 = call { ptr } %1488(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i.i36 = extractvalue { ptr } %1489, 0
  %1490 = sext i32 %1484 to i64
  %1491 = shl nsw i64 %1490, 5
  %1492 = getelementptr i8, ptr %.fca.0.extract55.i.i36, i64 %1491
  %1493 = load ptr, ptr %1492, align 8
  %1494 = getelementptr i8, ptr %1492, i64 8
  %1495 = load i64, ptr %1494, align 4
  %.sroa_idx.i459.i = getelementptr i8, ptr %1492, i64 16
  %1496 = load i64, ptr %.sroa_idx.i459.i, align 4
  %1497 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1498 = call { ptr } %1488(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i.i37 = extractvalue { ptr } %1498, 0
  %1499 = getelementptr i8, ptr %.fca.0.extract52.i.i37, i64 %1491
  store ptr %.sroa.0.0288.i.i26, ptr %1499, align 8
  %1500 = getelementptr i8, ptr %1499, i64 8
  %1501 = ptrtoint ptr %.sroa.6.0287.i.i27 to i64
  %1502 = ptrtoint ptr %.sroa.12.0286.i.i28 to i64
  store i64 %1501, ptr %1500, align 4
  %.sroa_idx104.i.i38 = getelementptr i8, ptr %1499, i64 16
  store i64 %1502, ptr %.sroa_idx104.i.i38, align 4
  %.sroa_idx105.i.i39 = getelementptr i8, ptr %1499, i64 24
  store i32 %.sroa.17.0285.i.i29, ptr %.sroa_idx105.i.i39, align 4
  %1503 = icmp ne ptr %1493, @nil_typ
  %1504 = icmp ne ptr %1493, null
  %.not94.i.i40 = and i1 %1503, %1504
  br i1 %.not94.i.i40, label %.cont.i.i86, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i41

.cont.i.i86:                                      ; preds = %1470
  %1505 = add nuw nsw i32 %.0290.i.i24, 1
  %1506 = xor i1 %.074289.i.i25, true
  %1507 = inttoptr i64 %1495 to ptr
  %1508 = inttoptr i64 %1496 to ptr
  %hash_coef_ptr.i.i46.i.i87 = getelementptr i8, ptr %1493, i64 8
  %tbl_size_ptr.i.i47.i.i88 = getelementptr i8, ptr %1493, i64 16
  %offset_tbl_ptr.i.i48.i.i89 = getelementptr i8, ptr %1493, i64 40
  %hash_coef.i.i49.i.i90 = load i64, ptr %hash_coef_ptr.i.i46.i.i87, align 4
  %tbl_size.i.i50.i.i91 = load i64, ptr %tbl_size_ptr.i.i47.i.i88, align 4
  %offset_tbl.i.i51.i.i92 = load ptr, ptr %offset_tbl_ptr.i.i48.i.i89, align 8
  %product.i.i.i52.i.i93 = mul i64 %hash_coef.i.i49.i.i90, 4015701072841558310
  %shifted.i.i.i53.i.i94 = lshr i64 %product.i.i.i52.i.i93, 32
  %xored.i.i.i54.i.i95 = xor i64 %shifted.i.i.i53.i.i94, %product.i.i.i52.i.i93
  %hash.i.i.i55.i.i96 = and i64 %xored.i.i.i54.i.i95, %tbl_size.i.i50.i.i91
  %offset_ptr.i.i56.i.i97 = getelementptr i32, ptr %offset_tbl.i.i51.i.i92, i64 %hash.i.i.i55.i.i96
  %offset.i.i57.i.i98 = load i32, ptr %offset_ptr.i.i56.i.i97, align 4
  %1509 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1510 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i.i99 = icmp eq i32 %1505, 100
  br i1 %exitcond.not.i.i99, label %1514, label %1470

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i41: ; preds = %1470
  %1511 = load i32, ptr %1025, align 4
  %1512 = add i32 %1511, 1
  %1513 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1512, ptr %1025, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  br label %CuckooMap_insert_keyK_valueV.exit.i42

1514:                                             ; preds = %.cont.i.i86
  %hash_coef_ptr.i.i46.i.i87.le = getelementptr i8, ptr %1493, i64 8
  %tbl_size_ptr.i.i47.i.i88.le = getelementptr i8, ptr %1493, i64 16
  %offset_tbl_ptr.i.i48.i.i89.le = getelementptr i8, ptr %1493, i64 40
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %29)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  %1515 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1516 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1517 = load ptr, ptr %1023, align 8
  %1518 = load ptr, ptr %1024, align 8
  %1519 = load i32, ptr %1022, align 8
  %1520 = shl i32 %1519, 1
  %spec.select.i477.i = call i32 @llvm.smax.i32(i32 %1520, i32 noundef 16) #40
  store i32 %spec.select.i477.i, ptr %1022, align 8
  %1521 = zext nneg i32 %spec.select.i477.i to i64
  %1522 = shl nuw nsw i64 %1521, 5
  %result.i5.i478.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %1522) #48
  store ptr %result.i5.i478.i, ptr %1023, align 8
  %result.i4.i479.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %1522) #48
  store ptr %result.i4.i479.i, ptr %1024, align 8
  store i32 0, ptr %1025, align 4
  %1523 = icmp sgt i32 %1519, 0
  br i1 %1523, label %.lr.ph.i896.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i

.lr.ph.i896.i:                                    ; preds = %1514
  %wide.trip.count.i909.i = zext nneg i32 %1519 to i64
  br label %1524

1524:                                             ; preds = %._crit_edge.i912.i, %.lr.ph.i896.i
  %indvars.iv.i910.i = phi i64 [ 0, %.lr.ph.i896.i ], [ %indvars.iv.next.i913.i, %._crit_edge.i912.i ]
  %1525 = shl nuw nsw i64 %indvars.iv.i910.i, 5
  %1526 = getelementptr i8, ptr %1517, i64 %1525
  %1527 = load ptr, ptr %1526, align 8
  %1528 = icmp ne ptr %1527, @nil_typ
  %1529 = icmp ne ptr %1527, null
  %.not17.i911.i = and i1 %1528, %1529
  br i1 %.not17.i911.i, label %1530, label %._crit_edge.i912.i

1530:                                             ; preds = %1524
  %1531 = getelementptr i8, ptr %1526, i64 8
  %1532 = load i64, ptr %1531, align 4
  %.sroa_idx.i915.i = getelementptr i8, ptr %1526, i64 16
  %1533 = load i64, ptr %.sroa_idx.i915.i, align 4
  %hash_coef_ptr.i.i6.i916.i = getelementptr i8, ptr %1527, i64 8
  %tbl_size_ptr.i.i7.i917.i = getelementptr i8, ptr %1527, i64 16
  %offset_tbl_ptr.i.i8.i918.i = getelementptr i8, ptr %1527, i64 40
  %1534 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %hash_coef.i.i21.i1250.i = load i64, ptr %hash_coef_ptr.i.i6.i916.i, align 4, !noalias !464
  %tbl_size.i.i22.i1251.i = load i64, ptr %tbl_size_ptr.i.i7.i917.i, align 4, !noalias !464
  %offset_tbl.i.i23.i1252.i = load ptr, ptr %offset_tbl_ptr.i.i8.i918.i, align 8, !noalias !464
  %product.i.i.i24.i1253.i = mul i64 %hash_coef.i.i21.i1250.i, 4015701072841558310
  %shifted.i.i.i25.i1254.i = lshr i64 %product.i.i.i24.i1253.i, 32
  %xored.i.i.i26.i1255.i = xor i64 %shifted.i.i.i25.i1254.i, %product.i.i.i24.i1253.i
  %hash.i.i.i27.i1256.i = and i64 %xored.i.i.i26.i1255.i, %tbl_size.i.i22.i1251.i
  %offset_ptr.i.i28.i1257.i = getelementptr i32, ptr %offset_tbl.i.i23.i1252.i, i64 %hash.i.i.i27.i1256.i
  %offset.i.i29.i1258.i = load i32, ptr %offset_ptr.i.i28.i1257.i, align 4, !noalias !464
  %1535 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1536 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1537 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1538

1538:                                             ; preds = %.cont.i1281.i, %1530
  %.0290.i1259.i = phi i32 [ 0, %1530 ], [ %1571, %.cont.i1281.i ]
  %.074289.i1260.i = phi i1 [ true, %1530 ], [ %1572, %.cont.i1281.i ]
  %.sroa.0.0288.i1261.i = phi ptr [ %1527, %1530 ], [ %1561, %.cont.i1281.i ]
  %.sroa.6.0287.i1262.in.i = phi i64 [ %1532, %1530 ], [ %1563, %.cont.i1281.i ]
  %.sroa.12.0286.i1263.in.i = phi i64 [ %1533, %1530 ], [ %1564, %.cont.i1281.i ]
  %.sroa.17.0285.i1264.i = phi i32 [ %offset.i.i29.i1258.i, %1530 ], [ %offset.i.i57.i1293.i, %.cont.i1281.i ]
  %.sroa.12.0286.i1263.i = inttoptr i64 %.sroa.12.0286.i1263.in.i to ptr
  %.sroa.6.0287.i1262.i = inttoptr i64 %.sroa.6.0287.i1262.in.i to ptr
  %1539 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1261.i, 0
  %1540 = insertvalue { ptr, ptr, ptr, i32 } %1539, ptr %.sroa.6.0287.i1262.i, 1
  %1541 = insertvalue { ptr, ptr, ptr, i32 } %1540, ptr %.sroa.12.0286.i1263.i, 2
  %1542 = insertvalue { ptr, ptr, ptr, i32 } %1541, i32 %.sroa.17.0285.i1264.i, 3
  %1543 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1261.i)
  %1544 = sext i32 %.sroa.17.0285.i1264.i to i64
  %1545 = getelementptr ptr, ptr %.sroa.0.0288.i1261.i, i64 %1544
  %1546 = getelementptr i8, ptr %1545, i64 64
  %1547 = load ptr, ptr %1546, align 8
  %result.i15.i1265.i = call ptr %1547({ ptr, ptr, ptr, i32 } %1542, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1548 = call i32 %result.i15.i1265.i({ ptr, ptr, ptr, i32 } %1542, { ptr, ptr, ptr, i32 } %1542, ptr nonnull align 8 %0) #53
  %..i1266.i = select i1 %.074289.i1260.i, ptr %13, ptr %15
  %.188.i1267.i = select i1 %.074289.i1260.i, i64 104, i64 112
  %.189.i1268.i = select i1 %.074289.i1260.i, ptr %14, ptr %16
  %.190.i1269.i = select i1 %.074289.i1260.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1266.i, align 8
  %1549 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1266.i)
  %1550 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1267.i
  %1551 = load ptr, ptr %1550, align 8
  store ptr @i32_typ, ptr %.189.i1268.i, align 8
  %result.i14.i1270.i = call ptr %1551({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1268.i) #46
  %1552 = call i32 %result.i14.i1270.i({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 dereferenceable(8) %..i1266.i, i32 %1548) #53
  %1553 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1554 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1269.i
  %1555 = load ptr, ptr %1554, align 8
  %1556 = load ptr, ptr %1555, align 8
  %1557 = call { ptr } %1556(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i1271.i = extractvalue { ptr } %1557, 0
  %1558 = sext i32 %1552 to i64
  %1559 = shl nsw i64 %1558, 5
  %1560 = getelementptr i8, ptr %.fca.0.extract55.i1271.i, i64 %1559
  %1561 = load ptr, ptr %1560, align 8
  %1562 = getelementptr i8, ptr %1560, i64 8
  %1563 = load i64, ptr %1562, align 4
  %.sroa_idx.i1272.i = getelementptr i8, ptr %1560, i64 16
  %1564 = load i64, ptr %.sroa_idx.i1272.i, align 4
  %1565 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1566 = call { ptr } %1556(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i1273.i = extractvalue { ptr } %1566, 0
  %1567 = getelementptr i8, ptr %.fca.0.extract52.i1273.i, i64 %1559
  store ptr %.sroa.0.0288.i1261.i, ptr %1567, align 8
  %1568 = getelementptr i8, ptr %1567, i64 8
  store i64 %.sroa.6.0287.i1262.in.i, ptr %1568, align 4
  %.sroa_idx104.i1274.i = getelementptr i8, ptr %1567, i64 16
  store i64 %.sroa.12.0286.i1263.in.i, ptr %.sroa_idx104.i1274.i, align 4
  %.sroa_idx105.i1275.i = getelementptr i8, ptr %1567, i64 24
  store i32 %.sroa.17.0285.i1264.i, ptr %.sroa_idx105.i1275.i, align 4
  %1569 = icmp ne ptr %1561, @nil_typ
  %1570 = icmp ne ptr %1561, null
  %.not94.i1276.i = and i1 %1569, %1570
  br i1 %.not94.i1276.i, label %.cont.i1281.i, label %1575

.cont.i1281.i:                                    ; preds = %1538
  %1571 = add nuw nsw i32 %.0290.i1259.i, 1
  %1572 = xor i1 %.074289.i1260.i, true
  %hash_coef_ptr.i.i46.i1282.i = getelementptr i8, ptr %1561, i64 8
  %tbl_size_ptr.i.i47.i1283.i = getelementptr i8, ptr %1561, i64 16
  %offset_tbl_ptr.i.i48.i1284.i = getelementptr i8, ptr %1561, i64 40
  %hash_coef.i.i49.i1285.i = load i64, ptr %hash_coef_ptr.i.i46.i1282.i, align 4
  %tbl_size.i.i50.i1286.i = load i64, ptr %tbl_size_ptr.i.i47.i1283.i, align 4
  %offset_tbl.i.i51.i1287.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1284.i, align 8
  %product.i.i.i52.i1288.i = mul i64 %hash_coef.i.i49.i1285.i, 4015701072841558310
  %shifted.i.i.i53.i1289.i = lshr i64 %product.i.i.i52.i1288.i, 32
  %xored.i.i.i54.i1290.i = xor i64 %shifted.i.i.i53.i1289.i, %product.i.i.i52.i1288.i
  %hash.i.i.i55.i1291.i = and i64 %xored.i.i.i54.i1290.i, %tbl_size.i.i50.i1286.i
  %offset_ptr.i.i56.i1292.i = getelementptr i32, ptr %offset_tbl.i.i51.i1287.i, i64 %hash.i.i.i55.i1291.i
  %offset.i.i57.i1293.i = load i32, ptr %offset_ptr.i.i56.i1292.i, align 4
  %1573 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1574 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1294.i = icmp eq i32 %1571, 100
  br i1 %exitcond.not.i1294.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303.i, label %1538

1575:                                             ; preds = %1538
  %1576 = load i32, ptr %1025, align 4
  %1577 = add i32 %1576, 1
  %1578 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1577, ptr %1025, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303.i: ; preds = %1575, %.cont.i1281.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  br label %._crit_edge.i912.i

._crit_edge.i912.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1303.i, %1524
  %indvars.iv.next.i913.i = add nuw nsw i64 %indvars.iv.i910.i, 1
  %exitcond.not.i914.i = icmp eq i64 %indvars.iv.next.i913.i, %wide.trip.count.i909.i
  br i1 %exitcond.not.i914.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932.i, label %1524

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932.i: ; preds = %._crit_edge.i950.i, %._crit_edge.i912.i
  %indvars.iv.i948.i = phi i64 [ %indvars.iv.next.i951.i, %._crit_edge.i950.i ], [ 0, %._crit_edge.i912.i ]
  %1579 = shl nuw nsw i64 %indvars.iv.i948.i, 5
  %1580 = getelementptr i8, ptr %1518, i64 %1579
  %1581 = load ptr, ptr %1580, align 8
  %1582 = icmp ne ptr %1581, @nil_typ
  %1583 = icmp ne ptr %1581, null
  %.not17.i949.i = and i1 %1582, %1583
  br i1 %.not17.i949.i, label %1584, label %._crit_edge.i950.i

1584:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932.i
  %1585 = getelementptr i8, ptr %1580, i64 8
  %1586 = load i64, ptr %1585, align 4
  %.sroa_idx.i953.i = getelementptr i8, ptr %1580, i64 16
  %1587 = load i64, ptr %.sroa_idx.i953.i, align 4
  %hash_coef_ptr.i.i6.i954.i = getelementptr i8, ptr %1581, i64 8
  %tbl_size_ptr.i.i7.i955.i = getelementptr i8, ptr %1581, i64 16
  %offset_tbl_ptr.i.i8.i956.i = getelementptr i8, ptr %1581, i64 40
  %1588 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  %hash_coef.i.i21.i1321.i = load i64, ptr %hash_coef_ptr.i.i6.i954.i, align 4, !noalias !467
  %tbl_size.i.i22.i1322.i = load i64, ptr %tbl_size_ptr.i.i7.i955.i, align 4, !noalias !467
  %offset_tbl.i.i23.i1323.i = load ptr, ptr %offset_tbl_ptr.i.i8.i956.i, align 8, !noalias !467
  %product.i.i.i24.i1324.i = mul i64 %hash_coef.i.i21.i1321.i, 4015701072841558310
  %shifted.i.i.i25.i1325.i = lshr i64 %product.i.i.i24.i1324.i, 32
  %xored.i.i.i26.i1326.i = xor i64 %shifted.i.i.i25.i1325.i, %product.i.i.i24.i1324.i
  %hash.i.i.i27.i1327.i = and i64 %xored.i.i.i26.i1326.i, %tbl_size.i.i22.i1322.i
  %offset_ptr.i.i28.i1328.i = getelementptr i32, ptr %offset_tbl.i.i23.i1323.i, i64 %hash.i.i.i27.i1327.i
  %offset.i.i29.i1329.i = load i32, ptr %offset_ptr.i.i28.i1328.i, align 4, !noalias !467
  %1589 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1590 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1591 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1592

1592:                                             ; preds = %.cont.i1352.i, %1584
  %.0290.i1330.i = phi i32 [ 0, %1584 ], [ %1625, %.cont.i1352.i ]
  %.074289.i1331.i = phi i1 [ true, %1584 ], [ %1626, %.cont.i1352.i ]
  %.sroa.0.0288.i1332.i = phi ptr [ %1581, %1584 ], [ %1615, %.cont.i1352.i ]
  %.sroa.6.0287.i1333.in.i = phi i64 [ %1586, %1584 ], [ %1617, %.cont.i1352.i ]
  %.sroa.12.0286.i1334.in.i = phi i64 [ %1587, %1584 ], [ %1618, %.cont.i1352.i ]
  %.sroa.17.0285.i1335.i = phi i32 [ %offset.i.i29.i1329.i, %1584 ], [ %offset.i.i57.i1364.i, %.cont.i1352.i ]
  %.sroa.12.0286.i1334.i = inttoptr i64 %.sroa.12.0286.i1334.in.i to ptr
  %.sroa.6.0287.i1333.i = inttoptr i64 %.sroa.6.0287.i1333.in.i to ptr
  %1593 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1332.i, 0
  %1594 = insertvalue { ptr, ptr, ptr, i32 } %1593, ptr %.sroa.6.0287.i1333.i, 1
  %1595 = insertvalue { ptr, ptr, ptr, i32 } %1594, ptr %.sroa.12.0286.i1334.i, 2
  %1596 = insertvalue { ptr, ptr, ptr, i32 } %1595, i32 %.sroa.17.0285.i1335.i, 3
  %1597 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1332.i)
  %1598 = sext i32 %.sroa.17.0285.i1335.i to i64
  %1599 = getelementptr ptr, ptr %.sroa.0.0288.i1332.i, i64 %1598
  %1600 = getelementptr i8, ptr %1599, i64 64
  %1601 = load ptr, ptr %1600, align 8
  %result.i15.i1336.i = call ptr %1601({ ptr, ptr, ptr, i32 } %1596, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1602 = call i32 %result.i15.i1336.i({ ptr, ptr, ptr, i32 } %1596, { ptr, ptr, ptr, i32 } %1596, ptr nonnull align 8 %0) #53
  %..i1337.i = select i1 %.074289.i1331.i, ptr %9, ptr %11
  %.188.i1338.i = select i1 %.074289.i1331.i, i64 104, i64 112
  %.189.i1339.i = select i1 %.074289.i1331.i, ptr %10, ptr %12
  %.190.i1340.i = select i1 %.074289.i1331.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1337.i, align 8
  %1603 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1337.i)
  %1604 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1338.i
  %1605 = load ptr, ptr %1604, align 8
  store ptr @i32_typ, ptr %.189.i1339.i, align 8
  %result.i14.i1341.i = call ptr %1605({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1339.i) #46
  %1606 = call i32 %result.i14.i1341.i({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 dereferenceable(8) %..i1337.i, i32 %1602) #53
  %1607 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1608 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1340.i
  %1609 = load ptr, ptr %1608, align 8
  %1610 = load ptr, ptr %1609, align 8
  %1611 = call { ptr } %1610(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i1342.i = extractvalue { ptr } %1611, 0
  %1612 = sext i32 %1606 to i64
  %1613 = shl nsw i64 %1612, 5
  %1614 = getelementptr i8, ptr %.fca.0.extract55.i1342.i, i64 %1613
  %1615 = load ptr, ptr %1614, align 8
  %1616 = getelementptr i8, ptr %1614, i64 8
  %1617 = load i64, ptr %1616, align 4
  %.sroa_idx.i1343.i = getelementptr i8, ptr %1614, i64 16
  %1618 = load i64, ptr %.sroa_idx.i1343.i, align 4
  %1619 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1620 = call { ptr } %1610(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i1344.i = extractvalue { ptr } %1620, 0
  %1621 = getelementptr i8, ptr %.fca.0.extract52.i1344.i, i64 %1613
  store ptr %.sroa.0.0288.i1332.i, ptr %1621, align 8
  %1622 = getelementptr i8, ptr %1621, i64 8
  store i64 %.sroa.6.0287.i1333.in.i, ptr %1622, align 4
  %.sroa_idx104.i1345.i = getelementptr i8, ptr %1621, i64 16
  store i64 %.sroa.12.0286.i1334.in.i, ptr %.sroa_idx104.i1345.i, align 4
  %.sroa_idx105.i1346.i = getelementptr i8, ptr %1621, i64 24
  store i32 %.sroa.17.0285.i1335.i, ptr %.sroa_idx105.i1346.i, align 4
  %1623 = icmp ne ptr %1615, @nil_typ
  %1624 = icmp ne ptr %1615, null
  %.not94.i1347.i = and i1 %1623, %1624
  br i1 %.not94.i1347.i, label %.cont.i1352.i, label %1629

.cont.i1352.i:                                    ; preds = %1592
  %1625 = add nuw nsw i32 %.0290.i1330.i, 1
  %1626 = xor i1 %.074289.i1331.i, true
  %hash_coef_ptr.i.i46.i1353.i = getelementptr i8, ptr %1615, i64 8
  %tbl_size_ptr.i.i47.i1354.i = getelementptr i8, ptr %1615, i64 16
  %offset_tbl_ptr.i.i48.i1355.i = getelementptr i8, ptr %1615, i64 40
  %hash_coef.i.i49.i1356.i = load i64, ptr %hash_coef_ptr.i.i46.i1353.i, align 4
  %tbl_size.i.i50.i1357.i = load i64, ptr %tbl_size_ptr.i.i47.i1354.i, align 4
  %offset_tbl.i.i51.i1358.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1355.i, align 8
  %product.i.i.i52.i1359.i = mul i64 %hash_coef.i.i49.i1356.i, 4015701072841558310
  %shifted.i.i.i53.i1360.i = lshr i64 %product.i.i.i52.i1359.i, 32
  %xored.i.i.i54.i1361.i = xor i64 %shifted.i.i.i53.i1360.i, %product.i.i.i52.i1359.i
  %hash.i.i.i55.i1362.i = and i64 %xored.i.i.i54.i1361.i, %tbl_size.i.i50.i1357.i
  %offset_ptr.i.i56.i1363.i = getelementptr i32, ptr %offset_tbl.i.i51.i1358.i, i64 %hash.i.i.i55.i1362.i
  %offset.i.i57.i1364.i = load i32, ptr %offset_ptr.i.i56.i1363.i, align 4
  %1627 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1628 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1365.i = icmp eq i32 %1625, 100
  br i1 %exitcond.not.i1365.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374.i, label %1592

1629:                                             ; preds = %1592
  %1630 = load i32, ptr %1025, align 4
  %1631 = add i32 %1630, 1
  %1632 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1631, ptr %1025, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374.i: ; preds = %1629, %.cont.i1352.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  br label %._crit_edge.i950.i

._crit_edge.i950.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1374.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932.i
  %indvars.iv.next.i951.i = add nuw nsw i64 %indvars.iv.i948.i, 1
  %exitcond.not.i952.i = icmp eq i64 %indvars.iv.next.i951.i, %wide.trip.count.i909.i
  br i1 %exitcond.not.i952.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit932.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i: ; preds = %._crit_edge.i950.i, %1514
  %1633 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %hash_coef.i.i21.i503.i = load i64, ptr %hash_coef_ptr.i.i46.i.i87.le, align 4, !noalias !470
  %tbl_size.i.i22.i504.i = load i64, ptr %tbl_size_ptr.i.i47.i.i88.le, align 4, !noalias !470
  %offset_tbl.i.i23.i505.i = load ptr, ptr %offset_tbl_ptr.i.i48.i.i89.le, align 8, !noalias !470
  %product.i.i.i24.i506.i = mul i64 %hash_coef.i.i21.i503.i, 4015701072841558310
  %shifted.i.i.i25.i507.i = lshr i64 %product.i.i.i24.i506.i, 32
  %xored.i.i.i26.i508.i = xor i64 %shifted.i.i.i25.i507.i, %product.i.i.i24.i506.i
  %hash.i.i.i27.i509.i = and i64 %xored.i.i.i26.i508.i, %tbl_size.i.i22.i504.i
  %offset_ptr.i.i28.i510.i = getelementptr i32, ptr %offset_tbl.i.i23.i505.i, i64 %hash.i.i.i27.i509.i
  %offset.i.i29.i511.i = load i32, ptr %offset_ptr.i.i28.i510.i, align 4, !noalias !470
  %1634 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1635 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1636 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1637

1637:                                             ; preds = %.cont.i535.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i
  %.0290.i513.i = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i ], [ %1670, %.cont.i535.i ]
  %.074289.i514.i = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i ], [ %1671, %.cont.i535.i ]
  %.sroa.0.0288.i515.i = phi ptr [ %1493, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i ], [ %1660, %.cont.i535.i ]
  %.sroa.6.0287.i516.in.i = phi i64 [ %1495, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i ], [ %1662, %.cont.i535.i ]
  %.sroa.12.0286.i517.in.i = phi i64 [ %1496, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i ], [ %1663, %.cont.i535.i ]
  %.sroa.17.0285.i518.i = phi i32 [ %offset.i.i29.i511.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit970.i ], [ %offset.i.i57.i547.i, %.cont.i535.i ]
  %.sroa.12.0286.i517.i = inttoptr i64 %.sroa.12.0286.i517.in.i to ptr
  %.sroa.6.0287.i516.i = inttoptr i64 %.sroa.6.0287.i516.in.i to ptr
  %1638 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i515.i, 0
  %1639 = insertvalue { ptr, ptr, ptr, i32 } %1638, ptr %.sroa.6.0287.i516.i, 1
  %1640 = insertvalue { ptr, ptr, ptr, i32 } %1639, ptr %.sroa.12.0286.i517.i, 2
  %1641 = insertvalue { ptr, ptr, ptr, i32 } %1640, i32 %.sroa.17.0285.i518.i, 3
  %1642 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i515.i)
  %1643 = sext i32 %.sroa.17.0285.i518.i to i64
  %1644 = getelementptr ptr, ptr %.sroa.0.0288.i515.i, i64 %1643
  %1645 = getelementptr i8, ptr %1644, i64 64
  %1646 = load ptr, ptr %1645, align 8
  %result.i15.i519.i = call ptr %1646({ ptr, ptr, ptr, i32 } %1641, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1647 = call i32 %result.i15.i519.i({ ptr, ptr, ptr, i32 } %1641, { ptr, ptr, ptr, i32 } %1641, ptr nonnull align 8 %0) #53
  %..i520.i = select i1 %.074289.i514.i, ptr %25, ptr %27
  %.188.i521.i = select i1 %.074289.i514.i, i64 104, i64 112
  %.189.i522.i = select i1 %.074289.i514.i, ptr %26, ptr %28
  %.190.i523.i = select i1 %.074289.i514.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i520.i, align 8
  %1648 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i520.i)
  %1649 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i521.i
  %1650 = load ptr, ptr %1649, align 8
  store ptr @i32_typ, ptr %.189.i522.i, align 8
  %result.i14.i524.i = call ptr %1650({ ptr, ptr, ptr, i32 } %1028, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i522.i) #46
  %1651 = call i32 %result.i14.i524.i({ ptr, ptr, ptr, i32 } %1028, { ptr, ptr, ptr, i32 } %1028, ptr nonnull align 8 dereferenceable(8) %..i520.i, i32 %1647) #53
  %1652 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1653 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i523.i
  %1654 = load ptr, ptr %1653, align 8
  %1655 = load ptr, ptr %1654, align 8
  %1656 = call { ptr } %1655(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i525.i = extractvalue { ptr } %1656, 0
  %1657 = sext i32 %1651 to i64
  %1658 = shl nsw i64 %1657, 5
  %1659 = getelementptr i8, ptr %.fca.0.extract55.i525.i, i64 %1658
  %1660 = load ptr, ptr %1659, align 8
  %1661 = getelementptr i8, ptr %1659, i64 8
  %1662 = load i64, ptr %1661, align 4
  %.sroa_idx.i526.i = getelementptr i8, ptr %1659, i64 16
  %1663 = load i64, ptr %.sroa_idx.i526.i, align 4
  %1664 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1665 = call { ptr } %1655(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i527.i = extractvalue { ptr } %1665, 0
  %1666 = getelementptr i8, ptr %.fca.0.extract52.i527.i, i64 %1658
  store ptr %.sroa.0.0288.i515.i, ptr %1666, align 8
  %1667 = getelementptr i8, ptr %1666, i64 8
  store i64 %.sroa.6.0287.i516.in.i, ptr %1667, align 4
  %.sroa_idx104.i528.i = getelementptr i8, ptr %1666, i64 16
  store i64 %.sroa.12.0286.i517.in.i, ptr %.sroa_idx104.i528.i, align 4
  %.sroa_idx105.i529.i = getelementptr i8, ptr %1666, i64 24
  store i32 %.sroa.17.0285.i518.i, ptr %.sroa_idx105.i529.i, align 4
  %1668 = icmp ne ptr %1660, @nil_typ
  %1669 = icmp ne ptr %1660, null
  %.not94.i530.i = and i1 %1668, %1669
  br i1 %.not94.i530.i, label %.cont.i535.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit557.i

.cont.i535.i:                                     ; preds = %1637
  %1670 = add nuw nsw i32 %.0290.i513.i, 1
  %1671 = xor i1 %.074289.i514.i, true
  %hash_coef_ptr.i.i46.i536.i = getelementptr i8, ptr %1660, i64 8
  %tbl_size_ptr.i.i47.i537.i = getelementptr i8, ptr %1660, i64 16
  %offset_tbl_ptr.i.i48.i538.i = getelementptr i8, ptr %1660, i64 40
  %hash_coef.i.i49.i539.i = load i64, ptr %hash_coef_ptr.i.i46.i536.i, align 4
  %tbl_size.i.i50.i540.i = load i64, ptr %tbl_size_ptr.i.i47.i537.i, align 4
  %offset_tbl.i.i51.i541.i = load ptr, ptr %offset_tbl_ptr.i.i48.i538.i, align 8
  %product.i.i.i52.i542.i = mul i64 %hash_coef.i.i49.i539.i, 4015701072841558310
  %shifted.i.i.i53.i543.i = lshr i64 %product.i.i.i52.i542.i, 32
  %xored.i.i.i54.i544.i = xor i64 %shifted.i.i.i53.i543.i, %product.i.i.i52.i542.i
  %hash.i.i.i55.i545.i = and i64 %xored.i.i.i54.i544.i, %tbl_size.i.i50.i540.i
  %offset_ptr.i.i56.i546.i = getelementptr i32, ptr %offset_tbl.i.i51.i541.i, i64 %hash.i.i.i55.i545.i
  %offset.i.i57.i547.i = load i32, ptr %offset_ptr.i.i56.i546.i, align 4
  %1672 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i548.i = icmp eq i32 %1670, 100
  br i1 %exitcond.not.i548.i, label %1677, label %1637

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit557.i: ; preds = %1637
  %1674 = load i32, ptr %1025, align 4
  %1675 = add i32 %1674, 1
  %1676 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1675, ptr %1025, align 4
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  br label %CuckooMap_insert_keyK_valueV.exit.i42

1677:                                             ; preds = %.cont.i535.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %1678 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1679 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1680 = load ptr, ptr %1023, align 8
  %1681 = load ptr, ptr %1024, align 8
  %1682 = load i32, ptr %1022, align 8
  %1683 = shl i32 %1682, 1
  %spec.select.i574.i = call i32 @llvm.smax.i32(i32 %1683, i32 noundef 16) #40
  store i32 %spec.select.i574.i, ptr %1022, align 8
  %1684 = zext nneg i32 %spec.select.i574.i to i64
  %1685 = shl nuw nsw i64 %1684, 5
  %result.i5.i575.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %1685) #48
  store ptr %result.i5.i575.i, ptr %1023, align 8
  %result.i4.i576.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %1685) #48
  store ptr %result.i4.i576.i, ptr %1024, align 8
  store i32 0, ptr %1025, align 4
  %1686 = icmp sgt i32 %1682, 0
  br i1 %1686, label %.lr.ph.i972.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.thread.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.thread.i: ; preds = %1677
  %1687 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %CuckooMap_insert_keyK_valueV.exit.i42

.lr.ph.i972.i:                                    ; preds = %1677
  %wide.trip.count.i985.i = zext nneg i32 %1682 to i64
  br label %1688

1688:                                             ; preds = %._crit_edge.i988.i, %.lr.ph.i972.i
  %indvars.iv.i986.i = phi i64 [ 0, %.lr.ph.i972.i ], [ %indvars.iv.next.i989.i, %._crit_edge.i988.i ]
  %1689 = shl nuw nsw i64 %indvars.iv.i986.i, 5
  %1690 = getelementptr i8, ptr %1680, i64 %1689
  %1691 = load ptr, ptr %1690, align 8
  %1692 = icmp ne ptr %1691, @nil_typ
  %1693 = icmp ne ptr %1691, null
  %.not17.i987.i = and i1 %1692, %1693
  br i1 %.not17.i987.i, label %1694, label %._crit_edge.i988.i

1694:                                             ; preds = %1688
  %1695 = getelementptr i8, ptr %1690, i64 8
  %1696 = load i64, ptr %1695, align 4
  %.sroa_idx.i991.i = getelementptr i8, ptr %1690, i64 16
  %1697 = load i64, ptr %.sroa_idx.i991.i, align 4
  %hash_coef_ptr.i.i6.i992.i = getelementptr i8, ptr %1691, i64 8
  %tbl_size_ptr.i.i7.i993.i = getelementptr i8, ptr %1691, i64 16
  %offset_tbl_ptr.i.i8.i994.i = getelementptr i8, ptr %1691, i64 40
  %1698 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %hash_coef.i.i21.i1392.i = load i64, ptr %hash_coef_ptr.i.i6.i992.i, align 4, !noalias !473
  %tbl_size.i.i22.i1393.i = load i64, ptr %tbl_size_ptr.i.i7.i993.i, align 4, !noalias !473
  %offset_tbl.i.i23.i1394.i = load ptr, ptr %offset_tbl_ptr.i.i8.i994.i, align 8, !noalias !473
  %product.i.i.i24.i1395.i = mul i64 %hash_coef.i.i21.i1392.i, 4015701072841558310
  %shifted.i.i.i25.i1396.i = lshr i64 %product.i.i.i24.i1395.i, 32
  %xored.i.i.i26.i1397.i = xor i64 %shifted.i.i.i25.i1396.i, %product.i.i.i24.i1395.i
  %hash.i.i.i27.i1398.i = and i64 %xored.i.i.i26.i1397.i, %tbl_size.i.i22.i1393.i
  %offset_ptr.i.i28.i1399.i = getelementptr i32, ptr %offset_tbl.i.i23.i1394.i, i64 %hash.i.i.i27.i1398.i
  %offset.i.i29.i1400.i = load i32, ptr %offset_ptr.i.i28.i1399.i, align 4, !noalias !473
  %1699 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1700 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1701 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1702

1702:                                             ; preds = %.cont.i1423.i, %1694
  %.0290.i1401.i = phi i32 [ 0, %1694 ], [ %1735, %.cont.i1423.i ]
  %.074289.i1402.i = phi i1 [ true, %1694 ], [ %1736, %.cont.i1423.i ]
  %.sroa.0.0288.i1403.i = phi ptr [ %1691, %1694 ], [ %1725, %.cont.i1423.i ]
  %.sroa.6.0287.i1404.in.i = phi i64 [ %1696, %1694 ], [ %1727, %.cont.i1423.i ]
  %.sroa.12.0286.i1405.in.i = phi i64 [ %1697, %1694 ], [ %1728, %.cont.i1423.i ]
  %.sroa.17.0285.i1406.i = phi i32 [ %offset.i.i29.i1400.i, %1694 ], [ %offset.i.i57.i1435.i, %.cont.i1423.i ]
  %.sroa.12.0286.i1405.i = inttoptr i64 %.sroa.12.0286.i1405.in.i to ptr
  %.sroa.6.0287.i1404.i = inttoptr i64 %.sroa.6.0287.i1404.in.i to ptr
  %1703 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1403.i, 0
  %1704 = insertvalue { ptr, ptr, ptr, i32 } %1703, ptr %.sroa.6.0287.i1404.i, 1
  %1705 = insertvalue { ptr, ptr, ptr, i32 } %1704, ptr %.sroa.12.0286.i1405.i, 2
  %1706 = insertvalue { ptr, ptr, ptr, i32 } %1705, i32 %.sroa.17.0285.i1406.i, 3
  %1707 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1403.i)
  %1708 = sext i32 %.sroa.17.0285.i1406.i to i64
  %1709 = getelementptr ptr, ptr %.sroa.0.0288.i1403.i, i64 %1708
  %1710 = getelementptr i8, ptr %1709, i64 64
  %1711 = load ptr, ptr %1710, align 8
  %result.i15.i1407.i = call ptr %1711({ ptr, ptr, ptr, i32 } %1706, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1712 = call i32 %result.i15.i1407.i({ ptr, ptr, ptr, i32 } %1706, { ptr, ptr, ptr, i32 } %1706, ptr nonnull align 8 %0) #53
  %..i1408.i = select i1 %.074289.i1402.i, ptr %5, ptr %7
  %.188.i1409.i = select i1 %.074289.i1402.i, i64 104, i64 112
  %.189.i1410.i = select i1 %.074289.i1402.i, ptr %6, ptr %8
  %.190.i1411.i = select i1 %.074289.i1402.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1408.i, align 8
  %1713 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1408.i)
  %1714 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1409.i
  %1715 = load ptr, ptr %1714, align 8
  store ptr @i32_typ, ptr %.189.i1410.i, align 8
  %result.i14.i1412.i = call ptr %1715({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1410.i) #46
  %1716 = call i32 %result.i14.i1412.i({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 dereferenceable(8) %..i1408.i, i32 %1712) #53
  %1717 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1718 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1411.i
  %1719 = load ptr, ptr %1718, align 8
  %1720 = load ptr, ptr %1719, align 8
  %1721 = call { ptr } %1720(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i1413.i = extractvalue { ptr } %1721, 0
  %1722 = sext i32 %1716 to i64
  %1723 = shl nsw i64 %1722, 5
  %1724 = getelementptr i8, ptr %.fca.0.extract55.i1413.i, i64 %1723
  %1725 = load ptr, ptr %1724, align 8
  %1726 = getelementptr i8, ptr %1724, i64 8
  %1727 = load i64, ptr %1726, align 4
  %.sroa_idx.i1414.i = getelementptr i8, ptr %1724, i64 16
  %1728 = load i64, ptr %.sroa_idx.i1414.i, align 4
  %1729 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1730 = call { ptr } %1720(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i1415.i = extractvalue { ptr } %1730, 0
  %1731 = getelementptr i8, ptr %.fca.0.extract52.i1415.i, i64 %1723
  store ptr %.sroa.0.0288.i1403.i, ptr %1731, align 8
  %1732 = getelementptr i8, ptr %1731, i64 8
  store i64 %.sroa.6.0287.i1404.in.i, ptr %1732, align 4
  %.sroa_idx104.i1416.i = getelementptr i8, ptr %1731, i64 16
  store i64 %.sroa.12.0286.i1405.in.i, ptr %.sroa_idx104.i1416.i, align 4
  %.sroa_idx105.i1417.i = getelementptr i8, ptr %1731, i64 24
  store i32 %.sroa.17.0285.i1406.i, ptr %.sroa_idx105.i1417.i, align 4
  %1733 = icmp ne ptr %1725, @nil_typ
  %1734 = icmp ne ptr %1725, null
  %.not94.i1418.i = and i1 %1733, %1734
  br i1 %.not94.i1418.i, label %.cont.i1423.i, label %1739

.cont.i1423.i:                                    ; preds = %1702
  %1735 = add nuw nsw i32 %.0290.i1401.i, 1
  %1736 = xor i1 %.074289.i1402.i, true
  %hash_coef_ptr.i.i46.i1424.i = getelementptr i8, ptr %1725, i64 8
  %tbl_size_ptr.i.i47.i1425.i = getelementptr i8, ptr %1725, i64 16
  %offset_tbl_ptr.i.i48.i1426.i = getelementptr i8, ptr %1725, i64 40
  %hash_coef.i.i49.i1427.i = load i64, ptr %hash_coef_ptr.i.i46.i1424.i, align 4
  %tbl_size.i.i50.i1428.i = load i64, ptr %tbl_size_ptr.i.i47.i1425.i, align 4
  %offset_tbl.i.i51.i1429.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1426.i, align 8
  %product.i.i.i52.i1430.i = mul i64 %hash_coef.i.i49.i1427.i, 4015701072841558310
  %shifted.i.i.i53.i1431.i = lshr i64 %product.i.i.i52.i1430.i, 32
  %xored.i.i.i54.i1432.i = xor i64 %shifted.i.i.i53.i1431.i, %product.i.i.i52.i1430.i
  %hash.i.i.i55.i1433.i = and i64 %xored.i.i.i54.i1432.i, %tbl_size.i.i50.i1428.i
  %offset_ptr.i.i56.i1434.i = getelementptr i32, ptr %offset_tbl.i.i51.i1429.i, i64 %hash.i.i.i55.i1433.i
  %offset.i.i57.i1435.i = load i32, ptr %offset_ptr.i.i56.i1434.i, align 4
  %1737 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1738 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1436.i = icmp eq i32 %1735, 100
  br i1 %exitcond.not.i1436.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445.i, label %1702

1739:                                             ; preds = %1702
  %1740 = load i32, ptr %1025, align 4
  %1741 = add i32 %1740, 1
  %1742 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1741, ptr %1025, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445.i: ; preds = %1739, %.cont.i1423.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  br label %._crit_edge.i988.i

._crit_edge.i988.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1445.i, %1688
  %indvars.iv.next.i989.i = add nuw nsw i64 %indvars.iv.i986.i, 1
  %exitcond.not.i990.i = icmp eq i64 %indvars.iv.next.i989.i, %wide.trip.count.i985.i
  br i1 %exitcond.not.i990.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.i, label %1688

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.i: ; preds = %._crit_edge.i988.i
  %1743 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  br label %1744

1744:                                             ; preds = %._crit_edge.i1026.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.i
  %indvars.iv.i1024.i = phi i64 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.i ], [ %indvars.iv.next.i1027.i, %._crit_edge.i1026.i ]
  %1745 = shl nuw nsw i64 %indvars.iv.i1024.i, 5
  %1746 = getelementptr i8, ptr %1681, i64 %1745
  %1747 = load ptr, ptr %1746, align 8
  %1748 = icmp ne ptr %1747, @nil_typ
  %1749 = icmp ne ptr %1747, null
  %.not17.i1025.i = and i1 %1748, %1749
  br i1 %.not17.i1025.i, label %1750, label %._crit_edge.i1026.i

1750:                                             ; preds = %1744
  %1751 = getelementptr i8, ptr %1746, i64 8
  %1752 = load i64, ptr %1751, align 4
  %.sroa_idx.i1029.i = getelementptr i8, ptr %1746, i64 16
  %1753 = load i64, ptr %.sroa_idx.i1029.i, align 4
  %hash_coef_ptr.i.i6.i1030.i = getelementptr i8, ptr %1747, i64 8
  %tbl_size_ptr.i.i7.i1031.i = getelementptr i8, ptr %1747, i64 16
  %offset_tbl_ptr.i.i8.i1032.i = getelementptr i8, ptr %1747, i64 40
  %1754 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %2)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  %hash_coef.i.i21.i1463.i = load i64, ptr %hash_coef_ptr.i.i6.i1030.i, align 4, !noalias !476
  %tbl_size.i.i22.i1464.i = load i64, ptr %tbl_size_ptr.i.i7.i1031.i, align 4, !noalias !476
  %offset_tbl.i.i23.i1465.i = load ptr, ptr %offset_tbl_ptr.i.i8.i1032.i, align 8, !noalias !476
  %product.i.i.i24.i1466.i = mul i64 %hash_coef.i.i21.i1463.i, 4015701072841558310
  %shifted.i.i.i25.i1467.i = lshr i64 %product.i.i.i24.i1466.i, 32
  %xored.i.i.i26.i1468.i = xor i64 %shifted.i.i.i25.i1467.i, %product.i.i.i24.i1466.i
  %hash.i.i.i27.i1469.i = and i64 %xored.i.i.i26.i1468.i, %tbl_size.i.i22.i1464.i
  %offset_ptr.i.i28.i1470.i = getelementptr i32, ptr %offset_tbl.i.i23.i1465.i, i64 %hash.i.i.i27.i1469.i
  %offset.i.i29.i1471.i = load i32, ptr %offset_ptr.i.i28.i1470.i, align 4, !noalias !476
  %1755 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1756 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %1757 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1758

1758:                                             ; preds = %.cont.i1494.i, %1750
  %.0290.i1472.i = phi i32 [ 0, %1750 ], [ %1791, %.cont.i1494.i ]
  %.074289.i1473.i = phi i1 [ true, %1750 ], [ %1792, %.cont.i1494.i ]
  %.sroa.0.0288.i1474.i = phi ptr [ %1747, %1750 ], [ %1781, %.cont.i1494.i ]
  %.sroa.6.0287.i1475.in.i = phi i64 [ %1752, %1750 ], [ %1783, %.cont.i1494.i ]
  %.sroa.12.0286.i1476.in.i = phi i64 [ %1753, %1750 ], [ %1784, %.cont.i1494.i ]
  %.sroa.17.0285.i1477.i = phi i32 [ %offset.i.i29.i1471.i, %1750 ], [ %offset.i.i57.i1506.i, %.cont.i1494.i ]
  %.sroa.12.0286.i1476.i = inttoptr i64 %.sroa.12.0286.i1476.in.i to ptr
  %.sroa.6.0287.i1475.i = inttoptr i64 %.sroa.6.0287.i1475.in.i to ptr
  %1759 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288.i1474.i, 0
  %1760 = insertvalue { ptr, ptr, ptr, i32 } %1759, ptr %.sroa.6.0287.i1475.i, 1
  %1761 = insertvalue { ptr, ptr, ptr, i32 } %1760, ptr %.sroa.12.0286.i1476.i, 2
  %1762 = insertvalue { ptr, ptr, ptr, i32 } %1761, i32 %.sroa.17.0285.i1477.i, 3
  %1763 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288.i1474.i)
  %1764 = sext i32 %.sroa.17.0285.i1477.i to i64
  %1765 = getelementptr ptr, ptr %.sroa.0.0288.i1474.i, i64 %1764
  %1766 = getelementptr i8, ptr %1765, i64 64
  %1767 = load ptr, ptr %1766, align 8
  %result.i15.i1478.i = call ptr %1767({ ptr, ptr, ptr, i32 } %1762, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1768 = call i32 %result.i15.i1478.i({ ptr, ptr, ptr, i32 } %1762, { ptr, ptr, ptr, i32 } %1762, ptr nonnull align 8 %0) #53
  %..i1479.i = select i1 %.074289.i1473.i, ptr %1, ptr %3
  %.188.i1480.i = select i1 %.074289.i1473.i, i64 104, i64 112
  %.189.i1481.i = select i1 %.074289.i1473.i, ptr %2, ptr %4
  %.190.i1482.i = select i1 %.074289.i1473.i, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %..i1479.i, align 8
  %1769 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %..i1479.i)
  %1770 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.188.i1480.i
  %1771 = load ptr, ptr %1770, align 8
  store ptr @i32_typ, ptr %.189.i1481.i, align 8
  %result.i14.i1483.i = call ptr %1771({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly align 8 %.189.i1481.i) #46
  %1772 = call i32 %result.i14.i1483.i({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 dereferenceable(8) %..i1479.i, i32 %1768) #53
  %1773 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1774 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 80), i64 %.190.i1482.i
  %1775 = load ptr, ptr %1774, align 8
  %1776 = load ptr, ptr %1775, align 8
  %1777 = call { ptr } %1776(ptr nonnull %result.i35.i) #43
  %.fca.0.extract55.i1484.i = extractvalue { ptr } %1777, 0
  %1778 = sext i32 %1772 to i64
  %1779 = shl nsw i64 %1778, 5
  %1780 = getelementptr i8, ptr %.fca.0.extract55.i1484.i, i64 %1779
  %1781 = load ptr, ptr %1780, align 8
  %1782 = getelementptr i8, ptr %1780, i64 8
  %1783 = load i64, ptr %1782, align 4
  %.sroa_idx.i1485.i = getelementptr i8, ptr %1780, i64 16
  %1784 = load i64, ptr %.sroa_idx.i1485.i, align 4
  %1785 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1786 = call { ptr } %1776(ptr nonnull %result.i35.i) #43
  %.fca.0.extract52.i1486.i = extractvalue { ptr } %1786, 0
  %1787 = getelementptr i8, ptr %.fca.0.extract52.i1486.i, i64 %1779
  store ptr %.sroa.0.0288.i1474.i, ptr %1787, align 8
  %1788 = getelementptr i8, ptr %1787, i64 8
  store i64 %.sroa.6.0287.i1475.in.i, ptr %1788, align 4
  %.sroa_idx104.i1487.i = getelementptr i8, ptr %1787, i64 16
  store i64 %.sroa.12.0286.i1476.in.i, ptr %.sroa_idx104.i1487.i, align 4
  %.sroa_idx105.i1488.i = getelementptr i8, ptr %1787, i64 24
  store i32 %.sroa.17.0285.i1477.i, ptr %.sroa_idx105.i1488.i, align 4
  %1789 = icmp ne ptr %1781, @nil_typ
  %1790 = icmp ne ptr %1781, null
  %.not94.i1489.i = and i1 %1789, %1790
  br i1 %.not94.i1489.i, label %.cont.i1494.i, label %1795

.cont.i1494.i:                                    ; preds = %1758
  %1791 = add nuw nsw i32 %.0290.i1472.i, 1
  %1792 = xor i1 %.074289.i1473.i, true
  %hash_coef_ptr.i.i46.i1495.i = getelementptr i8, ptr %1781, i64 8
  %tbl_size_ptr.i.i47.i1496.i = getelementptr i8, ptr %1781, i64 16
  %offset_tbl_ptr.i.i48.i1497.i = getelementptr i8, ptr %1781, i64 40
  %hash_coef.i.i49.i1498.i = load i64, ptr %hash_coef_ptr.i.i46.i1495.i, align 4
  %tbl_size.i.i50.i1499.i = load i64, ptr %tbl_size_ptr.i.i47.i1496.i, align 4
  %offset_tbl.i.i51.i1500.i = load ptr, ptr %offset_tbl_ptr.i.i48.i1497.i, align 8
  %product.i.i.i52.i1501.i = mul i64 %hash_coef.i.i49.i1498.i, 4015701072841558310
  %shifted.i.i.i53.i1502.i = lshr i64 %product.i.i.i52.i1501.i, 32
  %xored.i.i.i54.i1503.i = xor i64 %shifted.i.i.i53.i1502.i, %product.i.i.i52.i1501.i
  %hash.i.i.i55.i1504.i = and i64 %xored.i.i.i54.i1503.i, %tbl_size.i.i50.i1499.i
  %offset_ptr.i.i56.i1505.i = getelementptr i32, ptr %offset_tbl.i.i51.i1500.i, i64 %hash.i.i.i55.i1504.i
  %offset.i.i57.i1506.i = load i32, ptr %offset_ptr.i.i56.i1505.i, align 4
  %1793 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %1794 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %exitcond.not.i1507.i = icmp eq i32 %1791, 100
  br i1 %exitcond.not.i1507.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516.i, label %1758

1795:                                             ; preds = %1758
  %1796 = load i32, ptr %1025, align 4
  %1797 = add i32 %1796, 1
  %1798 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  store i32 %1797, ptr %1025, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516.i: ; preds = %1795, %.cont.i1494.i
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %2)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  br label %._crit_edge.i1026.i

._crit_edge.i1026.i:                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1516.i, %1744
  %indvars.iv.next.i1027.i = add nuw nsw i64 %indvars.iv.i1024.i, 1
  %exitcond.not.i1028.i = icmp eq i64 %indvars.iv.next.i1027.i, %wide.trip.count.i985.i
  br i1 %exitcond.not.i1028.i, label %CuckooMap_insert_keyK_valueV.exit.i42, label %1744

CuckooMap_insert_keyK_valueV.exit.i42:            ; preds = %._crit_edge.i1026.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32.exit1008.thread.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit557.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i41, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit424.i, %CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i135
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %exitcond.not.i43 = icmp eq i64 %indvars.iv.next.i, 1000000
  br i1 %exitcond.not.i43, label %.lr.ph.i, label %._crit_edge.i15

.lr.ph.i:                                         ; preds = %CuckooMap_insert_keyK_valueV.exit.i42
  %1799 = call i64 @clock()
  %1800 = load <55 x i8>, ptr @lwoib_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  br label %1801

1801:                                             ; preds = %._crit_edge2.i50, %.lr.ph.i
  %.2117.i = phi i32 [ 0, %.lr.ph.i ], [ %1926, %._crit_edge2.i50 ]
  %.0150116.i = phi i64 [ 0, %.lr.ph.i ], [ %.1151.i, %._crit_edge2.i50 ]
  %.0153115.i = phi i1 [ true, %.lr.ph.i ], [ %.1154.i, %._crit_edge2.i50 ]
  %.sroa.0126.0.insert.ext.i = zext nneg i32 %.2117.i to i160
  %1802 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0126.0.insert.ext.i, 1
  %1803 = load ptr, ptr %1020, align 8
  %1804 = call i32 %1803({ ptr, i160 } %1802) #53
  %1805 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %1806 = load i32, ptr %1022, align 8
  %1807 = add i32 %1806, -1
  %1808 = and i32 %1807, %1804
  %1809 = load ptr, ptr %1023, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1810 = sext i32 %1808 to i64
  %1811 = shl nsw i64 %1810, 5
  %1812 = getelementptr i8, ptr %1809, i64 %1811
  %1813 = load ptr, ptr %1812, align 8
  %1814 = icmp ne ptr %1813, @nil_typ
  %1815 = icmp ne ptr %1813, null
  %.not45.i.i44 = and i1 %1814, %1815
  br i1 %.not45.i.i44, label %1816, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i45

1816:                                             ; preds = %1801
  %1817 = getelementptr i8, ptr %1812, i64 8
  %1818 = load i64, ptr %1817, align 4
  %.sroa_idx.i622.i = getelementptr i8, ptr %1812, i64 16
  %1819 = load i64, ptr %.sroa_idx.i622.i, align 4
  %1820 = inttoptr i64 %1818 to ptr
  %1821 = inttoptr i64 %1819 to ptr
  %hash_coef_ptr.i.i4.i.i70 = getelementptr i8, ptr %1813, i64 8
  %tbl_size_ptr.i.i5.i.i71 = getelementptr i8, ptr %1813, i64 16
  %offset_tbl_ptr.i.i6.i.i72 = getelementptr i8, ptr %1813, i64 40
  %hash_coef.i.i7.i.i73 = load i64, ptr %hash_coef_ptr.i.i4.i.i70, align 4, !noalias !479
  %tbl_size.i.i8.i.i74 = load i64, ptr %tbl_size_ptr.i.i5.i.i71, align 4, !noalias !479
  %offset_tbl.i.i9.i.i75 = load ptr, ptr %offset_tbl_ptr.i.i6.i.i72, align 8, !noalias !479
  %product.i.i.i10.i.i76 = mul i64 %hash_coef.i.i7.i.i73, 4015701072841558310
  %shifted.i.i.i11.i.i77 = lshr i64 %product.i.i.i10.i.i76, 32
  %xored.i.i.i12.i.i78 = xor i64 %shifted.i.i.i11.i.i77, %product.i.i.i10.i.i76
  %hash.i.i.i13.i.i79 = and i64 %xored.i.i.i12.i.i78, %tbl_size.i.i8.i.i74
  %offset_ptr.i.i14.i.i80 = getelementptr i32, ptr %offset_tbl.i.i9.i.i75, i64 %hash.i.i.i13.i.i79
  %offset.i.i15.i.i81 = load i32, ptr %offset_ptr.i.i14.i.i80, align 4, !noalias !479
  %1822 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1813, 0
  %1823 = insertvalue { ptr, ptr, ptr, i32 } %1822, ptr %1820, 1
  %1824 = insertvalue { ptr, ptr, ptr, i32 } %1823, ptr %1821, 2
  %1825 = insertvalue { ptr, ptr, ptr, i32 } %1824, i32 %offset.i.i15.i.i81, 3
  %1826 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1827 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1813) #40
  %1828 = sext i32 %offset.i.i15.i.i81 to i64
  %1829 = getelementptr ptr, ptr %1813, i64 %1828
  %1830 = getelementptr i8, ptr %1829, i64 64
  %1831 = load ptr, ptr %1830, align 8
  %result.i2.i623.i = call ptr %1831({ ptr, ptr, ptr, i32 } %1825, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1832 = call i32 %result.i2.i623.i({ ptr, ptr, ptr, i32 } %1825, { ptr, ptr, ptr, i32 } %1825, ptr nonnull align 8 %0) #53
  %1833 = icmp eq i32 %1832, %1804
  br i1 %1833, label %._crit_edge.i624.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i45

._crit_edge.i624.i:                               ; preds = %1816
  %1834 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1835 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1813)
  %1836 = getelementptr i8, ptr %1829, i64 48
  %1837 = load ptr, ptr %1836, align 8
  %result.i1.i625.i = call ptr %1837({ ptr, ptr, ptr, i32 } %1825, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1838 = call { ptr, i160 } %result.i1.i625.i({ ptr, ptr, ptr, i32 } %1825, { ptr, ptr, ptr, i32 } %1825, ptr nonnull align 8 %0) #53
  %1839 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1840 = load ptr, ptr %1021, align 8
  %1841 = call i1 %1840({ ptr, i160 } %1838, { ptr, i160 } %1802) #53
  br i1 %1841, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i82, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i45

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i45: ; preds = %._crit_edge.i624.i, %1816, %1801
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1850

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i82: ; preds = %._crit_edge.i624.i
  %1842 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1843 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1813)
  %1844 = getelementptr i8, ptr %1829, i64 56
  %1845 = load ptr, ptr %1844, align 8
  %result.i.i626.i = call ptr %1845({ ptr, ptr, ptr, i32 } %1825, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1846 = call { ptr, i160 } %result.i.i626.i({ ptr, ptr, ptr, i32 } %1825, { ptr, ptr, ptr, i32 } %1825, ptr nonnull align 8 %0) #53
  %.fca.0.extract22.i.i83 = extractvalue { ptr, i160 } %1846, 0
  %.fca.1.extract23.i.i84 = extractvalue { ptr, i160 } %1846, 1
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1847 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1848 = icmp ne ptr %.fca.0.extract22.i.i83, @nil_typ
  %1849 = icmp ne ptr %.fca.0.extract22.i.i83, null
  %.not63.i.i85 = and i1 %1848, %1849
  %extract.t713.i = trunc i160 %.fca.1.extract23.i.i84 to i64
  br i1 %.not63.i.i85, label %CuckooMap_get_keyK.exit.i46, label %1850

1850:                                             ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i82, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.thread.i45
  %1851 = add i32 %1804, 2127912214
  %1852 = shl i32 %1804, 12
  %1853 = add i32 %1851, %1852
  %1854 = ashr i32 %1853, 19
  %1855 = xor i32 %1853, %1854
  %1856 = xor i32 %1855, -949894596
  %1857 = add i32 %1856, 374761393
  %1858 = shl i32 %1856, 5
  %1859 = add i32 %1857, %1858
  %1860 = add i32 %1859, -744332180
  %1861 = shl i32 %1859, 9
  %1862 = xor i32 %1860, %1861
  %1863 = add i32 %1862, -42973499
  %1864 = shl i32 %1862, 3
  %1865 = add i32 %1863, %1864
  %1866 = ashr i32 %1865, 16
  %1867 = xor i32 %1865, %1866
  %1868 = xor i32 %1867, -1252372727
  %1869 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1870 = load i32, ptr %1022, align 8
  %1871 = add i32 %1870, -1
  %1872 = and i32 %1871, %1868
  %1873 = load ptr, ptr %1024, align 8
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1874 = sext i32 %1872 to i64
  %1875 = shl nsw i64 %1874, 5
  %1876 = getelementptr i8, ptr %1873, i64 %1875
  %1877 = load ptr, ptr %1876, align 8
  %1878 = icmp ne ptr %1877, @nil_typ
  %1879 = icmp ne ptr %1877, null
  %.not45.i657.i = and i1 %1878, %1879
  br i1 %.not45.i657.i, label %1880, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i

1880:                                             ; preds = %1850
  %1881 = getelementptr i8, ptr %1876, i64 8
  %1882 = load i64, ptr %1881, align 4
  %.sroa_idx.i662.i = getelementptr i8, ptr %1876, i64 16
  %1883 = load i64, ptr %.sroa_idx.i662.i, align 4
  %1884 = inttoptr i64 %1882 to ptr
  %1885 = inttoptr i64 %1883 to ptr
  %hash_coef_ptr.i.i4.i663.i = getelementptr i8, ptr %1877, i64 8
  %tbl_size_ptr.i.i5.i664.i = getelementptr i8, ptr %1877, i64 16
  %offset_tbl_ptr.i.i6.i665.i = getelementptr i8, ptr %1877, i64 40
  %hash_coef.i.i7.i666.i = load i64, ptr %hash_coef_ptr.i.i4.i663.i, align 4, !noalias !482
  %tbl_size.i.i8.i667.i = load i64, ptr %tbl_size_ptr.i.i5.i664.i, align 4, !noalias !482
  %offset_tbl.i.i9.i668.i = load ptr, ptr %offset_tbl_ptr.i.i6.i665.i, align 8, !noalias !482
  %product.i.i.i10.i669.i = mul i64 %hash_coef.i.i7.i666.i, 4015701072841558310
  %shifted.i.i.i11.i670.i = lshr i64 %product.i.i.i10.i669.i, 32
  %xored.i.i.i12.i671.i = xor i64 %shifted.i.i.i11.i670.i, %product.i.i.i10.i669.i
  %hash.i.i.i13.i672.i = and i64 %xored.i.i.i12.i671.i, %tbl_size.i.i8.i667.i
  %offset_ptr.i.i14.i673.i = getelementptr i32, ptr %offset_tbl.i.i9.i668.i, i64 %hash.i.i.i13.i672.i
  %offset.i.i15.i674.i = load i32, ptr %offset_ptr.i.i14.i673.i, align 4, !noalias !482
  %1886 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1877, 0
  %1887 = insertvalue { ptr, ptr, ptr, i32 } %1886, ptr %1884, 1
  %1888 = insertvalue { ptr, ptr, ptr, i32 } %1887, ptr %1885, 2
  %1889 = insertvalue { ptr, ptr, ptr, i32 } %1888, i32 %offset.i.i15.i674.i, 3
  %1890 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1891 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1877) #40
  %1892 = sext i32 %offset.i.i15.i674.i to i64
  %1893 = getelementptr ptr, ptr %1877, i64 %1892
  %1894 = getelementptr i8, ptr %1893, i64 64
  %1895 = load ptr, ptr %1894, align 8
  %result.i2.i675.i = call ptr %1895({ ptr, ptr, ptr, i32 } %1889, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1896 = call i32 %result.i2.i675.i({ ptr, ptr, ptr, i32 } %1889, { ptr, ptr, ptr, i32 } %1889, ptr nonnull align 8 %0) #53
  %1897 = icmp eq i32 %1896, %1804
  br i1 %1897, label %._crit_edge.i676.i, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i

._crit_edge.i676.i:                               ; preds = %1880
  %1898 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1899 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1877)
  %1900 = getelementptr i8, ptr %1893, i64 48
  %1901 = load ptr, ptr %1900, align 8
  %result.i1.i677.i = call ptr %1901({ ptr, ptr, ptr, i32 } %1889, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1902 = call { ptr, i160 } %result.i1.i677.i({ ptr, ptr, ptr, i32 } %1889, { ptr, ptr, ptr, i32 } %1889, ptr nonnull align 8 %0) #53
  %1903 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %1904 = load ptr, ptr %1021, align 8
  %1905 = call i1 %1904({ ptr, i160 } %1902, { ptr, i160 } %1802) #53
  br i1 %1905, label %1906, label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i

1906:                                             ; preds = %._crit_edge.i676.i
  %1907 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1908 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %1877)
  %1909 = getelementptr i8, ptr %1893, i64 56
  %1910 = load ptr, ptr %1909, align 8
  %result.i.i679.i = call ptr %1910({ ptr, ptr, ptr, i32 } %1889, ptr nocapture nofree noundef nonnull readonly align 8 %0) #46
  %1911 = call { ptr, i160 } %result.i.i679.i({ ptr, ptr, ptr, i32 } %1889, { ptr, ptr, ptr, i32 } %1889, ptr nonnull align 8 %0) #53
  %.fca.0.extract22.i680.i = extractvalue { ptr, i160 } %1911, 0
  %.fca.1.extract23.i681.i = extractvalue { ptr, i160 } %1911, 1
  %1912 = trunc i160 %.fca.1.extract23.i681.i to i64
  br label %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i

CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i: ; preds = %1906, %._crit_edge.i676.i, %1880, %1850
  %.reg2mem43.sroa.3.0.i658.i = phi i64 [ %1912, %1906 ], [ poison, %._crit_edge.i676.i ], [ poison, %1850 ], [ poison, %1880 ]
  %.reg2mem41.0.i659.i = phi ptr [ %.fca.0.extract22.i680.i, %1906 ], [ @nil_typ, %._crit_edge.i676.i ], [ @nil_typ, %1850 ], [ @nil_typ, %1880 ]
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1913 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.not.i178.i = icmp eq ptr %.reg2mem41.0.i659.i, null
  %1914 = select i1 %.not.i178.i, ptr @nil_typ, ptr %.reg2mem41.0.i659.i
  br label %CuckooMap_get_keyK.exit.i46

CuckooMap_get_keyK.exit.i46:                      ; preds = %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i82
  %.not63.i712.off0.i = phi i64 [ %.reg2mem43.sroa.3.0.i658.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i ], [ %extract.t713.i, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i82 ]
  %.reg2mem56.0.i.i47 = phi ptr [ %1914, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit682.i ], [ %.fca.0.extract22.i.i83, %CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil.exit.i82 ]
  %1915 = icmp ne ptr %.reg2mem56.0.i.i47, @nil_typ
  %1916 = icmp ne ptr %.reg2mem56.0.i.i47, null
  %.not159.i = and i1 %1915, %1916
  br i1 %.not159.i, label %1917, label %._crit_edge.lr.ph.i.i

1917:                                             ; preds = %CuckooMap_get_keyK.exit.i46
  %sext.i = shl i64 %.not63.i712.off0.i, 32
  %1918 = ashr exact i64 %sext.i, 32
  %1919 = add i64 %1918, %.0150116.i
  br label %._crit_edge2.i50

._crit_edge.lr.ph.i.i:                            ; preds = %CuckooMap_get_keyK.exit.i46
  %result.i32.i48 = call noalias dereferenceable_or_null(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store <55 x i8> %1800, ptr %result.i32.i48, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1920 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1921 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i743.i = call noalias dereferenceable_or_null(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(56) %result.i.i743.i, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(56) %result.i32.i48, i64 noundef 55, i1 noundef false)
  %1922 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1923 = getelementptr i8, ptr %result.i.i743.i, i64 55
  store i8 0, ptr %1923, align 1
  %puts.i.i49 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(56) %result.i.i743.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1924 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1925 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2117.i) #55
  br label %._crit_edge2.i50

._crit_edge2.i50:                                 ; preds = %._crit_edge.lr.ph.i.i, %1917
  %.1154.i = phi i1 [ %.0153115.i, %1917 ], [ false, %._crit_edge.lr.ph.i.i ]
  %.1151.i = phi i64 [ %1919, %1917 ], [ %.0150116.i, %._crit_edge.lr.ph.i.i ]
  %1926 = add nuw nsw i32 %.2117.i, 1
  %exitcond129.not.i = icmp eq i32 %1926, 1000000
  br i1 %exitcond129.not.i, label %._crit_edge.lr.ph.i536, label %1801

._crit_edge.lr.ph.i536:                           ; preds = %._crit_edge2.i50
  %1927 = call i64 @clock()
  %result.i30.i51 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #48
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i30.i51, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1928 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1929 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i758.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(19) %result.i.i758.i, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(19) %result.i30.i51, i64 noundef 18, i1 noundef false)
  %1930 = sub i64 %1927, %1799
  %1931 = getelementptr i8, ptr %result.i.i758.i, i64 18
  store i8 0, ptr %1931, align 1
  %puts.i278.i = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i758.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %result.i28.i.i52 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i28.i.i52, align 1
  %result.i.i.i.i53 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(15) %result.i.i.i.i53, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(15) %result.i28.i.i52, i64 noundef 14, i1 noundef false)
  %1932 = getelementptr i8, ptr %result.i.i.i.i53, i64 14
  store i8 0, ptr %1932, align 1
  %puts.i.i.i54 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i.i.i53) #53
  %1933 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 noundef 1000000) #55
  %result.i26.i.i55 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i26.i.i55, align 1
  %result.i.i304.i.i56 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_wrapper(i64 noundef 15) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(15) %result.i.i304.i.i56, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(15) %result.i26.i.i55, i64 noundef 14, i1 noundef false)
  %1934 = getelementptr i8, ptr %result.i.i304.i.i56, i64 14
  store i8 0, ptr %1934, align 1
  %puts.i229.i.i57 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(15) %result.i.i304.i.i56) #53
  %1935 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1930) #55
  %result.i24.i.i58 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i24.i.i58, align 1
  %result.i.i324.i.i59 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(4) %result.i.i324.i.i59, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(4) %result.i24.i.i58, i64 noundef 3, i1 noundef false)
  %1936 = getelementptr i8, ptr %result.i.i324.i.i59, i64 3
  store i8 0, ptr %1936, align 1
  %puts.i249.i.i60 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i324.i.i59) #53
  %result.i22.i.i61 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i22.i.i61, align 1
  %result.i.i344.i.i62 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(16) %result.i.i344.i.i62, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(16) %result.i22.i.i61, i64 noundef 15, i1 noundef false)
  %1937 = mul i64 %1930, 1000000
  %1938 = sdiv i64 %1937, 1000000
  %1939 = getelementptr i8, ptr %result.i.i344.i.i62, i64 15
  store i8 0, ptr %1939, align 1
  %puts.i269.i.i63 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(16) %result.i.i344.i.i62) #53
  %1940 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1938) #55
  %result.i20.i.i64 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i20.i.i64, align 1
  %result.i.i364.i.i65 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_wrapper(i64 noundef 4) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(4) %result.i.i364.i.i65, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(4) %result.i20.i.i64, i64 noundef 3, i1 noundef false)
  %1941 = getelementptr i8, ptr %result.i.i364.i.i65, i64 3
  store i8 0, ptr %1941, align 1
  %puts.i289.i.i66 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i364.i.i65) #53
  %.not.i = icmp eq i64 %.1151.i, 500000500000
  %result.i28.i67 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #48
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i28.i67, align 1
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1942 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i778.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_wrapper(i64 noundef 19) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(19) %result.i.i778.i, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(19) %result.i28.i67, i64 noundef 18, i1 noundef false)
  %spec.select.i = select i1 %.not.i, i1 %.1154.i, i1 false
  %1944 = getelementptr i8, ptr %result.i.i778.i, i64 18
  store i8 0, ptr %1944, align 1
  %puts.i299.i = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(19) %result.i.i778.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %..i68 = select i1 %spec.select.i, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.194.i69 = select i1 %spec.select.i, ptr %33, ptr %37
  %.195.i = select i1 %spec.select.i, ptr %34, ptr %38
  %.196.i = select i1 %spec.select.i, ptr %35, ptr %39
  %.197.i = select i1 %spec.select.i, ptr %36, ptr %40
  store ptr @_parameterization_Bufferi8, ptr %.194.i69, align 8
  %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select.i, ptr %33, ptr %37
  %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.194.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select.i, ptr %33, ptr %37
  %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @_parameterization_i32, ptr %.194.sroa.sel206.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1945 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.194.i69)
  store ptr @buffer_typ, ptr %.195.i, align 8
  %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select.i, ptr %34, ptr %38
  %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.195.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %spec.select.i, ptr %34, ptr %38
  %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  store ptr @i32_typ, ptr %.195.sroa.sel201.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.i.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1946 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %.195.i) #40
  store ptr @_parameterization_String, ptr %.196.i, align 8
  %1947 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.196.i)
  %1948 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  store ptr @String, ptr %.197.i, align 8
  %1949 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %.197.i) #40
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1950 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1951 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i798.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_wrapper(i64 noundef 5) #48
  store <4 x i8> %..i68, ptr %result.i.i798.i, align 1
  %1952 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1953 = getelementptr i8, ptr %result.i.i798.i, i64 4
  store i8 0, ptr %1953, align 1
  %puts.i320.i = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i798.i) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %33)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %35)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %37)
  call void @llvm.lifetime.end.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %38)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  call void @llvm.lifetime.end.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  call void @benchmark_get_random_hit(i32 noundef 1000000)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %result.i7 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_wrapper(i64 noundef 28) #48
  store <27 x i8> <i8 45, i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %result.i7, align 1
  %1954 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1955 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #40
  %1956 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %0) #40
  %result.i.i535 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_wrapper(i64 noundef 28) #48
  call void @llvm.memcpy.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 1 dereferenceable(28) %result.i.i535, ptr nocapture nofree noundef nonnull readonly align 1 dereferenceable(28) %result.i7, i64 noundef 27, i1 noundef false)
  %1957 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %1958 = getelementptr i8, ptr %result.i.i535, i64 27
  store i8 0, ptr %1958, align 1
  %puts.i357 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(28) %result.i.i535) #53
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_bool_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @IO_B__Self_print_xBool__Self_print_xi32__Self_print_xf64__Self_print_xi8__Self_print_xi64__Self_print_xNil__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xString(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #32 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #40
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i6 = call i1 %10(i64 %9, i64 %8, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %11) #44
  br i1 %result.i6, label %12, label %.critedge

12:                                               ; preds = %1
  %result.i5 = call i1 %10(i64 %9, i64 %8, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %11) #44
  br i1 %result.i5, label %.critedge, label %13

13:                                               ; preds = %12
  %result.i4 = call i1 %10(i64 %9, i64 %8, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %11) #44
  br i1 %result.i4, label %.critedge, label %27

.critedge:                                        ; preds = %13, %12, %1
  %result.i3 = call i1 %10(i64 %9, i64 %8, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %11) #44
  br i1 %result.i3, label %14, label %.critedge15

14:                                               ; preds = %.critedge
  %result.i2 = call i1 %10(i64 %9, i64 %8, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %11) #44
  br i1 %result.i2, label %.critedge15, label %27

.critedge15:                                      ; preds = %14, %.critedge
  %15 = icmp eq ptr %3, @i32_typ
  br i1 %15, label %27, label %16

16:                                               ; preds = %.critedge15
  %17 = icmp eq ptr %3, @nil_typ
  %18 = icmp eq ptr %3, null
  %19 = or i1 %17, %18
  br i1 %19, label %27, label %20

20:                                               ; preds = %16
  %21 = icmp eq ptr %3, @bool_typ
  br i1 %21, label %27, label %22

22:                                               ; preds = %20
  %23 = icmp eq ptr %3, @f64_typ
  br i1 %23, label %27, label %24

24:                                               ; preds = %22
  %result.i1 = call i1 %10(i64 %9, i64 %8, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %11) #44
  %result.i1.not = xor i1 %result.i1, true
  %brmerge = or i1 %result.i3, %result.i1.not
  br i1 %brmerge, label %.critedge17, label %27

.critedge17:                                      ; preds = %24
  %25 = icmp eq ptr %3, @i64_typ
  %26 = select i1 %25, i64 5, i64 4
  br label %27

27:                                               ; preds = %.critedge17, %24, %22, %20, %16, %.critedge15, %14, %13
  %.reg2mem27.0 = phi i64 [ 2, %.critedge15 ], [ 6, %16 ], [ 1, %20 ], [ 3, %22 ], [ %26, %.critedge17 ], [ 7, %14 ], [ 8, %13 ], [ 9, %24 ]
  %28 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %.reg2mem27.0
  %29 = getelementptr i8, ptr %28, i64 80
  %30 = load ptr, ptr %29, align 8
  ret ptr %30
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xBool(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %result.i.i49.h2s61 = alloca [6 x i8], align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(6) %result.i.i49.h2s61, i8 0, i64 6, i1 false)
  %result.i.i.h2s63 = alloca [5 x i8], align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(5) %result.i.i.h2s63, i8 0, i64 5, i1 false)
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %3 = trunc i160 %.fca.1.extract to i1
  br i1 %3, label %._crit_edge.lr.ph.i, label %._crit_edge.lr.ph.i50

._crit_edge.lr.ph.i:                              ; preds = %2
  store i32 1702195828, ptr %result.i.i.h2s63, align 4
  br label %String_c_string_.exit

._crit_edge.lr.ph.i50:                            ; preds = %2
  store <5 x i8> <i8 102, i8 97, i8 108, i8 115, i8 101>, ptr %result.i.i49.h2s61, align 8
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %._crit_edge.lr.ph.i50, %._crit_edge.lr.ph.i
  %4 = phi i64 [ 4, %._crit_edge.lr.ph.i ], [ 5, %._crit_edge.lr.ph.i50 ]
  %result.i.i49.sink = phi ptr [ %result.i.i.h2s63, %._crit_edge.lr.ph.i ], [ %result.i.i49.h2s61, %._crit_edge.lr.ph.i50 ]
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #58
  %6 = getelementptr i8, ptr %result.i.i49.sink, i64 %4
  store i8 0, ptr %6, align 1
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(5) %result.i.i49.sink) #53
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #55
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #55
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %sext = shl i32 %.sroa.1.8.extract.trunc, 24
  %3 = ashr exact i32 %sext, 24
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #55
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #55
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #25 {
._crit_edge.lr.ph.i:
  %result.i.i.h2s17 = alloca [4 x i8], align 4
  store <3 x i8> <i8 110, i8 105, i8 108>, ptr %result.i.i.h2s17, align 4
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #58
  %3 = getelementptr inbounds i8, ptr %result.i.i.h2s17, i64 3
  store i8 0, ptr %3, align 1
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(4) %result.i.i.h2s17) #53
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #28 {
  %3 = alloca [0 x ptr], align 8
  %.h2s1 = alloca [2 x i8], align 1
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !485
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !485
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !485
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !485
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #40
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 16
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %16 = call i8 %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #53
  store i8 %16, ptr %.h2s1, align 1
  %17 = getelementptr inbounds i8, ptr %.h2s1, i64 1
  store i8 0, ptr %17, align 1
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(2) %.h2s1) #53
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #28 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.317.8.extract.trunc = trunc i160 %.fca.1.extract3 to i64
  %4 = inttoptr i64 %.sroa.317.8.extract.trunc to ptr
  %.sroa.518.8.extract.shift = lshr i160 %.fca.1.extract3, 64
  %.sroa.518.8.extract.trunc = trunc i160 %.sroa.518.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.518.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !488
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !488
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !488
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260840641129990118
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !488
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #40
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract2, i64 %12
  %14 = load ptr, ptr %13, align 8
  %result.i1 = call ptr %14({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %15 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #53
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !491
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !491
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !491
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 6499063144389013426
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i14 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !491
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i14, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract1)
  %22 = sext i32 %offset.i.i14 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract1, i64 %22
  %24 = getelementptr i8, ptr %23, i64 80
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %26 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %3) #53
  %.fca.0.extract = extractvalue { ptr } %26, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #53
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #28 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !494
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !494
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !494
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !494
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #40
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract1, i64 %12
  %14 = getelementptr i8, ptr %13, i64 80
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #53
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #53
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #25

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @String_field_String_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #40
  ret ptr @String__Self_from_c_string_c_stringBufferi8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferi8_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_xi8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_extend_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 54, i64 53
  %8 = getelementptr [149 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 57, %.critedge ], [ 56, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [149 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 58, i64 59
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [149 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 61, %.critedge ], [ 60, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [149 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 63, i64 62
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [149 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree readnone %0, { ptr } %1) #34 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %2
  %.0 = phi i32 [ 0, %2 ], [ %.1, %._crit_edge ]
  %3 = sext i32 %.0 to i64
  %4 = getelementptr i8, ptr %.fca.0.extract, i64 %3
  %5 = load i8, ptr %4, align 1
  %.not = icmp ne i8 %5, 0
  %6 = zext i1 %.not to i32
  %.1 = add i32 %.0, %6
  br i1 %.not, label %._crit_edge, label %7

7:                                                ; preds = %._crit_edge
  %result.i2 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %8 = add i32 %.1, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 10, 3
  store ptr %.fca.0.extract, ptr %result.i2, align 8
  %12 = getelementptr i8, ptr %result.i2, i64 8
  store i32 %.1, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  %14 = getelementptr i8, ptr %result.i2, i64 12
  store i32 %8, ptr %14, align 4
  ret { ptr, ptr, ptr, i32 } %11
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !497
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !497
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !497
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !497
  %result.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #48
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %9(ptr %.fca.1.extract, { ptr } %10) #42
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %12 = getelementptr i8, ptr %6, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 1) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !500
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !500
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !500
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !500
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %14 = getelementptr i8, ptr %8, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 %4) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %19 = load ptr, ptr %14, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %.fca.1.extract) #43
  %22 = sext i32 %21 to i64
  %result.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %22) #48
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %24 = load ptr, ptr %8, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %26(ptr %.fca.1.extract, { ptr } %27) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_bytesBufferi8_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #5 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !503
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !503
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !503
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !503
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract2, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, { ptr } %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 %4) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 %5) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !506
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !506
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !506
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !506
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !509
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !509
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !509
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !509
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  %11 = add i32 %10, 1
  %12 = sext i32 %11 to i64
  %result.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %12) #48
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #43
  %17 = icmp sgt i32 %16, 0
  br i1 %17, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %19 = load ptr, ptr %6, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call { ptr } %20(ptr %.fca.1.extract) #43
  %.fca.0.extract19 = extractvalue { ptr } %21, 0
  %22 = getelementptr i8, ptr %.fca.0.extract19, i64 %indvars.iv
  %23 = load i8, ptr %22, align 1
  %24 = getelementptr i8, ptr %result.i, i64 %indvars.iv
  store i8 %23, ptr %24, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract) #43
  %28 = sext i32 %27 to i64
  %29 = icmp slt i64 %indvars.iv.next, %28
  br i1 %29, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %30 = phi ptr [ %15, %3 ], [ %26, %._crit_edge ]
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %32 = call i32 %30(ptr %.fca.1.extract) #43
  %33 = sext i32 %32 to i64
  %34 = getelementptr i8, ptr %result.i, i64 %33
  store i8 0, ptr %34, align 1
  %35 = insertvalue { ptr } undef, ptr %result.i, 0
  ret { ptr } %35
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @String_append_xi8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) #28 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !512
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !512
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !512
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !512
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #40
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %.fca.1.extract) #43
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %.pre28 = insertvalue { ptr, ptr, ptr, i32 } %.pre27, ptr %.fca.1.extract, 1
  %.pre30 = insertvalue { ptr, ptr, ptr, i32 } %.pre28, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %21 = call i32 %17(ptr %.fca.1.extract) #43
  %22 = shl i32 %21, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #58
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %29 = getelementptr i8, ptr %9, i64 104
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %22) #53
  %.pre = load ptr, ptr %10, align 8
  %.pre26 = load ptr, ptr %.pre, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %19, %.._crit_edge_crit_edge
  %.pre-phi31 = phi { ptr, ptr, ptr, i32 } [ %.pre30, %.._crit_edge_crit_edge ], [ %25, %19 ]
  %31 = phi ptr [ %12, %.._crit_edge_crit_edge ], [ %.pre26, %19 ]
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %33 = call i32 %31(ptr %.fca.1.extract) #43
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %35 = load ptr, ptr %9, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call { ptr } %36(ptr %.fca.1.extract) #43
  %.fca.0.extract7 = extractvalue { ptr } %37, 0
  %38 = sext i32 %33 to i64
  %39 = getelementptr i8, ptr %.fca.0.extract7, i64 %38
  store i8 %3, ptr %39, align 1
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %41 = load ptr, ptr %10, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %.fca.1.extract) #43
  %44 = add i32 %43, 1
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %46 = getelementptr i8, ptr %41, i64 8
  %47 = load ptr, ptr %46, align 8
  call void %47(ptr %.fca.1.extract, i32 %44) #42
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !515
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !515
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !515
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 6499063144389013426
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !515
  %48 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi31, i32 %offset.i.i13, 3
  ret { ptr, ptr, ptr, i32 } %48
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @String_extend_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #28 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !518
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !518
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !518
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !518
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i6 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i8 = load i64, ptr %hash_coef_ptr.i.i5, align 4, !noalias !521
  %tbl_size.i.i9 = load i64, ptr %tbl_size_ptr.i.i6, align 4, !noalias !521
  %offset_tbl.i.i10 = load ptr, ptr %offset_tbl_ptr.i.i7, align 8, !noalias !521
  %product.i.i.i11 = mul i64 %hash_coef.i.i8, 6499063144389013426
  %shifted.i.i.i12 = lshr i64 %product.i.i.i11, 32
  %xored.i.i.i13 = xor i64 %shifted.i.i.i12, %product.i.i.i11
  %hash.i.i.i14 = and i64 %xored.i.i.i13, %tbl_size.i.i9
  %offset_ptr.i.i15 = getelementptr i32, ptr %offset_tbl.i.i10, i64 %hash.i.i.i14
  %offset.i.i16 = load i32, ptr %offset_ptr.i.i15, align 4, !noalias !521
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.1.extract, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.2.extract, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %offset.i.i16, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #40
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %16 = sext i32 %offset.i.i16 to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract, i64 %16
  %18 = getelementptr i8, ptr %17, i64 64
  %19 = load ptr, ptr %18, align 8
  %result.i3 = call ptr %19({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %20 = call i32 %result.i3({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 %5) #53
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %22 = sext i32 %offset.i.i to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract11, i64 %22
  %24 = getelementptr i8, ptr %23, i64 8
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract12) #43
  %28 = add i32 %27, %20
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.1.extract12, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.2.extract13, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i, 3
  %33 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %36 = getelementptr i8, ptr %23, i64 104
  %37 = load ptr, ptr %36, align 8
  %38 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %38, align 8
  %result.i2 = call ptr %37({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly align 8 %38) #46
  call void %result.i2({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 dereferenceable(8) %33, i32 %28) #53
  %39 = getelementptr inbounds i8, ptr %8, i64 8
  %40 = getelementptr inbounds i8, ptr %9, i64 8
  %41 = icmp sgt i32 %20, 0
  br i1 %41, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %4
  %42 = getelementptr i8, ptr %17, i64 120
  %43 = getelementptr i8, ptr %23, i64 128
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.051 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %52, %._crit_edge ]
  %44 = add i32 %.051, %27
  store ptr @_parameterization_i32, ptr %6, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %47 = load ptr, ptr %42, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i1 = call ptr %47({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly %7) #46
  %48 = call i8 %result.i1({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 dereferenceable(8) %6, i32 %.051) #53
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr @_parameterization_i8, ptr %39, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract11)
  %51 = load ptr, ptr %43, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr @i8_typ, ptr %40, align 8
  %result.i = call ptr %51({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %9) #46
  call void %result.i({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 dereferenceable(16) %8, i32 %44, i8 %48) #53
  %52 = add nuw nsw i32 %.051, 1
  %exitcond.not = icmp eq i32 %52, %20
  br i1 %exitcond.not, label %._crit_edge1._crit_edge, label %._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract11)
  %54 = load ptr, ptr %24, align 8
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  call void %56(ptr %.fca.1.extract12, i32 %28) #42
  %hash_coef.i.i22 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !524
  %tbl_size.i.i23 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !524
  %offset_tbl.i.i24 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !524
  %product.i.i.i25 = mul i64 %hash_coef.i.i22, 6499063144389013426
  %shifted.i.i.i26 = lshr i64 %product.i.i.i25, 32
  %xored.i.i.i27 = xor i64 %shifted.i.i.i26, %product.i.i.i25
  %hash.i.i.i28 = and i64 %xored.i.i.i27, %tbl_size.i.i23
  %offset_ptr.i.i29 = getelementptr i32, ptr %offset_tbl.i.i24, i64 %hash.i.i.i28
  %offset.i.i30 = load i32, ptr %offset_ptr.i.i29, align 4, !noalias !524
  %57 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i30, 3
  ret { ptr, ptr, ptr, i32 } %57
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #43
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %.loopexit

12:                                               ; preds = %4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 %3) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr } %18(ptr %.fca.1.extract) #43
  %.fca.0.extract20 = extractvalue { ptr } %19, 0
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call i32 %22(ptr %.fca.1.extract) #43
  %24 = sext i32 %23 to i64
  %result.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %24) #48
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %26 = load ptr, ptr %7, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %28(ptr %.fca.1.extract, { ptr } %29) #42
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract) #43
  %35 = icmp sgt i32 %34, 0
  br i1 %35, label %._crit_edge.lr.ph, label %.loopexit

._crit_edge.lr.ph:                                ; preds = %12
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %37 = getelementptr i8, ptr %.fca.0.extract20, i64 %indvars.iv
  %38 = load i8, ptr %37, align 1
  %39 = load ptr, ptr %7, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call { ptr } %40(ptr %.fca.1.extract) #43
  %.fca.0.extract6 = extractvalue { ptr } %41, 0
  %42 = getelementptr i8, ptr %.fca.0.extract6, i64 %indvars.iv
  store i8 %38, ptr %42, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %43 = load ptr, ptr %31, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call i32 %44(ptr %.fca.1.extract) #43
  %46 = sext i32 %45 to i64
  %47 = icmp slt i64 %indvars.iv.next, %46
  br i1 %47, label %._crit_edge, label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %12, %4
  ret void
}

; Function Attrs: nounwind
define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #28 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !527
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !527
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !527
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !527
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !530
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !530
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !530
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 6499063144389013426
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i14 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !530
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract2, i64 %9
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract3) #43
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %offset.i.i14, 3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #58
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #58
  %21 = sext i32 %offset.i.i14 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract, i64 %21
  %23 = getelementptr i8, ptr %22, i64 64
  %24 = load ptr, ptr %23, align 8
  %result.i1 = call ptr %24({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %25 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %5) #53
  %.not = icmp eq i32 %14, %25
  br i1 %.not, label %.preheader.preheader, label %.loopexit

.preheader.preheader:                             ; preds = %4
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract2)
  %27 = getelementptr i8, ptr %22, i64 120
  br label %.preheader

.preheader:                                       ; preds = %32, %.preheader.preheader
  %indvars.iv = phi i64 [ 0, %.preheader.preheader ], [ %indvars.iv.next, %32 ]
  %28 = load ptr, ptr %11, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %.fca.1.extract3) #43
  %31 = sext i32 %30 to i64
  %.not25.not.not.not.not.not = icmp sge i64 %indvars.iv, %31
  br i1 %.not25.not.not.not.not.not, label %.loopexit, label %32

32:                                               ; preds = %.preheader
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract2)
  %34 = load ptr, ptr %10, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract3) #43
  %.fca.0.extract16 = extractvalue { ptr } %36, 0
  %37 = getelementptr i8, ptr %.fca.0.extract16, i64 %indvars.iv
  %38 = load i8, ptr %37, align 1
  store ptr @_parameterization_i32, ptr %6, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %41 = load ptr, ptr %27, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i = call ptr %41({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly %7) #46
  %42 = trunc nuw nsw i64 %indvars.iv to i32
  %43 = call i8 %result.i({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 dereferenceable(8) %6, i32 %42) #53
  %.not24 = icmp eq i8 %38, %43
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br i1 %.not24, label %.preheader, label %.loopexit

.loopexit:                                        ; preds = %32, %.preheader, %4
  %.reg2mem42.0 = phi i1 [ false, %4 ], [ %.not25.not.not.not.not.not, %32 ], [ %.not25.not.not.not.not.not, %.preheader ]
  ret i1 %.reg2mem42.0
}

; Function Attrs: mustprogress nounwind willreturn
define i8 @String_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !533
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !533
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !533
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !533
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract3, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr %.fca.1.extract) #43
  %.fca.0.extract = extractvalue { ptr } %10, 0
  %11 = sext i32 %3 to i64
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load i8, ptr %12, align 1
  ret i8 %13
}

; Function Attrs: mustprogress nounwind willreturn
define void @String_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i8 %4) #6 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !536
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !536
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !536
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !536
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract3, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract) #43
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = sext i32 %3 to i64
  %13 = getelementptr i8, ptr %.fca.0.extract, i64 %12
  store i8 %4, ptr %13, align 1
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  %11 = sext i32 %10 to i64
  %result.i3 = call noalias ptr @bump_malloc_wrapper(i64 noundef %11) #48
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract) #43
  %16 = icmp sgt i32 %15, 0
  br i1 %16, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr } %19(ptr %.fca.1.extract) #43
  %.fca.0.extract27 = extractvalue { ptr } %20, 0
  %21 = getelementptr i8, ptr %.fca.0.extract27, i64 %indvars.iv
  %22 = load i8, ptr %21, align 1
  %23 = getelementptr i8, ptr %result.i3, i64 %indvars.iv
  store i8 %22, ptr %23, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr %.fca.1.extract) #43
  %27 = sext i32 %26 to i64
  %28 = icmp slt i64 %indvars.iv.next, %27
  br i1 %28, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %29 = phi ptr [ %14, %3 ], [ %25, %._crit_edge ]
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %31 = call i32 %29(ptr %.fca.1.extract) #43
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %33 = call i32 %29(ptr %.fca.1.extract) #43
  %result.i2 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %35 = load ptr, ptr %7, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %.fca.1.extract) #43
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %39 = call i32 %36(ptr %.fca.1.extract) #43
  %40 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr undef, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 10, 3
  store ptr %result.i3, ptr %result.i2, align 8
  %43 = getelementptr i8, ptr %result.i2, i64 8
  store i32 %37, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  %45 = getelementptr i8, ptr %result.i2, i64 12
  store i32 %39, ptr %45, align 4
  ret { ptr, ptr, ptr, i32 } %42
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !539
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !539
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !539
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !539
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #35 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %result.i2 = call noalias align 8 dereferenceable_or_null(40) ptr @bump_malloc_wrapper(i64 noundef 40) #48
  %hash_coef.i.i7 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i8 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i9 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i10 = mul i64 %hash_coef.i.i7, 6499063144389013426
  %shifted.i.i.i11 = lshr i64 %product.i.i.i10, 32
  %xored.i.i.i12 = xor i64 %shifted.i.i.i11, %product.i.i.i10
  %hash.i.i.i13 = and i64 %xored.i.i.i12, %tbl_size.i.i8
  %offset_ptr.i.i14 = getelementptr i32, ptr %offset_tbl.i.i9, i64 %hash.i.i.i13
  %offset.i.i15 = load i32, ptr %offset_ptr.i.i14, align 4, !noalias !542
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  store ptr %.fca.0.extract, ptr %result.i2, align 8
  %6 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %result.i2, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %result.i2, i64 24
  store i32 %offset.i.i15, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @StringIterator) #40
  %10 = getelementptr i8, ptr %result.i2, i64 32
  store i32 0, ptr %10, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %11
}

define void @Iterable_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !543
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !543
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !543
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !543
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #56
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #56
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !546
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !546
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !546
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 8673632051301757104
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i14 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !546
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i14, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i.i14 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %result.i18 = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %27 = call { ptr, i160 } %result.i18({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #53
  %.fca.0.extract2219 = extractvalue { ptr, i160 } %27, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %29 = icmp ne ptr %.fca.0.extract2219, @nil_typ
  %30 = icmp ne ptr %.fca.0.extract2219, null
  %.not2820 = and i1 %29, %30
  br i1 %.not2820, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge, %4
  %31 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %27, %4 ]
  call void %.fca.0.extract3({ ptr, i160 } %31)
  %32 = load ptr, ptr %25, align 8
  %result.i = call ptr %32({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #46
  %33 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #53
  %.fca.0.extract22 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %35 = icmp ne ptr %.fca.0.extract22, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract22, null
  %.not28 = and i1 %35, %36
  br i1 %.not28, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  ret void
}

define { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #18 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !549
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !549
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !549
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !549
  %.fca.0.extract3 = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract14, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract15, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #56
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #56
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract13, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i1 = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  %17 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !552
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !552
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !552
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 8673632051301757104
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i14 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !552
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i14, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %24 = sext i32 %offset.i.i14 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i23 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  %28 = call { ptr, i160 } %result.i23({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #53
  %.fca.0.extract4024 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract13)
  %30 = icmp ne ptr %.fca.0.extract4024, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract4024, null
  %.not4825 = and i1 %30, %31
  br i1 %.not4825, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %5
  %32 = phi { ptr, i160 } [ %35, %._crit_edge ], [ %28, %5 ]
  %.pn26 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %3, %5 ]
  %33 = call { ptr, i160 } %.fca.0.extract3({ ptr, i160 } %.pn26, { ptr, i160 } %32)
  %34 = load ptr, ptr %26, align 8
  %result.i = call ptr %34({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #46
  %35 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #53
  %.fca.0.extract40 = extractvalue { ptr, i160 } %35, 0
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract13)
  %37 = icmp ne ptr %.fca.0.extract40, @nil_typ
  %38 = icmp ne ptr %.fca.0.extract40, null
  %.not48 = and i1 %37, %38
  br i1 %.not48, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %5
  %.pn.lcssa = phi { ptr, i160 } [ %3, %5 ], [ %33, %._crit_edge ]
  ret { ptr, i160 } %.pn.lcssa
}

define noundef i1 @Iterable_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !555
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !555
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !555
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !555
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #56
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #56
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !558
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !558
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !558
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 8673632051301757104
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i14 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !558
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i14, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i.i14 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #53
  %.fca.0.extract25 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %30 = icmp eq ptr %.fca.0.extract25, @nil_typ
  %31 = icmp eq ptr %.fca.0.extract25, null
  %.not28.not = or i1 %30, %31
  br i1 %.not28.not, label %.critedge, label %32

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %26, label %.critedge

.critedge:                                        ; preds = %32, %26
  ret i1 %.not28.not
}

define noundef i1 @Iterable_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #18 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !561
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !561
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !561
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !561
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #56
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #56
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i1 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %16 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !564
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !564
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !564
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 8673632051301757104
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i14 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !564
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i14, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %23 = sext i32 %offset.i.i14 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #53
  %.fca.0.extract23 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract5)
  %30 = icmp ne ptr %.fca.0.extract23, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract23, null
  %.not26 = and i1 %30, %31
  br i1 %.not26, label %32, label %.critedge

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %.critedge, label %26

.critedge:                                        ; preds = %32, %26
  ret i1 %.not26
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !567
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !567
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !567
  %product.i.i.i = mul i64 %hash_coef.i.i, 1375598993350293883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !567
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %result.i6 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %9 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i1, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i6, i64 24
  store ptr null, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i6) #40
  store ptr @Pair, ptr %result.i6, align 8
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #48
  store ptr %result.i1, ptr %result.i5, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i6, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #40
  %hash_coef.i.i11 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i12 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i13 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i14 = mul i64 %hash_coef.i.i11, 1375598993350293883
  %shifted.i.i.i15 = lshr i64 %product.i.i.i14, 32
  %xored.i.i.i16 = xor i64 %shifted.i.i.i15, %product.i.i.i14
  %hash.i.i.i17 = and i64 %xored.i.i.i16, %tbl_size.i.i12
  %offset_ptr.i.i18 = getelementptr i32, ptr %offset_tbl.i.i13, i64 %hash.i.i.i17
  %offset.i.i19 = load i32, ptr %offset_ptr.i.i18, align 4, !noalias !542
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @EnumeratedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @EnumeratedCollection) #40
  %19 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 %offset.i.i19, ptr %22, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 103, 3
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, { ptr } %3) #36 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !570
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !570
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !570
  %product.i.i.i = mul i64 %hash_coef.i.i, 1375598993350293883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !570
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %12 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %11, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7) #40
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, 1375598993350293883
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4, !noalias !542
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MappedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract8, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i.i20, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1032) @MappedCollection) #40
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 104, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %2, { ptr } %3) #36 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !573
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !573
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !573
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !573
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %12 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %11, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7) #40
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, 3037712219555723519
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4, !noalias !542
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract8, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i.i20, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef nonnull align 16 dereferenceable(520) @MapIterable) #40
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 40, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #36 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !576
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !576
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !576
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !576
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %result.i7 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i7) #40
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, 3037712219555723519
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4, !noalias !542
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract8) #40
  %14 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract8, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i.i20, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @FilterIterable) #40
  %19 = getelementptr inbounds i8, ptr %result.i7, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %19, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %20
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !579
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !579
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !579
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !579
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #44
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #40
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 3037712219555723519
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4, !noalias !542
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @ChainIterable) #40
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract7, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract8, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract9, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i.i34, ptr %18, align 8
  %hash_coef.i.i100 = load i64, ptr %hash_coef_ptr.i.i9, align 4, !noalias !542
  %tbl_size.i.i101 = load i64, ptr %tbl_size_ptr.i.i10, align 4, !noalias !542
  %offset_tbl.i.i102 = load ptr, ptr %offset_tbl_ptr.i.i11, align 8, !noalias !542
  %product.i.i.i103 = mul i64 %hash_coef.i.i100, 3037712219555723519
  %shifted.i.i.i104 = lshr i64 %product.i.i.i103, 32
  %xored.i.i.i105 = xor i64 %shifted.i.i.i104, %product.i.i.i103
  %hash.i.i.i106 = and i64 %xored.i.i.i105, %tbl_size.i.i101
  %offset_ptr.i.i107 = getelementptr i32, ptr %offset_tbl.i.i102, i64 %hash.i.i.i106
  %offset.i.i95 = load i32, ptr %offset_ptr.i.i107, align 4, !noalias !582
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @ChainIterable) #40
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i.i95, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !585
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !585
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !585
  %product.i.i.i = mul i64 %hash_coef.i.i, 1375598993350293883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !585
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #44
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #40
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 1375598993350293883
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4, !noalias !542
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @ChainedCollection) #40
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract7, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract8, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract9, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i.i34, ptr %18, align 8
  %hash_coef.i.i100 = load i64, ptr %hash_coef_ptr.i.i9, align 4, !noalias !542
  %tbl_size.i.i101 = load i64, ptr %tbl_size_ptr.i.i10, align 4, !noalias !542
  %offset_tbl.i.i102 = load ptr, ptr %offset_tbl_ptr.i.i11, align 8, !noalias !542
  %product.i.i.i103 = mul i64 %hash_coef.i.i100, 1375598993350293883
  %shifted.i.i.i104 = lshr i64 %product.i.i.i103, 32
  %xored.i.i.i105 = xor i64 %shifted.i.i.i104, %product.i.i.i103
  %hash.i.i.i106 = and i64 %xored.i.i.i105, %tbl_size.i.i101
  %offset_ptr.i.i107 = getelementptr i32, ptr %offset_tbl.i.i102, i64 %hash.i.i.i106
  %offset.i.i95 = load i32, ptr %offset_ptr.i.i107, align 4, !noalias !588
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @ChainedCollection) #40
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i.i95, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 103, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !591
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !591
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !591
  %product.i.i.i = mul i64 %hash_coef.i.i, 1375598993350293883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !591
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #44
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #40
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 1375598993350293883
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4, !noalias !542
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleavedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @InterleavedCollection) #40
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract7, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract8, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract9, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i.i34, ptr %18, align 8
  %hash_coef.i.i100 = load i64, ptr %hash_coef_ptr.i.i9, align 4, !noalias !542
  %tbl_size.i.i101 = load i64, ptr %tbl_size_ptr.i.i10, align 4, !noalias !542
  %offset_tbl.i.i102 = load ptr, ptr %offset_tbl_ptr.i.i11, align 8, !noalias !542
  %product.i.i.i103 = mul i64 %hash_coef.i.i100, 1375598993350293883
  %shifted.i.i.i104 = lshr i64 %product.i.i.i103, 32
  %xored.i.i.i105 = xor i64 %shifted.i.i.i104, %product.i.i.i103
  %hash.i.i.i106 = and i64 %xored.i.i.i105, %tbl_size.i.i101
  %offset_ptr.i.i107 = getelementptr i32, ptr %offset_tbl.i.i102, i64 %hash.i.i.i106
  %offset.i.i95 = load i32, ptr %offset_ptr.i.i107, align 4, !noalias !594
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @InterleavedCollection) #40
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i.i95, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 103, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !597
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !597
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !597
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !597
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #44
  %result.i7 = call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_wrapper(i64 noundef 72) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(72) %result.i7) #40
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 3037712219555723519
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4, !noalias !542
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @InterleaveIterable) #40
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.0.extract7, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.1.extract8, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.2.extract9, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store i32 %offset.i.i34, ptr %18, align 8
  %hash_coef.i.i100 = load i64, ptr %hash_coef_ptr.i.i9, align 4, !noalias !542
  %tbl_size.i.i101 = load i64, ptr %tbl_size_ptr.i.i10, align 4, !noalias !542
  %offset_tbl.i.i102 = load ptr, ptr %offset_tbl_ptr.i.i11, align 8, !noalias !542
  %product.i.i.i103 = mul i64 %hash_coef.i.i100, 3037712219555723519
  %shifted.i.i.i104 = lshr i64 %product.i.i.i103, 32
  %xored.i.i.i105 = xor i64 %shifted.i.i.i104, %product.i.i.i103
  %hash.i.i.i106 = and i64 %xored.i.i.i105, %tbl_size.i.i101
  %offset_ptr.i.i107 = getelementptr i32, ptr %offset_tbl.i.i102, i64 %hash.i.i.i106
  %offset.i.i95 = load i32, ptr %offset_ptr.i.i107, align 4, !noalias !600
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @InterleaveIterable) #40
  %20 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store ptr %.fca.1.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i7, i64 56
  store ptr %.fca.2.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i7, i64 64
  store i32 %offset.i.i95, ptr %23, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !603
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !603
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !603
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !603
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #44
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #44
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #40
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #48
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #40
  %hash_coef.i.i28 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i29 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i30 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i31 = mul i64 %hash_coef.i.i28, 3037712219555723519
  %shifted.i.i.i32 = lshr i64 %product.i.i.i31, 32
  %xored.i.i.i33 = xor i64 %shifted.i.i.i32, %product.i.i.i31
  %hash.i.i.i34 = and i64 %xored.i.i.i33, %tbl_size.i.i29
  %offset_ptr.i.i35 = getelementptr i32, ptr %offset_tbl.i.i30, i64 %hash.i.i.i34
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i35, align 4, !noalias !542
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ZipIterable) #40
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract30, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract31, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract32, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i.i36, ptr %30, align 8
  %hash_coef.i.i102 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !542
  %tbl_size.i.i103 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !542
  %offset_tbl.i.i104 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !542
  %product.i.i.i105 = mul i64 %hash_coef.i.i102, 3037712219555723519
  %shifted.i.i.i106 = lshr i64 %product.i.i.i105, 32
  %xored.i.i.i107 = xor i64 %shifted.i.i.i106, %product.i.i.i105
  %hash.i.i.i108 = and i64 %xored.i.i.i107, %tbl_size.i.i103
  %offset_ptr.i.i109 = getelementptr i32, ptr %offset_tbl.i.i104, i64 %hash.i.i.i108
  %offset.i.i97 = load i32, ptr %offset_ptr.i.i109, align 4, !noalias !606
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ZipIterable) #40
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract23, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract24, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract25, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i.i97, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 41, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !609
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !609
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !609
  %product.i.i.i = mul i64 %hash_coef.i.i, 1375598993350293883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !609
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #44
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #44
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #40
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #48
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #40
  %hash_coef.i.i28 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i29 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i30 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i31 = mul i64 %hash_coef.i.i28, 1375598993350293883
  %shifted.i.i.i32 = lshr i64 %product.i.i.i31, 32
  %xored.i.i.i33 = xor i64 %shifted.i.i.i32, %product.i.i.i31
  %hash.i.i.i34 = and i64 %xored.i.i.i33, %tbl_size.i.i29
  %offset_ptr.i.i35 = getelementptr i32, ptr %offset_tbl.i.i30, i64 %hash.i.i.i34
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i35, align 4, !noalias !542
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZippedCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1040) @ZippedCollection) #40
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract30, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract31, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract32, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i.i36, ptr %30, align 8
  %hash_coef.i.i102 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !542
  %tbl_size.i.i103 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !542
  %offset_tbl.i.i104 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !542
  %product.i.i.i105 = mul i64 %hash_coef.i.i102, 1375598993350293883
  %shifted.i.i.i106 = lshr i64 %product.i.i.i105, 32
  %xored.i.i.i107 = xor i64 %shifted.i.i.i106, %product.i.i.i105
  %hash.i.i.i108 = and i64 %xored.i.i.i107, %tbl_size.i.i103
  %offset_ptr.i.i109 = getelementptr i32, ptr %offset_tbl.i.i104, i64 %hash.i.i.i108
  %offset.i.i97 = load i32, ptr %offset_ptr.i.i109, align 4, !noalias !612
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1040) @ZippedCollection) #40
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract23, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract24, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract25, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i.i97, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 105, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !615
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !615
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !615
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !615
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #44
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #44
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #40
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #48
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #40
  %hash_coef.i.i28 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i29 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i30 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i31 = mul i64 %hash_coef.i.i28, 3037712219555723519
  %shifted.i.i.i32 = lshr i64 %product.i.i.i31, 32
  %xored.i.i.i33 = xor i64 %shifted.i.i.i32, %product.i.i.i31
  %hash.i.i.i34 = and i64 %xored.i.i.i33, %tbl_size.i.i29
  %offset_ptr.i.i35 = getelementptr i32, ptr %offset_tbl.i.i30, i64 %hash.i.i.i34
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i35, align 4, !noalias !542
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ProductIterable) #40
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract30, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract31, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract32, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i.i36, ptr %30, align 8
  %hash_coef.i.i102 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !542
  %tbl_size.i.i103 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !542
  %offset_tbl.i.i104 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !542
  %product.i.i.i105 = mul i64 %hash_coef.i.i102, 3037712219555723519
  %shifted.i.i.i106 = lshr i64 %product.i.i.i105, 32
  %xored.i.i.i107 = xor i64 %shifted.i.i.i106, %product.i.i.i105
  %hash.i.i.i108 = and i64 %xored.i.i.i107, %tbl_size.i.i103
  %offset_ptr.i.i109 = getelementptr i32, ptr %offset_tbl.i.i104, i64 %hash.i.i.i108
  %offset.i.i97 = load i32, ptr %offset_ptr.i.i109, align 4, !noalias !618
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ProductIterable) #40
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract23, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract24, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract25, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i.i97, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 41, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #36 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !621
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !621
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !621
  %product.i.i.i = mul i64 %hash_coef.i.i, 1375598993350293883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !621
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #44
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i2 = call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #44
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %result.i9 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %15 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %result.i2, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr null, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i9) #40
  store ptr @Pair, ptr %result.i9, align 8
  %result.i8 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #48
  store ptr %result.i3, ptr %result.i8, align 8
  %19 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i9, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i8) #40
  %hash_coef.i.i28 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i29 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i30 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i31 = mul i64 %hash_coef.i.i28, 1375598993350293883
  %shifted.i.i.i32 = lshr i64 %product.i.i.i31, 32
  %xored.i.i.i33 = xor i64 %shifted.i.i.i32, %product.i.i.i31
  %hash.i.i.i34 = and i64 %xored.i.i.i33, %tbl_size.i.i29
  %offset_ptr.i.i35 = getelementptr i32, ptr %offset_tbl.i.i30, i64 %hash.i.i.i34
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i35, align 4, !noalias !542
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductCollection, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract30) #40
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef align 8 %.fca.0.extract23) #40
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1040) @ProductCollection) #40
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.0.extract30, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store ptr %.fca.1.extract31, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 40
  store ptr %.fca.2.extract32, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 48
  store i32 %offset.i.i36, ptr %30, align 8
  %hash_coef.i.i102 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !542
  %tbl_size.i.i103 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !542
  %offset_tbl.i.i104 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !542
  %product.i.i.i105 = mul i64 %hash_coef.i.i102, 1375598993350293883
  %shifted.i.i.i106 = lshr i64 %product.i.i.i105, 32
  %xored.i.i.i107 = xor i64 %shifted.i.i.i106, %product.i.i.i105
  %hash.i.i.i108 = and i64 %xored.i.i.i107, %tbl_size.i.i103
  %offset_ptr.i.i109 = getelementptr i32, ptr %offset_tbl.i.i104, i64 %hash.i.i.i108
  %offset.i.i97 = load i32, ptr %offset_ptr.i.i109, align 4, !noalias !624
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1040) @ProductCollection) #40
  %32 = getelementptr inbounds i8, ptr %result.i8, i64 56
  store ptr %.fca.0.extract23, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i8, i64 64
  store ptr %.fca.1.extract24, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i8, i64 72
  store ptr %.fca.2.extract25, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i8, i64 80
  store i32 %offset.i.i97, ptr %35, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 105, 3
  ret { ptr, ptr, ptr, i32 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #8 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i, align 4, !noalias !627
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i.i13, 3
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Container(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [120 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [120 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 32, %.critedge ], [ 33, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [120 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [120 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 37, %.critedge ], [ 36, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [120 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !630
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !630
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !630
  %product.i.i.i = mul i64 %hash_coef.i.i, -310975631771072937
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !630
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 1375598993350293883
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !633
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 1375598993350293883
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !636
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define i32 @ProductCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !639
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !639
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !639
  %product.i.i.i = mul i64 %hash_coef.i.i, -310975631771072937
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !639
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract11, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract13) #43
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract3) #58
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract13) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = mul i32 %38, %22
  ret i32 %39
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ProductCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !642
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !642
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !642
  %product.i.i.i = mul i64 %hash_coef.i.i, -310975631771072937
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !642
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract51, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract53) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract43) #58
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 16
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract53) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %29 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #44
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i2 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #44
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %result.i11 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %35 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %result.i2, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr null, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i11)
  store ptr @Pair, ptr %result.i11, align 8
  %result.i10 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_wrapper(i64 noundef 152) #48
  store ptr %result.i3, ptr %result.i10, align 8
  %39 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %result.i11, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(152) %result.i10)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract53) #43
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract11, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract13, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract15, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract9)
  %52 = sext i32 %.fca.3.extract15 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract9, i64 %52
  %54 = getelementptr i8, ptr %53, i64 16
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #53
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4, !noalias !542
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4, !noalias !542
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8, !noalias !542
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 8673632051301757104
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract53) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %offset.i.i52 = load i32, ptr %offset_ptr.i.i37, align 4, !noalias !542
  %hash_coef_ptr.i.i55 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i56 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr undef, 2
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #40
  %69 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.0.extract1, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.1.extract3, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store ptr %.fca.2.extract5, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %result.i10, i64 48
  store i32 %offset.i.i52, ptr %72, align 8
  %hash_coef.i.i34.i = load i64, ptr %hash_coef_ptr.i.i55, align 4, !noalias !542
  %tbl_size.i.i35.i = load i64, ptr %tbl_size_ptr.i.i56, align 4, !noalias !542
  %offset_tbl.i.i36.i = load ptr, ptr %offset_tbl_ptr.i.i57, align 8, !noalias !542
  %product.i.i.i37.i = mul i64 %hash_coef.i.i34.i, 3037712219555723519
  %shifted.i.i.i38.i = lshr i64 %product.i.i.i37.i, 32
  %xored.i.i.i39.i = xor i64 %shifted.i.i.i38.i, %product.i.i.i37.i
  %hash.i.i.i40.i = and i64 %xored.i.i.i39.i, %tbl_size.i.i35.i
  %offset_ptr.i.i41.i = getelementptr i32, ptr %offset_tbl.i.i36.i, i64 %hash.i.i.i40.i
  %offset.i.i56.i = load i32, ptr %offset_ptr.i.i41.i, align 4, !noalias !645
  %73 = getelementptr inbounds i8, ptr %result.i10, i64 88
  store ptr %.fca.0.extract, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %result.i10, i64 96
  store ptr %.fca.1.extract, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %result.i10, i64 104
  store ptr %.fca.2.extract, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i10, i64 112
  store i32 %offset.i.i56.i, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #40
  %78 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %offset.i.i56.i, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %81 = sext i32 %offset.i.i56.i to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  %result.i1.i = call ptr %84({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %85 = call { ptr, ptr, ptr, i32 } %result.i1.i({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %4) #53
  %.fca.0.extract3.i = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract5.i = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract7.i = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %hash_coef_ptr.i.i59.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 8
  %tbl_size_ptr.i.i60.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 16
  %offset_tbl_ptr.i.i61.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 40
  %hash_coef.i.i62.i = load i64, ptr %hash_coef_ptr.i.i59.i, align 4, !noalias !542
  %tbl_size.i.i63.i = load i64, ptr %tbl_size_ptr.i.i60.i, align 4, !noalias !542
  %offset_tbl.i.i64.i = load ptr, ptr %offset_tbl_ptr.i.i61.i, align 8, !noalias !542
  %product.i.i.i65.i = mul i64 %hash_coef.i.i62.i, 8673632051301757104
  %shifted.i.i.i66.i = lshr i64 %product.i.i.i65.i, 32
  %xored.i.i.i67.i = xor i64 %shifted.i.i.i66.i, %product.i.i.i65.i
  %hash.i.i.i68.i = and i64 %xored.i.i.i67.i, %tbl_size.i.i63.i
  %offset_ptr.i.i69.i = getelementptr i32, ptr %offset_tbl.i.i64.i, i64 %hash.i.i.i68.i
  %offset.i.i84.i = load i32, ptr %offset_ptr.i.i69.i, align 4, !noalias !648
  %86 = getelementptr inbounds i8, ptr %result.i10, i64 56
  store ptr %.fca.0.extract3.i, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i10, i64 64
  store ptr %.fca.1.extract5.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i10, i64 72
  store ptr %.fca.2.extract7.i, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i10, i64 80
  store i32 %offset.i.i84.i, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %91 = load ptr, ptr %69, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %70, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %71, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %72, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %result.i.i = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %105 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %4) #53
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %107 = getelementptr inbounds i8, ptr %result.i10, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %105, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %105, 1
  store ptr %.fca.0.extract.i, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %result.i10, i64 128
  store i160 %.fca.1.extract.i, ptr %108, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %109 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %109
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define void @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #28 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !651
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !651
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !651
  %product.i.i.i = mul i64 %hash_coef.i.i, 1697250377212095568
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !651
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !542
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !542
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !542
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 8673632051301757104
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i28 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !654
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract45, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract35, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract37, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i28, 3
  call void %13(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %17) #42
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i34 = load i64, ptr %hash_coef_ptr.i.i31, align 4, !noalias !542
  %tbl_size.i.i35 = load i64, ptr %tbl_size_ptr.i.i32, align 4, !noalias !542
  %offset_tbl.i.i36 = load ptr, ptr %offset_tbl_ptr.i.i33, align 8, !noalias !542
  %product.i.i.i37 = mul i64 %hash_coef.i.i34, 3037712219555723519
  %shifted.i.i.i38 = lshr i64 %product.i.i.i37, 32
  %xored.i.i.i39 = xor i64 %shifted.i.i.i38, %product.i.i.i37
  %hash.i.i.i40 = and i64 %xored.i.i.i39, %tbl_size.i.i35
  %offset_ptr.i.i41 = getelementptr i32, ptr %offset_tbl.i.i36, i64 %hash.i.i.i40
  %offset.i.i56 = load i32, ptr %offset_ptr.i.i41, align 4, !noalias !657
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #40
  %19 = getelementptr i8, ptr %9, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract23, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract25, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i56, 3
  call void %22(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %26) #42
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract45) #40
  %28 = load ptr, ptr %19, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr, ptr, ptr, i32 } %29(ptr %.fca.1.extract47) #43
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %30, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %30, 1
  %.fca.2.extract17 = extractvalue { ptr, ptr, ptr, i32 } %30, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %30, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract15, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract17, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %.fca.3.extract19, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #40
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract13) #40
  %37 = sext i32 %.fca.3.extract19 to i64
  %38 = getelementptr ptr, ptr %.fca.0.extract13, i64 %37
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %result.i1 = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  %41 = call { ptr, ptr, ptr, i32 } %result.i1({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %6) #53
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i60 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i61 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i62 = load i64, ptr %hash_coef_ptr.i.i59, align 4, !noalias !542
  %tbl_size.i.i63 = load i64, ptr %tbl_size_ptr.i.i60, align 4, !noalias !542
  %offset_tbl.i.i64 = load ptr, ptr %offset_tbl_ptr.i.i61, align 8, !noalias !542
  %product.i.i.i65 = mul i64 %hash_coef.i.i62, 8673632051301757104
  %shifted.i.i.i66 = lshr i64 %product.i.i.i65, 32
  %xored.i.i.i67 = xor i64 %shifted.i.i.i66, %product.i.i.i65
  %hash.i.i.i68 = and i64 %xored.i.i.i67, %tbl_size.i.i63
  %offset_ptr.i.i69 = getelementptr i32, ptr %offset_tbl.i.i64, i64 %hash.i.i.i68
  %offset.i.i84 = load i32, ptr %offset_ptr.i.i69, align 4, !noalias !660
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract45)
  %43 = getelementptr i8, ptr %9, i64 32
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract5, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract7, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i.i84, 3
  call void %46(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %50) #42
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract45)
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract47) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.1.extract2, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.2.extract, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %.fca.3.extract, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %61 = sext i32 %.fca.3.extract to i64
  %62 = getelementptr ptr, ptr %.fca.0.extract1, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %result.i = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  %65 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %6) #53
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %.fca.0.extract45)
  %67 = getelementptr i8, ptr %9, i64 48
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %.fca.1.extract47, { ptr, i160 } %65) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ProductIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 1697250377212095568
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7) #56
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract8) #43
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %.0103 = extractvalue { ptr, i160 } %11, 0
  %13 = icmp ne ptr %.0103, @nil_typ
  %14 = icmp ne ptr %.0103, null
  %.not82104 = and i1 %13, %14
  br i1 %.not82104, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %3
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %16 = getelementptr i8, ptr %7, i64 32
  %17 = getelementptr i8, ptr %7, i64 24
  %18 = getelementptr i8, ptr %7, i64 40
  br label %19

19:                                               ; preds = %38, %.lr.ph
  %.pn105 = phi { ptr, i160 } [ %11, %.lr.ph ], [ %83, %38 ]
  %20 = load ptr, ptr %16, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call { ptr, ptr, ptr, i32 } %21(ptr %.fca.1.extract8) #43
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %22, 3
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract65, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract67, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %.fca.3.extract69, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract63)
  %29 = sext i32 %.fca.3.extract69 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract63, i64 %29
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i8 = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %33 = call { ptr, i160 } %result.i8({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %4) #53
  %.fca.0.extract56 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %35 = icmp eq ptr %.fca.0.extract56, @nil_typ
  %36 = icmp eq ptr %.fca.0.extract56, null
  %.not84.not = or i1 %35, %36
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  br i1 %.not84.not, label %38, label %86

38:                                               ; preds = %19
  %39 = load ptr, ptr %17, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call { ptr, ptr, ptr, i32 } %40(ptr %.fca.1.extract8) #43
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract41 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %.fca.3.extract43 = extractvalue { ptr, ptr, ptr, i32 } %41, 3
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract37, 0
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.1.extract39, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.2.extract41, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %.fca.3.extract43, 3
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract37)
  %48 = sext i32 %.fca.3.extract43 to i64
  %49 = getelementptr ptr, ptr %.fca.0.extract37, i64 %48
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  %result.i7 = call ptr %51({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %52 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %4) #53
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %54 = load ptr, ptr %8, align 8
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  call void %56(ptr %.fca.1.extract8, { ptr, i160 } %52) #42
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %58 = load ptr, ptr %18, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract8) #43
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract29 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract30 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract28, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract29, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract30, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract27)
  %67 = sext i32 %.fca.3.extract30 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract27, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i6 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %71 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #53
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 8673632051301757104
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %73 = load ptr, ptr %16, align 8
  %74 = getelementptr i8, ptr %73, i64 8
  %75 = load ptr, ptr %74, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.1.extract20, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.fca.2.extract21, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %offset.i.i36, 3
  call void %75(ptr %.fca.1.extract8, { ptr, ptr, ptr, i32 } %79) #42
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %81 = load ptr, ptr %8, align 8
  %82 = load ptr, ptr %81, align 8
  %83 = call { ptr, i160 } %82(ptr %.fca.1.extract8) #43
  %.0 = extractvalue { ptr, i160 } %83, 0
  %84 = icmp ne ptr %.0, @nil_typ
  %85 = icmp ne ptr %.0, null
  %.not82 = and i1 %84, %85
  br i1 %.not82, label %19, label %.loopexit

86:                                               ; preds = %19
  %87 = load ptr, ptr %7, align 8
  %result.i3 = call align 8 ptr %87(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #44
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %89 = getelementptr i8, ptr %7, i64 8
  %90 = load ptr, ptr %89, align 8
  %result.i2 = call align 8 ptr %90(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #44
  %91 = load ptr, ptr %result.i3, align 8
  %92 = getelementptr i8, ptr %91, i64 72
  %93 = load ptr, ptr %92, align 8
  %result.i1.i = call { i64, i64 } %93(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44
  %94 = extractvalue { i64, i64 } %result.i1.i, 0
  %95 = extractvalue { i64, i64 } %result.i1.i, 1
  %96 = urem i64 16, %95
  %97 = icmp eq i64 %96, 0
  %98 = sub i64 %95, %96
  %99 = select i1 %97, i64 0, i64 %98
  %100 = add i64 %94, 16
  %101 = add i64 %100, %99
  %102 = load ptr, ptr %result.i2, align 8
  %103 = getelementptr i8, ptr %102, i64 72
  %104 = load ptr, ptr %103, align 8
  %result.i.i = call { i64, i64 } %104(ptr nocapture nofree nonnull readonly align 8 %result.i2) #44
  %105 = extractvalue { i64, i64 } %result.i.i, 0
  %106 = extractvalue { i64, i64 } %result.i.i, 1
  %107 = call i64 @llvm.umax.i64(i64 %95, i64 %106) #41
  %108 = call i64 @llvm.umax.i64(i64 %107, i64 noundef 8) #41, !range !16
  %109 = urem i64 %101, %106
  %110 = icmp eq i64 %109, 0
  %111 = sub i64 %106, %109
  %112 = select i1 %110, i64 0, i64 %111
  %113 = add i64 %105, %101
  %114 = add i64 %113, %112
  %115 = urem i64 %114, %108
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %108, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = add i64 %118, %114
  %result.i9 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %119) #48
  store ptr %result.i3, ptr %result.i9, align 8
  %120 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i2, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i9)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract7)
  %124 = load ptr, ptr %result.i3, align 8
  %125 = getelementptr i8, ptr %124, i64 72
  %126 = load ptr, ptr %125, align 8
  %result.i.i116 = call { i64, i64 } %126(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44
  %127 = extractvalue { i64, i64 } %result.i.i116, 1
  %128 = urem i64 16, %127
  %129 = icmp eq i64 %128, 0
  %reass.sub133 = sub i64 %127, %128
  %130 = add i64 %reass.sub133, 16
  %131 = select i1 %129, i64 16, i64 %130
  %132 = getelementptr i8, ptr %result.i9, i64 %131
  %133 = getelementptr i8, ptr %124, i64 64
  %134 = load ptr, ptr %133, align 8
  call void %134({ ptr, i160 } %.pn105, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %132) #45
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #40
  %136 = load ptr, ptr %result.i9, align 8
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr i8, ptr %137, i64 72
  %139 = load ptr, ptr %138, align 8
  %result.i1.i117 = call { i64, i64 } %139(ptr nocapture nofree nonnull readonly align 8 %136) #44
  %140 = extractvalue { i64, i64 } %result.i1.i117, 0
  %141 = extractvalue { i64, i64 } %result.i1.i117, 1
  %142 = urem i64 16, %141
  %143 = icmp eq i64 %142, 0
  %144 = sub i64 %141, %142
  %145 = select i1 %143, i64 0, i64 %144
  %146 = add i64 %140, 16
  %147 = add i64 %146, %145
  %148 = load ptr, ptr %120, align 8
  %149 = load ptr, ptr %148, align 8
  %150 = getelementptr i8, ptr %149, i64 72
  %151 = load ptr, ptr %150, align 8
  %result.i.i118 = call { i64, i64 } %151(ptr nocapture nofree nonnull readonly align 8 %148) #44
  %152 = extractvalue { i64, i64 } %result.i.i118, 1
  %153 = urem i64 %147, %152
  %154 = icmp eq i64 %153, 0
  %155 = sub i64 %152, %153
  %156 = select i1 %154, i64 0, i64 %155
  %157 = getelementptr i8, ptr %result.i9, i64 %147
  %158 = getelementptr i8, ptr %157, i64 %156
  %159 = getelementptr i8, ptr %149, i64 64
  %160 = load ptr, ptr %159, align 8
  call void %160({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly align 8 %148, ptr nocapture nofree writeonly %158) #45
  %161 = ptrtoint ptr %result.i9 to i64
  %.sroa.3.8.insert.ext = zext i64 %161 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.loopexit

.loopexit:                                        ; preds = %86, %38, %3
  %.reg2mem42.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %86 ], [ undef, %3 ], [ undef, %38 ]
  %.reg2mem42.sroa.0.0 = phi ptr [ @Pair, %86 ], [ @nil_typ, %3 ], [ @nil_typ, %38 ]
  %.reload43.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem42.sroa.0.0, 0
  %.reload43.fca.1.insert = insertvalue { ptr, i160 } %.reload43.fca.0.insert, i160 %.reg2mem42.sroa.3.0, 1
  ret { ptr, i160 } %.reload43.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #37 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #44
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #44
  %20 = extractvalue { i64, i64 } %result.i, 0
  %21 = extractvalue { i64, i64 } %result.i, 1
  %22 = call i64 @llvm.umax.i64(i64 %8, i64 %21) #41
  %23 = call i64 @llvm.umax.i64(i64 %22, i64 noundef 8) #41, !range !16
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %33, %29
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readnone %0, ptr nocapture nofree readnone %1) #1 {
  ret { ptr, i160 } { ptr @nil_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nil_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree readnone %2) #1 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator_getter_current_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 8
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_current_first(ptr nocapture nofree writeonly align 8 %0, { ptr, i160 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_first_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_first_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_function_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_function_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #5 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !663
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !663
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !663
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !663
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract11, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract12, { ptr, i160 } %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract12, { ptr, i160 } %4) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !666
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !666
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !666
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !666
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract4) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !669
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !669
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !669
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !669
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract4) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_second(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i1 = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #44
  %6 = extractvalue { i64, i64 } %result.i1, 0
  %7 = extractvalue { i64, i64 } %result.i1, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 16
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %15) #44
  %19 = extractvalue { i64, i64 } %result.i, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly align 8 %15) #44
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_second(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #44
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #44
  %20 = extractvalue { i64, i64 } %result.i, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %16, ptr nocapture nofree writeonly %26) #45
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_first(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #44
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 16, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 16
  %10 = select i1 %8, i64 16, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly align 8 %2) #44
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_first(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #44
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %3, ptr nocapture nofree writeonly %12) #45
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Collection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !672
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !672
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !672
  %product.i.i.i = mul i64 %hash_coef.i.i, 4128338911757318636
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !672
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 3037712219555723519
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !675
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 3037712219555723519
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !678
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ProductIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !681
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !681
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !681
  %product.i.i.i = mul i64 %hash_coef.i.i, 4128338911757318636
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !681
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract51, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract53) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43) #58
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract53) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %29 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #44
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i2 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #44
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %result.i11 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %35 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %result.i2, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr null, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i11)
  store ptr @Pair, ptr %result.i11, align 8
  %result.i10 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_wrapper(i64 noundef 152) #48
  store ptr %result.i3, ptr %result.i10, align 8
  %39 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %result.i2, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %result.i11, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(152) %result.i10)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract53) #43
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract11, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract13, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract15, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract9)
  %52 = sext i32 %.fca.3.extract15 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract9, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #53
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4, !noalias !542
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4, !noalias !542
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8, !noalias !542
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 8673632051301757104
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract53) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %offset.i.i52 = load i32, ptr %offset_ptr.i.i37, align 4, !noalias !542
  %hash_coef_ptr.i.i55 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i56 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr undef, 2
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract51)
  call void @llvm.lifetime.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #40
  %69 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.0.extract1, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.1.extract3, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store ptr %.fca.2.extract5, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %result.i10, i64 48
  store i32 %offset.i.i52, ptr %72, align 8
  %hash_coef.i.i34.i = load i64, ptr %hash_coef_ptr.i.i55, align 4, !noalias !542
  %tbl_size.i.i35.i = load i64, ptr %tbl_size_ptr.i.i56, align 4, !noalias !542
  %offset_tbl.i.i36.i = load ptr, ptr %offset_tbl_ptr.i.i57, align 8, !noalias !542
  %product.i.i.i37.i = mul i64 %hash_coef.i.i34.i, 3037712219555723519
  %shifted.i.i.i38.i = lshr i64 %product.i.i.i37.i, 32
  %xored.i.i.i39.i = xor i64 %shifted.i.i.i38.i, %product.i.i.i37.i
  %hash.i.i.i40.i = and i64 %xored.i.i.i39.i, %tbl_size.i.i35.i
  %offset_ptr.i.i41.i = getelementptr i32, ptr %offset_tbl.i.i36.i, i64 %hash.i.i.i40.i
  %offset.i.i56.i = load i32, ptr %offset_ptr.i.i41.i, align 4, !noalias !684
  %73 = getelementptr inbounds i8, ptr %result.i10, i64 88
  store ptr %.fca.0.extract, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %result.i10, i64 96
  store ptr %.fca.1.extract, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %result.i10, i64 104
  store ptr %.fca.2.extract, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i10, i64 112
  store i32 %offset.i.i56.i, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator) #40
  %78 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %offset.i.i56.i, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %81 = sext i32 %offset.i.i56.i to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  %result.i1.i = call ptr %84({ ptr, ptr, ptr, i32 } %78, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %85 = call { ptr, ptr, ptr, i32 } %result.i1.i({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull align 8 %4) #53
  %.fca.0.extract3.i = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract5.i = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract7.i = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %hash_coef_ptr.i.i59.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 8
  %tbl_size_ptr.i.i60.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 16
  %offset_tbl_ptr.i.i61.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 40
  %hash_coef.i.i62.i = load i64, ptr %hash_coef_ptr.i.i59.i, align 4, !noalias !542
  %tbl_size.i.i63.i = load i64, ptr %tbl_size_ptr.i.i60.i, align 4, !noalias !542
  %offset_tbl.i.i64.i = load ptr, ptr %offset_tbl_ptr.i.i61.i, align 8, !noalias !542
  %product.i.i.i65.i = mul i64 %hash_coef.i.i62.i, 8673632051301757104
  %shifted.i.i.i66.i = lshr i64 %product.i.i.i65.i, 32
  %xored.i.i.i67.i = xor i64 %shifted.i.i.i66.i, %product.i.i.i65.i
  %hash.i.i.i68.i = and i64 %xored.i.i.i67.i, %tbl_size.i.i63.i
  %offset_ptr.i.i69.i = getelementptr i32, ptr %offset_tbl.i.i64.i, i64 %hash.i.i.i68.i
  %offset.i.i84.i = load i32, ptr %offset_ptr.i.i69.i, align 4, !noalias !687
  %86 = getelementptr inbounds i8, ptr %result.i10, i64 56
  store ptr %.fca.0.extract3.i, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i10, i64 64
  store ptr %.fca.1.extract5.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i10, i64 72
  store ptr %.fca.2.extract7.i, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i10, i64 80
  store i32 %offset.i.i84.i, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %91 = load ptr, ptr %69, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %70, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %71, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %72, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %result.i.i = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %105 = call { ptr, i160 } %result.i.i({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %4) #53
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %107 = getelementptr inbounds i8, ptr %result.i10, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %105, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %105, 1
  store ptr %.fca.0.extract.i, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %result.i10, i64 128
  store i160 %.fca.1.extract.i, ptr %108, align 8
  call void @llvm.lifetime.end.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %109 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %109
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !690
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !690
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !690
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !690
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %result.i6 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %9 = getelementptr inbounds i8, ptr %result.i6, i64 16
  store ptr %result.i1, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i6, i64 24
  store ptr null, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i6) #40
  store ptr @Pair, ptr %result.i6, align 8
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #48
  store ptr %result.i1, ptr %result.i5, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i6, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #40
  %hash_coef.i.i11 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i12 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i13 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i14 = mul i64 %hash_coef.i.i11, 3037712219555723519
  %shifted.i.i.i15 = lshr i64 %product.i.i.i14, 32
  %xored.i.i.i16 = xor i64 %shifted.i.i.i15, %product.i.i.i14
  %hash.i.i.i17 = and i64 %xored.i.i.i16, %tbl_size.i.i12
  %offset_ptr.i.i18 = getelementptr i32, ptr %offset_tbl.i.i13, i64 %hash.i.i.i17
  %offset.i.i19 = load i32, ptr %offset_ptr.i.i18, align 4, !noalias !542
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumeration, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Enumeration) #40
  %19 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 %offset.i.i19, ptr %22, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 39, 3
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumeration(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Enumeration_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !693
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !693
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !693
  %product.i.i.i = mul i64 %hash_coef.i.i, -2805197119131967777
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !693
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 3037712219555723519
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !696
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i27, 3
  call void %11(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Enumeration_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !699
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !699
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !699
  %product.i.i.i = mul i64 %hash_coef.i.i, -2805197119131967777
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !699
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract31) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract31, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract33) #43
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract23, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract25, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract27, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract29, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract23) #58
  %18 = sext i32 %.fca.3.extract29 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract23, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i5 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %24 = load ptr, ptr %7, align 8
  %result.i1 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract33) #44
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %result.i8 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %26 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i1, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr null, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i8)
  store ptr @Pair, ptr %result.i8, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store ptr %result.i1, ptr %result.i7, align 8
  %30 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i8, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %33 = load ptr, ptr %8, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract33) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract2, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract3, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %.fca.3.extract4, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract1)
  %42 = sext i32 %.fca.3.extract4 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract1, i64 %42
  %44 = getelementptr i8, ptr %43, i64 8
  %45 = load ptr, ptr %44, align 8
  %result.i4 = call ptr %45({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %46 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 2
  %hash_coef_ptr.i.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i27 = load i64, ptr %hash_coef_ptr.i.i24, align 4, !noalias !542
  %tbl_size.i.i28 = load i64, ptr %tbl_size_ptr.i.i25, align 4, !noalias !542
  %offset_tbl.i.i29 = load ptr, ptr %offset_tbl_ptr.i.i26, align 8, !noalias !542
  %product.i.i.i30 = mul i64 %hash_coef.i.i27, 8673632051301757104
  %shifted.i.i.i31 = lshr i64 %product.i.i.i30, 32
  %xored.i.i.i32 = xor i64 %shifted.i.i.i31, %product.i.i.i30
  %hash.i.i.i33 = and i64 %xored.i.i.i32, %tbl_size.i.i28
  %offset_ptr.i.i34 = getelementptr i32, ptr %offset_tbl.i.i29, i64 %hash.i.i.i33
  %offset.i.i49 = load i32, ptr %offset_ptr.i.i34, align 4, !noalias !542
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %50 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i.i49, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator) #40
  %55 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store i32 0, ptr %55, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %56
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumerator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Enumerator_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !702
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !702
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !702
  %product.i.i.i = mul i64 %hash_coef.i.i, -3435222131909153872
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !702
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 8673632051301757104
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !705
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i27, 3
  call void %11(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %17 = getelementptr i8, ptr %7, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract2, i32 0) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @Enumerator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !708
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !708
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !708
  %product.i.i.i = mul i64 %hash_coef.i.i, -3435222131909153872
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !708
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract16) #43
  %12 = add i32 %11, 1
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #40
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract16, i32 %12) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #40
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr, ptr, ptr, i32 } %19(ptr %.fca.1.extract16) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 3
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract3, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %.fca.3.extract, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #40
  %27 = sext i32 %.fca.3.extract to i64
  %28 = getelementptr ptr, ptr %.fca.0.extract2, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %result.i4 = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %31 = call { ptr, i160 } %result.i4({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, i160 } %31, 0
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract14)
  %33 = icmp ne ptr %.fca.0.extract, @nil_typ
  %34 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %33, %34
  br i1 %.not43, label %35, label %82

35:                                               ; preds = %3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %37 = load ptr, ptr %8, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call i32 %38(ptr nonnull %.fca.1.extract16) #43
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %41 = load ptr, ptr %7, align 8
  %result.i1 = call align 8 ptr %41(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract16) #44
  %42 = load ptr, ptr %result.i1, align 8, !alias.scope !711
  %43 = getelementptr i8, ptr %42, i64 72
  %44 = load ptr, ptr %43, align 8, !alias.scope !711
  %result.i.i = call { i64, i64 } %44(ptr nocapture nofree nonnull readonly align 8 %result.i1) #44, !alias.scope !711
  %45 = extractvalue { i64, i64 } %result.i.i, 0
  %46 = extractvalue { i64, i64 } %result.i.i, 1
  %47 = call i64 @llvm.umax.i64(i64 %46, i64 noundef 8), !range !16
  %48 = urem i64 20, %46
  %49 = icmp eq i64 %48, 0
  %50 = sub i64 %46, %48
  %51 = select i1 %49, i64 0, i64 %50
  %52 = add i64 %45, 20
  %53 = add i64 %52, %51
  %54 = urem i64 %53, %47
  %55 = icmp eq i64 %54, 0
  %56 = sub i64 %47, %54
  %57 = select i1 %55, i64 0, i64 %56
  %58 = add i64 %57, %53
  %result.i5 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %58) #48
  store ptr @_parameterization_i32, ptr %result.i5, align 8
  %59 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %result.i1, ptr %59, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i5)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %62 = load ptr, ptr %8, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call i32 %63(ptr nonnull %.fca.1.extract16) #43
  %65 = add i32 %64, -1
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %67 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store i32 %65, ptr %67, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #40
  %69 = load ptr, ptr %result.i1, align 8
  %70 = getelementptr i8, ptr %69, i64 72
  %71 = load ptr, ptr %70, align 8
  %result.i.i16 = call { i64, i64 } %71(ptr nocapture nofree nonnull readonly align 8 %result.i1) #44
  %72 = extractvalue { i64, i64 } %result.i.i16, 1
  %73 = urem i64 20, %72
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %72, %73
  %76 = select i1 %74, i64 0, i64 %75
  %77 = getelementptr inbounds i8, ptr %result.i5, i64 20
  %78 = getelementptr i8, ptr %77, i64 %76
  %79 = getelementptr i8, ptr %69, i64 64
  %80 = load ptr, ptr %79, align 8
  call void %80({ ptr, i160 } %31, ptr nocapture nofree nonnull readonly align 8 %result.i1, ptr nocapture nofree writeonly %78) #45
  %81 = ptrtoint ptr %result.i5 to i64
  %.sroa.335.8.insert.ext = zext i64 %81 to i160
  %.sroa.335.8.insert.insert = or disjoint i160 %.sroa.335.8.insert.ext, 3402823669209384634633746074317682114560
  br label %82

82:                                               ; preds = %35, %3
  %.reg2mem25.sroa.0.0 = phi ptr [ @Pair, %35 ], [ @nil_typ, %3 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.sroa.335.8.insert.insert, %35 ], [ undef, %3 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i32, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i32 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i32_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(4) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  store i32 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Enumerator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumerator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumeration_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumeration_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZippedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [120 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 31, i64 30
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [120 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 32, %.critedge ], [ 33, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [120 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 35, i64 34
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [120 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 37, %.critedge ], [ 36, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [120 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZippedCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !714
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !714
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !714
  %product.i.i.i = mul i64 %hash_coef.i.i, 880335312586431241
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !714
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 1375598993350293883
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !717
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 1375598993350293883
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !720
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define i32 @ZippedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !723
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !723
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !723
  %product.i.i.i = mul i64 %hash_coef.i.i, 880335312586431241
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !723
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract15) #43
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract7, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract9, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract11, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract5) #58
  %18 = sext i32 %.fca.3.extract11 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract5, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract13)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract15) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %.sroa.speculated = call i32 @llvm.smin.i32(i32 %22, i32 %38)
  ret i32 %.sroa.speculated
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ZippedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !726
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !726
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !726
  %product.i.i.i = mul i64 %hash_coef.i.i, 880335312586431241
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !726
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #43
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract63) #58
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 16
  %21 = load ptr, ptr %20, align 8
  %result.i9 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i9({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 16
  %37 = load ptr, ptr %36, align 8
  %result.i8 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %result.i13 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %46 = getelementptr inbounds i8, ptr %result.i13, i64 16
  store ptr %result.i2, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i13, i64 8
  store ptr %result.i3, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i13, i64 24
  store ptr null, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i13)
  store ptr @Pair, ptr %result.i13, align 8
  %result.i12 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #48
  store ptr %result.i3, ptr %result.i12, align 8
  %50 = getelementptr inbounds i8, ptr %result.i12, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i12, i64 16
  store ptr %result.i13, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i12)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr %.fca.1.extract73) #43
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %56, 3
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract19, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract21, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %.fca.3.extract23, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract17)
  %63 = sext i32 %.fca.3.extract23 to i64
  %64 = getelementptr ptr, ptr %.fca.0.extract17, i64 %63
  %65 = getelementptr i8, ptr %64, i64 16
  %66 = load ptr, ptr %65, align 8
  %result.i7 = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %67 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %4) #53
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %hash_coef_ptr.i.i43 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i44 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i45 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %69 = load ptr, ptr %24, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr, ptr, ptr, i32 } %70(ptr %.fca.1.extract73) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %71, 3
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.1.extract2, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.2.extract3, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %.fca.3.extract4, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract1)
  %78 = sext i32 %.fca.3.extract4 to i64
  %79 = getelementptr ptr, ptr %.fca.0.extract1, i64 %78
  %80 = getelementptr i8, ptr %79, i64 16
  %81 = load ptr, ptr %80, align 8
  %result.i6 = call ptr %81({ ptr, ptr, ptr, i32 } %75, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %82 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 2
  %hash_coef_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i58 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i74 = load i64, ptr %hash_coef_ptr.i.i43, align 4, !noalias !542
  %tbl_size.i.i75 = load i64, ptr %tbl_size_ptr.i.i44, align 4, !noalias !542
  %offset_tbl.i.i76 = load ptr, ptr %offset_tbl_ptr.i.i45, align 8, !noalias !542
  %product.i.i.i77 = mul i64 %hash_coef.i.i74, 8673632051301757104
  %shifted.i.i.i78 = lshr i64 %product.i.i.i77, 32
  %xored.i.i.i79 = xor i64 %shifted.i.i.i78, %product.i.i.i77
  %hash.i.i.i80 = and i64 %xored.i.i.i79, %tbl_size.i.i75
  %offset_ptr.i.i81 = getelementptr i32, ptr %offset_tbl.i.i76, i64 %hash.i.i.i80
  %offset.i.i82 = load i32, ptr %offset_ptr.i.i81, align 4, !noalias !542
  %83 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i12, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr undef, 2
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #40
  %88 = getelementptr inbounds i8, ptr %result.i12, i64 24
  store ptr %.fca.0.extract5, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i12, i64 32
  store ptr %.fca.1.extract7, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i12, i64 40
  store ptr %.fca.2.extract9, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i12, i64 48
  store i32 %offset.i.i82, ptr %91, align 8
  %hash_coef.i.i33.i = load i64, ptr %hash_coef_ptr.i.i57, align 4, !noalias !542
  %tbl_size.i.i34.i = load i64, ptr %tbl_size_ptr.i.i58, align 4, !noalias !542
  %offset_tbl.i.i35.i = load ptr, ptr %offset_tbl_ptr.i.i59, align 8, !noalias !542
  %product.i.i.i36.i = mul i64 %hash_coef.i.i33.i, 8673632051301757104
  %shifted.i.i.i37.i = lshr i64 %product.i.i.i36.i, 32
  %xored.i.i.i38.i = xor i64 %shifted.i.i.i37.i, %product.i.i.i36.i
  %hash.i.i.i39.i = and i64 %xored.i.i.i38.i, %tbl_size.i.i34.i
  %offset_ptr.i.i40.i = getelementptr i32, ptr %offset_tbl.i.i35.i, i64 %hash.i.i.i39.i
  %offset.i.i55.i = load i32, ptr %offset_ptr.i.i40.i, align 4, !noalias !729
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #40
  %93 = getelementptr inbounds i8, ptr %result.i12, i64 56
  store ptr %.fca.0.extract, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i12, i64 64
  store ptr %.fca.1.extract, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i12, i64 72
  store ptr %.fca.2.extract, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %result.i12, i64 80
  store i32 %offset.i.i55.i, ptr %96, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterator_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !732
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !732
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !732
  %product.i.i.i = mul i64 %hash_coef.i.i, -2141114445739585318
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !732
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 8673632051301757104
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !735
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 8673632051301757104
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !738
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ZipIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !741
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !741
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !741
  %product.i.i.i = mul i64 %hash_coef.i.i, -2141114445739585318
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !741
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract28) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract28, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract30) #43
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract12 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract14 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract12, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract14, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract8) #58
  %18 = sext i32 %.fca.3.extract14 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract8, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %.fca.0.extract4 = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract28)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract30) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract3, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract2, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i6 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call { ptr, i160 } %result.i6({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef align 8 %.fca.0.extract28)
  %40 = load ptr, ptr %7, align 8
  %41 = icmp ne ptr %.fca.0.extract4, @nil_typ
  %42 = icmp ne ptr %.fca.0.extract4, null
  %.not55 = and i1 %41, %42
  br i1 %.not55, label %43, label %123

43:                                               ; preds = %3
  %.fca.0.extract = extractvalue { ptr, i160 } %38, 0
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %45 = icmp ne ptr %.fca.0.extract, @nil_typ
  %46 = icmp ne ptr %.fca.0.extract, null
  %.not57.not.not = and i1 %45, %46
  br i1 %.not57.not.not, label %47, label %123

47:                                               ; preds = %43
  %48 = getelementptr i8, ptr %7, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %result.i3 = call align 8 ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #44
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %result.i2 = call align 8 ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #44
  %52 = load ptr, ptr %result.i3, align 8, !alias.scope !744
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8, !alias.scope !744
  %result.i1.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44, !alias.scope !744
  %55 = extractvalue { i64, i64 } %result.i1.i, 0
  %56 = extractvalue { i64, i64 } %result.i1.i, 1
  %57 = urem i64 16, %56
  %58 = icmp eq i64 %57, 0
  %59 = sub i64 %56, %57
  %60 = select i1 %58, i64 0, i64 %59
  %61 = add i64 %55, 16
  %62 = add i64 %61, %60
  %63 = load ptr, ptr %result.i2, align 8, !alias.scope !744
  %64 = getelementptr i8, ptr %63, i64 72
  %65 = load ptr, ptr %64, align 8, !alias.scope !744
  %result.i.i = call { i64, i64 } %65(ptr nocapture nofree nonnull readonly align 8 %result.i2) #44, !alias.scope !744
  %66 = extractvalue { i64, i64 } %result.i.i, 0
  %67 = extractvalue { i64, i64 } %result.i.i, 1
  %68 = call i64 @llvm.umax.i64(i64 %56, i64 %67) #41
  %69 = call i64 @llvm.umax.i64(i64 %68, i64 noundef 8) #41, !range !16
  %70 = urem i64 %62, %67
  %71 = icmp eq i64 %70, 0
  %72 = sub i64 %67, %70
  %73 = select i1 %71, i64 0, i64 %72
  %74 = add i64 %66, %62
  %75 = add i64 %74, %73
  %76 = urem i64 %75, %69
  %77 = icmp eq i64 %76, 0
  %78 = sub i64 %69, %76
  %79 = select i1 %77, i64 0, i64 %78
  %80 = add i64 %79, %75
  %result.i8 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %80) #48
  store ptr %result.i3, ptr %result.i8, align 8
  %81 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i8)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract28)
  %85 = load ptr, ptr %result.i3, align 8
  %86 = getelementptr i8, ptr %85, i64 72
  %87 = load ptr, ptr %86, align 8
  %result.i.i22 = call { i64, i64 } %87(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44
  %88 = extractvalue { i64, i64 } %result.i.i22, 1
  %89 = urem i64 16, %88
  %90 = icmp eq i64 %89, 0
  %reass.sub25 = sub i64 %88, %89
  %91 = add i64 %reass.sub25, 16
  %92 = select i1 %90, i64 16, i64 %91
  %93 = getelementptr i8, ptr %result.i8, i64 %92
  %94 = getelementptr i8, ptr %85, i64 64
  %95 = load ptr, ptr %94, align 8
  call void %95({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %93) #45
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #40
  %97 = load ptr, ptr %result.i8, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i1.i23 = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly align 8 %97) #44
  %101 = extractvalue { i64, i64 } %result.i1.i23, 0
  %102 = extractvalue { i64, i64 } %result.i1.i23, 1
  %103 = urem i64 16, %102
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %102, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %101, 16
  %108 = add i64 %107, %106
  %109 = load ptr, ptr %81, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i.i24 = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly align 8 %109) #44
  %113 = extractvalue { i64, i64 } %result.i.i24, 1
  %114 = urem i64 %108, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = getelementptr i8, ptr %result.i8, i64 %108
  %119 = getelementptr i8, ptr %118, i64 %117
  %120 = getelementptr i8, ptr %110, i64 64
  %121 = load ptr, ptr %120, align 8
  call void %121({ ptr, i160 } %38, ptr nocapture nofree nonnull readonly align 8 %109, ptr nocapture nofree writeonly %119) #45
  %122 = ptrtoint ptr %result.i8 to i64
  %.sroa.344.8.insert.ext = zext i64 %122 to i160
  %.sroa.344.8.insert.insert = or disjoint i160 %.sroa.344.8.insert.ext, 3402823669209384634633746074317682114560
  br label %123

123:                                              ; preds = %47, %43, %3
  %.reg2mem41.sroa.3.0 = phi i160 [ %.sroa.344.8.insert.insert, %47 ], [ poison, %3 ], [ poison, %43 ]
  %.reg2mem39.0 = phi ptr [ @Pair, %47 ], [ @nil_typ, %3 ], [ @nil_typ, %43 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem39.0, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem41.sroa.3.0, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #9

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !747
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !747
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !747
  %product.i.i.i = mul i64 %hash_coef.i.i, 35232740166152944
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !747
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 3037712219555723519
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !750
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 3037712219555723519
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !753
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ZipIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !756
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !756
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !756
  %product.i.i.i = mul i64 %hash_coef.i.i, 35232740166152944
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !756
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #43
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract63) #58
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i9 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i9({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i8 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i3 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i2 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %result.i13 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %46 = getelementptr inbounds i8, ptr %result.i13, i64 16
  store ptr %result.i2, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i13, i64 8
  store ptr %result.i3, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i13, i64 24
  store ptr null, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i13)
  store ptr @Pair, ptr %result.i13, align 8
  %result.i12 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_wrapper(i64 noundef 88) #48
  store ptr %result.i3, ptr %result.i12, align 8
  %50 = getelementptr inbounds i8, ptr %result.i12, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i12, i64 16
  store ptr %result.i13, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(88) %result.i12)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr %.fca.1.extract73) #43
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %56, 3
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract19, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract21, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %.fca.3.extract23, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract17)
  %63 = sext i32 %.fca.3.extract23 to i64
  %64 = getelementptr ptr, ptr %.fca.0.extract17, i64 %63
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %result.i7 = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %67 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %4) #53
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %hash_coef_ptr.i.i43 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i44 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i45 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %69 = load ptr, ptr %24, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr, ptr, ptr, i32 } %70(ptr %.fca.1.extract73) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %71, 3
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.1.extract2, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.2.extract3, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %.fca.3.extract4, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract1)
  %78 = sext i32 %.fca.3.extract4 to i64
  %79 = getelementptr ptr, ptr %.fca.0.extract1, i64 %78
  %80 = getelementptr i8, ptr %79, i64 8
  %81 = load ptr, ptr %80, align 8
  %result.i6 = call ptr %81({ ptr, ptr, ptr, i32 } %75, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %82 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %82, 2
  %hash_coef_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i58 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i74 = load i64, ptr %hash_coef_ptr.i.i43, align 4, !noalias !542
  %tbl_size.i.i75 = load i64, ptr %tbl_size_ptr.i.i44, align 4, !noalias !542
  %offset_tbl.i.i76 = load ptr, ptr %offset_tbl_ptr.i.i45, align 8, !noalias !542
  %product.i.i.i77 = mul i64 %hash_coef.i.i74, 8673632051301757104
  %shifted.i.i.i78 = lshr i64 %product.i.i.i77, 32
  %xored.i.i.i79 = xor i64 %shifted.i.i.i78, %product.i.i.i77
  %hash.i.i.i80 = and i64 %xored.i.i.i79, %tbl_size.i.i75
  %offset_ptr.i.i81 = getelementptr i32, ptr %offset_tbl.i.i76, i64 %hash.i.i.i80
  %offset.i.i82 = load i32, ptr %offset_ptr.i.i81, align 4, !noalias !542
  %83 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i12, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr undef, 2
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #40
  %88 = getelementptr inbounds i8, ptr %result.i12, i64 24
  store ptr %.fca.0.extract5, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i12, i64 32
  store ptr %.fca.1.extract7, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i12, i64 40
  store ptr %.fca.2.extract9, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i12, i64 48
  store i32 %offset.i.i82, ptr %91, align 8
  %hash_coef.i.i33.i = load i64, ptr %hash_coef_ptr.i.i57, align 4, !noalias !542
  %tbl_size.i.i34.i = load i64, ptr %tbl_size_ptr.i.i58, align 4, !noalias !542
  %offset_tbl.i.i35.i = load ptr, ptr %offset_tbl_ptr.i.i59, align 8, !noalias !542
  %product.i.i.i36.i = mul i64 %hash_coef.i.i33.i, 8673632051301757104
  %shifted.i.i.i37.i = lshr i64 %product.i.i.i36.i, 32
  %xored.i.i.i38.i = xor i64 %shifted.i.i.i37.i, %product.i.i.i36.i
  %hash.i.i.i39.i = and i64 %xored.i.i.i38.i, %tbl_size.i.i34.i
  %offset_ptr.i.i40.i = getelementptr i32, ptr %offset_tbl.i.i35.i, i64 %hash.i.i.i39.i
  %offset.i.i55.i = load i32, ptr %offset_ptr.i.i40.i, align 4, !noalias !759
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator) #40
  %93 = getelementptr inbounds i8, ptr %result.i12, i64 56
  store ptr %.fca.0.extract, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i12, i64 64
  store ptr %.fca.1.extract, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i12, i64 72
  store ptr %.fca.2.extract, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %result.i12, i64 80
  store i32 %offset.i.i55.i, ptr %96, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable_field_InterleaveIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !762
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !762
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !762
  %product.i.i.i = mul i64 %hash_coef.i.i, 4936782714255954462
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !762
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 3037712219555723519
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !765
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 3037712219555723519
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !768
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @InterleaveIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !771
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !771
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !771
  %product.i.i.i = mul i64 %hash_coef.i.i, 4936782714255954462
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !771
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #43
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract63) #58
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #48
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #43
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #53
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i42 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i43 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i55 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i56 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i72 = load i64, ptr %hash_coef_ptr.i.i41, align 4, !noalias !542
  %tbl_size.i.i73 = load i64, ptr %tbl_size_ptr.i.i42, align 4, !noalias !542
  %offset_tbl.i.i74 = load ptr, ptr %offset_tbl_ptr.i.i43, align 8, !noalias !542
  %product.i.i.i75 = mul i64 %hash_coef.i.i72, 8673632051301757104
  %shifted.i.i.i76 = lshr i64 %product.i.i.i75, 32
  %xored.i.i.i77 = xor i64 %shifted.i.i.i76, %product.i.i.i75
  %hash.i.i.i78 = and i64 %xored.i.i.i77, %tbl_size.i.i73
  %offset_ptr.i.i79 = getelementptr i32, ptr %offset_tbl.i.i74, i64 %hash.i.i.i78
  %offset.i.i80 = load i32, ptr %offset_ptr.i.i79, align 4, !noalias !542
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #40
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract5, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract7, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract9, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i.i80, ptr %80, align 8
  %hash_coef.i.i33.i = load i64, ptr %hash_coef_ptr.i.i55, align 4, !noalias !542
  %tbl_size.i.i34.i = load i64, ptr %tbl_size_ptr.i.i56, align 4, !noalias !542
  %offset_tbl.i.i35.i = load ptr, ptr %offset_tbl_ptr.i.i57, align 8, !noalias !542
  %product.i.i.i36.i = mul i64 %hash_coef.i.i33.i, 8673632051301757104
  %shifted.i.i.i37.i = lshr i64 %product.i.i.i36.i, 32
  %xored.i.i.i38.i = xor i64 %shifted.i.i.i37.i, %product.i.i.i36.i
  %hash.i.i.i39.i = and i64 %xored.i.i.i38.i, %tbl_size.i.i34.i
  %offset_ptr.i.i40.i = getelementptr i32, ptr %offset_tbl.i.i35.i, i64 %hash.i.i.i39.i
  %offset.i.i55.i = load i32, ptr %offset_ptr.i.i40.i, align 4, !noalias !774
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i.i55.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #40
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator_field_InterleaveIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !777
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !777
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !777
  %product.i.i.i = mul i64 %hash_coef.i.i, -3924664358248524505
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !777
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 8673632051301757104
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !780
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 8673632051301757104
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !783
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract10, i1 true) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @InterleaveIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
.cont30:
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !786
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !786
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !786
  %product.i.i.i = mul i64 %hash_coef.i.i, -3924664358248524505
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !786
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i1 %9(ptr %.fca.1.extract4) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %12 = getelementptr i8, ptr %8, i64 8
  %13 = load ptr, ptr %12, align 8
  %not. = xor i1 %10, true
  %.68 = select i1 %10, i64 8, i64 16
  call void %13(ptr %.fca.1.extract4, i1 %not.) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %15 = getelementptr i8, ptr %6, i64 %.68
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract4) #43
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract10, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract11, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract12, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #40
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract9) #40
  %25 = sext i32 %.fca.3.extract12 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract9, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %result.i = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %29 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %3) #53
  ret { ptr, i160 } %29
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator_getter_on_first(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleavedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleavedCollection_field_InterleavedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 25, i64 26
  %8 = getelementptr [118 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 29, %.critedge ], [ 28, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 30, %.critedge ], [ 31, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [118 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 35, %.critedge ], [ 34, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleavedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !789
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !789
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !789
  %product.i.i.i = mul i64 %hash_coef.i.i, 8589355597059143861
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !789
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 1375598993350293883
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !792
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 1375598993350293883
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !795
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define i32 @InterleavedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !798
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !798
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !798
  %product.i.i.i = mul i64 %hash_coef.i.i, 8589355597059143861
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !798
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract11, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract13) #43
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract3) #58
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract13) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = add i32 %38, %22
  ret i32 %39
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @InterleavedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !801
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !801
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !801
  %product.i.i.i = mul i64 %hash_coef.i.i, 8589355597059143861
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !801
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #43
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract63) #58
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 16
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 16
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #48
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #43
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 16
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #53
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i42 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i43 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 16
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i55 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i56 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i72 = load i64, ptr %hash_coef_ptr.i.i41, align 4, !noalias !542
  %tbl_size.i.i73 = load i64, ptr %tbl_size_ptr.i.i42, align 4, !noalias !542
  %offset_tbl.i.i74 = load ptr, ptr %offset_tbl_ptr.i.i43, align 8, !noalias !542
  %product.i.i.i75 = mul i64 %hash_coef.i.i72, 8673632051301757104
  %shifted.i.i.i76 = lshr i64 %product.i.i.i75, 32
  %xored.i.i.i77 = xor i64 %shifted.i.i.i76, %product.i.i.i75
  %hash.i.i.i78 = and i64 %xored.i.i.i77, %tbl_size.i.i73
  %offset_ptr.i.i79 = getelementptr i32, ptr %offset_tbl.i.i74, i64 %hash.i.i.i78
  %offset.i.i80 = load i32, ptr %offset_ptr.i.i79, align 4, !noalias !542
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #40
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract5, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract7, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract9, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i.i80, ptr %80, align 8
  %hash_coef.i.i33.i = load i64, ptr %hash_coef_ptr.i.i55, align 4, !noalias !542
  %tbl_size.i.i34.i = load i64, ptr %tbl_size_ptr.i.i56, align 4, !noalias !542
  %offset_tbl.i.i35.i = load ptr, ptr %offset_tbl_ptr.i.i57, align 8, !noalias !542
  %product.i.i.i36.i = mul i64 %hash_coef.i.i33.i, 8673632051301757104
  %shifted.i.i.i37.i = lshr i64 %product.i.i.i36.i, 32
  %xored.i.i.i38.i = xor i64 %shifted.i.i.i37.i, %product.i.i.i36.i
  %hash.i.i.i39.i = and i64 %xored.i.i.i38.i, %tbl_size.i.i34.i
  %offset_ptr.i.i40.i = getelementptr i32, ptr %offset_tbl.i.i35.i, i64 %hash.i.i.i39.i
  %offset.i.i55.i = load i32, ptr %offset_ptr.i.i40.i, align 4, !noalias !804
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i.i55.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator) #40
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainedCollection_field_ChainedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 25, i64 26
  %8 = getelementptr [118 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 29, %.critedge ], [ 28, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 30, %.critedge ], [ 31, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [118 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 35, %.critedge ], [ 34, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !807
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !807
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !807
  %product.i.i.i = mul i64 %hash_coef.i.i, -4136536984535342799
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !807
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 1375598993350293883
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !810
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 1375598993350293883
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !813
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define i32 @ChainedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !816
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !816
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !816
  %product.i.i.i = mul i64 %hash_coef.i.i, -4136536984535342799
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !816
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract11, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract13) #43
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract5, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract7, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract9, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract3) #58
  %18 = sext i32 %.fca.3.extract9 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract3, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract13) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call i32 %result.i({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = add i32 %38, %22
  ret i32 %39
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ChainedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !819
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !819
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !819
  %product.i.i.i = mul i64 %hash_coef.i.i, -4136536984535342799
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !819
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #43
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract63) #58
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 16
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 16
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #48
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #43
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 16
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #53
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i42 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i43 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 16
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i55 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i56 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i72 = load i64, ptr %hash_coef_ptr.i.i41, align 4, !noalias !542
  %tbl_size.i.i73 = load i64, ptr %tbl_size_ptr.i.i42, align 4, !noalias !542
  %offset_tbl.i.i74 = load ptr, ptr %offset_tbl_ptr.i.i43, align 8, !noalias !542
  %product.i.i.i75 = mul i64 %hash_coef.i.i72, 8673632051301757104
  %shifted.i.i.i76 = lshr i64 %product.i.i.i75, 32
  %xored.i.i.i77 = xor i64 %shifted.i.i.i76, %product.i.i.i75
  %hash.i.i.i78 = and i64 %xored.i.i.i77, %tbl_size.i.i73
  %offset_ptr.i.i79 = getelementptr i32, ptr %offset_tbl.i.i74, i64 %hash.i.i.i78
  %offset.i.i80 = load i32, ptr %offset_ptr.i.i79, align 4, !noalias !542
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #40
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract5, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract7, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract9, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i.i80, ptr %80, align 8
  %hash_coef.i.i33.i = load i64, ptr %hash_coef_ptr.i.i55, align 4, !noalias !542
  %tbl_size.i.i34.i = load i64, ptr %tbl_size_ptr.i.i56, align 4, !noalias !542
  %offset_tbl.i.i35.i = load ptr, ptr %offset_tbl_ptr.i.i57, align 8, !noalias !542
  %product.i.i.i36.i = mul i64 %hash_coef.i.i33.i, 8673632051301757104
  %shifted.i.i.i37.i = lshr i64 %product.i.i.i36.i, 32
  %xored.i.i.i38.i = xor i64 %shifted.i.i.i37.i, %product.i.i.i36.i
  %hash.i.i.i39.i = and i64 %xored.i.i.i38.i, %tbl_size.i.i34.i
  %offset_ptr.i.i40.i = getelementptr i32, ptr %offset_tbl.i.i35.i, i64 %hash.i.i.i39.i
  %offset.i.i55.i = load i32, ptr %offset_ptr.i.i40.i, align 4, !noalias !822
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i.i55.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #40
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator_field_ChainIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !825
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !825
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !825
  %product.i.i.i = mul i64 %hash_coef.i.i, 6043157723929225452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !825
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 8673632051301757104
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !828
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 8673632051301757104
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !831
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract10, i1 true) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ChainIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !834
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !834
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !834
  %product.i.i.i = mul i64 %hash_coef.i.i, 6043157723929225452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !834
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract3) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract3, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i1 %10(ptr %.fca.1.extract4) #43
  br i1 %11, label %12, label %37

12:                                               ; preds = %3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract3) #58
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract4) #43
  %.fca.0.extract22 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract26 = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract28 = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract22, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract24, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract26, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract28, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract22) #58
  %24 = sext i32 %.fca.3.extract28 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract22, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i1 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %28 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4) #53
  %.fca.0.extract16 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract3) #58
  %30 = icmp ne ptr %.fca.0.extract16, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract16, null
  %.not31.not.not = and i1 %30, %31
  br i1 %.not31.not.not, label %54, label %32

32:                                               ; preds = %12
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract3)
  %34 = load ptr, ptr %8, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr %.fca.1.extract4, i1 false) #42
  br label %37

37:                                               ; preds = %32, %3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract3) #58
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract4) #43
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract10, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract11, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract12, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract9) #58
  %49 = sext i32 %.fca.3.extract12 to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract9, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %53 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4) #53
  %.fca.0.extract5 = extractvalue { ptr, i160 } %53, 0
  br label %54

54:                                               ; preds = %37, %12
  %.reg2mem25.sroa.0.0 = phi ptr [ %.fca.0.extract5, %37 ], [ %.fca.0.extract16, %12 ]
  %.pn = phi { ptr, i160 } [ %53, %37 ], [ %28, %12 ]
  %.reg2mem25.sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator_getter_on_first(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable_field_ChainIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !837
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !837
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !837
  %product.i.i.i = mul i64 %hash_coef.i.i, -2370247058431047815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !837
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 3037712219555723519
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !840
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !542
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !542
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !542
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 3037712219555723519
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !843
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract9) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i55, 3
  call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ChainIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !846
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !846
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !846
  %product.i.i.i = mul i64 %hash_coef.i.i, -2370247058431047815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !846
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #43
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract63) #58
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #43
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %38 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #44
  %result.i11 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_wrapper(i64 noundef 80) #48
  store ptr %result.i2, ptr %result.i11, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(80) %result.i11)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #43
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i6 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %56 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #53
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i42 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i43 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i5 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %71 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i55 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i56 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i72 = load i64, ptr %hash_coef_ptr.i.i41, align 4, !noalias !542
  %tbl_size.i.i73 = load i64, ptr %tbl_size_ptr.i.i42, align 4, !noalias !542
  %offset_tbl.i.i74 = load ptr, ptr %offset_tbl_ptr.i.i43, align 8, !noalias !542
  %product.i.i.i75 = mul i64 %hash_coef.i.i72, 8673632051301757104
  %shifted.i.i.i76 = lshr i64 %product.i.i.i75, 32
  %xored.i.i.i77 = xor i64 %shifted.i.i.i76, %product.i.i.i75
  %hash.i.i.i78 = and i64 %xored.i.i.i77, %tbl_size.i.i73
  %offset_ptr.i.i79 = getelementptr i32, ptr %offset_tbl.i.i74, i64 %hash.i.i.i78
  %offset.i.i80 = load i32, ptr %offset_ptr.i.i79, align 4, !noalias !542
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #40
  %77 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %.fca.0.extract5, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.1.extract7, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.2.extract9, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store i32 %offset.i.i80, ptr %80, align 8
  %hash_coef.i.i33.i = load i64, ptr %hash_coef_ptr.i.i55, align 4, !noalias !542
  %tbl_size.i.i34.i = load i64, ptr %tbl_size_ptr.i.i56, align 4, !noalias !542
  %offset_tbl.i.i35.i = load ptr, ptr %offset_tbl_ptr.i.i57, align 8, !noalias !542
  %product.i.i.i36.i = mul i64 %hash_coef.i.i33.i, 8673632051301757104
  %shifted.i.i.i37.i = lshr i64 %product.i.i.i36.i, 32
  %xored.i.i.i38.i = xor i64 %shifted.i.i.i37.i, %product.i.i.i36.i
  %hash.i.i.i39.i = and i64 %xored.i.i.i38.i, %tbl_size.i.i34.i
  %offset_ptr.i.i40.i = getelementptr i32, ptr %offset_tbl.i.i35.i, i64 %hash.i.i.i39.i
  %offset.i.i55.i = load i32, ptr %offset_ptr.i.i40.i, align 4, !noalias !849
  %81 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i11, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i11, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i11, i64 64
  store i32 %offset.i.i55.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator) #40
  %86 = getelementptr inbounds i8, ptr %result.i11, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable_field_FilterIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !852
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !852
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !852
  %product.i.i.i = mul i64 %hash_coef.i.i, 8498466713076104350
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !852
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 3037712219555723519
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !855
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract3, { ptr } %4) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @FilterIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !858
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !858
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !858
  %product.i.i.i = mul i64 %hash_coef.i.i, 8498466713076104350
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !858
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract35) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #43
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract27) #58
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i6 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i6({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract37) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i2 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #44
  %result.i9 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #48
  store ptr %result.i2, ptr %result.i9, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i9)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract37) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract3, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract4, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract5, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract2)
  %41 = sext i32 %.fca.3.extract5 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract2, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i5 = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %45 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4) #53
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %hash_coef_ptr.i.i25 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i28 = load i64, ptr %hash_coef_ptr.i.i25, align 4, !noalias !542
  %tbl_size.i.i29 = load i64, ptr %tbl_size_ptr.i.i26, align 4, !noalias !542
  %offset_tbl.i.i30 = load ptr, ptr %offset_tbl_ptr.i.i27, align 8, !noalias !542
  %product.i.i.i31 = mul i64 %hash_coef.i.i28, 8673632051301757104
  %shifted.i.i.i32 = lshr i64 %product.i.i.i31, 32
  %xored.i.i.i33 = xor i64 %shifted.i.i.i32, %product.i.i.i31
  %hash.i.i.i34 = and i64 %xored.i.i.i33, %tbl_size.i.i29
  %offset_ptr.i.i35 = getelementptr i32, ptr %offset_tbl.i.i30, i64 %hash.i.i.i34
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract37) #43
  %offset.i.i50 = load i32, ptr %offset_ptr.i.i35, align 4, !noalias !542
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %54 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %.fca.0.extract1, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store ptr %.fca.1.extract, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i9, i64 24
  store ptr %.fca.2.extract, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %result.i9, i64 32
  store i32 %offset.i.i50, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @FilterIterator) #40
  %59 = getelementptr inbounds i8, ptr %result.i9, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i, ptr %59, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %60
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator_field_FilterIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !861
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !861
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !861
  %product.i.i.i = mul i64 %hash_coef.i.i, -1221365496900303883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !861
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 8673632051301757104
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !864
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract3, { ptr } %4) #42
  ret void
}

define { ptr, i160 } @FilterIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !867
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !867
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !867
  %product.i.i.i = mul i64 %hash_coef.i.i, -1221365496900303883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !867
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract14) #56
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract16) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %.sroa.0.021 = extractvalue { ptr, i160 } %22, 0
  %24 = icmp ne ptr %.sroa.0.021, @nil_typ
  %25 = icmp ne ptr %.sroa.0.021, null
  %.not5023 = and i1 %24, %25
  br i1 %.not5023, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %27 = getelementptr i8, ptr %7, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr } %29(ptr %.fca.1.extract16) #43
  %.fca.0.extract3731 = extractvalue { ptr } %30, 0
  %31 = call i1 %.fca.0.extract3731({ ptr, i160 } %22)
  br i1 %31, label %._crit_edge.loopexit, label %.lr.ph33.preheader

.lr.ph33.preheader:                               ; preds = %.lr.ph
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  br label %.lr.ph33

33:                                               ; preds = %.lr.ph33
  %34 = load ptr, ptr %27, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract16) #43
  %.fca.0.extract37 = extractvalue { ptr } %36, 0
  %37 = call i1 %.fca.0.extract37({ ptr, i160 } %51)
  br i1 %37, label %._crit_edge.loopexit, label %.lr.ph33

.lr.ph33:                                         ; preds = %33, %.lr.ph33.preheader
  %.pn2432 = phi { ptr, i160 } [ %51, %33 ], [ %22, %.lr.ph33.preheader ]
  %38 = load ptr, ptr %8, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract16) #43
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract34 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract30, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract32, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract34, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract28)
  %47 = sext i32 %.fca.3.extract34 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract28, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %51 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4) #53
  %.sroa.0.0 = extractvalue { ptr, i160 } %51, 0
  %52 = icmp ne ptr %.sroa.0.0, @nil_typ
  %53 = icmp ne ptr %.sroa.0.0, null
  %.not50 = and i1 %52, %53
  br i1 %.not50, label %33, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph33, %33, %.lr.ph
  %.pn24.lcssa = phi { ptr, i160 } [ %22, %.lr.ph ], [ %51, %33 ], [ %.pn2432, %.lr.ph33 ]
  %.reg2mem34.0.ph.ph = phi ptr [ %.sroa.0.021, %.lr.ph ], [ %.sroa.0.0, %33 ], [ @nil_typ, %.lr.ph33 ]
  %.sroa.3.026.le = extractvalue { ptr, i160 } %.pn24.lcssa, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.1.ph = phi i160 [ undef, %3 ], [ %.sroa.3.026.le, %._crit_edge.loopexit ]
  %.reg2mem34.0.ph = phi ptr [ @nil_typ, %3 ], [ %.reg2mem34.0.ph.ph, %._crit_edge.loopexit ]
  %.reload31.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem34.0.ph, 0
  %.reload31.fca.1.insert = insertvalue { ptr, i160 } %.reload31.fca.0.insert, i160 %.1.ph, 1
  ret { ptr, i160 } %.reload31.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterable_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !870
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !870
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !870
  %product.i.i.i = mul i64 %hash_coef.i.i, -7488770571603291722
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !870
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 3037712219555723519
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !873
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract3, { ptr } %4) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @MapIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !876
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !876
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !876
  %product.i.i.i = mul i64 %hash_coef.i.i, -7488770571603291722
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !876
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #43
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract27) #58
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract37) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i4 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #44
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #44
  %result.i11 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store ptr %result.i4, ptr %result.i11, align 8
  %33 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i11)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr %.fca.1.extract37) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract3, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract4, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract5, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract2)
  %45 = sext i32 %.fca.3.extract5 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract2, i64 %45
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %result.i7 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %49 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4) #53
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4, !noalias !542
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4, !noalias !542
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8, !noalias !542
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 8673632051301757104
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr %.fca.1.extract37) #43
  %offset.i.i52 = load i32, ptr %offset_ptr.i.i37, align 4, !noalias !542
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %59 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.0.extract1, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.1.extract, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store ptr %.fca.2.extract, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store i32 %offset.i.i52, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @MapIterator) #40
  %64 = getelementptr inbounds i8, ptr %result.i11, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %64, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %65
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterator_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !879
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !879
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !879
  %product.i.i.i = mul i64 %hash_coef.i.i, -146553482626734782
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !879
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 8673632051301757104
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !882
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract3, { ptr } %4) #42
  ret void
}

define { ptr, i160 } @MapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !885
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !885
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !885
  %product.i.i.i = mul i64 %hash_coef.i.i, -146553482626734782
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !885
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract12, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract14) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #58
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef align 8 %.fca.0.extract12)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not36 = and i1 %24, %25
  br i1 %.not36, label %26, label %33

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract12)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %.fca.1.extract14) #43
  %.fca.0.extract28 = extractvalue { ptr } %31, 0
  %32 = call { ptr, i160 } %.fca.0.extract28({ ptr, i160 } %22)
  %.fca.0.extract22 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract24 = extractvalue { ptr, i160 } %32, 1
  br label %33

33:                                               ; preds = %26, %3
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract22, %26 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract24, %26 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MappedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 26
  %8 = getelementptr [119 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 30, i64 29
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [119 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 31, %.critedge ], [ 32, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [119 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 34, i64 33
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [119 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 36, %.critedge ], [ 35, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [119 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MappedCollection_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #5 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !888
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !888
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !888
  %product.i.i.i = mul i64 %hash_coef.i.i, 5460697656559120915
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !888
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 1375598993350293883
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !891
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i27, 3
  call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #42
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract3, { ptr } %4) #42
  ret void
}

; Function Attrs: nounwind
define i32 @MappedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !894
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !894
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !894
  %product.i.i.i = mul i64 %hash_coef.i.i, 5460697656559120915
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !894
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract3) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract) #58
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  ret i32 %22
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @MappedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !897
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !897
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !897
  %product.i.i.i = mul i64 %hash_coef.i.i, 5460697656559120915
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !897
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #43
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract27) #58
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 16
  %21 = load ptr, ptr %20, align 8
  %result.i8 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i8({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr nonnull %.fca.1.extract37) #43
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i4 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #44
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i3 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #44
  %result.i11 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store ptr %result.i4, ptr %result.i11, align 8
  %33 = getelementptr inbounds i8, ptr %result.i11, i64 8
  store ptr %result.i3, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i11)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr %.fca.1.extract37) #43
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract3, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract4, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract5, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract2)
  %45 = sext i32 %.fca.3.extract5 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract2, i64 %45
  %47 = getelementptr i8, ptr %46, i64 16
  %48 = load ptr, ptr %47, align 8
  %result.i7 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %49 = call { ptr, ptr, ptr, i32 } %result.i7({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4) #53
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4, !noalias !542
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4, !noalias !542
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8, !noalias !542
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 8673632051301757104
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr %.fca.1.extract37) #43
  %offset.i.i52 = load i32, ptr %offset_ptr.i.i37, align 4, !noalias !542
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i11, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef align 8 %.fca.0.extract35)
  %59 = getelementptr inbounds i8, ptr %result.i11, i64 16
  store ptr %.fca.0.extract1, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %result.i11, i64 24
  store ptr %.fca.1.extract, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %result.i11, i64 32
  store ptr %.fca.2.extract, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %result.i11, i64 40
  store i32 %offset.i.i52, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @MapIterator) #40
  %64 = getelementptr inbounds i8, ptr %result.i11, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %64, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %65
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MappedCollection_getter_f(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MappedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_EnumeratedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 25, i64 26
  %8 = getelementptr [118 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 29, %.critedge ], [ 28, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 30, %.critedge ], [ 31, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 33, i64 32
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [118 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 35, %.critedge ], [ 34, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [118 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @EnumeratedCollection_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !900
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !900
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !900
  %product.i.i.i = mul i64 %hash_coef.i.i, 7081690788784801875
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !900
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 1375598993350293883
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !903
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i27, 3
  call void %11(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %15) #42
  ret void
}

; Function Attrs: nounwind
define i32 @EnumeratedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !906
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !906
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !906
  %product.i.i.i = mul i64 %hash_coef.i.i, 7081690788784801875
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !906
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract3) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract) #58
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call i32 %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  ret i32 %22
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @EnumeratedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !909
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !909
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !909
  %product.i.i.i = mul i64 %hash_coef.i.i, 7081690788784801875
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !909
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract31) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract31, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract33) #43
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract23, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract25, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract27, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract29, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract23) #58
  %18 = sext i32 %.fca.3.extract29 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract23, i64 %18
  %20 = getelementptr i8, ptr %19, i64 16
  %21 = load ptr, ptr %20, align 8
  %result.i5 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %24 = load ptr, ptr %7, align 8
  %result.i1 = call ptr %24(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract33) #44
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %result.i8 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %26 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i1, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr null, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i8)
  store ptr @Pair, ptr %result.i8, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store ptr %result.i1, ptr %result.i7, align 8
  %30 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i8, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %33 = load ptr, ptr %8, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract33) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract2, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract3, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %.fca.3.extract4, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract1)
  %42 = sext i32 %.fca.3.extract4 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract1, i64 %42
  %44 = getelementptr i8, ptr %43, i64 16
  %45 = load ptr, ptr %44, align 8
  %result.i4 = call ptr %45({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %46 = call { ptr, ptr, ptr, i32 } %result.i4({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 2
  %hash_coef_ptr.i.i24 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i25 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i27 = load i64, ptr %hash_coef_ptr.i.i24, align 4, !noalias !542
  %tbl_size.i.i28 = load i64, ptr %tbl_size_ptr.i.i25, align 4, !noalias !542
  %offset_tbl.i.i29 = load ptr, ptr %offset_tbl_ptr.i.i26, align 8, !noalias !542
  %product.i.i.i30 = mul i64 %hash_coef.i.i27, 8673632051301757104
  %shifted.i.i.i31 = lshr i64 %product.i.i.i30, 32
  %xored.i.i.i32 = xor i64 %shifted.i.i.i31, %product.i.i.i30
  %hash.i.i.i33 = and i64 %xored.i.i.i32, %tbl_size.i.i28
  %offset_ptr.i.i34 = getelementptr i32, ptr %offset_tbl.i.i29, i64 %hash.i.i.i33
  %offset.i.i49 = load i32, ptr %offset_ptr.i.i34, align 4, !noalias !542
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %50 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store ptr %.fca.1.extract, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i7, i64 32
  store ptr %.fca.2.extract, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %offset.i.i49, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator) #40
  %55 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store i32 0, ptr %55, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %56
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @EnumeratedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @EnumeratedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @StringIterator_field_StringIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !912
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !912
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !912
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !912
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 6499063144389013426
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !915
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i27, 3
  call void %10(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %14) #42
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %16 = getelementptr i8, ptr %7, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract2, i32 0) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !918
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !918
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !918
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !918
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract10, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract12) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #58
  %17 = load ptr, ptr %11, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr, ptr, ptr, i32 } %18(ptr %.fca.1.extract12) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 3
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %.fca.3.extract, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract) #58
  %26 = sext i32 %.fca.3.extract to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 64
  %29 = load ptr, ptr %28, align 8
  %result.i4 = call ptr %29({ ptr, ptr, ptr, i32 } %23, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %30 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull align 8 %4) #53
  %.not = icmp slt i32 %15, %30
  br i1 %.not, label %31, label %82

31:                                               ; preds = %3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %33 = load ptr, ptr %12, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call i32 %34(ptr %.fca.1.extract12) #43
  %36 = add i32 %35, 1
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %38 = getelementptr i8, ptr %33, i64 8
  %39 = load ptr, ptr %38, align 8
  call void %39(ptr %.fca.1.extract12, i32 %36) #42
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %41 = load ptr, ptr %12, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %.fca.1.extract12) #43
  %44 = add i32 %43, -1
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %46 = load ptr, ptr %11, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr, ptr, ptr, i32 } %47(ptr %.fca.1.extract12) #43
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %48, 0
  %.fca.1.extract36 = extractvalue { ptr, ptr, ptr, i32 } %48, 1
  %.fca.2.extract38 = extractvalue { ptr, ptr, ptr, i32 } %48, 2
  %.fca.3.extract40 = extractvalue { ptr, ptr, ptr, i32 } %48, 3
  %49 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.1.extract36, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %.fca.2.extract38, 2
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 %.fca.3.extract40, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract34)
  %55 = sext i32 %.fca.3.extract40 to i64
  %56 = getelementptr ptr, ptr %.fca.0.extract34, i64 %55
  %57 = getelementptr i8, ptr %56, i64 120
  %58 = load ptr, ptr %57, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i3 = call ptr %58({ ptr, ptr, ptr, i32 } %52, ptr nocapture nofree noundef nonnull readonly %6) #46
  %59 = call i8 %result.i3({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull align 8 dereferenceable(8) %5, i32 %44) #53
  %result.i5 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #48
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %61 = load ptr, ptr %12, align 8
  %62 = load ptr, ptr %61, align 8
  %63 = call i32 %62(ptr %.fca.1.extract12) #43
  %64 = add i32 %63, -1
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %66 = load ptr, ptr %11, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr, ptr, ptr, i32 } %67(ptr %.fca.1.extract12) #43
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.3.extract25 = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.1.extract21, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %.fca.2.extract23, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %.fca.3.extract25, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract19)
  %75 = sext i32 %.fca.3.extract25 to i64
  %76 = getelementptr ptr, ptr %.fca.0.extract19, i64 %75
  %77 = getelementptr i8, ptr %76, i64 120
  %78 = load ptr, ptr %77, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i2 = call ptr %78({ ptr, ptr, ptr, i32 } %72, ptr nocapture nofree noundef nonnull readonly %8) #46
  %79 = call i8 %result.i2({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull align 8 dereferenceable(8) %7, i32 %64) #53
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @Character) #40
  store i8 %79, ptr %result.i5, align 1
  %81 = ptrtoint ptr %result.i5 to i64
  %.sroa.3.8.insert.ext = zext i64 %81 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %82

82:                                               ; preds = %31, %3
  %.reg2mem25.sroa.0.0 = phi ptr [ @Character, %31 ], [ @nil_typ, %3 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %31 ], [ undef, %3 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_bytei8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i8_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_byte_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Character_init_bytei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !921
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !921
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !921
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !921
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  call void %10(ptr %.fca.1.extract, i8 %3) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i8 @Character_byte_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !924
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !924
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !924
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !924
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = call i8 %8(ptr %.fca.1.extract) #43
  ret i8 %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i8 @Character_getter_byte(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0) #2 {
  %2 = load i8, ptr %0, align 1
  ret i8 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_byte(ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %0, i8 %1) #3 {
  store i8 %1, ptr %0, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #3 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #35 {
  %result.i3 = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #48
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %result.i3, align 1
  %result.i2 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i3, ptr %result.i2, align 8
  %7 = getelementptr i8, ptr %result.i2, i64 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 6, i32 7>, ptr %7, align 8
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i64_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree noundef nonnull readonly dereferenceable(8) %0, ptr nocapture nofree readnone %1) #2 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_f64_typ({ ptr, i160 } %0, ptr nocapture nofree readnone %1, ptr nocapture nofree noundef nonnull writeonly dereferenceable(8) %2) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterableT(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #40
  ret ptr @Array__Self_from_iterable_iterableIterableT
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_extend_otherArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__set_index_xi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_insert_xi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 54, i64 53
  %8 = getelementptr [149 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 57, %.critedge ], [ 56, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [149 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 58, i64 59
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [149 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 3037712219555723519, i64 ptrtoint (ptr @Iterable to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %.critedge

13:                                               ; preds = %2
  %result.i = call i1 %11(i64 %10, i64 %9, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %12) #44
  br i1 %result.i, label %.critedge, label %14

.critedge:                                        ; preds = %13, %2
  br label %14

14:                                               ; preds = %.critedge, %13
  %.reg2mem3.0 = phi i64 [ 61, %.critedge ], [ 60, %13 ]
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr [149 x ptr], ptr %15, i64 0, i64 %.reg2mem3.0
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #32 {
._crit_edge:
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = call i1 %10(i64 %9, i64 %8, i64 1375598993350293883, i64 ptrtoint (ptr @Collection to i64), ptr readonly %11) #44
  %12 = select i1 %result.i, i64 63, i64 62
  %13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %14 = getelementptr [149 x ptr], ptr %13, i64 0, i64 %12
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterableT(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #28 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !927
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !927
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !927
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !927
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract26) #56
  %5 = sext i32 %.fca.3.extract29 to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract26, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call align 8 ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract27) #44
  %result.i7 = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_wrapper(i64 noundef 24) #48
  store ptr %result.i1, ptr %result.i7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i7) #56
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #40
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #40
  %11 = load ptr, ptr %result.i1, align 8
  %12 = getelementptr i8, ptr %11, i64 72
  %13 = load ptr, ptr %12, align 8
  %result.i1.i = call { i64, i64 } %13(ptr nocapture nofree nonnull readonly align 8 %result.i1) #44
  %14 = extractvalue { i64, i64 } %result.i1.i, 0
  %result.i2.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %14) #48
  %15 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i2.i, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i7, i64 16
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #40
  %18 = getelementptr inbounds i8, ptr %result.i7, i64 20
  store <2 x i32> <i32 0, i32 1>, ptr %16, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract27, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract28, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %offset.i.i, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #56
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef align 8 %.fca.0.extract26) #56
  %25 = sext i32 %offset.i.i to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract26, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %result.i5 = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %29 = call { ptr, ptr, ptr, i32 } %result.i5({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %3) #53
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %29, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %29, 2
  %hash_coef_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i9, align 4, !noalias !930
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i10, align 4, !noalias !930
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i11, align 8, !noalias !930
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, 8673632051301757104
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4, !noalias !930
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.1.extract, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.2.extract, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %offset.i.i20, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %36 = sext i32 %offset.i.i20 to i64
  %37 = getelementptr ptr, ptr %.fca.0.extract, i64 %36
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %result.i458 = call ptr %39({ ptr, ptr, ptr, i32 } %33, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %40 = call { ptr, i160 } %result.i458({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull align 8 %3) #53
  %.fca.0.extract6359 = extractvalue { ptr, i160 } %40, 0
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract26)
  %42 = icmp ne ptr %.fca.0.extract6359, @nil_typ
  %43 = icmp ne ptr %.fca.0.extract6359, null
  %.not7160 = and i1 %42, %43
  br i1 %.not7160, label %._crit_edge.lr.ph, label %.critedge

._crit_edge.lr.ph:                                ; preds = %2
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %Array_append_xT.exit, %._crit_edge.lr.ph
  %45 = phi ptr [ %result.i2.i, %._crit_edge.lr.ph ], [ %71, %Array_append_xT.exit ]
  %.pre76 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %82, %Array_append_xT.exit ]
  %46 = phi { ptr, i160 } [ %40, %._crit_edge.lr.ph ], [ %85, %Array_append_xT.exit ]
  %47 = load i32, ptr %18, align 4
  %.not.i = icmp slt i32 %.pre76, %47
  br i1 %.not.i, label %._crit_edge.Array_append_xT.exit_crit_edge, label %48

._crit_edge.Array_append_xT.exit_crit_edge:       ; preds = %._crit_edge
  %.pre81 = load ptr, ptr %result.i1, align 8
  br label %Array_append_xT.exit

48:                                               ; preds = %._crit_edge
  %49 = shl i32 %47, 1
  %.not.i77 = icmp sgt i32 %49, %47
  %.pre.pre = load ptr, ptr %15, align 8
  %.pre = load ptr, ptr %result.i1, align 8
  br i1 %.not.i77, label %50, label %Array_append_xT.exit

50:                                               ; preds = %48
  store i32 %49, ptr %18, align 4
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array)
  %52 = sext i32 %49 to i64
  %53 = getelementptr i8, ptr %.pre, i64 72
  %54 = load ptr, ptr %53, align 8
  %result.i6.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly %result.i1) #44
  %55 = extractvalue { i64, i64 } %result.i6.i, 0
  %56 = mul i64 %55, %52
  %result.i8.i = call noalias ptr @bump_malloc_wrapper(i64 noundef %56) #48
  store ptr %result.i8.i, ptr %15, align 8
  %57 = icmp sgt i32 %.pre76, 0
  %.pre82 = load ptr, ptr %result.i1, align 8
  br i1 %57, label %._crit_edge.lr.ph.i, label %Array_append_xT.exit

._crit_edge.lr.ph.i:                              ; preds = %50
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array)
  %59 = zext nneg i32 %.pre76 to i64
  %60 = getelementptr i8, ptr %.pre82, i64 72
  %61 = getelementptr i8, ptr %.pre82, i64 56
  %62 = getelementptr i8, ptr %.pre82, i64 64
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i, %._crit_edge.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %._crit_edge.lr.ph.i ], [ %indvars.iv.next.i, %._crit_edge.i ]
  %63 = load ptr, ptr %60, align 8
  %result.i5.i = call { i64, i64 } %63(ptr nocapture nofree nonnull readonly %result.i1) #44
  %64 = extractvalue { i64, i64 } %result.i5.i, 0
  %65 = mul i64 %64, %indvars.iv.i
  %66 = getelementptr i8, ptr %.pre.pre, i64 %65
  %67 = load ptr, ptr %61, align 8
  %result.i7.i = call { ptr, i160 } %67(ptr nocapture nofree readonly %66, ptr nocapture nofree nonnull readonly %result.i1) #44
  %68 = getelementptr i8, ptr %result.i8.i, i64 %65
  %69 = load ptr, ptr %62, align 8
  call void %69({ ptr, i160 } %result.i7.i, ptr nocapture nofree nonnull readonly %result.i1, ptr nocapture nofree writeonly %68) #45
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next.i, %59
  br i1 %exitcond.not, label %Array_append_xT.exit, label %._crit_edge.i

Array_append_xT.exit:                             ; preds = %._crit_edge.i, %50, %48, %._crit_edge.Array_append_xT.exit_crit_edge
  %70 = phi ptr [ %.pre81, %._crit_edge.Array_append_xT.exit_crit_edge ], [ %.pre, %48 ], [ %.pre82, %50 ], [ %.pre82, %._crit_edge.i ]
  %71 = phi ptr [ %45, %._crit_edge.Array_append_xT.exit_crit_edge ], [ %.pre.pre, %48 ], [ %result.i8.i, %50 ], [ %result.i8.i, %._crit_edge.i ]
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  %73 = sext i32 %.pre76 to i64
  %74 = getelementptr i8, ptr %70, i64 72
  %75 = load ptr, ptr %74, align 8
  %result.i1.i75 = call { i64, i64 } %75(ptr nocapture nofree nonnull readonly %result.i1) #44
  %76 = extractvalue { i64, i64 } %result.i1.i75, 0
  %77 = mul i64 %76, %73
  %78 = getelementptr i8, ptr %71, i64 %77
  %79 = getelementptr i8, ptr %70, i64 64
  %80 = load ptr, ptr %79, align 8
  call void %80({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %result.i1, ptr nocapture nofree writeonly %78) #45
  %81 = load i32, ptr %16, align 8
  %82 = add i32 %81, 1
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array) #58
  store i32 %82, ptr %16, align 8
  %84 = load ptr, ptr %38, align 8
  %result.i4 = call ptr %84({ ptr, ptr, ptr, i32 } %33, ptr nocapture nofree noundef nonnull readonly %3) #46
  %85 = call { ptr, i160 } %result.i4({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull align 8 %3) #53
  %.fca.0.extract63 = extractvalue { ptr, i160 } %85, 0
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract26)
  %87 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %88 = icmp ne ptr %.fca.0.extract63, null
  %.not71 = and i1 %87, %88
  br i1 %.not71, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %Array_append_xT.exit, %2
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %89 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %90 = insertvalue { ptr, ptr, ptr, i32 } %89, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %90
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !933
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !933
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !933
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !933
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %8 = load ptr, ptr %result.i, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %result.i1 = call { i64, i64 } %10(ptr nocapture nofree nonnull readonly align 8 %result.i) #44
  %11 = extractvalue { i64, i64 } %result.i1, 0
  %result.i2 = call noalias ptr @bump_malloc_wrapper(i64 noundef %11) #48
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %16(ptr %.fca.1.extract, { ptr } %17) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %19 = getelementptr i8, ptr %6, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 0) #42
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #58
  %24 = getelementptr i8, ptr %6, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr %.fca.1.extract, i32 1) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !936
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !936
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !936
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !936
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #42
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr nonnull %.fca.1.extract) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %17 = load ptr, ptr %7, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %18 = sext i32 %15 to i64
  %19 = load ptr, ptr %result.i, align 8
  %20 = getelementptr i8, ptr %19, i64 72
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call { i64, i64 } %21(ptr nocapture nofree nonnull readonly align 8 %result.i) #44
  %22 = extractvalue { i64, i64 } %result.i1, 0
  %23 = mul i64 %22, %18
  %result.i2 = call noalias ptr @bump_malloc_wrapper(i64 noundef %23) #48
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %25 = getelementptr i8, ptr %7, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %28(ptr %.fca.1.extract, { ptr } %29) #42
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %31 = getelementptr i8, ptr %7, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %.fca.1.extract, i32 0) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !939
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !939
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !939
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !939
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 %4) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %19 = load ptr, ptr %14, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr nonnull %.fca.1.extract) #43
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %23 = load ptr, ptr %8, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %23(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %24 = sext i32 %21 to i64
  %25 = load ptr, ptr %result.i, align 8
  %26 = getelementptr i8, ptr %25, i64 72
  %27 = load ptr, ptr %26, align 8
  %result.i1 = call { i64, i64 } %27(ptr nocapture nofree nonnull readonly align 8 %result.i) #44
  %28 = extractvalue { i64, i64 } %result.i1, 0
  %29 = mul i64 %28, %24
  %result.i2 = call noalias ptr @bump_malloc_wrapper(i64 noundef %29) #48
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %31 = getelementptr i8, ptr %8, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %34(ptr %.fca.1.extract, { ptr } %35) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #5 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !942
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !942
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !942
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !942
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract2, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, i32 %4) #42
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %20 = getelementptr i8, ptr %9, i64 24
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !945
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !945
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !945
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !945
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !948
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !948
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !948
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !948
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #28 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !951
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !951
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !951
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !951
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract4, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract5) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #40
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %.fca.1.extract5) #43
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %.pre30 = insertvalue { ptr, ptr, ptr, i32 } %.pre29, ptr %.fca.1.extract5, 1
  %.pre32 = insertvalue { ptr, ptr, ptr, i32 } %.pre30, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #58
  %21 = call i32 %17(ptr %.fca.1.extract5) #43
  %22 = shl i32 %21, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract5, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #58
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #58
  %29 = getelementptr i8, ptr %9, i64 104
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  call void %result.i2({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %22) #53
  %.pre = load ptr, ptr %10, align 8
  %.pre28 = load ptr, ptr %.pre, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %19, %.._crit_edge_crit_edge
  %.pre-phi33 = phi { ptr, ptr, ptr, i32 } [ %.pre32, %.._crit_edge_crit_edge ], [ %25, %19 ]
  %31 = phi ptr [ %12, %.._crit_edge_crit_edge ], [ %.pre28, %19 ]
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #58
  %33 = call i32 %31(ptr nonnull %.fca.1.extract5) #43
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #58
  %35 = getelementptr i8, ptr %9, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr nonnull %.fca.1.extract5) #43
  %.fca.0.extract14 = extractvalue { ptr } %38, 0
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #58
  %40 = load ptr, ptr %9, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #44
  %41 = sext i32 %33 to i64
  %42 = load ptr, ptr %result.i, align 8
  %43 = getelementptr i8, ptr %42, i64 72
  %44 = load ptr, ptr %43, align 8
  %result.i1 = call { i64, i64 } %44(ptr nocapture nofree nonnull readonly align 8 %result.i) #44
  %45 = extractvalue { i64, i64 } %result.i1, 0
  %46 = mul i64 %45, %41
  %47 = getelementptr i8, ptr %.fca.0.extract14, i64 %46
  %48 = getelementptr i8, ptr %42, i64 64
  %49 = load ptr, ptr %48, align 8
  call void %49({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i, ptr nocapture nofree writeonly %47) #45
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #58
  %51 = load ptr, ptr %10, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr %.fca.1.extract5) #43
  %54 = add i32 %53, 1
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract4) #58
  %56 = getelementptr i8, ptr %51, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %.fca.1.extract5, i32 %54) #42
  %hash_coef.i.i7 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !954
  %tbl_size.i.i8 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !954
  %offset_tbl.i.i9 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !954
  %product.i.i.i10 = mul i64 %hash_coef.i.i7, -5261542750394134544
  %shifted.i.i.i11 = lshr i64 %product.i.i.i10, 32
  %xored.i.i.i12 = xor i64 %shifted.i.i.i11, %product.i.i.i10
  %hash.i.i.i13 = and i64 %xored.i.i.i12, %tbl_size.i.i8
  %offset_ptr.i.i14 = getelementptr i32, ptr %offset_tbl.i.i9, i64 %hash.i.i.i13
  %offset.i.i15 = load i32, ptr %offset_ptr.i.i14, align 4, !noalias !954
  %58 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi33, i32 %offset.i.i15, 3
  ret { ptr, ptr, ptr, i32 } %58
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array_extend_otherArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #28 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !957
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !957
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !957
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !957
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i6 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i8 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i9 = load i64, ptr %hash_coef_ptr.i.i6, align 4, !noalias !960
  %tbl_size.i.i10 = load i64, ptr %tbl_size_ptr.i.i7, align 4, !noalias !960
  %offset_tbl.i.i11 = load ptr, ptr %offset_tbl_ptr.i.i8, align 8, !noalias !960
  %product.i.i.i12 = mul i64 %hash_coef.i.i9, -5261542750394134544
  %shifted.i.i.i13 = lshr i64 %product.i.i.i12, 32
  %xored.i.i.i14 = xor i64 %shifted.i.i.i13, %product.i.i.i12
  %hash.i.i.i15 = and i64 %xored.i.i.i14, %tbl_size.i.i10
  %offset_ptr.i.i16 = getelementptr i32, ptr %offset_tbl.i.i11, i64 %hash.i.i.i15
  %offset.i.i17 = load i32, ptr %offset_ptr.i.i16, align 4, !noalias !960
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.1.extract, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.2.extract, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %offset.i.i17, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #40
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %16 = sext i32 %offset.i.i17 to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract, i64 %16
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i4 = call ptr %19({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %20 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 %5) #53
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %22 = sext i32 %offset.i.i to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract11, i64 %22
  %24 = getelementptr i8, ptr %23, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract12) #43
  %28 = add i32 %27, %20
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.1.extract12, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.2.extract13, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i, 3
  %33 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract11)
  %36 = getelementptr i8, ptr %23, i64 104
  %37 = load ptr, ptr %36, align 8
  %38 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %38, align 8
  %result.i3 = call ptr %37({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly align 8 %38) #46
  call void %result.i3({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 dereferenceable(8) %33, i32 %28) #53
  %39 = getelementptr inbounds i8, ptr %8, i64 8
  %40 = getelementptr inbounds i8, ptr %9, i64 8
  %41 = icmp sgt i32 %20, 0
  br i1 %41, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %4
  %42 = getelementptr i8, ptr %17, i64 128
  %43 = getelementptr i8, ptr %23, i64 136
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %.052 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %54, %._crit_edge ]
  %44 = add i32 %.052, %27
  store ptr @_parameterization_i32, ptr %6, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %47 = load ptr, ptr %42, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i2 = call ptr %47({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly %7) #46
  %48 = call { ptr, i160 } %result.i2({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 dereferenceable(8) %6, i32 %.052) #53
  %.fca.0.extract24 = extractvalue { ptr, i160 } %48, 0
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract11)
  %50 = load ptr, ptr %23, align 8
  %result.i = call ptr %50(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #44
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr %result.i, ptr %39, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract11)
  %53 = load ptr, ptr %43, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr %.fca.0.extract24, ptr %40, align 8
  %result.i1 = call ptr %53({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %9) #46
  call void %result.i1({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 dereferenceable(16) %8, i32 %44, { ptr, i160 } %48) #53
  %54 = add nuw nsw i32 %.052, 1
  %exitcond.not = icmp eq i32 %54, %20
  br i1 %exitcond.not, label %._crit_edge1._crit_edge, label %._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract11)
  %56 = load ptr, ptr %24, align 8
  %57 = getelementptr i8, ptr %56, i64 8
  %58 = load ptr, ptr %57, align 8
  call void %58(ptr %.fca.1.extract12, i32 %28) #42
  %hash_coef.i.i23 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !963
  %tbl_size.i.i24 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !963
  %offset_tbl.i.i25 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !963
  %product.i.i.i26 = mul i64 %hash_coef.i.i23, -5261542750394134544
  %shifted.i.i.i27 = lshr i64 %product.i.i.i26, 32
  %xored.i.i.i28 = xor i64 %shifted.i.i.i27, %product.i.i.i26
  %hash.i.i.i29 = and i64 %xored.i.i.i28, %tbl_size.i.i24
  %offset_ptr.i.i30 = getelementptr i32, ptr %offset_tbl.i.i25, i64 %hash.i.i.i29
  %offset.i.i31 = load i32, ptr %offset_ptr.i.i30, align 4, !noalias !963
  %59 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i31, 3
  ret { ptr, ptr, ptr, i32 } %59
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #43
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %.loopexit

12:                                               ; preds = %4
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  call void %15(ptr %.fca.1.extract, i32 %3) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr } %19(ptr nonnull %.fca.1.extract) #43
  %.fca.0.extract25 = extractvalue { ptr } %20, 0
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %22 = load ptr, ptr %8, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = call i32 %23(ptr nonnull %.fca.1.extract) #43
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %26 = load ptr, ptr %7, align 8
  %result.i3 = call nonnull align 8 dereferenceable(8) ptr %26(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %27 = sext i32 %24 to i64
  %28 = load ptr, ptr %result.i3, align 8
  %29 = getelementptr i8, ptr %28, i64 72
  %30 = load ptr, ptr %29, align 8
  %result.i6 = call { i64, i64 } %30(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44
  %31 = extractvalue { i64, i64 } %result.i6, 0
  %32 = mul i64 %31, %27
  %result.i8 = call noalias ptr @bump_malloc_wrapper(i64 noundef %32) #48
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %34 = load ptr, ptr %17, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %result.i8, 0
  call void %36(ptr %.fca.1.extract, { ptr } %37) #42
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr %.fca.1.extract) #43
  %43 = icmp sgt i32 %42, 0
  br i1 %43, label %._crit_edge.lr.ph, label %.loopexit

._crit_edge.lr.ph:                                ; preds = %12
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %._crit_edge.lr.ph
  %indvars.iv = phi i64 [ 0, %._crit_edge.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %46 = load ptr, ptr %7, align 8
  %result.i2 = call align 8 ptr %46(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %47 = load ptr, ptr %result.i2, align 8
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i5 = call { i64, i64 } %49(ptr nocapture nofree nonnull readonly align 8 %result.i2) #44
  %50 = extractvalue { i64, i64 } %result.i5, 0
  %51 = mul i64 %50, %indvars.iv
  %52 = getelementptr i8, ptr %.fca.0.extract25, i64 %51
  %53 = getelementptr i8, ptr %47, i64 56
  %54 = load ptr, ptr %53, align 8
  %result.i7 = call { ptr, i160 } %54(ptr nocapture nofree readonly %52, ptr nocapture nofree nonnull readonly align 8 %result.i2) #44
  %55 = load ptr, ptr %17, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = call { ptr } %56(ptr nonnull %.fca.1.extract) #43
  %.fca.0.extract8 = extractvalue { ptr } %57, 0
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract) #58
  %59 = getelementptr i8, ptr %.fca.0.extract8, i64 %51
  %60 = getelementptr i8, ptr %47, i64 64
  %61 = load ptr, ptr %60, align 8
  call void %61({ ptr, i160 } %result.i7, ptr nocapture nofree nonnull readonly align 8 %result.i2, ptr nocapture nofree writeonly %59) #45
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %62 = load ptr, ptr %39, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call i32 %63(ptr %.fca.1.extract) #43
  %65 = sext i32 %64 to i64
  %66 = icmp slt i64 %indvars.iv.next, %65
  br i1 %66, label %._crit_edge, label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %12, %4
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @Array__index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #28 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca [3 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr }, align 8
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  %12 = alloca [2 x ptr], align 8
  %13 = alloca { ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %.fca.1.extract, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %16, i64 16
  store ptr %.fca.2.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %16, i64 24
  call void @llvm.experimental.noalias.scope.decl(metadata !966) #40
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !966
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !966
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !966
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !966
  store i32 %offset.i.i, ptr %19, align 8, !alias.scope !966
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %21 = sext i32 %offset.i.i to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract, i64 %21
  %23 = getelementptr i8, ptr %22, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr %.fca.1.extract) #43
  %27 = add i32 %26, -1
  %28 = icmp sgt i32 %3, %27
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %30 = call i32 %25(ptr %.fca.1.extract) #43
  %31 = add i32 %30, %3
  %32 = icmp slt i32 %31, 0
  %.0 = select i1 %28, i1 true, i1 %32
  br i1 %.0, label %codeRepl, label %._crit_edge

codeRepl:                                         ; preds = %4
  call fastcc void @Array__index_xi32.cold.1(ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract, ptr %.fca.1.extract, ptr nocapture nofree noundef nonnull readonly %25, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %5, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %17, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7, i32 %3, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %13) #59
  %.pre.pre = load ptr, ptr %16, align 8
  %.pre2.pre = load ptr, ptr %17, align 8
  %.pre3.pre = load i32, ptr %19, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %codeRepl, %4
  %.pre3 = phi i32 [ %.pre3.pre, %codeRepl ], [ %offset.i.i, %4 ]
  %.pre2 = phi ptr [ %.pre2.pre, %codeRepl ], [ %.fca.1.extract, %4 ]
  %.pre = phi ptr [ %.pre.pre, %codeRepl ], [ %.fca.0.extract, %4 ]
  %33 = icmp slt i32 %3, 0
  br i1 %33, label %34, label %._crit_edge.._crit_edge1_crit_edge

._crit_edge.._crit_edge1_crit_edge:               ; preds = %._crit_edge
  %.pre7 = sext i32 %.pre3 to i64
  br label %._crit_edge1

34:                                               ; preds = %._crit_edge
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.pre) #58
  %36 = sext i32 %.pre3 to i64
  %37 = getelementptr ptr, ptr %.pre, i64 %36
  %38 = getelementptr i8, ptr %37, i64 16
  %39 = load ptr, ptr %38, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call i32 %40(ptr %.pre2) #43
  %42 = add i32 %41, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %34, %._crit_edge.._crit_edge1_crit_edge
  %.pre-phi = phi i64 [ %.pre7, %._crit_edge.._crit_edge1_crit_edge ], [ %36, %34 ]
  %.060 = phi i32 [ %3, %._crit_edge.._crit_edge1_crit_edge ], [ %42, %34 ]
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.pre, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.pre2, 1
  %45 = load ptr, ptr %18, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %.pre3, 3
  store ptr @_parameterization_i32, ptr %14, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14) #58
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.pre) #58
  %50 = getelementptr ptr, ptr %.pre, i64 %.pre-phi
  %51 = getelementptr i8, ptr %50, i64 128
  %52 = load ptr, ptr %51, align 8
  store ptr @i32_typ, ptr %15, align 8
  %result.i = call ptr %52({ ptr, ptr, ptr, i32 } %47, ptr nocapture nofree noundef nonnull readonly align 8 %15) #46
  %53 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull align 8 dereferenceable(8) %14, i32 %.060) #53
  ret { ptr, i160 } %53
}

; Function Attrs: nounwind
define void @Array__set_index_xi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #28 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca [3 x ptr], align 8
  %11 = alloca { ptr, ptr, ptr }, align 8
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  %13 = alloca [2 x ptr], align 8
  %14 = alloca { ptr, ptr }, align 8
  %15 = alloca [2 x ptr], align 8
  %16 = alloca { ptr, ptr }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract16, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %.fca.1.extract17, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr %.fca.2.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %17, i64 24
  call void @llvm.experimental.noalias.scope.decl(metadata !969) #40
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !969
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !969
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !969
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !969
  store i32 %offset.i.i, ptr %20, align 8, !alias.scope !969
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #40
  %22 = sext i32 %offset.i.i to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract16, i64 %22
  %24 = getelementptr i8, ptr %23, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract17) #43
  %28 = add i32 %27, -1
  %29 = icmp sgt i32 %3, %28
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract16) #40
  %31 = call i32 %26(ptr %.fca.1.extract17) #43
  %32 = add i32 %31, %3
  %33 = icmp slt i32 %32, 0
  %.0 = select i1 %29, i1 true, i1 %33
  br i1 %.0, label %codeRepl, label %._crit_edge

codeRepl:                                         ; preds = %5
  call fastcc void @Array__set_index_xi32_valueT.cold.1(ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract16, ptr %.fca.1.extract17, ptr nocapture nofree noundef nonnull readonly %26, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %18, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %17, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %20, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8, i32 %3, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %14) #59
  %.pre.pre = load ptr, ptr %17, align 8
  %.pre3.pre = load ptr, ptr %18, align 8
  %.pre4.pre = load i32, ptr %20, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %codeRepl, %5
  %.pre4 = phi i32 [ %.pre4.pre, %codeRepl ], [ %offset.i.i, %5 ]
  %.pre3 = phi ptr [ %.pre3.pre, %codeRepl ], [ %.fca.1.extract17, %5 ]
  %.pre = phi ptr [ %.pre.pre, %codeRepl ], [ %.fca.0.extract16, %5 ]
  %34 = icmp slt i32 %3, 0
  br i1 %34, label %35, label %._crit_edge.._crit_edge1_crit_edge

._crit_edge.._crit_edge1_crit_edge:               ; preds = %._crit_edge
  %.pre8 = sext i32 %.pre4 to i64
  br label %._crit_edge1

35:                                               ; preds = %._crit_edge
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.pre) #58
  %37 = sext i32 %.pre4 to i64
  %38 = getelementptr ptr, ptr %.pre, i64 %37
  %39 = getelementptr i8, ptr %38, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr %.pre3) #43
  %43 = add i32 %42, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %35, %._crit_edge.._crit_edge1_crit_edge
  %.pre-phi = phi i64 [ %.pre8, %._crit_edge.._crit_edge1_crit_edge ], [ %37, %35 ]
  %.060 = phi i32 [ %3, %._crit_edge.._crit_edge1_crit_edge ], [ %43, %35 ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.pre, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.pre3, 1
  %46 = load ptr, ptr %19, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %46, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %.pre4, 3
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.pre) #58
  %50 = getelementptr ptr, ptr %.pre, i64 %.pre-phi
  %51 = load ptr, ptr %50, align 8
  %result.i = call ptr %51(ptr nocapture nofree noundef nonnull readonly %.pre3) #44
  store ptr @_parameterization_i32, ptr %15, align 8
  %52 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr %result.i, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %15) #58
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.pre) #58
  %55 = getelementptr i8, ptr %50, i64 136
  %56 = load ptr, ptr %55, align 8
  store ptr @i32_typ, ptr %16, align 8
  %57 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %.fca.0.extract, ptr %57, align 8
  %result.i2 = call ptr %56({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly align 8 %16) #46
  call void %result.i2({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %15, i32 %.060, { ptr, i160 } %4) #53
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Array_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !972
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !972
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !972
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !972
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr nonnull %.fca.1.extract6) #43
  %.fca.0.extract2 = extractvalue { ptr } %11, 0
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #58
  %13 = load ptr, ptr %7, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract6) #44
  %14 = sext i32 %3 to i64
  %15 = load ptr, ptr %result.i, align 8
  %16 = getelementptr i8, ptr %15, i64 72
  %17 = load ptr, ptr %16, align 8
  %result.i1 = call { i64, i64 } %17(ptr nocapture nofree nonnull readonly align 8 %result.i) #44
  %18 = extractvalue { i64, i64 } %result.i1, 0
  %19 = mul i64 %18, %14
  %20 = getelementptr i8, ptr %.fca.0.extract2, i64 %19
  %21 = getelementptr i8, ptr %15, i64 56
  %22 = load ptr, ptr %21, align 8
  %result.i2 = call { ptr, i160 } %22(ptr nocapture nofree readonly %20, ptr nocapture nofree nonnull readonly align 8 %result.i) #44
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_unchecked_insert_xi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #6 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !975
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !975
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !975
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !975
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract7, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr nonnull %.fca.1.extract8) #43
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #58
  %14 = load ptr, ptr %8, align 8
  %result.i = call nonnull align 8 dereferenceable(8) ptr %14(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #44
  %15 = sext i32 %3 to i64
  %16 = load ptr, ptr %result.i, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %result.i) #44
  %19 = extractvalue { i64, i64 } %result.i1, 0
  %20 = mul i64 %19, %15
  %21 = getelementptr i8, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %16, i64 64
  %23 = load ptr, ptr %22, align 8
  call void %23({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %result.i, ptr nocapture nofree writeonly %21) #45
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !978
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !978
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !978
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !978
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #36 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !981
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !981
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !981
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !981
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i1 = call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %result.i5 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_wrapper(i64 noundef 48) #48
  store ptr %result.i1, ptr %result.i5, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(48) %result.i5) #40
  %hash_coef.i.i10 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !542
  %tbl_size.i.i11 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !542
  %offset_tbl.i.i12 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !542
  %product.i.i.i13 = mul i64 %hash_coef.i.i10, -5261542750394134544
  %shifted.i.i.i14 = lshr i64 %product.i.i.i13, 32
  %xored.i.i.i15 = xor i64 %shifted.i.i.i14, %product.i.i.i13
  %hash.i.i.i16 = and i64 %xored.i.i.i15, %tbl_size.i.i11
  %offset_ptr.i.i17 = getelementptr i32, ptr %offset_tbl.i.i12, i64 %hash.i.i.i16
  %offset.i.i18 = load i32, ptr %offset_ptr.i.i17, align 4, !noalias !542
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %12 = getelementptr inbounds i8, ptr %result.i5, i64 8
  store ptr %.fca.0.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i5, i64 16
  store ptr %.fca.1.extract, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i5, i64 24
  store ptr %.fca.2.extract, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i5, i64 32
  store i32 %offset.i.i18, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @ArrayIterator) #40
  %17 = getelementptr inbounds i8, ptr %result.i5, i64 40
  store i32 0, ptr %17, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #35 {
  %result.i3 = call noalias dereferenceable_or_null(6) ptr @bump_malloc_wrapper(i64 noundef 6) #48
  store <5 x i8> <i8 65, i8 114, i8 114, i8 97, i8 121>, ptr %result.i3, align 1
  %result.i2 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i3, ptr %result.i2, align 8
  %7 = getelementptr i8, ptr %result.i2, i64 8
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 5, i32 6>, ptr %7, align 8
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #5 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !984
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !984
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !984
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !984
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, -5261542750394134544
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !987
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i27, 3
  call void %11(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract2, i32 0) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !990
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !990
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !990
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !990
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract10, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract12) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #58
  %15 = getelementptr i8, ptr %9, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract12) #43
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract) #58
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 72
  %28 = load ptr, ptr %27, align 8
  %result.i1 = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %29 = call i32 %result.i1({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4) #53
  %.not = icmp slt i32 %13, %29
  br i1 %.not, label %30, label %59

30:                                               ; preds = %3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %32 = load ptr, ptr %10, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract12) #43
  %35 = add i32 %34, 1
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %37 = getelementptr i8, ptr %32, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract12, i32 %35) #42
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %40 = load ptr, ptr %10, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr %.fca.1.extract12) #43
  %43 = add i32 %42, -1
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract10)
  %45 = load ptr, ptr %15, align 8
  %46 = load ptr, ptr %45, align 8
  %47 = call { ptr, ptr, ptr, i32 } %46(ptr %.fca.1.extract12) #43
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %47, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %47, 1
  %.fca.2.extract30 = extractvalue { ptr, ptr, ptr, i32 } %47, 2
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %47, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.1.extract28, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.2.extract30, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %.fca.3.extract32, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract26)
  %54 = sext i32 %.fca.3.extract32 to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract26, i64 %54
  %56 = getelementptr i8, ptr %55, i64 128
  %57 = load ptr, ptr %56, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %57({ ptr, ptr, ptr, i32 } %51, ptr nocapture nofree noundef nonnull readonly %6) #46
  %58 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull align 8 dereferenceable(8) %5, i32 %43) #53
  %.fca.0.extract20 = extractvalue { ptr, i160 } %58, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %58, 1
  br label %59

59:                                               ; preds = %30, %3
  %.reg2mem21.sroa.0.0 = phi ptr [ %.fca.0.extract20, %30 ], [ @nil_typ, %3 ]
  %.reg2mem21.sroa.3.0 = phi i160 [ %.fca.1.extract22, %30 ], [ undef, %3 ]
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem21.sroa.0.0, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %.reg2mem21.sroa.3.0, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBounds(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 120, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @OutOfBounds_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #18 {
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract40, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract40, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract40, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !993
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !993
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !993
  %product.i.i.i = mul i64 %hash_coef.i.i, 5348403617834207535
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !993
  %result.i11 = call noalias align 4 dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #48
  store i32 %3, ptr %result.i11, align 4
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails) #40
  %7 = getelementptr i8, ptr %result.i11, i64 4
  store i32 %4, ptr %7, align 4
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract40) #40
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract40, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = ptrtoint ptr %result.i11 to i64
  %.sroa.3.8.insert.ext = zext i64 %14 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %15 = insertvalue { ptr, i160 } { ptr @OutOfBoundsDetails, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  call void %13(ptr %.fca.1.extract, { ptr, i160 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract40) #58
  %17 = getelementptr i8, ptr %10, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 0) #42
  %result.i10 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #48
  %result.i9 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i9, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i10, ptr %result.i9, align 8
  %24 = getelementptr i8, ptr %result.i9, i64 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 0, i32 1>, ptr %24, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract40) #58
  %27 = getelementptr i8, ptr %10, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #42
  %result.i8 = call noalias dereferenceable_or_null(66) ptr @bump_malloc_wrapper(i64 noundef 66) #48
  %31 = load <65 x i8>, ptr @wapia_An_outofbounds_error_occurred_while_indexing_into_a_collection, align 128
  store <65 x i8> %31, ptr %result.i8, align 1
  %result.i7 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  store ptr %result.i8, ptr %result.i7, align 8
  %35 = getelementptr i8, ptr %result.i7, i64 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 65, i32 66>, ptr %35, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract40) #58
  %38 = getelementptr i8, ptr %10, i64 24
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr i8, ptr %39, i64 8
  %41 = load ptr, ptr %40, align 8
  call void %41(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #42
  %result.i6 = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #48
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract40) #58
  %43 = getelementptr i8, ptr %10, i64 32
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  %47 = insertvalue { ptr } undef, ptr %result.i6, 0
  call void %46(ptr %.fca.1.extract, { ptr } %47) #42
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract40) #58
  %49 = load ptr, ptr %43, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = call { ptr } %50(ptr %.fca.1.extract) #43
  %52 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %51)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract40)
  %54 = getelementptr i8, ptr %10, i64 40
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr i8, ptr %55, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %.fca.1.extract, i64 %52) #42
  ret void
}

define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #18 {
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !996
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !996
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !996
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !996
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i6 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i.i8 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i.i9 = load i64, ptr %hash_coef_ptr.i.i6, align 4, !noalias !542
  %tbl_size.i.i10 = load i64, ptr %tbl_size_ptr.i.i7, align 4, !noalias !542
  %offset_tbl.i.i11 = load ptr, ptr %offset_tbl_ptr.i.i8, align 8, !noalias !542
  %product.i.i.i12 = mul i64 %hash_coef.i.i9, 6499063144389013426
  %shifted.i.i.i13 = lshr i64 %product.i.i.i12, 32
  %xored.i.i.i14 = xor i64 %shifted.i.i.i13, %product.i.i.i12
  %hash.i.i.i15 = and i64 %xored.i.i.i14, %tbl_size.i.i10
  %offset_ptr.i.i16 = getelementptr i32, ptr %offset_tbl.i.i11, i64 %hash.i.i.i15
  %offset.i.i31 = load i32, ptr %offset_ptr.i.i16, align 4, !noalias !999
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract21, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i31, 3
  call void %11(ptr %.fca.1.extract22, { ptr, ptr, ptr, i32 } %15) #42
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #40
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract22, i32 0) #42
  %result.i4 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #48
  %result.i3 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i3, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  store ptr %result.i4, ptr %result.i3, align 8
  %23 = getelementptr i8, ptr %result.i3, i64 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 0, i32 1>, ptr %23, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #58
  %26 = getelementptr i8, ptr %7, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %.fca.1.extract22, { ptr, ptr, ptr, i32 } %22) #42
  %result.i2 = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #48
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #58
  %31 = getelementptr i8, ptr %7, i64 24
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr } undef, ptr %result.i2, 0
  call void %34(ptr %.fca.1.extract22, { ptr } %35) #42
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21) #58
  %37 = load ptr, ptr %31, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %.fca.1.extract22) #43
  %40 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %39)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract21)
  %42 = getelementptr i8, ptr %7, i64 32
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr i8, ptr %43, i64 8
  %45 = load ptr, ptr %44, align 8
  call void %45(ptr %.fca.1.extract22, i64 %40) #42
  ret void
}

define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %.fca.0.extract36 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract36, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract36, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract36, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1002
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1002
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1002
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1002
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract36) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract36, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  call void %9(ptr %.fca.1.extract, i32 0) #42
  %result.i8 = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #48
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i8, align 1
  %result.i7 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  store ptr %result.i8, ptr %result.i7, align 8
  %13 = getelementptr i8, ptr %result.i7, i64 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 6, i32 7>, ptr %13, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract36) #58
  %16 = getelementptr i8, ptr %6, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %12) #42
  %result.i6 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_wrapper(i64 noundef 1) #48
  %result.i5 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  store ptr %result.i6, ptr %result.i5, align 8
  %23 = getelementptr i8, ptr %result.i5, i64 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 0, i32 1>, ptr %23, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract36) #58
  %26 = getelementptr i8, ptr %6, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %22) #42
  %result.i4 = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #48
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract36) #58
  %31 = getelementptr i8, ptr %6, i64 24
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr } undef, ptr %result.i4, 0
  call void %34(ptr %.fca.1.extract, { ptr } %35) #42
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract36) #58
  %37 = load ptr, ptr %31, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %.fca.1.extract) #43
  %40 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %39)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract36)
  %42 = getelementptr i8, ptr %6, i64 32
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr i8, ptr %43, i64 8
  %45 = load ptr, ptr %44, align 8
  call void %45(ptr %.fca.1.extract, i64 %40) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #5 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1005
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1005
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1005
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1005
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract1, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract2, i32 %3) #42
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !542
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !542
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !542
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 6499063144389013426
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !1008
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i27, 3
  call void %16(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %20) #42
  ret void
}

define void @Exception_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #18 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1011
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1011
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1011
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1011
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract1, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr %.fca.1.extract) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract1) #58
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i64 %14(ptr %.fca.1.extract) #43
  call void @print_backtrace({ ptr } %10, i64 %15)
  ret void
}

; Function Attrs: nounwind
define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
._crit_edge.lr.ph.i:
  %3 = alloca [0 x ptr], align 8
  %result.i.i221.h2s238 = alloca [10 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(10) %result.i.i221.h2s238, i8 0, i64 10, i1 false)
  %result.i.i188.h2s240 = alloca [13 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(13) %result.i.i188.h2s240, i8 0, i64 13, i1 false)
  %result.i.i155.h2s242 = alloca [13 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(13) %result.i.i155.h2s242, i8 0, i64 13, i1 false)
  %result.i.i122.h2s244 = alloca [8 x i8], align 8
  store i64 0, ptr %result.i.i122.h2s244, align 8
  %result.i.i89.h2s246 = alloca [27 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i89.h2s246, i8 0, i64 27, i1 false)
  %result.i.i.h2s248 = alloca [10 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(10) %result.i.i.h2s248, i8 0, i64 10, i1 false)
  %.fca.0.extract117 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract119 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract117, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract117, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract117, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1014
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1014
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1014
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1014
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #40
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i.i.h2s248, align 16
  %5 = getelementptr inbounds i8, ptr %result.i.i.h2s248, i64 9
  store i8 0, ptr %5, align 1
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(10) %result.i.i.h2s248) #55
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #40
  store <26 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110, i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105, i8 108, i8 101>, ptr %result.i.i89.h2s246, align 1
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #56
  %8 = getelementptr inbounds i8, ptr %result.i.i89.h2s246, i64 26
  store i8 0, ptr %8, align 1
  %puts125 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(27) %result.i.i89.h2s246) #55
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract117) #56
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract117, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr, ptr, ptr, i32 } %14(ptr %.fca.1.extract119) #43
  %.fca.0.extract76 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 3
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract76, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %.fca.3.extract, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract76)
  %22 = sext i32 %.fca.3.extract to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract76, i64 %22
  %24 = getelementptr i8, ptr %23, i64 80
  %25 = load ptr, ptr %24, align 8
  %result.i16 = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  %26 = call { ptr } %result.i16({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %3) #53
  %.fca.0.extract74 = extractvalue { ptr } %26, 0
  %puts126 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract74) #53
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #40
  store <7 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101>, ptr %result.i.i122.h2s244, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %30 = getelementptr inbounds i8, ptr %result.i.i122.h2s244, i64 7
  store i8 0, ptr %30, align 1
  %puts127 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(8) %result.i.i122.h2s244) #53
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract117)
  %32 = load ptr, ptr %11, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract119) #43
  %35 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %34) #53
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #40
  store <12 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115, i8 115, i8 97, i8 103, i8 101>, ptr %result.i.i155.h2s242, align 16
  %.fca.2.extract121 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %39 = getelementptr inbounds i8, ptr %result.i.i155.h2s242, i64 12
  store i8 0, ptr %39, align 4
  %puts128 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(13) %result.i.i155.h2s242) #53
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract117, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.1.extract119, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.2.extract121, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %offset.i.i, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract117)
  %46 = getelementptr i8, ptr %11, i64 80
  %47 = load ptr, ptr %46, align 8
  %result.i11 = call ptr %47({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  call void %result.i11({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %3) #53
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #40
  store <12 x i8> <i8 83, i8 116, i8 97, i8 99, i8 107, i8 32, i8 116, i8 114, i8 97, i8 99, i8 101, i8 58>, ptr %result.i.i188.h2s240, align 16
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %51 = getelementptr inbounds i8, ptr %result.i.i188.h2s240, i64 12
  store i8 0, ptr %51, align 4
  %puts129 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(13) %result.i.i188.h2s240) #53
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract117)
  %54 = getelementptr i8, ptr %11, i64 64
  %55 = load ptr, ptr %54, align 8
  %result.i8 = call ptr %55({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly align 8 %3) #46
  call void %result.i8({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %3) #53
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %3) #40
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i.i221.h2s238, align 16
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %59 = getelementptr inbounds i8, ptr %result.i.i221.h2s238, i64 9
  store i8 0, ptr %59, align 1
  %puts130 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(10) %result.i.i221.h2s238) #53
  ret void
}

; Function Attrs: nounwind
define void @OutOfBounds_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1017
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1017
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1017
  %product.i.i.i = mul i64 %hash_coef.i.i, 5348403617834207535
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1017
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract7) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract9) #43
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract6, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract5) #58
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract5, i64 %18
  %20 = getelementptr i8, ptr %19, i64 80
  %21 = load ptr, ptr %20, align 8
  %result.i1 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr } %result.i1({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %.fca.0.extract3 = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract3) #53
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef align 8 %.fca.0.extract7)
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr, i160 } %25(ptr %.fca.1.extract9) #43
  %.fca.0.extract = extractvalue { ptr, i160 } %26, 0
  %27 = icmp ne ptr %.fca.0.extract, @nil_typ
  %28 = icmp ne ptr %.fca.0.extract, null
  %.not18 = and i1 %27, %28
  br i1 %.not18, label %29, label %._crit_edge

29:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %26, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %30 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.521.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.521.8.extract.trunc = trunc i160 %.sroa.521.8.extract.shift to i64
  %31 = inttoptr i64 %.sroa.521.8.extract.trunc to ptr
  %hash_coef_ptr.i.i3 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i4 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i6 = load i64, ptr %hash_coef_ptr.i.i3, align 4, !noalias !1020
  %tbl_size.i.i7 = load i64, ptr %tbl_size_ptr.i.i4, align 4, !noalias !1020
  %offset_tbl.i.i8 = load ptr, ptr %offset_tbl_ptr.i.i5, align 8, !noalias !1020
  %product.i.i.i9 = mul i64 %hash_coef.i.i6, 4650630525701360429
  %shifted.i.i.i10 = lshr i64 %product.i.i.i9, 32
  %xored.i.i.i11 = xor i64 %shifted.i.i.i10, %product.i.i.i9
  %hash.i.i.i12 = and i64 %xored.i.i.i11, %tbl_size.i.i7
  %offset_ptr.i.i13 = getelementptr i32, ptr %offset_tbl.i.i8, i64 %hash.i.i.i12
  %offset.i.i14 = load i32, ptr %offset_ptr.i.i13, align 4, !noalias !1020
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %30, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %31, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %offset.i.i14, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract)
  %38 = sext i32 %offset.i.i14 to i64
  %39 = getelementptr ptr, ptr %.fca.0.extract, i64 %38
  %40 = getelementptr i8, ptr %39, i64 24
  %41 = load ptr, ptr %40, align 8
  %result.i = call ptr %41({ ptr, ptr, ptr, i32 } %35, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  call void %result.i({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull align 8 %4) #53
  br label %._crit_edge

._crit_edge:                                      ; preds = %29, %3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBoundsDetails(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @OutOfBoundsDetails_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1023
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1023
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1023
  %product.i.i.i = mul i64 %hash_coef.i.i, 4650630525701360429
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1023
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #42
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 %4) #42
  ret void
}

; Function Attrs: nounwind
define void @OutOfBoundsDetails_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
._crit_edge.lr.ph.i:
  %result.i.i52.h2s61 = alloca [26 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i.i52.h2s61, i8 0, i64 26, i1 false)
  %result.i.i.h2s63 = alloca [45 x i8], align 1
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(45) %result.i.i.h2s63, i8 0, i64 45, i1 false)
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract37, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract37, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract37, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1026
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1026
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1026
  %product.i.i.i = mul i64 %hash_coef.i.i, 4650630525701360429
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1026
  %3 = load <44 x i8>, ptr @modls_The_size_of_the_collection_being_indexed_was, align 64
  store <44 x i8> %3, ptr %result.i.i.h2s63, align 1
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  %5 = getelementptr inbounds i8, ptr %result.i.i.h2s63, i64 44
  store i8 0, ptr %5, align 1
  %puts = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(45) %result.i.i.h2s63) #55
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract37) #56
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract37, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #43
  %12 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %11) #53
  store <25 x i8> <i8 84, i8 104, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 97, i8 114, i8 103, i8 117, i8 109, i8 101, i8 110, i8 116, i8 32, i8 119, i8 97, i8 115>, ptr %result.i.i52.h2s61, align 1
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %14 = getelementptr inbounds i8, ptr %result.i.i52.h2s61, i64 25
  store i8 0, ptr %14, align 1
  %puts38 = call i32 @puts(ptr noalias nocapture nofree noundef nonnull readonly dereferenceable(26) %result.i.i52.h2s61) #53
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef align 8 %.fca.0.extract37)
  %16 = getelementptr i8, ptr %8, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract) #43
  %20 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %19) #53
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_bounds(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_bounds(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1029
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1029
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1029
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1029
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract2) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract2, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract4) #43
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #58
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract1) #58
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 80
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %22 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #53
  %.fca.0.extract = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #53
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @Exception_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 80
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 80
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Exception_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @OutOfBounds_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 112
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 112
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @OutOfBounds_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 104
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 104
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBounds_getter_line_number(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_line_number(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @OutOfBounds_getter_details(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, i160 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load i160, ptr %4, align 8
  %6 = insertvalue { ptr, i160 } %3, i160 %5, 1
  ret { ptr, i160 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_details(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, i160 } %1) #3 {
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store i160 %.fca.1.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_6(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @CuckooMap_B__Self_max_displacements_(ptr nocapture nofree %0) #33 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #40
  ret ptr @CuckooMap__Self_max_displacements_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash1_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_resize_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 616
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 624
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 632
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @CuckooMap__Self_max_displacements_(ptr nocapture nofree readnone %0) #1 {
  ret i32 100
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #5 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1032
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1032
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1032
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1032
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract10, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, { ptr } %3) #42
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %14 = getelementptr i8, ptr %8, i64 64
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, { ptr } %4) #42
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %19 = getelementptr i8, ptr %8, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 8) #42
  %result.i1 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %24 = getelementptr i8, ptr %8, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr } undef, ptr %result.i1, 0
  call void %27(ptr %.fca.1.extract, { ptr } %28) #42
  %result.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %30 = getelementptr i8, ptr %8, i64 32
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %33(ptr %.fca.1.extract, { ptr } %34) #42
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract10) #40
  %36 = getelementptr i8, ptr %8, i64 48
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  call void %39(ptr %.fca.1.extract, i32 0) #42
  ret void
}

define i32 @CuckooMap_hash1_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #18 {
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1035
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1035
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1035
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1035
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract6) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract6, i64 %6
  %8 = getelementptr i8, ptr %7, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract7) #43
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = call i32 %.fca.0.extract({ ptr, i160 } %3)
  ret i32 %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @CuckooMap_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #1 {
  %5 = add i32 %3, 2127912214
  %6 = shl i32 %3, 12
  %7 = add i32 %5, %6
  %8 = ashr i32 %7, 19
  %9 = xor i32 %7, %8
  %10 = xor i32 %9, -949894596
  %11 = add i32 %10, 374761393
  %12 = shl i32 %10, 5
  %13 = add i32 %11, %12
  %14 = add i32 %13, -744332180
  %15 = shl i32 %13, 9
  %16 = xor i32 %14, %15
  %17 = add i32 %16, -42973499
  %18 = shl i32 %16, 3
  %19 = add i32 %17, %18
  %20 = ashr i32 %19, 16
  %21 = xor i32 %19, %20
  %22 = xor i32 %21, -1252372727
  ret i32 %22
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @CuckooMap_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1038
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1038
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1038
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1038
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #43
  %12 = add i32 %11, -1
  %13 = and i32 %12, %3
  ret i32 %13
}

; Function Attrs: nounwind
define i32 @CuckooMap_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #28 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1041
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1041
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1041
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1041
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i.i, 3
  %9 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %9, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9) #40
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 96
  %15 = load ptr, ptr %14, align 8
  %16 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %16, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly align 8 %16) #46
  %17 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 dereferenceable(8) %9, i32 %3) #53
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract)
  %19 = getelementptr i8, ptr %13, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i32 %21(ptr %.fca.1.extract) #43
  %23 = add i32 %22, -1
  %24 = and i32 %23, %17
  ret i32 %24
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #28 {
.lr.ph:
  %4 = alloca {}, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1044
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1044
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1044
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1044
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !1047
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !1047
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !1047
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4015701072841558310
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i29 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !1047
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8) #40
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract8, i64 %10
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8) #40
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #40
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %4) #40
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract9, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract10, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i, 3
  br label %20

20:                                               ; preds = %.cont, %.lr.ph
  %.0290 = phi i32 [ 0, %.lr.ph ], [ %56, %.cont ]
  %.074289 = phi i1 [ true, %.lr.ph ], [ %57, %.cont ]
  %.sroa.0.0288 = phi ptr [ %.fca.0.extract, %.lr.ph ], [ %44, %.cont ]
  %.sroa.6.0287 = phi ptr [ %.fca.1.extract, %.lr.ph ], [ %58, %.cont ]
  %.sroa.12.0286 = phi ptr [ %.fca.2.extract, %.lr.ph ], [ %59, %.cont ]
  %.sroa.17.0285 = phi i32 [ %offset.i.i29, %.lr.ph ], [ %offset.i.i57, %.cont ]
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0288, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.sroa.6.0287, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.sroa.12.0286, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %.sroa.17.0285, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %.sroa.0.0288) #40
  %26 = sext i32 %.sroa.17.0285 to i64
  %27 = getelementptr ptr, ptr %.sroa.0.0288, i64 %26
  %28 = getelementptr i8, ptr %27, i64 64
  %29 = load ptr, ptr %28, align 8
  %result.i15 = call ptr %29({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  %30 = call i32 %result.i15({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %4) #53
  %. = select i1 %.074289, ptr %5, ptr %7
  %.188 = select i1 %.074289, i64 104, i64 112
  %.189 = select i1 %.074289, ptr %6, ptr %8
  %.190 = select i1 %.074289, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %., align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8)
  %33 = getelementptr i8, ptr %11, i64 %.188
  %34 = load ptr, ptr %33, align 8
  store ptr @i32_typ, ptr %.189, align 8
  %result.i14 = call ptr %34({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly align 8 %.189) #46
  %35 = call i32 %result.i14({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 dereferenceable(8) %., i32 %30) #53
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8)
  %37 = getelementptr i8, ptr %11, i64 %.190
  %38 = load ptr, ptr %37, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr } %39(ptr %.fca.1.extract9) #43
  %.fca.0.extract55 = extractvalue { ptr } %40, 0
  %41 = sext i32 %35 to i64
  %42 = shl nsw i64 %41, 5
  %43 = getelementptr i8, ptr %.fca.0.extract55, i64 %42
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %43, i64 8
  %46 = load i64, ptr %45, align 4
  %.sroa_idx = getelementptr i8, ptr %43, i64 16
  %47 = load i64, ptr %.sroa_idx, align 4
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8)
  %49 = call { ptr } %39(ptr %.fca.1.extract9) #43
  %.fca.0.extract52 = extractvalue { ptr } %49, 0
  %50 = getelementptr i8, ptr %.fca.0.extract52, i64 %42
  store ptr %.sroa.0.0288, ptr %50, align 8
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = ptrtoint ptr %.sroa.6.0287 to i64
  %53 = ptrtoint ptr %.sroa.12.0286 to i64
  store i64 %52, ptr %51, align 4
  %.sroa_idx104 = getelementptr i8, ptr %50, i64 16
  store i64 %53, ptr %.sroa_idx104, align 4
  %.sroa_idx105 = getelementptr i8, ptr %50, i64 24
  store i32 %.sroa.17.0285, ptr %.sroa_idx105, align 4
  %54 = icmp ne ptr %44, @nil_typ
  %55 = icmp ne ptr %44, null
  %.not94 = and i1 %54, %55
  br i1 %.not94, label %.cont, label %62

.cont:                                            ; preds = %20
  %56 = add nuw nsw i32 %.0290, 1
  %57 = xor i1 %.074289, true
  %58 = inttoptr i64 %46 to ptr
  %59 = inttoptr i64 %47 to ptr
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %44, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %44, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %44, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4015701072841558310
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap) #56
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull readonly align 8 %4) #40
  %exitcond.not = icmp eq i32 %56, 100
  br i1 %exitcond.not, label %._crit_edge, label %20

62:                                               ; preds = %20
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8)
  %64 = getelementptr i8, ptr %11, i64 48
  %65 = load ptr, ptr %64, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call i32 %66(ptr %.fca.1.extract9) #43
  %68 = add i32 %67, 1
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract8)
  %70 = getelementptr i8, ptr %65, i64 8
  %71 = load ptr, ptr %70, align 8
  call void %71(ptr %.fca.1.extract9, i32 %68) #42
  br label %72

._crit_edge:                                      ; preds = %.cont
  %.sroa.17.8.insert.ext = zext i32 %offset.i.i57 to i160
  %.sroa.17.8.insert.shift = shl nuw i160 %.sroa.17.8.insert.ext, 128
  %.sroa.12.8.insert.ext = zext i64 %47 to i160
  %.sroa.12.8.insert.shift = shl nuw nsw i160 %.sroa.12.8.insert.ext, 64
  %.sroa.6.8.insert.ext = zext i64 %46 to i160
  %.sroa.12.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.shift, %.sroa.6.8.insert.ext
  %.sroa.6.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.insert, %.sroa.17.8.insert.shift
  br label %72

72:                                               ; preds = %._crit_edge, %62
  %.reg2mem141.sroa.3.0 = phi i160 [ undef, %62 ], [ %.sroa.6.8.insert.insert, %._crit_edge ]
  %.reg2mem141.sroa.0.0 = phi ptr [ @nil_typ, %62 ], [ %44, %._crit_edge ]
  %.reload142.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem141.sroa.0.0, 0
  %.reload142.fca.1.insert = insertvalue { ptr, i160 } %.reload142.fca.0.insert, i160 %.reg2mem141.sroa.3.0, 1
  ret { ptr, i160 } %.reload142.fca.1.insert
}

; Function Attrs: nounwind
define void @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4) #28 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %8 = icmp sgt i32 %4, 0
  br i1 %8, label %.lr.ph, label %._crit_edge2._crit_edge

.lr.ph:                                           ; preds = %5
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1050
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1050
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1050
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1050
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract4, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = getelementptr i8, ptr %14, i64 120
  %wide.trip.count = zext nneg i32 %4 to i64
  br label %17

17:                                               ; preds = %._crit_edge, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %._crit_edge ]
  %18 = shl nuw nsw i64 %indvars.iv, 5
  %19 = getelementptr i8, ptr %.fca.0.extract, i64 %18
  %20 = load ptr, ptr %19, align 8
  %21 = icmp ne ptr %20, @nil_typ
  %22 = icmp ne ptr %20, null
  %.not17 = and i1 %21, %22
  br i1 %.not17, label %23, label %._crit_edge

23:                                               ; preds = %17
  %24 = getelementptr i8, ptr %19, i64 8
  %25 = load i64, ptr %24, align 4
  %.sroa_idx = getelementptr i8, ptr %19, i64 16
  %26 = load i64, ptr %.sroa_idx, align 4
  %27 = inttoptr i64 %25 to ptr
  %28 = inttoptr i64 %26 to ptr
  %hash_coef_ptr.i.i6 = getelementptr i8, ptr %20, i64 8
  %tbl_size_ptr.i.i7 = getelementptr i8, ptr %20, i64 16
  %offset_tbl_ptr.i.i8 = getelementptr i8, ptr %20, i64 40
  %hash_coef.i.i9 = load i64, ptr %hash_coef_ptr.i.i6, align 4, !noalias !542
  %tbl_size.i.i10 = load i64, ptr %tbl_size_ptr.i.i7, align 4, !noalias !542
  %offset_tbl.i.i11 = load ptr, ptr %offset_tbl_ptr.i.i8, align 8, !noalias !542
  %product.i.i.i12 = mul i64 %hash_coef.i.i9, 4015701072841558310
  %shifted.i.i.i13 = lshr i64 %product.i.i.i12, 32
  %xored.i.i.i14 = xor i64 %shifted.i.i.i13, %product.i.i.i12
  %hash.i.i.i15 = and i64 %xored.i.i.i14, %tbl_size.i.i10
  %offset_ptr.i.i16 = getelementptr i32, ptr %offset_tbl.i.i11, i64 %hash.i.i.i15
  %offset.i.i31 = load i32, ptr %offset_ptr.i.i16, align 4, !noalias !1053
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %27, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %28, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i31, 3
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #40
  %34 = load ptr, ptr %14, align 8
  %result.i2 = call ptr %34(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #40
  %36 = load ptr, ptr %15, align 8
  %result.i = call ptr %36(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %result.i4 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %37 = getelementptr inbounds i8, ptr %result.i4, i64 16
  store ptr %result.i, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %result.i4, i64 8
  store ptr %result.i2, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %result.i4, i64 24
  store ptr null, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i4) #40
  store ptr @Entry, ptr %result.i4, align 8
  store ptr %result.i4, ptr %6, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #40
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract4) #40
  %43 = load ptr, ptr %16, align 8
  store ptr %20, ptr %7, align 8
  %result.i3 = call ptr %43({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %7) #46
  %44 = call { ptr, i160 } %result.i3({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %6, { ptr, ptr, ptr, i32 } %32) #53
  br label %._crit_edge

._crit_edge:                                      ; preds = %23, %17
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge2._crit_edge, label %17

._crit_edge2._crit_edge:                          ; preds = %._crit_edge, %5
  ret void
}

; Function Attrs: nounwind
define void @CuckooMap_resize_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
._crit_edge:
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1056
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1056
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1056
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1056
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract15, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call { ptr } %12(ptr %.fca.1.extract) #43
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr } %17(ptr %.fca.1.extract) #43
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call i32 %22(ptr %.fca.1.extract) #43
  %24 = shl i32 %23, 1
  %spec.select = call i32 @llvm.smax.i32(i32 %24, i32 noundef 16) #40
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %26 = getelementptr i8, ptr %21, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr %.fca.1.extract, i32 %spec.select) #42
  %28 = zext nneg i32 %spec.select to i64
  %29 = shl nuw nsw i64 %28, 5
  %result.i5 = call noalias ptr @bump_malloc_wrapper(i64 noundef %29) #48
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %31 = load ptr, ptr %10, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i5, 0
  call void %33(ptr %.fca.1.extract, { ptr } %34) #42
  %result.i4 = call noalias ptr @bump_malloc_wrapper(i64 noundef %29) #48
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %36 = load ptr, ptr %15, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %39 = insertvalue { ptr } undef, ptr %result.i4, 0
  call void %38(ptr %.fca.1.extract, { ptr } %39) #42
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %41 = getelementptr i8, ptr %9, i64 48
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %.fca.1.extract, i32 0) #42
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract15, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.1.extract, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.2.extract, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %offset.i.i, 3
  %result.i3 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %49 = getelementptr inbounds i8, ptr %result.i3, i64 8
  store ptr null, ptr %49, align 8
  store ptr @buffer_typ, ptr %result.i3, align 8
  store ptr %result.i3, ptr %3, align 8
  %50 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3) #40
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15) #40
  %53 = getelementptr i8, ptr %9, i64 128
  %54 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %4, align 8
  %55 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %result.i1 = call ptr %54({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly align 8 %4) #46
  call void %result.i1({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %3, { ptr } %13, i32 %23) #53
  %result.i2 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %56 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr null, ptr %56, align 8
  store ptr @buffer_typ, ptr %result.i2, align 8
  store ptr %result.i2, ptr %5, align 8
  %57 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract15)
  %60 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %6, align 8
  %61 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %61, align 8
  %result.i = call ptr %60({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %6) #46
  call void %result.i({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %5, { ptr } %18, i32 %23) #53
  ret void
}

define noundef i1 @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5, i32 %6, { ptr } %7) #18 {
  %9 = alloca [0 x ptr], align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1059
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1059
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1059
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1059
  %.fca.0.extract = extractvalue { ptr } %7, 0
  %10 = sext i32 %6 to i64
  %11 = shl nsw i64 %10, 5
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %12, i64 8
  %15 = icmp ne ptr %13, @nil_typ
  %16 = icmp ne ptr %13, null
  %.not66 = and i1 %15, %16
  br i1 %.not66, label %17, label %.critedge

17:                                               ; preds = %8
  %18 = load i64, ptr %14, align 4
  %.sroa_idx = getelementptr i8, ptr %12, i64 16
  %19 = load i64, ptr %.sroa_idx, align 4
  %20 = inttoptr i64 %18 to ptr
  %21 = inttoptr i64 %19 to ptr
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %13, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %13, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %13, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !1062
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !1062
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !1062
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 4015701072841558310
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i22 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !1062
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %21, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i22, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9) #40
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %13) #40
  %28 = sext i32 %offset.i.i22 to i64
  %29 = getelementptr ptr, ptr %13, i64 %28
  %30 = getelementptr i8, ptr %29, i64 64
  %31 = load ptr, ptr %30, align 8
  %result.i8 = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly align 8 %9) #46
  %32 = call i32 %result.i8({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9) #53
  %33 = icmp eq i32 %32, %5
  br i1 %33, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %17
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %13)
  %36 = getelementptr i8, ptr %29, i64 48
  %37 = load ptr, ptr %36, align 8
  %result.i7 = call ptr %37({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly align 8 %9) #46
  %38 = call { ptr, i160 } %result.i7({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9) #53
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract21)
  %40 = sext i32 %offset.i.i to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract21, i64 %40
  %42 = getelementptr i8, ptr %41, i64 64
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr } %44(ptr %.fca.1.extract22) #43
  %.fca.0.extract49 = extractvalue { ptr } %45, 0
  %46 = call i1 %.fca.0.extract49({ ptr, i160 } %38, { ptr, i160 } %3)
  br i1 %46, label %47, label %.critedge

47:                                               ; preds = %._crit_edge
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract21)
  %49 = load ptr, ptr %41, align 8
  %result.i4 = call align 8 ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract22) #44
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract21)
  %51 = getelementptr i8, ptr %41, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i3 = call align 8 ptr %52(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract22) #44
  %53 = load ptr, ptr %result.i4, align 8, !alias.scope !1065
  %54 = getelementptr i8, ptr %53, i64 72
  %55 = load ptr, ptr %54, align 8, !alias.scope !1065
  %result.i1.i = call { i64, i64 } %55(ptr nocapture nofree nonnull readonly align 8 %result.i4) #44, !alias.scope !1065
  %56 = extractvalue { i64, i64 } %result.i1.i, 0
  %57 = extractvalue { i64, i64 } %result.i1.i, 1
  %58 = urem i64 20, %57
  %59 = icmp eq i64 %58, 0
  %60 = sub i64 %57, %58
  %61 = select i1 %59, i64 0, i64 %60
  %62 = add i64 %56, 20
  %63 = add i64 %62, %61
  %64 = load ptr, ptr %result.i3, align 8, !alias.scope !1065
  %65 = getelementptr i8, ptr %64, i64 72
  %66 = load ptr, ptr %65, align 8, !alias.scope !1065
  %result.i.i = call { i64, i64 } %66(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44, !alias.scope !1065
  %67 = extractvalue { i64, i64 } %result.i.i, 0
  %68 = extractvalue { i64, i64 } %result.i.i, 1
  %69 = call i64 @llvm.umax.i64(i64 %57, i64 %68) #41
  %70 = call i64 @llvm.umax.i64(i64 %69, i64 noundef 8) #41, !range !16
  %71 = urem i64 %63, %68
  %72 = icmp eq i64 %71, 0
  %73 = sub i64 %68, %71
  %74 = select i1 %72, i64 0, i64 %73
  %75 = add i64 %67, %63
  %76 = add i64 %75, %74
  %77 = urem i64 %76, %70
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %70, %77
  %80 = select i1 %78, i64 0, i64 %79
  %81 = add i64 %80, %76
  %result.i9 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %81) #48
  store ptr %result.i4, ptr %result.i9, align 8
  %82 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr %result.i3, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i9)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract21)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract21)
  %86 = load ptr, ptr %result.i4, align 8
  %87 = getelementptr i8, ptr %86, i64 72
  %88 = load ptr, ptr %87, align 8
  %result.i.i38 = call { i64, i64 } %88(ptr nocapture nofree nonnull readonly align 8 %result.i4) #44
  %89 = extractvalue { i64, i64 } %result.i.i38, 1
  %90 = urem i64 20, %89
  %91 = icmp eq i64 %90, 0
  %reass.sub42 = sub i64 %89, %90
  %92 = add i64 %reass.sub42, 20
  %93 = select i1 %91, i64 20, i64 %92
  %94 = getelementptr i8, ptr %result.i9, i64 %93
  %95 = getelementptr i8, ptr %86, i64 64
  %96 = load ptr, ptr %95, align 8
  call void %96({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i4, ptr nocapture nofree writeonly %94) #45
  %97 = load ptr, ptr %result.i9, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i1.i39 = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly align 8 %97) #44
  %101 = extractvalue { i64, i64 } %result.i1.i39, 0
  %102 = extractvalue { i64, i64 } %result.i1.i39, 1
  %103 = urem i64 20, %102
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %102, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %101, 20
  %108 = add i64 %107, %106
  %109 = load ptr, ptr %82, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i.i40 = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly align 8 %109) #44
  %113 = extractvalue { i64, i64 } %result.i.i40, 1
  %114 = urem i64 %108, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = getelementptr i8, ptr %result.i9, i64 %108
  %119 = getelementptr i8, ptr %118, i64 %117
  %120 = getelementptr i8, ptr %110, i64 64
  %121 = load ptr, ptr %120, align 8
  call void %121({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %109, ptr nocapture nofree writeonly %119) #45
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %123 = getelementptr inbounds i8, ptr %result.i9, i64 16
  store i32 %5, ptr %123, align 8
  store ptr @Entry, ptr %12, align 8
  %124 = ptrtoint ptr %result.i9 to i64
  store i64 %124, ptr %14, align 4
  %.sroa_idx30 = getelementptr i8, ptr %12, i64 24
  store i32 10, ptr %.sroa_idx30, align 4
  br label %.critedge

.critedge:                                        ; preds = %47, %._crit_edge, %17, %8
  %.reg2mem45.0 = phi i1 [ false, %._crit_edge ], [ true, %47 ], [ false, %8 ], [ false, %17 ]
  ret i1 %.reg2mem45.0
}

define { ptr, i160 } @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #18 {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1068
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1068
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1068
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1068
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not45 = and i1 %13, %14
  br i1 %.not45, label %15, label %.critedge

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i.i4 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i.i5 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i.i6 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i.i7 = load i64, ptr %hash_coef_ptr.i.i4, align 4, !noalias !1071
  %tbl_size.i.i8 = load i64, ptr %tbl_size_ptr.i.i5, align 4, !noalias !1071
  %offset_tbl.i.i9 = load ptr, ptr %offset_tbl_ptr.i.i6, align 8, !noalias !1071
  %product.i.i.i10 = mul i64 %hash_coef.i.i7, 4015701072841558310
  %shifted.i.i.i11 = lshr i64 %product.i.i.i10, 32
  %xored.i.i.i12 = xor i64 %shifted.i.i.i11, %product.i.i.i10
  %hash.i.i.i13 = and i64 %xored.i.i.i12, %tbl_size.i.i8
  %offset_ptr.i.i14 = getelementptr i32, ptr %offset_tbl.i.i9, i64 %hash.i.i.i13
  %offset.i.i15 = load i32, ptr %offset_ptr.i.i14, align 4, !noalias !1071
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i15, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #40
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12) #40
  %27 = sext i32 %offset.i.i15 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #46
  %31 = call i32 %result.i2({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #53
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i1 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #46
  %37 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #53
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract14)
  %39 = sext i32 %offset.i.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract14, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract15) #43
  %.fca.0.extract28 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract28({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.critedge

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #46
  %51 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #53
  %.fca.0.extract22 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract23 = extractvalue { ptr, i160 } %51, 1
  br label %.critedge

.critedge:                                        ; preds = %46, %._crit_edge, %15, %7
  %.reg2mem43.sroa.3.0 = phi i160 [ %.fca.1.extract23, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %.reg2mem41.0 = phi ptr [ %.fca.0.extract22, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload40.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem41.0, 0
  %.reload40.fca.1.insert = insertvalue { ptr, i160 } %.reload40.fca.0.insert, i160 %.reg2mem43.sroa.3.0, 1
  ret { ptr, i160 } %.reload40.fca.1.insert
}

define { ptr, i160 } @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #18 {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1074
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1074
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1074
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1074
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not53 = and i1 %13, %14
  br i1 %.not53, label %15, label %.critedge

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i.i4 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i.i5 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i.i6 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i.i7 = load i64, ptr %hash_coef_ptr.i.i4, align 4, !noalias !1077
  %tbl_size.i.i8 = load i64, ptr %tbl_size_ptr.i.i5, align 4, !noalias !1077
  %offset_tbl.i.i9 = load ptr, ptr %offset_tbl_ptr.i.i6, align 8, !noalias !1077
  %product.i.i.i10 = mul i64 %hash_coef.i.i7, 4015701072841558310
  %shifted.i.i.i11 = lshr i64 %product.i.i.i10, 32
  %xored.i.i.i12 = xor i64 %shifted.i.i.i11, %product.i.i.i10
  %hash.i.i.i13 = and i64 %xored.i.i.i12, %tbl_size.i.i8
  %offset_ptr.i.i14 = getelementptr i32, ptr %offset_tbl.i.i9, i64 %hash.i.i.i13
  %offset.i.i15 = load i32, ptr %offset_ptr.i.i14, align 4, !noalias !1077
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i15, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #40
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12) #40
  %27 = sext i32 %offset.i.i15 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i2 = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #46
  %31 = call i32 %result.i2({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #53
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i1 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #46
  %37 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #53
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract16)
  %39 = sext i32 %offset.i.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract16, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract17) #43
  %.fca.0.extract36 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract36({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.critedge

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 8 %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %8) #46
  %51 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #53
  %.fca.0.extract30 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract31 = extractvalue { ptr, i160 } %51, 1
  store ptr @nil_typ, ptr %11, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract16)
  %53 = getelementptr i8, ptr %40, i64 48
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 %55(ptr %.fca.1.extract17) #43
  %57 = add i32 %56, -1
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract16)
  %59 = getelementptr i8, ptr %54, i64 8
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %.fca.1.extract17, i32 %57) #42
  br label %.critedge

.critedge:                                        ; preds = %46, %._crit_edge, %15, %7
  %.reg2mem47.sroa.3.0 = phi i160 [ %.fca.1.extract31, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %.reg2mem45.0 = phi ptr [ %.fca.0.extract30, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload44.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem45.0, 0
  %.reload44.fca.1.insert = insertvalue { ptr, i160 } %.reload44.fca.0.insert, i160 %.reg2mem47.sroa.3.0, 1
  ret { ptr, i160 } %.reload44.fca.1.insert
}

; Function Attrs: nounwind
define void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #28 {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [5 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract29 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract20 = extractvalue { ptr, i160 } %4, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract35, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #40
  %18 = sext i32 %offset.i.i to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract34, i64 %18
  %20 = load ptr, ptr %19, align 8
  %result.i10 = call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %21 = alloca [1 x ptr], align 8
  store ptr %result.i10, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21) #40
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract34) #40
  %24 = getelementptr i8, ptr %19, i64 88
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr }, align 8
  store ptr %.fca.0.extract29, ptr %26, align 8
  %result.i20 = call ptr %25({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %26) #46
  %27 = call i32 %result.i20({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %21, { ptr, i160 } %3) #53
  %28 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract34)
  %31 = getelementptr i8, ptr %19, i64 104
  %32 = load ptr, ptr %31, align 8
  %33 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %33, align 8
  %result.i19 = call ptr %32({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %33) #46
  %34 = call i32 %result.i19({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %28, i32 %27) #53
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract34)
  %36 = getelementptr i8, ptr %19, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr nonnull %.fca.1.extract35) #43
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract34)
  %41 = load ptr, ptr %19, align 8
  %result.i9 = call ptr %41(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract34)
  %43 = getelementptr i8, ptr %19, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i8 = call ptr %44(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %result.i24 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %45 = getelementptr inbounds i8, ptr %result.i24, i64 8
  store ptr null, ptr %45, align 8
  store ptr @buffer_typ, ptr %result.i24, align 8
  %46 = alloca [5 x ptr], align 8
  store ptr %result.i9, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr %result.i8, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr @_parameterization_i32, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %46, i64 32
  store ptr %result.i24, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %46)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract34)
  %53 = getelementptr i8, ptr %19, i64 144
  %54 = load ptr, ptr %53, align 8
  %55 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract29, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %55, i64 8
  store ptr %.fca.0.extract20, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %55, i64 16
  store ptr @i32_typ, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %55, i64 24
  store ptr @i32_typ, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %55, i64 32
  store ptr @buffer_typ, ptr %59, align 8
  %result.i18 = call ptr %54({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %55) #46
  %60 = call i1 %result.i18({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %46, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %34, { ptr } %39) #53
  br i1 %60, label %.loopexit, label %61

61:                                               ; preds = %5
  store ptr @_parameterization_i32, ptr %7, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %64 = getelementptr i8, ptr %19, i64 112
  %65 = load ptr, ptr %64, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i17 = call ptr %65({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %8) #46
  %66 = call i32 %result.i17({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %7, i32 %27) #53
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %68 = getelementptr i8, ptr %19, i64 32
  %69 = load ptr, ptr %68, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr } %70(ptr nonnull %.fca.1.extract35) #43
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %73 = load ptr, ptr %19, align 8
  %result.i7 = call ptr %73(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %75 = load ptr, ptr %43, align 8
  %result.i6 = call ptr %75(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %result.i23 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %76 = getelementptr inbounds i8, ptr %result.i23, i64 8
  store ptr null, ptr %76, align 8
  store ptr @buffer_typ, ptr %result.i23, align 8
  store ptr %result.i7, ptr %9, align 8
  %77 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %result.i6, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_i32, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @_parameterization_i32, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %9, i64 32
  store ptr %result.i23, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %9)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %83 = load ptr, ptr %53, align 8
  store ptr %.fca.0.extract29, ptr %10, align 8
  %84 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.0.extract20, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %10, i64 24
  store ptr @i32_typ, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %10, i64 32
  store ptr @buffer_typ, ptr %87, align 8
  %result.i16 = call ptr %83({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %10) #46
  %88 = call i1 %result.i16({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %9, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %66, { ptr } %71) #53
  br i1 %88, label %.loopexit, label %89

89:                                               ; preds = %61
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %91 = getelementptr i8, ptr %19, i64 48
  %92 = load ptr, ptr %91, align 8
  %93 = load ptr, ptr %92, align 8
  %94 = call i32 %93(ptr %.fca.1.extract35) #43
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %96 = getelementptr i8, ptr %19, i64 40
  %97 = load ptr, ptr %96, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = call i32 %98(ptr %.fca.1.extract35) #43
  %.not = icmp slt i32 %94, %99
  br i1 %.not, label %._crit_edge, label %100

100:                                              ; preds = %89
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %103 = getelementptr i8, ptr %19, i64 136
  %104 = load ptr, ptr %103, align 8
  %result.i15 = call ptr %104({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  call void %result.i15({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #53
  br label %._crit_edge

._crit_edge:                                      ; preds = %100, %89
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %106 = load ptr, ptr %19, align 8
  %result.i5 = call align 8 ptr %106(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %108 = load ptr, ptr %43, align 8
  %result.i4 = call align 8 ptr %108(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %109 = load ptr, ptr %result.i5, align 8
  %110 = getelementptr i8, ptr %109, i64 72
  %111 = load ptr, ptr %110, align 8
  %result.i1.i = call { i64, i64 } %111(ptr nocapture nofree nonnull readonly align 8 %result.i5) #44
  %112 = extractvalue { i64, i64 } %result.i1.i, 0
  %113 = extractvalue { i64, i64 } %result.i1.i, 1
  %114 = urem i64 20, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = add i64 %112, 20
  %119 = add i64 %118, %117
  %120 = load ptr, ptr %result.i4, align 8
  %121 = getelementptr i8, ptr %120, i64 72
  %122 = load ptr, ptr %121, align 8
  %result.i.i = call { i64, i64 } %122(ptr nocapture nofree nonnull readonly align 8 %result.i4) #44
  %123 = extractvalue { i64, i64 } %result.i.i, 0
  %124 = extractvalue { i64, i64 } %result.i.i, 1
  %125 = call i64 @llvm.umax.i64(i64 %113, i64 %124) #41
  %126 = call i64 @llvm.umax.i64(i64 %125, i64 noundef 8) #41, !range !16
  %127 = urem i64 %119, %124
  %128 = icmp eq i64 %127, 0
  %129 = sub i64 %124, %127
  %130 = select i1 %128, i64 0, i64 %129
  %131 = add i64 %123, %119
  %132 = add i64 %131, %130
  %133 = urem i64 %132, %126
  %134 = icmp eq i64 %133, 0
  %135 = sub i64 %126, %133
  %136 = select i1 %134, i64 0, i64 %135
  %137 = add i64 %136, %132
  %result.i22 = call noalias nonnull align 8 dereferenceable(20) ptr @bump_malloc_wrapper(i64 noundef %137) #48
  store ptr %result.i5, ptr %result.i22, align 8
  %138 = getelementptr inbounds i8, ptr %result.i22, i64 8
  store ptr %result.i4, ptr %138, align 8
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(20) %result.i22)
  %140 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i22, 1
  %141 = insertvalue { ptr, ptr, ptr, i32 } %140, ptr undef, 2
  %142 = insertvalue { ptr, ptr, ptr, i32 } %141, i32 10, 3
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %145 = load ptr, ptr %result.i5, align 8
  %146 = getelementptr i8, ptr %145, i64 72
  %147 = load ptr, ptr %146, align 8
  %result.i.i127 = call { i64, i64 } %147(ptr nocapture nofree nonnull readonly align 8 %result.i5) #44
  %148 = extractvalue { i64, i64 } %result.i.i127, 1
  %149 = urem i64 20, %148
  %150 = icmp eq i64 %149, 0
  %reass.sub130 = sub i64 %148, %149
  %151 = add i64 %reass.sub130, 20
  %152 = select i1 %150, i64 20, i64 %151
  %153 = getelementptr i8, ptr %result.i22, i64 %152
  %154 = getelementptr i8, ptr %145, i64 64
  %155 = load ptr, ptr %154, align 8
  call void %155({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly align 8 %result.i5, ptr nocapture nofree writeonly %153) #45
  %156 = load ptr, ptr %result.i22, align 8
  %157 = load ptr, ptr %156, align 8
  %158 = getelementptr i8, ptr %157, i64 72
  %159 = load ptr, ptr %158, align 8
  %result.i1.i128 = call { i64, i64 } %159(ptr nocapture nofree nonnull readonly align 8 %156) #44
  %160 = extractvalue { i64, i64 } %result.i1.i128, 0
  %161 = extractvalue { i64, i64 } %result.i1.i128, 1
  %162 = urem i64 20, %161
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %161, %162
  %165 = select i1 %163, i64 0, i64 %164
  %166 = add i64 %160, 20
  %167 = add i64 %166, %165
  %168 = load ptr, ptr %138, align 8
  %169 = load ptr, ptr %168, align 8
  %170 = getelementptr i8, ptr %169, i64 72
  %171 = load ptr, ptr %170, align 8
  %result.i.i129 = call { i64, i64 } %171(ptr nocapture nofree nonnull readonly align 8 %168) #44
  %172 = extractvalue { i64, i64 } %result.i.i129, 1
  %173 = urem i64 %167, %172
  %174 = icmp eq i64 %173, 0
  %175 = sub i64 %172, %173
  %176 = select i1 %174, i64 0, i64 %175
  %177 = getelementptr i8, ptr %result.i22, i64 %167
  %178 = getelementptr i8, ptr %177, i64 %176
  %179 = getelementptr i8, ptr %169, i64 64
  %180 = load ptr, ptr %179, align 8
  call void %180({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly align 8 %168, ptr nocapture nofree writeonly %178) #45
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry) #40
  %182 = getelementptr inbounds i8, ptr %result.i22, i64 16
  store i32 %27, ptr %182, align 8
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %185 = getelementptr i8, ptr %19, i64 120
  %186 = getelementptr i8, ptr %19, i64 136
  %187 = load ptr, ptr %19, align 8
  %result.i1 = call ptr %187(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %188 = load ptr, ptr %43, align 8
  %result.i = call ptr %188(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %result.i21 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %189 = getelementptr inbounds i8, ptr %result.i21, i64 16
  store ptr %result.i, ptr %189, align 8
  %190 = getelementptr inbounds i8, ptr %result.i21, i64 8
  store ptr %result.i1, ptr %190, align 8
  %191 = getelementptr inbounds i8, ptr %result.i21, i64 24
  store ptr null, ptr %191, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i21)
  store ptr @Entry, ptr %result.i21, align 8
  store ptr %result.i21, ptr %11, align 8
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %195 = load ptr, ptr %185, align 8
  store ptr @Entry, ptr %12, align 8
  %result.i13 = call ptr %195({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #46
  %196 = call { ptr, i160 } %result.i13({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %142) #53
  %.fca.0.extract42 = extractvalue { ptr, i160 } %196, 0
  %197 = icmp ne ptr %.fca.0.extract42, @nil_typ
  %198 = icmp ne ptr %.fca.0.extract42, null
  %.not98 = and i1 %197, %198
  br i1 %.not98, label %199, label %.loopexit

199:                                              ; preds = %._crit_edge
  %.fca.1.extract43 = extractvalue { ptr, i160 } %196, 1
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %202 = load ptr, ptr %186, align 8
  %result.i12 = call ptr %202({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  call void %result.i12({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #53
  %.sroa.3109.8.extract.trunc = trunc i160 %.fca.1.extract43 to i64
  %203 = inttoptr i64 %.sroa.3109.8.extract.trunc to ptr
  %.sroa.5110.8.extract.shift = lshr i160 %.fca.1.extract43, 64
  %.sroa.5110.8.extract.trunc = trunc i160 %.sroa.5110.8.extract.shift to i64
  %204 = inttoptr i64 %.sroa.5110.8.extract.trunc to ptr
  %hash_coef_ptr.i.i26.1 = getelementptr i8, ptr %.fca.0.extract42, i64 8
  %tbl_size_ptr.i.i27.1 = getelementptr i8, ptr %.fca.0.extract42, i64 16
  %offset_tbl_ptr.i.i28.1 = getelementptr i8, ptr %.fca.0.extract42, i64 40
  %hash_coef.i.i29.1 = load i64, ptr %hash_coef_ptr.i.i26.1, align 4
  %tbl_size.i.i30.1 = load i64, ptr %tbl_size_ptr.i.i27.1, align 4
  %offset_tbl.i.i31.1 = load ptr, ptr %offset_tbl_ptr.i.i28.1, align 8
  %product.i.i.i32.1 = mul i64 %hash_coef.i.i29.1, 4015701072841558310
  %shifted.i.i.i33.1 = lshr i64 %product.i.i.i32.1, 32
  %xored.i.i.i34.1 = xor i64 %shifted.i.i.i33.1, %product.i.i.i32.1
  %hash.i.i.i35.1 = and i64 %xored.i.i.i34.1, %tbl_size.i.i30.1
  %offset_ptr.i.i36.1 = getelementptr i32, ptr %offset_tbl.i.i31.1, i64 %hash.i.i.i35.1
  %offset.i.i37.1 = load i32, ptr %offset_ptr.i.i36.1, align 4
  %205 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract42, 0
  %206 = insertvalue { ptr, ptr, ptr, i32 } %205, ptr %203, 1
  %207 = insertvalue { ptr, ptr, ptr, i32 } %206, ptr %204, 2
  %208 = insertvalue { ptr, ptr, ptr, i32 } %207, i32 %offset.i.i37.1, 3
  %209 = load ptr, ptr %19, align 8
  %result.i1.1 = call ptr %209(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %210 = load ptr, ptr %43, align 8
  %result.i.1 = call ptr %210(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #44
  %result.i21.1 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %211 = getelementptr inbounds i8, ptr %result.i21.1, i64 16
  store ptr %result.i.1, ptr %211, align 8
  %212 = getelementptr inbounds i8, ptr %result.i21.1, i64 8
  store ptr %result.i1.1, ptr %212, align 8
  %213 = getelementptr inbounds i8, ptr %result.i21.1, i64 24
  store ptr null, ptr %213, align 8
  %214 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i21.1)
  store ptr @Entry, ptr %result.i21.1, align 8
  store ptr %result.i21.1, ptr %11, align 8
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %217 = load ptr, ptr %185, align 8
  store ptr %.fca.0.extract42, ptr %12, align 8
  %result.i13.1 = call ptr %217({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #46
  %218 = call { ptr, i160 } %result.i13.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %208) #53
  %.fca.0.extract42.1 = extractvalue { ptr, i160 } %218, 0
  %219 = icmp ne ptr %.fca.0.extract42.1, @nil_typ
  %220 = icmp ne ptr %.fca.0.extract42.1, null
  %.not98.1 = and i1 %219, %220
  br i1 %.not98.1, label %221, label %.loopexit

221:                                              ; preds = %199
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract34)
  %224 = load ptr, ptr %186, align 8
  %result.i12.1 = call ptr %224({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %6) #46
  call void %result.i12.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #53
  br label %.loopexit

.loopexit:                                        ; preds = %221, %199, %._crit_edge, %61, %5
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @CuckooMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1080
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1080
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1080
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1080
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 48
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #28 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1083
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1083
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1083
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1083
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract31, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract32, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31) #40
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract31, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i2 = call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #44
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i2, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #40
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31) #40
  %20 = getelementptr i8, ptr %15, i64 88
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %22) #46
  %23 = call i32 %result.i7({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3) #53
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %27 = getelementptr i8, ptr %15, i64 104
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i6 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %29) #46
  %30 = call i32 %result.i6({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23) #53
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr nonnull %.fca.1.extract32) #43
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %37 = load ptr, ptr %15, align 8
  %result.i1 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #44
  %result.i9 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %38 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr null, ptr %38, align 8
  store ptr @buffer_typ, ptr %result.i9, align 8
  %39 = alloca [4 x ptr], align 8
  store ptr %result.i1, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr %result.i9, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %39)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %45 = getelementptr i8, ptr %15, i64 152
  %46 = load ptr, ptr %45, align 8
  %47 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %47, i64 16
  store ptr @i32_typ, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %47, i64 24
  store ptr @buffer_typ, ptr %50, align 8
  %result.i5 = call ptr %46({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %47) #46
  %51 = call { ptr, i160 } %result.i5({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %39, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35) #53
  %.fca.0.extract = extractvalue { ptr, i160 } %51, 0
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %53 = icmp ne ptr %.fca.0.extract, @nil_typ
  %54 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %53, %54
  br i1 %.not63, label %81, label %55

55:                                               ; preds = %4
  store ptr @_parameterization_i32, ptr %5, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %58 = getelementptr i8, ptr %15, i64 112
  %59 = load ptr, ptr %58, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i4 = call ptr %59({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #46
  %60 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23) #53
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %62 = getelementptr i8, ptr %15, i64 32
  %63 = load ptr, ptr %62, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = call { ptr } %64(ptr nonnull %.fca.1.extract32) #43
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %67 = load ptr, ptr %15, align 8
  %result.i = call ptr %67(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #44
  %result.i8 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %68 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr null, ptr %68, align 8
  store ptr @buffer_typ, ptr %result.i8, align 8
  store ptr %result.i, ptr %7, align 8
  %69 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %result.i8, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %74 = load ptr, ptr %45, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %75 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %77, align 8
  %result.i3 = call ptr %74({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #46
  %78 = call { ptr, i160 } %result.i3({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %60, { ptr } %65) #53
  %.fca.0.extract51 = extractvalue { ptr, i160 } %78, 0
  %.fca.1.extract52 = extractvalue { ptr, i160 } %78, 1
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %.not = icmp eq ptr %.fca.0.extract51, null
  %80 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract51
  br label %81

81:                                               ; preds = %55, %4
  %.reg2mem56.0 = phi ptr [ %80, %55 ], [ %.fca.0.extract, %4 ]
  %.sroa.354.0 = phi i160 [ %.fca.1.extract52, %55 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %51, 1
  %.fca.1.extract..sroa.354.0 = select i1 %.not63, i160 %.fca.1.extract, i160 %.sroa.354.0
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem56.0, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

; Function Attrs: nounwind
define void @CuckooMap__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #28 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1086
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1086
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1086
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1086
  %.fca.0.extract7 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract12, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract11, i64 %11
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #44
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %15 = getelementptr i8, ptr %12, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i = call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #44
  %17 = alloca [2 x ptr], align 8
  store ptr %result.i1, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %result.i, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %17) #40
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %21 = getelementptr i8, ptr %12, i64 168
  %22 = load ptr, ptr %21, align 8
  %23 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract7, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %23, i64 8
  store ptr %.fca.0.extract, ptr %24, align 8
  %result.i2 = call ptr %22({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly align 8 %23) #46
  call void %result.i2({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 dereferenceable(16) %17, { ptr, i160 } %3, { ptr, i160 } %4) #53
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #28 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1089
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1089
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1089
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1089
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract31, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract32, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31) #40
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract31, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i2 = call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #44
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i2, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #40
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31) #40
  %20 = getelementptr i8, ptr %15, i64 88
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i7 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %22) #46
  %23 = call i32 %result.i7({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3) #53
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %27 = getelementptr i8, ptr %15, i64 104
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i6 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %29) #46
  %30 = call i32 %result.i6({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23) #53
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr nonnull %.fca.1.extract32) #43
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %37 = load ptr, ptr %15, align 8
  %result.i1 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #44
  %result.i9 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %38 = getelementptr inbounds i8, ptr %result.i9, i64 8
  store ptr null, ptr %38, align 8
  store ptr @buffer_typ, ptr %result.i9, align 8
  %39 = alloca [4 x ptr], align 8
  store ptr %result.i1, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr %result.i9, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %39)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %45 = getelementptr i8, ptr %15, i64 160
  %46 = load ptr, ptr %45, align 8
  %47 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %47, i64 16
  store ptr @i32_typ, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %47, i64 24
  store ptr @buffer_typ, ptr %50, align 8
  %result.i5 = call ptr %46({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly align 8 %47) #46
  %51 = call { ptr, i160 } %result.i5({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %39, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35) #53
  %.fca.0.extract = extractvalue { ptr, i160 } %51, 0
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract31)
  %53 = icmp ne ptr %.fca.0.extract, @nil_typ
  %54 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %53, %54
  br i1 %.not63, label %81, label %55

55:                                               ; preds = %4
  store ptr @_parameterization_i32, ptr %5, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %58 = getelementptr i8, ptr %15, i64 112
  %59 = load ptr, ptr %58, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i4 = call ptr %59({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #46
  %60 = call i32 %result.i4({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23) #53
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %62 = getelementptr i8, ptr %15, i64 32
  %63 = load ptr, ptr %62, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = call { ptr } %64(ptr nonnull %.fca.1.extract32) #43
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %67 = load ptr, ptr %15, align 8
  %result.i = call ptr %67(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #44
  %result.i8 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %68 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr null, ptr %68, align 8
  store ptr @buffer_typ, ptr %result.i8, align 8
  store ptr %result.i, ptr %7, align 8
  %69 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %result.i8, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %74 = load ptr, ptr %45, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %75 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %77, align 8
  %result.i3 = call ptr %74({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #46
  %78 = call { ptr, i160 } %result.i3({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %60, { ptr } %65) #53
  %.fca.0.extract51 = extractvalue { ptr, i160 } %78, 0
  %.fca.1.extract52 = extractvalue { ptr, i160 } %78, 1
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract31)
  %.not = icmp eq ptr %.fca.0.extract51, null
  %80 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract51
  br label %81

81:                                               ; preds = %55, %4
  %.reg2mem56.0 = phi ptr [ %80, %55 ], [ %.fca.0.extract, %4 ]
  %.sroa.354.0 = phi i160 [ %.fca.1.extract52, %55 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %51, 1
  %.fca.1.extract..sroa.354.0 = select i1 %.not63, i160 %.fca.1.extract, i160 %.sroa.354.0
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem56.0, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #5 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1092
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1092
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1092
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1092
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 40
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  call void %10(ptr %.fca.1.extract, i32 8) #42
  %result.i1 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %12 = getelementptr i8, ptr %6, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr } undef, ptr %result.i1, 0
  call void %15(ptr %.fca.1.extract, { ptr } %16) #42
  %result.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_wrapper(i64 noundef 256) #48
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %18 = getelementptr i8, ptr %6, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %21(ptr %.fca.1.extract, { ptr } %22) #42
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %24 = getelementptr i8, ptr %6, i64 48
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr %.fca.1.extract, i32 0) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @Map__index_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #28 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [3 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr }, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1095
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1095
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1095
  %product.i.i.i = mul i64 %hash_coef.i.i, -5249855671126779970
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1095
  %.fca.0.extract6 = extractvalue { ptr, i160 } %3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract12, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 512, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %18 = sext i32 %offset.i.i to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract11, i64 %18
  %20 = load ptr, ptr %19, align 8
  %result.i = call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #44
  %21 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21) #40
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 512, ptr nocapture nofree noundef align 8 %.fca.0.extract11) #40
  %24 = getelementptr i8, ptr %19, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr }, align 8
  store ptr %.fca.0.extract6, ptr %26, align 8
  %result.i1 = call ptr %25({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly align 8 %26) #46
  %27 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %21, { ptr, i160 } %3) #53
  %.fca.0.extract = extractvalue { ptr, i160 } %27, 0
  %28 = icmp eq ptr %.fca.0.extract, @nil_typ
  %29 = icmp eq ptr %.fca.0.extract, null
  %30 = or i1 %28, %29
  br i1 %30, label %codeRepl, label %._crit_edge

codeRepl:                                         ; preds = %4
  call fastcc void @Map__index_keyK.cold.1(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %6, ptr noalias nocapture nofree noundef nonnull align 8 %5, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %7, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %8, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %9, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %10, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %11, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %12) #59
  br label %._crit_edge

._crit_edge:                                      ; preds = %codeRepl, %4
  %.sroa.0.0 = phi ptr [ @nil_typ, %codeRepl ], [ %.fca.0.extract, %4 ]
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract11)
  %.fca.1.extract = extractvalue { ptr, i160 } %27, 1
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.fca.1.extract, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @CuckooMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1098
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1098
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1098
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1098
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract13, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr nonnull %.fca.1.extract) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr } %14(ptr nonnull %.fca.1.extract) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %17 = getelementptr i8, ptr %6, i64 40
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr nonnull %.fca.1.extract) #43
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %22 = load ptr, ptr %6, align 8
  %result.i2 = call ptr %22(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %24 = getelementptr i8, ptr %6, i64 8
  %25 = load ptr, ptr %24, align 8
  %result.i1 = call ptr %25(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #44
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %result.i8 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_wrapper(i64 noundef 32) #48
  %28 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %result.i1, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %result.i2, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr null, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i8) #40
  store ptr @Pair, ptr %result.i8, align 8
  %result.i7 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_wrapper(i64 noundef 56) #48
  store ptr %result.i2, ptr %result.i7, align 8
  %32 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %result.i1, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %result.i8, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(56) %result.i7) #40
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #40
  %36 = load ptr, ptr %7, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr %.fca.1.extract) #43
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #58
  %40 = load ptr, ptr %12, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr } %41(ptr %.fca.1.extract) #43
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef align 8 %.fca.0.extract13) #58
  %44 = load ptr, ptr %17, align 8
  %45 = load ptr, ptr %44, align 8
  %46 = call i32 %45(ptr %.fca.1.extract) #43
  %47 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr undef, 2
  %49 = getelementptr inbounds i8, ptr %result.i7, i64 24
  %.fca.0.extract.i = extractvalue { ptr } %38, 0
  store ptr %.fca.0.extract.i, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i7, i64 32
  %.fca.0.extract.i31 = extractvalue { ptr } %42, 0
  store ptr %.fca.0.extract.i31, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %result.i7, i64 40
  store i32 %46, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i7, i64 44
  store i32 0, ptr %52, align 4
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator) #40
  %54 = getelementptr inbounds i8, ptr %result.i7, i64 48
  store i1 false, ptr %54, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 24, 3
  ret { ptr, ptr, ptr, i32 } %55
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4, i32 %5) #5 {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1101
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1101
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1101
  %product.i.i.i = mul i64 %hash_coef.i.i, -1975748647346050920
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1101
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract5, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #40
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, { ptr } %4) #42
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #40
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #42
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #40
  %25 = getelementptr i8, ptr %9, i64 48
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %.fca.1.extract, i32 0) #42
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef align 8 %.fca.0.extract5) #40
  %30 = getelementptr i8, ptr %9, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  call void %33(ptr %.fca.1.extract, i1 false) #42
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #28 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1104
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1104
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1104
  %product.i.i.i = mul i64 %hash_coef.i.i, -1975748647346050920
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1104
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5) #56
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract5, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = getelementptr i8, ptr %8, i64 40
  br label %11

11:                                               ; preds = %20, %4
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract6) #43
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5) #56
  %16 = load ptr, ptr %10, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %.fca.1.extract6) #43
  %19 = icmp slt i32 %14, %18
  br i1 %19, label %20, label %.thread41

20:                                               ; preds = %11
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5)
  %22 = call i32 %13(ptr %.fca.1.extract6) #43
  %23 = sext i32 %22 to i64
  %24 = shl nsw i64 %23, 5
  %25 = getelementptr i8, ptr %.fca.0.extract, i64 %24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %25, i64 8
  %28 = load i160, ptr %27, align 4
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5)
  %30 = call i32 %13(ptr %.fca.1.extract6) #43
  %31 = add i32 %30, 1
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5)
  %33 = getelementptr i8, ptr %12, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %.fca.1.extract6, i32 %31) #42
  %35 = icmp eq ptr %26, @nil_typ
  %36 = icmp eq ptr %26, null
  %.not31.not = or i1 %35, %36
  br i1 %.not31.not, label %11, label %37

37:                                               ; preds = %20
  %.sroa.331.8.extract.trunc = trunc i160 %28 to i64
  %38 = inttoptr i64 %.sroa.331.8.extract.trunc to ptr
  %.sroa.532.8.extract.shift = lshr i160 %28, 64
  %.sroa.532.8.extract.trunc = trunc i160 %.sroa.532.8.extract.shift to i64
  %39 = inttoptr i64 %.sroa.532.8.extract.trunc to ptr
  %hash_coef_ptr.i.i2 = getelementptr i8, ptr %26, i64 8
  %tbl_size_ptr.i.i3 = getelementptr i8, ptr %26, i64 16
  %offset_tbl_ptr.i.i4 = getelementptr i8, ptr %26, i64 40
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i2, align 4, !noalias !1107
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i3, align 4, !noalias !1107
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i4, align 8, !noalias !1107
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 4015701072841558310
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !1107
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %26, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %38, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %39, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %offset.i.i13, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %26)
  %46 = sext i32 %offset.i.i13 to i64
  %47 = getelementptr ptr, ptr %26, i64 %46
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i = call ptr %49({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %50 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %5) #53
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %50, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %50, 1
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %50, 2
  %hash_coef_ptr.i.i16 = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i17 = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i19 = load i64, ptr %hash_coef_ptr.i.i16, align 4, !noalias !1110
  %tbl_size.i.i20 = load i64, ptr %tbl_size_ptr.i.i17, align 4, !noalias !1110
  %offset_tbl.i.i21 = load ptr, ptr %offset_tbl_ptr.i.i18, align 8, !noalias !1110
  %product.i.i.i22 = mul i64 %hash_coef.i.i19, 9197944775169318296
  %shifted.i.i.i23 = lshr i64 %product.i.i.i22, 32
  %xored.i.i.i24 = xor i64 %shifted.i.i.i23, %product.i.i.i22
  %hash.i.i.i25 = and i64 %xored.i.i.i24, %tbl_size.i.i20
  %offset_ptr.i.i26 = getelementptr i32, ptr %offset_tbl.i.i21, i64 %hash.i.i.i25
  %offset.i.i27 = load i32, ptr %offset_ptr.i.i26, align 4, !noalias !1110
  %51 = ptrtoint ptr %.fca.1.extract9 to i64
  %52 = ptrtoint ptr %.fca.2.extract10 to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i27 to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %52 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext = zext i64 %51 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext
  br label %.thread41

.thread41:                                        ; preds = %37, %11
  %.reg2mem26.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %37 ], [ undef, %11 ]
  %.reg2mem26.sroa.0.0 = phi ptr [ %.fca.0.extract8, %37 ], [ @nil_typ, %11 ]
  %.reload27.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem26.sroa.0.0, 0
  %.reload27.fca.1.insert = insertvalue { ptr, i160 } %.reload27.fca.0.insert, i160 %.reg2mem26.sroa.3.0, 1
  ret { ptr, i160 } %.reload27.fca.1.insert
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #28 {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1113
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1113
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1113
  %product.i.i.i = mul i64 %hash_coef.i.i, -1975748647346050920
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1113
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5) #40
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract5, i64 %9
  %11 = getelementptr i8, ptr %10, i64 56
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i1 %13(ptr %.fca.1.extract6) #43
  br i1 %14, label %._crit_edge, label %15

._crit_edge:                                      ; preds = %3
  %.pre = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %.pre32 = insertvalue { ptr, ptr, ptr, i32 } %.pre, ptr %.fca.1.extract6, 1
  %.pre34 = insertvalue { ptr, ptr, ptr, i32 } %.pre32, ptr %.fca.2.extract, 2
  %.pre36 = insertvalue { ptr, ptr, ptr, i32 } %.pre34, i32 %offset.i.i, 3
  br label %44

15:                                               ; preds = %3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5) #58
  %17 = getelementptr i8, ptr %10, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr } %19(ptr %.fca.1.extract6) #43
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract6, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i, 3
  %result.i3 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %25 = getelementptr inbounds i8, ptr %result.i3, i64 8
  store ptr null, ptr %25, align 8
  store ptr @buffer_typ, ptr %result.i3, align 8
  store ptr %result.i3, ptr %4, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4) #58
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5) #58
  %28 = getelementptr i8, ptr %10, i64 72
  %29 = load ptr, ptr %28, align 8
  store ptr @buffer_typ, ptr %5, align 8
  %result.i1 = call ptr %29({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly align 8 %5) #46
  %30 = call { ptr, i160 } %result.i1({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 dereferenceable(8) %4, { ptr } %20) #53
  %.fca.0.extract15 = extractvalue { ptr, i160 } %30, 0
  %31 = icmp ne ptr %.fca.0.extract15, @nil_typ
  %32 = icmp ne ptr %.fca.0.extract15, null
  %.not22.not.not = and i1 %31, %32
  br i1 %.not22.not.not, label %43, label %33

33:                                               ; preds = %15
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5)
  %35 = getelementptr i8, ptr %10, i64 48
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract6, i32 0) #42
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5)
  %40 = load ptr, ptr %11, align 8
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  call void %42(ptr %.fca.1.extract6, i1 true) #42
  br label %44

43:                                               ; preds = %15
  %.fca.1.extract16 = extractvalue { ptr, i160 } %30, 1
  %hash_coef_ptr.i.i5 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i.i6 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i.i8 = load i64, ptr %hash_coef_ptr.i.i5, align 4, !noalias !1116
  %tbl_size.i.i9 = load i64, ptr %tbl_size_ptr.i.i6, align 4, !noalias !1116
  %offset_tbl.i.i10 = load ptr, ptr %offset_tbl_ptr.i.i7, align 8, !noalias !1116
  %product.i.i.i11 = mul i64 %hash_coef.i.i8, 9197944775169318296
  %shifted.i.i.i12 = lshr i64 %product.i.i.i11, 32
  %xored.i.i.i13 = xor i64 %shifted.i.i.i12, %product.i.i.i11
  %hash.i.i.i14 = and i64 %xored.i.i.i13, %tbl_size.i.i9
  %offset_ptr.i.i15 = getelementptr i32, ptr %offset_tbl.i.i10, i64 %hash.i.i.i14
  %offset.i.i16 = load i32, ptr %offset_ptr.i.i15, align 4, !noalias !1116
  %.sroa.5.8.insert.ext = zext i32 %offset.i.i16 to i160
  %.sroa.5.8.insert.shift = shl nuw i160 %.sroa.5.8.insert.ext, 128
  %.sroa.3.8.insert.ext = and i160 %.fca.1.extract16, 340282366920938463463374607431768211455
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.shift, %.sroa.3.8.insert.ext
  br label %56

44:                                               ; preds = %33, %._crit_edge
  %.pre-phi37 = phi { ptr, ptr, ptr, i32 } [ %.pre36, %._crit_edge ], [ %24, %33 ]
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5) #58
  %46 = getelementptr i8, ptr %10, i64 32
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract6) #43
  %result.i2 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  %50 = getelementptr inbounds i8, ptr %result.i2, i64 8
  store ptr null, ptr %50, align 8
  store ptr @buffer_typ, ptr %result.i2, align 8
  store ptr %result.i2, ptr %6, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #58
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %.fca.0.extract5) #58
  %53 = getelementptr i8, ptr %10, i64 72
  %54 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %7, align 8
  %result.i = call ptr %54({ ptr, ptr, ptr, i32 } %.pre-phi37, ptr nocapture nofree noundef nonnull readonly align 8 %7) #46
  %55 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %.pre-phi37, { ptr, ptr, ptr, i32 } %.pre-phi37, ptr nonnull align 8 dereferenceable(8) %6, { ptr } %49) #53
  %.fca.0.extract7 = extractvalue { ptr, i160 } %55, 0
  %.fca.1.extract8 = extractvalue { ptr, i160 } %55, 1
  br label %56

56:                                               ; preds = %44, %43
  %.reg2mem37.sroa.0.0 = phi ptr [ %.fca.0.extract7, %44 ], [ %.fca.0.extract15, %43 ]
  %.reg2mem37.sroa.3.0 = phi i160 [ %.fca.1.extract8, %44 ], [ %.sroa.3.8.insert.insert, %43 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem37.sroa.0.0, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem37.sroa.3.0, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #37 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #44
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #44
  %20 = extractvalue { i64, i64 } %result.i, 0
  %21 = extractvalue { i64, i64 } %result.i, 1
  %22 = call i64 @llvm.umax.i64(i64 %8, i64 %21) #41
  %23 = call i64 @llvm.umax.i64(i64 %22, i64 noundef 8) #41, !range !16
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %33, %29
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #2 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_primary_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_to_pair_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #5 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1119
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1119
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1119
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1119
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #40
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract12, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract13, { ptr, i160 } %3) #42
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #40
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract13, { ptr, i160 } %4) #42
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract12) #40
  %20 = getelementptr i8, ptr %9, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract13, i32 %5) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1122
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1122
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1122
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1122
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract4) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1125
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1125
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1125
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1125
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract3) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 32
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr %.fca.1.extract4) #43
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Entry_primary_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1128
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1128
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1128
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1128
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #43
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Entry_to_pair_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #6 {
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1131
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1131
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1131
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1131
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #40
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract27, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr, i160 } %9(ptr nonnull %.fca.1.extract28) #43
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #40
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr, i160 } %14(ptr nonnull %.fca.1.extract28) #43
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #40
  %17 = load ptr, ptr %6, align 8
  %result.i3 = call align 8 ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract28) #44
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #40
  %19 = getelementptr i8, ptr %6, i64 8
  %20 = load ptr, ptr %19, align 8
  %result.i2 = call align 8 ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract28) #44
  %21 = load ptr, ptr %result.i3, align 8, !alias.scope !1134
  %22 = getelementptr i8, ptr %21, i64 72
  %23 = load ptr, ptr %22, align 8, !alias.scope !1134
  %result.i1.i = call { i64, i64 } %23(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44, !alias.scope !1134
  %24 = extractvalue { i64, i64 } %result.i1.i, 0
  %25 = extractvalue { i64, i64 } %result.i1.i, 1
  %26 = urem i64 16, %25
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %25, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %24, 16
  %31 = add i64 %30, %29
  %32 = load ptr, ptr %result.i2, align 8, !alias.scope !1134
  %33 = getelementptr i8, ptr %32, i64 72
  %34 = load ptr, ptr %33, align 8, !alias.scope !1134
  %result.i.i = call { i64, i64 } %34(ptr nocapture nofree nonnull readonly align 8 %result.i2) #44, !alias.scope !1134
  %35 = extractvalue { i64, i64 } %result.i.i, 0
  %36 = extractvalue { i64, i64 } %result.i.i, 1
  %37 = call i64 @llvm.umax.i64(i64 %25, i64 %36) #41
  %38 = call i64 @llvm.umax.i64(i64 %37, i64 noundef 8) #41, !range !16
  %39 = urem i64 %31, %36
  %40 = icmp eq i64 %39, 0
  %41 = sub i64 %36, %39
  %42 = select i1 %40, i64 0, i64 %41
  %43 = add i64 %35, %31
  %44 = add i64 %43, %42
  %45 = urem i64 %44, %38
  %46 = icmp eq i64 %45, 0
  %47 = sub i64 %38, %45
  %48 = select i1 %46, i64 0, i64 %47
  %49 = add i64 %48, %44
  %result.i6 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_wrapper(i64 noundef %49) #48
  store ptr %result.i3, ptr %result.i6, align 8
  %50 = getelementptr inbounds i8, ptr %result.i6, i64 8
  store ptr %result.i2, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i6) #40
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #40
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr, i160 } %54(ptr nonnull %.fca.1.extract28) #43
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #58
  %57 = load ptr, ptr %12, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, i160 } %58(ptr nonnull %.fca.1.extract28) #43
  %60 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %result.i6, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr undef, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 10, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #58
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef align 8 %.fca.0.extract27) #58
  %65 = load ptr, ptr %result.i3, align 8
  %66 = getelementptr i8, ptr %65, i64 72
  %67 = load ptr, ptr %66, align 8
  %result.i.i30 = call { i64, i64 } %67(ptr nocapture nofree nonnull readonly align 8 %result.i3) #44
  %68 = extractvalue { i64, i64 } %result.i.i30, 1
  %69 = urem i64 16, %68
  %70 = icmp eq i64 %69, 0
  %reass.sub33 = sub i64 %68, %69
  %71 = add i64 %reass.sub33, 16
  %72 = select i1 %70, i64 16, i64 %71
  %73 = getelementptr i8, ptr %result.i6, i64 %72
  %74 = getelementptr i8, ptr %65, i64 64
  %75 = load ptr, ptr %74, align 8
  call void %75({ ptr, i160 } %55, ptr nocapture nofree nonnull readonly align 8 %result.i3, ptr nocapture nofree writeonly %73) #45
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair) #40
  %77 = load ptr, ptr %result.i6, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr i8, ptr %78, i64 72
  %80 = load ptr, ptr %79, align 8
  %result.i1.i31 = call { i64, i64 } %80(ptr nocapture nofree nonnull readonly align 8 %77) #44
  %81 = extractvalue { i64, i64 } %result.i1.i31, 0
  %82 = extractvalue { i64, i64 } %result.i1.i31, 1
  %83 = urem i64 16, %82
  %84 = icmp eq i64 %83, 0
  %85 = sub i64 %82, %83
  %86 = select i1 %84, i64 0, i64 %85
  %87 = add i64 %81, 16
  %88 = add i64 %87, %86
  %89 = load ptr, ptr %50, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = getelementptr i8, ptr %90, i64 72
  %92 = load ptr, ptr %91, align 8
  %result.i.i32 = call { i64, i64 } %92(ptr nocapture nofree nonnull readonly align 8 %89) #44
  %93 = extractvalue { i64, i64 } %result.i.i32, 1
  %94 = urem i64 %88, %93
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %93, %94
  %97 = select i1 %95, i64 0, i64 %96
  %98 = getelementptr i8, ptr %result.i6, i64 %88
  %99 = getelementptr i8, ptr %98, i64 %97
  %100 = getelementptr i8, ptr %90, i64 64
  %101 = load ptr, ptr %100, align 8
  call void %101({ ptr, i160 } %59, ptr nocapture nofree nonnull readonly align 8 %89, ptr nocapture nofree writeonly %99) #45
  ret { ptr, ptr, ptr, i32 } %62
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_value(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i1 = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #44
  %6 = extractvalue { i64, i64 } %result.i1, 0
  %7 = extractvalue { i64, i64 } %result.i1, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 20
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i = call { i64, i64 } %18(ptr nocapture nofree nonnull readonly align 8 %15) #44
  %19 = extractvalue { i64, i64 } %result.i, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly align 8 %15) #44
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_value(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i1 = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #44
  %7 = extractvalue { i64, i64 } %result.i1, 0
  %8 = extractvalue { i64, i64 } %result.i1, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call { i64, i64 } %19(ptr nocapture nofree nonnull readonly align 8 %16) #44
  %20 = extractvalue { i64, i64 } %result.i, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %16, ptr nocapture nofree writeonly %26) #45
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_key(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #37 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = call { i64, i64 } %5(ptr nocapture nofree nonnull readonly align 8 %2) #44
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 20, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 20
  %10 = select i1 %8, i64 20, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly align 8 %2) #44
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_key(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #36 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = call { i64, i64 } %6(ptr nocapture nofree nonnull readonly align 8 %3) #44
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly align 8 %3, ptr nocapture nofree writeonly %12) #45
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_primary_hash(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_primary_hash(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @CuckooMapIterator_getter_on_second(ptr nocapture nofree readonly %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_on_second(ptr nocapture nofree writeonly %0, i1 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_table_len(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_KeyNotFound(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #4 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #40
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @KeyNotFound_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 80
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 80
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @KeyNotFound_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_message(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_file_name(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @KeyNotFound_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #2 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #3 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Map(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #1 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_eq(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_eq(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_hasher(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_hasher(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_size(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_size(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_table_len(ptr nocapture nofree readonly align 4 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table2(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table1(ptr nocapture nofree readonly align 8 %0) #2 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #3 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: nounwind
define void @report_exception({ ptr } %0) local_unnamed_addr #28 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i1 = call i1 %11(i64 %10, i64 %9, i64 9027164862567808692, i64 ptrtoint (ptr @Exception to i64), ptr readonly %12) #44
  br i1 %result.i1, label %13, label %._crit_edge

13:                                               ; preds = %1
  %14 = getelementptr i8, ptr %.fca.0.extract2, i64 56
  %15 = load i64, ptr %14, align 4
  %.sroa_idx = getelementptr i8, ptr %.fca.0.extract2, i64 64
  %16 = load i64, ptr %.sroa_idx, align 4
  %17 = inttoptr i64 %15 to ptr
  %18 = inttoptr i64 %16 to ptr
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %4, i64 40
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1137
  %product.i.i.i = mul i64 %9, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %10
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1137
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %4, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %17, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %18, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %offset.i.i, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #40
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %25 = sext i32 %offset.i.i to i64
  %26 = getelementptr ptr, ptr %4, i64 %25
  %27 = getelementptr i8, ptr %26, i64 72
  %28 = load ptr, ptr %27, align 8
  %result.i = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly align 8 %2) #46
  call void %result.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %2) #53
  br label %._crit_edge

._crit_edge:                                      ; preds = %13, %1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #1 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

; Function Attrs: cold minsize nounwind
define internal fastcc void @Array__index_xi32.cold.1(ptr nocapture nofree noundef nonnull align 8 %0, ptr %1, ptr nocapture nofree noundef nonnull readonly %2, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %3, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %4, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %5, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8, i32 %9, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %15) unnamed_addr #38 section "__llvm_cold" {
newFuncRoot:
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %0) #60
  %17 = call i32 %2(ptr %1) #61
  store ptr @OutOfBounds, ptr %3, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(120) ptr @bump_malloc_wrapper(i64 noundef 120) #48
  %18 = load ptr, ptr %4, align 8
  %19 = load ptr, ptr %5, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %19) #60
  %21 = load i32, ptr %6, align 8
  %22 = sext i32 %21 to i64
  %23 = getelementptr ptr, ptr %19, i64 %22
  %24 = getelementptr i8, ptr %23, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %18) #61
  store ptr @_parameterization_i32, ptr %7, align 8
  %28 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7) #40
  store ptr @i32_typ, ptr %8, align 8
  %30 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %8) #40
  %result.i11.i = call noalias align 4 dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #48
  store i32 %27, ptr %result.i11.i, align 4
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails) #40
  %33 = getelementptr i8, ptr %result.i11.i, i64 4
  store i32 %9, ptr %33, align 4
  %34 = ptrtoint ptr %result.i11.i to i64
  %.sroa.3.8.insert.ext.i = zext i64 %34 to i160
  %.sroa.3.8.insert.insert.i = or disjoint i160 %.sroa.3.8.insert.ext.i, 3402823669209384634633746074317682114560
  store ptr @OutOfBoundsDetails, ptr %result.i7, align 8
  %35 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store i160 %.sroa.3.8.insert.insert.i, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 32
  %37 = getelementptr i8, ptr %result.i7, i64 40
  %38 = getelementptr i8, ptr %result.i7, i64 48
  %39 = getelementptr i8, ptr %result.i7, i64 56
  %40 = getelementptr i8, ptr %result.i7, i64 64
  %result.i8.i = call noalias dereferenceable_or_null(66) ptr @bump_malloc_wrapper(i64 noundef 66) #48
  %41 = load <65 x i8>, ptr @wapia_An_outofbounds_error_occurred_while_indexing_into_a_collection, align 128
  store <65 x i8> %41, ptr %result.i8.i, align 1
  %result.i7.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store ptr %result.i8.i, ptr %result.i7.i, align 8
  %42 = getelementptr i8, ptr %result.i7.i, i64 8
  store <2 x i32> <i32 65, i32 66>, ptr %42, align 8
  %43 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @String, ptr %43, align 8
  %44 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i7.i, ptr %44, align 8
  %45 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %45, align 8
  %result.i6.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #48
  %46 = getelementptr i8, ptr %result.i7, i64 104
  store ptr %result.i6.i, ptr %46, align 8
  %47 = insertvalue { ptr } undef, ptr %result.i6.i, 0
  %48 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %47) #53
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 16 dereferenceable(376) @OutOfBounds)
  %50 = getelementptr i8, ptr %result.i7, i64 112
  store i64 %48, ptr %50, align 8
  %result.i6 = call noalias dereferenceable_or_null(57) ptr @bump_malloc_wrapper(i64 noundef 57) #48
  %51 = load <56 x i8>, ptr @uagtt_CUsersPaulKOneDriveDocumentsPLPyPLlibarraymini, align 64
  store <56 x i8> %51, ptr %result.i6, align 1
  store ptr @String, ptr %10, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store ptr @_parameterization_Bufferi8, ptr %11, align 8
  %52 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_i32, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %11)
  store ptr @buffer_typ, ptr %12, align 8
  %55 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @i32_typ, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %12) #40
  store ptr %result.i6, ptr %result.i5, align 8
  %58 = getelementptr i8, ptr %result.i5, i64 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 56, i32 57>, ptr %58, align 8
  store ptr @String, ptr %13, align 8
  %60 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %result.i5, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %13, i64 16
  %62 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 10, ptr %62, align 8
  %63 = load ptr, ptr %61, align 8
  store ptr @_parameterization_i32, ptr %14, align 8
  %64 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_String, ptr %64, align 8
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %14)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 16 dereferenceable(376) @OutOfBounds)
  store ptr @i32_typ, ptr %15, align 8
  %67 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @String, ptr %67, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %15) #40
  store i32 86, ptr %36, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 16 dereferenceable(376) @OutOfBounds) #40
  store ptr @String, ptr %37, align 8
  store ptr %result.i5, ptr %38, align 8
  store ptr %63, ptr %39, align 8
  store i32 10, ptr %40, align 8
  %70 = ptrtoint ptr %result.i7 to i64
  %.sroa.454.8.insert.ext = zext i64 %70 to i160
  %.sroa.454.8.insert.insert = or disjoint i160 %.sroa.454.8.insert.ext, 3402823669209384634633746074317682114560
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %71 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @OutOfBounds, ptr %71, align 8
  %72 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i160 %.sroa.454.8.insert.insert, ptr %72, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #53
  ret void
}

; Function Attrs: cold minsize nounwind
define internal fastcc void @Array__set_index_xi32_valueT.cold.1(ptr nocapture nofree noundef nonnull align 8 %0, ptr %1, ptr nocapture nofree noundef nonnull readonly %2, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %3, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %4, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(32) %5, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8, i32 %9, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %15) unnamed_addr #38 section "__llvm_cold" {
newFuncRoot:
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 %0) #60
  %17 = call i32 %2(ptr %1) #61
  store ptr @OutOfBounds, ptr %3, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(120) ptr @bump_malloc_wrapper(i64 noundef 120) #48
  %18 = load ptr, ptr %4, align 8
  %19 = load ptr, ptr %5, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %19) #60
  %21 = load i32, ptr %6, align 8
  %22 = sext i32 %21 to i64
  %23 = getelementptr ptr, ptr %19, i64 %22
  %24 = getelementptr i8, ptr %23, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %18) #61
  store ptr @_parameterization_i32, ptr %7, align 8
  %28 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7) #60
  store ptr @i32_typ, ptr %8, align 8
  %30 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %8) #60
  %result.i11.i = call noalias align 4 dereferenceable_or_null(8) ptr @bump_malloc_wrapper(i64 noundef 8) #48
  store i32 %27, ptr %result.i11.i, align 4
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails) #60
  %33 = getelementptr i8, ptr %result.i11.i, i64 4
  store i32 %9, ptr %33, align 4
  %34 = ptrtoint ptr %result.i11.i to i64
  %.sroa.3.8.insert.ext.i = zext i64 %34 to i160
  %.sroa.3.8.insert.insert.i = or disjoint i160 %.sroa.3.8.insert.ext.i, 3402823669209384634633746074317682114560
  store ptr @OutOfBoundsDetails, ptr %result.i7, align 8
  %35 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store i160 %.sroa.3.8.insert.insert.i, ptr %35, align 8
  %36 = getelementptr i8, ptr %result.i7, i64 32
  %37 = getelementptr i8, ptr %result.i7, i64 40
  %38 = getelementptr i8, ptr %result.i7, i64 48
  %39 = getelementptr i8, ptr %result.i7, i64 56
  %40 = getelementptr i8, ptr %result.i7, i64 64
  %result.i8.i = call noalias dereferenceable_or_null(66) ptr @bump_malloc_wrapper(i64 noundef 66) #48
  %41 = load <65 x i8>, ptr @wapia_An_outofbounds_error_occurred_while_indexing_into_a_collection, align 128
  store <65 x i8> %41, ptr %result.i8.i, align 1
  %result.i7.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store ptr %result.i8.i, ptr %result.i7.i, align 8
  %42 = getelementptr i8, ptr %result.i7.i, i64 8
  store <2 x i32> <i32 65, i32 66>, ptr %42, align 8
  %43 = getelementptr i8, ptr %result.i7, i64 72
  store ptr @String, ptr %43, align 8
  %44 = getelementptr i8, ptr %result.i7, i64 80
  store ptr %result.i7.i, ptr %44, align 8
  %45 = getelementptr i8, ptr %result.i7, i64 96
  store i32 10, ptr %45, align 8
  %result.i6.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #48
  %46 = getelementptr i8, ptr %result.i7, i64 104
  store ptr %result.i6.i, ptr %46, align 8
  %47 = insertvalue { ptr } undef, ptr %result.i6.i, 0
  %48 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %47) #53
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 16 dereferenceable(376) @OutOfBounds) #60
  %50 = getelementptr i8, ptr %result.i7, i64 112
  store i64 %48, ptr %50, align 8
  %result.i6 = call noalias dereferenceable_or_null(57) ptr @bump_malloc_wrapper(i64 noundef 57) #48
  %51 = load <56 x i8>, ptr @uagtt_CUsersPaulKOneDriveDocumentsPLPyPLlibarraymini, align 64
  store <56 x i8> %51, ptr %result.i6, align 1
  store ptr @String, ptr %10, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store ptr @_parameterization_Bufferi8, ptr %11, align 8
  %52 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_i32, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %11) #60
  store ptr @buffer_typ, ptr %12, align 8
  %55 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @i32_typ, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %12) #60
  store ptr %result.i6, ptr %result.i5, align 8
  %58 = getelementptr i8, ptr %result.i5, i64 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #60
  store <2 x i32> <i32 56, i32 57>, ptr %58, align 8
  store ptr @String, ptr %13, align 8
  %60 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %result.i5, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %13, i64 16
  %62 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 10, ptr %62, align 8
  %63 = load ptr, ptr %61, align 8
  store ptr @_parameterization_i32, ptr %14, align 8
  %64 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_String, ptr %64, align 8
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %14) #60
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 16 dereferenceable(376) @OutOfBounds) #60
  store ptr @i32_typ, ptr %15, align 8
  %67 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @String, ptr %67, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %15) #60
  store i32 94, ptr %36, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 16 dereferenceable(376) @OutOfBounds) #60
  store ptr @String, ptr %37, align 8
  store ptr %result.i5, ptr %38, align 8
  store ptr %63, ptr %39, align 8
  store i32 10, ptr %40, align 8
  %70 = ptrtoint ptr %result.i7 to i64
  %.sroa.454.8.insert.ext = zext i64 %70 to i160
  %.sroa.454.8.insert.insert = or disjoint i160 %.sroa.454.8.insert.ext, 3402823669209384634633746074317682114560
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %71 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @OutOfBounds, ptr %71, align 8
  %72 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i160 %.sroa.454.8.insert.insert, ptr %72, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #53
  ret void
}

; Function Attrs: cold minsize nounwind
define internal fastcc void @Map__index_keyK.cold.1(ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, ptr noalias nocapture nofree noundef nonnull align 8 %1, ptr noalias nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %2, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %3, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(32) %5, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %6, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %7) unnamed_addr #38 section "__llvm_cold" {
newFuncRoot:
  store ptr @KeyNotFound, ptr %0, align 8
  %result.i7 = call noalias align 8 dereferenceable_or_null(88) ptr @bump_malloc_wrapper(i64 noundef 88) #48
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull align 8 %1) #60
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr noalias nocapture nofree noundef nonnull readonly align 8 %1) #60
  %result.i8.i = call noalias dereferenceable_or_null(7) ptr @bump_malloc_wrapper(i64 noundef 7) #48
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i8.i, align 1
  %result.i7.i = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store ptr %result.i8.i, ptr %result.i7.i, align 8
  %10 = getelementptr i8, ptr %result.i7.i, i64 8
  store <2 x i32> <i32 6, i32 7>, ptr %10, align 8
  %11 = getelementptr i8, ptr %result.i7, i64 40
  store ptr @String, ptr %11, align 8
  %12 = getelementptr i8, ptr %result.i7, i64 48
  store ptr %result.i7.i, ptr %12, align 8
  %13 = getelementptr i8, ptr %result.i7, i64 64
  store i32 10, ptr %13, align 8
  %14 = getelementptr i8, ptr %result.i7, i64 8
  %15 = getelementptr i8, ptr %result.i7, i64 16
  %16 = getelementptr i8, ptr %result.i7, i64 24
  %17 = getelementptr i8, ptr %result.i7, i64 32
  %result.i4.i = call noalias dereferenceable_or_null(800) ptr @bump_malloc_wrapper(i64 noundef 800) #48
  %18 = getelementptr i8, ptr %result.i7, i64 72
  store ptr %result.i4.i, ptr %18, align 8
  %19 = insertvalue { ptr } undef, ptr %result.i4.i, 0
  %20 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %19) #53
  %21 = getelementptr i8, ptr %result.i7, i64 80
  store i64 %20, ptr %21, align 8
  %result.i6 = call noalias dereferenceable_or_null(55) ptr @bump_malloc_wrapper(i64 noundef 55) #48
  %22 = load <54 x i8>, ptr @fsifx_CUsersPaulKOneDriveDocumentsPLPyPLlibmapmini, align 64
  store <54 x i8> %22, ptr %result.i6, align 1
  store ptr @String, ptr %2, align 8
  %result.i5 = call noalias align 8 dereferenceable_or_null(16) ptr @bump_malloc_wrapper(i64 noundef 16) #48
  store ptr @_parameterization_Bufferi8, ptr %3, align 8
  %23 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %3, i64 16
  store ptr @_parameterization_i32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  store ptr @buffer_typ, ptr %4, align 8
  %26 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr @i32_typ, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr noalias nocapture nofree noundef nonnull readonly align 8 dereferenceable(24) %4) #40
  store ptr %result.i6, ptr %result.i5, align 8
  %29 = getelementptr i8, ptr %result.i5, i64 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String) #40
  store <2 x i32> <i32 54, i32 55>, ptr %29, align 8
  store ptr @String, ptr %5, align 8
  %31 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %result.i5, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %5, i64 16
  %33 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 10, ptr %33, align 8
  %34 = load ptr, ptr %32, align 8
  store ptr @_parameterization_i32, ptr %6, align 8
  %35 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @_parameterization_String, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr noalias nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 272, ptr nocapture nofree noundef nonnull align 16 dereferenceable(352) @KeyNotFound)
  store ptr @i32_typ, ptr %7, align 8
  %38 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @String, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr noalias nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %7) #40
  store i32 14, ptr %result.i7, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 16 dereferenceable(352) @KeyNotFound) #40
  store ptr @String, ptr %14, align 8
  store ptr %result.i5, ptr %15, align 8
  store ptr %34, ptr %16, align 8
  store i32 10, ptr %17, align 8
  %41 = ptrtoint ptr %result.i7 to i64
  %.sroa.449.8.insert.ext = zext i64 %41 to i160
  %.sroa.449.8.insert.insert = or disjoint i160 %.sroa.449.8.insert.ext, 3402823669209384634633746074317682114560
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %42 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store ptr @KeyNotFound, ptr %42, align 8
  %43 = getelementptr i8, ptr %current_coroutine.i, i64 56
  store i160 %.sroa.449.8.insert.insert, ptr %43, align 4
  call void @coroutine_yield_cold(ptr nocapture nofree noundef writeonly align 8 %current_coroutine.i) #53
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #39

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #7

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #7

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #19

attributes #0 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "disable-tail-calls"="true" }
attributes #2 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #3 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "disable-tail-calls"="true" }
attributes #4 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #5 = { mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #6 = { mustprogress nounwind willreturn "disable-tail-calls"="true" }
attributes #7 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #8 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #9 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #10 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #11 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #12 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #13 = { alwaysinline mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #14 = { nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #15 = { alwaysinline mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, inaccessiblemem: none) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #16 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #17 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #18 = { "disable-tail-calls"="true" }
attributes #19 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #20 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #21 = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #22 = { noreturn nounwind }
attributes #23 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" "disable-tail-calls"="true" }
attributes #24 = { nocallback nofree nosync nounwind willreturn }
attributes #25 = { nofree nounwind "disable-tail-calls"="true" }
attributes #26 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #27 = { noinline nounwind memory(readwrite) "disable-tail-calls"="true" }
attributes #28 = { nounwind "disable-tail-calls"="true" }
attributes #29 = { cold minsize noinline nounwind "disable-tail-calls"="true" }
attributes #30 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #31 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #32 = { mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #33 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #34 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #35 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #36 = { mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #37 = { mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #38 = { cold minsize nounwind "disable-tail-calls"="true" }
attributes #39 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #40 = { nofree willreturn }
attributes #41 = { nofree nosync willreturn }
attributes #42 = { nounwind willreturn memory(argmem: readwrite) }
attributes #43 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #44 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #45 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #46 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #47 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #48 = { mustprogress nofree nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #49 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #50 = { nofree nosync nounwind willreturn memory(read) }
attributes #51 = { mustprogress nofree nosync nounwind willreturn }
attributes #52 = { nounwind memory(read) }
attributes #53 = { nounwind }
attributes #54 = { nounwind memory(readwrite) }
attributes #55 = { nofree nounwind }
attributes #56 = { nofree }
attributes #57 = { nofree nounwind willreturn }
attributes #58 = { willreturn }
attributes #59 = { noinline nounwind }
attributes #60 = { nofree willreturn memory(readwrite) }
attributes #61 = { nounwind willreturn memory(readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{!2}
!2 = distinct !{!2, !3, !"set_offset: %fat_ptr"}
!3 = distinct !{!3, !"set_offset"}
!4 = !{!5}
!5 = distinct !{!5, !6, !"set_offset: %fat_ptr"}
!6 = distinct !{!6, !"set_offset"}
!7 = !{!8}
!8 = distinct !{!8, !9, !"set_offset: %fat_ptr"}
!9 = distinct !{!9, !"set_offset"}
!10 = !{!11}
!11 = distinct !{!11, !12, !"set_offset: %fat_ptr"}
!12 = distinct !{!12, !"set_offset"}
!13 = !{!14}
!14 = distinct !{!14, !15, !"size_wrapper: argument 0"}
!15 = distinct !{!15, !"size_wrapper"}
!16 = !{i64 8, i64 0}
!17 = !{!18}
!18 = distinct !{!18, !19, !"set_offset: %fat_ptr"}
!19 = distinct !{!19, !"set_offset"}
!20 = !{!21}
!21 = distinct !{!21, !22, !"size_wrapper: argument 0"}
!22 = distinct !{!22, !"size_wrapper"}
!23 = !{!24}
!24 = distinct !{!24, !25, !"set_offset: %fat_ptr"}
!25 = distinct !{!25, !"set_offset"}
!26 = !{!27}
!27 = distinct !{!27, !28, !"set_offset: %fat_ptr"}
!28 = distinct !{!28, !"set_offset"}
!29 = !{!30}
!30 = distinct !{!30, !31, !"set_offset: %fat_ptr"}
!31 = distinct !{!31, !"set_offset"}
!32 = !{!33}
!33 = distinct !{!33, !34, !"set_offset: %fat_ptr"}
!34 = distinct !{!34, !"set_offset"}
!35 = !{!36}
!36 = distinct !{!36, !37, !"set_offset: %fat_ptr"}
!37 = distinct !{!37, !"set_offset"}
!38 = !{!39}
!39 = distinct !{!39, !40, !"set_offset: %fat_ptr"}
!40 = distinct !{!40, !"set_offset"}
!41 = !{!42}
!42 = distinct !{!42, !43, !"set_offset: %fat_ptr"}
!43 = distinct !{!43, !"set_offset"}
!44 = !{!45}
!45 = distinct !{!45, !46, !"set_offset: %fat_ptr"}
!46 = distinct !{!46, !"set_offset"}
!47 = !{!48}
!48 = distinct !{!48, !49, !"set_offset: %fat_ptr"}
!49 = distinct !{!49, !"set_offset"}
!50 = !{!51}
!51 = distinct !{!51, !52, !"set_offset: %fat_ptr"}
!52 = distinct !{!52, !"set_offset"}
!53 = !{!54}
!54 = distinct !{!54, !55, !"size_wrapper: argument 0"}
!55 = distinct !{!55, !"size_wrapper"}
!56 = !{!57}
!57 = distinct !{!57, !58, !"set_offset: %fat_ptr"}
!58 = distinct !{!58, !"set_offset"}
!59 = !{!60}
!60 = distinct !{!60, !61, !"size_wrapper: argument 0"}
!61 = distinct !{!61, !"size_wrapper"}
!62 = !{!63}
!63 = distinct !{!63, !64, !"set_offset: %fat_ptr"}
!64 = distinct !{!64, !"set_offset"}
!65 = !{!66}
!66 = distinct !{!66, !67, !"set_offset: %fat_ptr"}
!67 = distinct !{!67, !"set_offset"}
!68 = !{!69}
!69 = distinct !{!69, !70, !"set_offset: %fat_ptr"}
!70 = distinct !{!70, !"set_offset"}
!71 = !{!72}
!72 = distinct !{!72, !73, !"set_offset: %fat_ptr"}
!73 = distinct !{!73, !"set_offset"}
!74 = !{!75}
!75 = distinct !{!75, !76, !"set_offset: %fat_ptr"}
!76 = distinct !{!76, !"set_offset"}
!77 = !{!78}
!78 = distinct !{!78, !79, !"set_offset: %fat_ptr"}
!79 = distinct !{!79, !"set_offset"}
!80 = !{!81}
!81 = distinct !{!81, !82, !"set_offset: %fat_ptr"}
!82 = distinct !{!82, !"set_offset"}
!83 = !{!84}
!84 = distinct !{!84, !85, !"set_offset: %fat_ptr"}
!85 = distinct !{!85, !"set_offset"}
!86 = !{!87}
!87 = distinct !{!87, !88, !"size_wrapper: argument 0"}
!88 = distinct !{!88, !"size_wrapper"}
!89 = !{!90}
!90 = distinct !{!90, !91, !"set_offset: %fat_ptr"}
!91 = distinct !{!91, !"set_offset"}
!92 = !{!93}
!93 = distinct !{!93, !94, !"size_wrapper: argument 0"}
!94 = distinct !{!94, !"size_wrapper"}
!95 = !{!96}
!96 = distinct !{!96, !97, !"set_offset: %fat_ptr"}
!97 = distinct !{!97, !"set_offset"}
!98 = !{!99}
!99 = distinct !{!99, !100, !"set_offset: %fat_ptr"}
!100 = distinct !{!100, !"set_offset"}
!101 = !{!102}
!102 = distinct !{!102, !103, !"set_offset: %fat_ptr"}
!103 = distinct !{!103, !"set_offset"}
!104 = !{!105}
!105 = distinct !{!105, !106, !"set_offset: %fat_ptr"}
!106 = distinct !{!106, !"set_offset"}
!107 = !{!108}
!108 = distinct !{!108, !109, !"set_offset: %fat_ptr"}
!109 = distinct !{!109, !"set_offset"}
!110 = !{!111}
!111 = distinct !{!111, !112, !"set_offset: %fat_ptr"}
!112 = distinct !{!112, !"set_offset"}
!113 = !{!114}
!114 = distinct !{!114, !115, !"set_offset: %fat_ptr"}
!115 = distinct !{!115, !"set_offset"}
!116 = !{!117}
!117 = distinct !{!117, !118, !"set_offset: %fat_ptr"}
!118 = distinct !{!118, !"set_offset"}
!119 = !{!120}
!120 = distinct !{!120, !121, !"set_offset: %fat_ptr"}
!121 = distinct !{!121, !"set_offset"}
!122 = !{!123}
!123 = distinct !{!123, !124, !"set_offset: %fat_ptr"}
!124 = distinct !{!124, !"set_offset"}
!125 = !{!126}
!126 = distinct !{!126, !127, !"size_wrapper: argument 0"}
!127 = distinct !{!127, !"size_wrapper"}
!128 = !{!129}
!129 = distinct !{!129, !130, !"set_offset: %fat_ptr"}
!130 = distinct !{!130, !"set_offset"}
!131 = !{!132}
!132 = distinct !{!132, !133, !"size_wrapper: argument 0"}
!133 = distinct !{!133, !"size_wrapper"}
!134 = !{!135}
!135 = distinct !{!135, !136, !"set_offset: %fat_ptr"}
!136 = distinct !{!136, !"set_offset"}
!137 = !{!138}
!138 = distinct !{!138, !139, !"set_offset: %fat_ptr"}
!139 = distinct !{!139, !"set_offset"}
!140 = !{!141}
!141 = distinct !{!141, !142, !"set_offset: %fat_ptr"}
!142 = distinct !{!142, !"set_offset"}
!143 = !{!144}
!144 = distinct !{!144, !145, !"set_offset: %fat_ptr"}
!145 = distinct !{!145, !"set_offset"}
!146 = !{!147}
!147 = distinct !{!147, !148, !"set_offset: %fat_ptr"}
!148 = distinct !{!148, !"set_offset"}
!149 = !{!150}
!150 = distinct !{!150, !151, !"set_offset: %fat_ptr"}
!151 = distinct !{!151, !"set_offset"}
!152 = !{!153}
!153 = distinct !{!153, !154, !"set_offset: %fat_ptr"}
!154 = distinct !{!154, !"set_offset"}
!155 = !{!156}
!156 = distinct !{!156, !157, !"set_offset: %fat_ptr"}
!157 = distinct !{!157, !"set_offset"}
!158 = !{!159}
!159 = distinct !{!159, !160, !"set_offset: %fat_ptr"}
!160 = distinct !{!160, !"set_offset"}
!161 = !{!162}
!162 = distinct !{!162, !163, !"set_offset: %fat_ptr"}
!163 = distinct !{!163, !"set_offset"}
!164 = !{!165}
!165 = distinct !{!165, !166, !"set_offset: %fat_ptr"}
!166 = distinct !{!166, !"set_offset"}
!167 = !{!168}
!168 = distinct !{!168, !169, !"set_offset: %fat_ptr"}
!169 = distinct !{!169, !"set_offset"}
!170 = !{!171}
!171 = distinct !{!171, !172, !"size_wrapper: argument 0"}
!172 = distinct !{!172, !"size_wrapper"}
!173 = !{!174}
!174 = distinct !{!174, !175, !"set_offset: %fat_ptr"}
!175 = distinct !{!175, !"set_offset"}
!176 = !{!177}
!177 = distinct !{!177, !178, !"size_wrapper: argument 0"}
!178 = distinct !{!178, !"size_wrapper"}
!179 = !{!180}
!180 = distinct !{!180, !181, !"set_offset: %fat_ptr"}
!181 = distinct !{!181, !"set_offset"}
!182 = !{!183}
!183 = distinct !{!183, !184, !"set_offset: %fat_ptr"}
!184 = distinct !{!184, !"set_offset"}
!185 = !{!186}
!186 = distinct !{!186, !187, !"set_offset: %fat_ptr"}
!187 = distinct !{!187, !"set_offset"}
!188 = !{!189}
!189 = distinct !{!189, !190, !"set_offset: %fat_ptr"}
!190 = distinct !{!190, !"set_offset"}
!191 = !{!192}
!192 = distinct !{!192, !193, !"set_offset: %fat_ptr"}
!193 = distinct !{!193, !"set_offset"}
!194 = !{!195}
!195 = distinct !{!195, !196, !"set_offset: %fat_ptr"}
!196 = distinct !{!196, !"set_offset"}
!197 = !{!198}
!198 = distinct !{!198, !199, !"set_offset: %fat_ptr"}
!199 = distinct !{!199, !"set_offset"}
!200 = !{!201}
!201 = distinct !{!201, !202, !"set_offset: %fat_ptr"}
!202 = distinct !{!202, !"set_offset"}
!203 = !{!204}
!204 = distinct !{!204, !205, !"size_wrapper: argument 0"}
!205 = distinct !{!205, !"size_wrapper"}
!206 = !{!207}
!207 = distinct !{!207, !208, !"set_offset: %fat_ptr"}
!208 = distinct !{!208, !"set_offset"}
!209 = !{!210}
!210 = distinct !{!210, !211, !"size_wrapper: argument 0"}
!211 = distinct !{!211, !"size_wrapper"}
!212 = !{!213}
!213 = distinct !{!213, !214, !"set_offset: %fat_ptr"}
!214 = distinct !{!214, !"set_offset"}
!215 = !{!216}
!216 = distinct !{!216, !217, !"set_offset: %fat_ptr"}
!217 = distinct !{!217, !"set_offset"}
!218 = !{!219}
!219 = distinct !{!219, !220, !"set_offset: %fat_ptr"}
!220 = distinct !{!220, !"set_offset"}
!221 = !{!222}
!222 = distinct !{!222, !223, !"set_offset: %fat_ptr"}
!223 = distinct !{!223, !"set_offset"}
!224 = !{!225}
!225 = distinct !{!225, !226, !"set_offset: %fat_ptr"}
!226 = distinct !{!226, !"set_offset"}
!227 = !{!228}
!228 = distinct !{!228, !229, !"set_offset: %fat_ptr"}
!229 = distinct !{!229, !"set_offset"}
!230 = !{!231}
!231 = distinct !{!231, !232, !"set_offset: %fat_ptr"}
!232 = distinct !{!232, !"set_offset"}
!233 = !{!234}
!234 = distinct !{!234, !235, !"set_offset: %fat_ptr"}
!235 = distinct !{!235, !"set_offset"}
!236 = !{!237}
!237 = distinct !{!237, !238, !"set_offset: %fat_ptr"}
!238 = distinct !{!238, !"set_offset"}
!239 = !{!240}
!240 = distinct !{!240, !241, !"set_offset: %fat_ptr"}
!241 = distinct !{!241, !"set_offset"}
!242 = !{!243}
!243 = distinct !{!243, !244, !"set_offset: %fat_ptr"}
!244 = distinct !{!244, !"set_offset"}
!245 = !{!246}
!246 = distinct !{!246, !247, !"set_offset: %fat_ptr"}
!247 = distinct !{!247, !"set_offset"}
!248 = !{!249}
!249 = distinct !{!249, !250, !"size_wrapper: argument 0"}
!250 = distinct !{!250, !"size_wrapper"}
!251 = !{!252}
!252 = distinct !{!252, !253, !"set_offset: %fat_ptr"}
!253 = distinct !{!253, !"set_offset"}
!254 = !{!255}
!255 = distinct !{!255, !256, !"size_wrapper: argument 0"}
!256 = distinct !{!256, !"size_wrapper"}
!257 = !{!258}
!258 = distinct !{!258, !259, !"set_offset: %fat_ptr"}
!259 = distinct !{!259, !"set_offset"}
!260 = !{!261}
!261 = distinct !{!261, !262, !"set_offset: %fat_ptr"}
!262 = distinct !{!262, !"set_offset"}
!263 = !{!264}
!264 = distinct !{!264, !265, !"set_offset: %fat_ptr"}
!265 = distinct !{!265, !"set_offset"}
!266 = !{!267}
!267 = distinct !{!267, !268, !"set_offset: %fat_ptr"}
!268 = distinct !{!268, !"set_offset"}
!269 = !{!270}
!270 = distinct !{!270, !271, !"set_offset: %fat_ptr"}
!271 = distinct !{!271, !"set_offset"}
!272 = !{!273}
!273 = distinct !{!273, !274, !"set_offset: %fat_ptr"}
!274 = distinct !{!274, !"set_offset"}
!275 = !{!276}
!276 = distinct !{!276, !277, !"set_offset: %fat_ptr"}
!277 = distinct !{!277, !"set_offset"}
!278 = !{!279}
!279 = distinct !{!279, !280, !"set_offset: %fat_ptr"}
!280 = distinct !{!280, !"set_offset"}
!281 = !{!282}
!282 = distinct !{!282, !283, !"size_wrapper: argument 0"}
!283 = distinct !{!283, !"size_wrapper"}
!284 = !{!285}
!285 = distinct !{!285, !286, !"set_offset: %fat_ptr"}
!286 = distinct !{!286, !"set_offset"}
!287 = !{!288}
!288 = distinct !{!288, !289, !"size_wrapper: argument 0"}
!289 = distinct !{!289, !"size_wrapper"}
!290 = !{!291}
!291 = distinct !{!291, !292, !"set_offset: %fat_ptr"}
!292 = distinct !{!292, !"set_offset"}
!293 = !{!294}
!294 = distinct !{!294, !295, !"set_offset: %fat_ptr"}
!295 = distinct !{!295, !"set_offset"}
!296 = !{!297}
!297 = distinct !{!297, !298, !"set_offset: %fat_ptr"}
!298 = distinct !{!298, !"set_offset"}
!299 = !{!300}
!300 = distinct !{!300, !301, !"set_offset: %fat_ptr"}
!301 = distinct !{!301, !"set_offset"}
!302 = !{!303}
!303 = distinct !{!303, !304, !"set_offset: %fat_ptr"}
!304 = distinct !{!304, !"set_offset"}
!305 = !{!306}
!306 = distinct !{!306, !307, !"set_offset: %fat_ptr"}
!307 = distinct !{!307, !"set_offset"}
!308 = !{!309}
!309 = distinct !{!309, !310, !"set_offset: %fat_ptr"}
!310 = distinct !{!310, !"set_offset"}
!311 = !{!312}
!312 = distinct !{!312, !313, !"set_offset: %fat_ptr"}
!313 = distinct !{!313, !"set_offset"}
!314 = !{!315}
!315 = distinct !{!315, !316, !"set_offset: %fat_ptr"}
!316 = distinct !{!316, !"set_offset"}
!317 = !{!318}
!318 = distinct !{!318, !319, !"set_offset: %fat_ptr"}
!319 = distinct !{!319, !"set_offset"}
!320 = !{!321}
!321 = distinct !{!321, !322, !"set_offset: %fat_ptr"}
!322 = distinct !{!322, !"set_offset"}
!323 = !{!324}
!324 = distinct !{!324, !325, !"set_offset: %fat_ptr"}
!325 = distinct !{!325, !"set_offset"}
!326 = !{!327}
!327 = distinct !{!327, !328, !"set_offset: %fat_ptr"}
!328 = distinct !{!328, !"set_offset"}
!329 = !{!330}
!330 = distinct !{!330, !331, !"set_offset: %fat_ptr"}
!331 = distinct !{!331, !"set_offset"}
!332 = !{!333}
!333 = distinct !{!333, !334, !"size_wrapper: argument 0"}
!334 = distinct !{!334, !"size_wrapper"}
!335 = !{!336}
!336 = distinct !{!336, !337, !"set_offset: %fat_ptr"}
!337 = distinct !{!337, !"set_offset"}
!338 = !{!339}
!339 = distinct !{!339, !340, !"size_wrapper: argument 0"}
!340 = distinct !{!340, !"size_wrapper"}
!341 = !{!342}
!342 = distinct !{!342, !343, !"set_offset: %fat_ptr"}
!343 = distinct !{!343, !"set_offset"}
!344 = !{!345}
!345 = distinct !{!345, !346, !"set_offset: %fat_ptr"}
!346 = distinct !{!346, !"set_offset"}
!347 = !{!348}
!348 = distinct !{!348, !349, !"set_offset: %fat_ptr"}
!349 = distinct !{!349, !"set_offset"}
!350 = !{!351}
!351 = distinct !{!351, !352, !"set_offset: %fat_ptr"}
!352 = distinct !{!352, !"set_offset"}
!353 = !{!354}
!354 = distinct !{!354, !355, !"set_offset: %fat_ptr"}
!355 = distinct !{!355, !"set_offset"}
!356 = !{!357}
!357 = distinct !{!357, !358, !"set_offset: %fat_ptr"}
!358 = distinct !{!358, !"set_offset"}
!359 = !{!360}
!360 = distinct !{!360, !361, !"set_offset: %fat_ptr"}
!361 = distinct !{!361, !"set_offset"}
!362 = !{!363}
!363 = distinct !{!363, !364, !"set_offset: %fat_ptr"}
!364 = distinct !{!364, !"set_offset"}
!365 = !{!366}
!366 = distinct !{!366, !367, !"size_wrapper: argument 0"}
!367 = distinct !{!367, !"size_wrapper"}
!368 = !{!369}
!369 = distinct !{!369, !370, !"set_offset: %fat_ptr"}
!370 = distinct !{!370, !"set_offset"}
!371 = !{!372}
!372 = distinct !{!372, !373, !"size_wrapper: argument 0"}
!373 = distinct !{!373, !"size_wrapper"}
!374 = !{!375}
!375 = distinct !{!375, !376, !"set_offset: %fat_ptr"}
!376 = distinct !{!376, !"set_offset"}
!377 = !{!378}
!378 = distinct !{!378, !379, !"set_offset: %fat_ptr"}
!379 = distinct !{!379, !"set_offset"}
!380 = !{!381}
!381 = distinct !{!381, !382, !"set_offset: %fat_ptr"}
!382 = distinct !{!382, !"set_offset"}
!383 = !{!384}
!384 = distinct !{!384, !385, !"set_offset: %fat_ptr"}
!385 = distinct !{!385, !"set_offset"}
!386 = !{!387}
!387 = distinct !{!387, !388, !"set_offset: %fat_ptr"}
!388 = distinct !{!388, !"set_offset"}
!389 = !{!390}
!390 = distinct !{!390, !391, !"set_offset: %fat_ptr"}
!391 = distinct !{!391, !"set_offset"}
!392 = !{!393}
!393 = distinct !{!393, !394, !"set_offset: %fat_ptr"}
!394 = distinct !{!394, !"set_offset"}
!395 = !{!396}
!396 = distinct !{!396, !397, !"set_offset: %fat_ptr"}
!397 = distinct !{!397, !"set_offset"}
!398 = !{!399}
!399 = distinct !{!399, !400, !"set_offset: %fat_ptr"}
!400 = distinct !{!400, !"set_offset"}
!401 = !{!402}
!402 = distinct !{!402, !403, !"set_offset: %fat_ptr"}
!403 = distinct !{!403, !"set_offset"}
!404 = !{!405}
!405 = distinct !{!405, !406, !"set_offset: %fat_ptr"}
!406 = distinct !{!406, !"set_offset"}
!407 = !{!408}
!408 = distinct !{!408, !409, !"set_offset: %fat_ptr"}
!409 = distinct !{!409, !"set_offset"}
!410 = !{!411}
!411 = distinct !{!411, !412, !"size_wrapper: argument 0"}
!412 = distinct !{!412, !"size_wrapper"}
!413 = !{!414}
!414 = distinct !{!414, !415, !"set_offset: %fat_ptr"}
!415 = distinct !{!415, !"set_offset"}
!416 = !{!417}
!417 = distinct !{!417, !418, !"size_wrapper: argument 0"}
!418 = distinct !{!418, !"size_wrapper"}
!419 = !{!420}
!420 = distinct !{!420, !421, !"set_offset: %fat_ptr"}
!421 = distinct !{!421, !"set_offset"}
!422 = !{!423}
!423 = distinct !{!423, !424, !"set_offset: %fat_ptr"}
!424 = distinct !{!424, !"set_offset"}
!425 = !{!426}
!426 = distinct !{!426, !427, !"set_offset: %fat_ptr"}
!427 = distinct !{!427, !"set_offset"}
!428 = !{!429}
!429 = distinct !{!429, !430, !"set_offset: %fat_ptr"}
!430 = distinct !{!430, !"set_offset"}
!431 = !{!432}
!432 = distinct !{!432, !433, !"set_offset: %fat_ptr"}
!433 = distinct !{!433, !"set_offset"}
!434 = !{!435}
!435 = distinct !{!435, !436, !"set_offset: %fat_ptr"}
!436 = distinct !{!436, !"set_offset"}
!437 = !{!438}
!438 = distinct !{!438, !439, !"set_offset: %fat_ptr"}
!439 = distinct !{!439, !"set_offset"}
!440 = !{!441}
!441 = distinct !{!441, !442, !"set_offset: %fat_ptr"}
!442 = distinct !{!442, !"set_offset"}
!443 = !{!444}
!444 = distinct !{!444, !445, !"set_offset: %fat_ptr"}
!445 = distinct !{!445, !"set_offset"}
!446 = !{!447}
!447 = distinct !{!447, !448, !"set_offset: %fat_ptr"}
!448 = distinct !{!448, !"set_offset"}
!449 = !{!450}
!450 = distinct !{!450, !451, !"size_wrapper: argument 0"}
!451 = distinct !{!451, !"size_wrapper"}
!452 = !{!453}
!453 = distinct !{!453, !454, !"set_offset: %fat_ptr"}
!454 = distinct !{!454, !"set_offset"}
!455 = !{!456}
!456 = distinct !{!456, !457, !"size_wrapper: argument 0"}
!457 = distinct !{!457, !"size_wrapper"}
!458 = !{!459}
!459 = distinct !{!459, !460, !"set_offset: %fat_ptr"}
!460 = distinct !{!460, !"set_offset"}
!461 = !{!462}
!462 = distinct !{!462, !463, !"set_offset: %fat_ptr"}
!463 = distinct !{!463, !"set_offset"}
!464 = !{!465}
!465 = distinct !{!465, !466, !"set_offset: %fat_ptr"}
!466 = distinct !{!466, !"set_offset"}
!467 = !{!468}
!468 = distinct !{!468, !469, !"set_offset: %fat_ptr"}
!469 = distinct !{!469, !"set_offset"}
!470 = !{!471}
!471 = distinct !{!471, !472, !"set_offset: %fat_ptr"}
!472 = distinct !{!472, !"set_offset"}
!473 = !{!474}
!474 = distinct !{!474, !475, !"set_offset: %fat_ptr"}
!475 = distinct !{!475, !"set_offset"}
!476 = !{!477}
!477 = distinct !{!477, !478, !"set_offset: %fat_ptr"}
!478 = distinct !{!478, !"set_offset"}
!479 = !{!480}
!480 = distinct !{!480, !481, !"set_offset: %fat_ptr"}
!481 = distinct !{!481, !"set_offset"}
!482 = !{!483}
!483 = distinct !{!483, !484, !"set_offset: %fat_ptr"}
!484 = distinct !{!484, !"set_offset"}
!485 = !{!486}
!486 = distinct !{!486, !487, !"set_offset: %fat_ptr"}
!487 = distinct !{!487, !"set_offset"}
!488 = !{!489}
!489 = distinct !{!489, !490, !"set_offset: %fat_ptr"}
!490 = distinct !{!490, !"set_offset"}
!491 = !{!492}
!492 = distinct !{!492, !493, !"set_offset: %fat_ptr"}
!493 = distinct !{!493, !"set_offset"}
!494 = !{!495}
!495 = distinct !{!495, !496, !"set_offset: %fat_ptr"}
!496 = distinct !{!496, !"set_offset"}
!497 = !{!498}
!498 = distinct !{!498, !499, !"set_offset: %fat_ptr"}
!499 = distinct !{!499, !"set_offset"}
!500 = !{!501}
!501 = distinct !{!501, !502, !"set_offset: %fat_ptr"}
!502 = distinct !{!502, !"set_offset"}
!503 = !{!504}
!504 = distinct !{!504, !505, !"set_offset: %fat_ptr"}
!505 = distinct !{!505, !"set_offset"}
!506 = !{!507}
!507 = distinct !{!507, !508, !"set_offset: %fat_ptr"}
!508 = distinct !{!508, !"set_offset"}
!509 = !{!510}
!510 = distinct !{!510, !511, !"set_offset: %fat_ptr"}
!511 = distinct !{!511, !"set_offset"}
!512 = !{!513}
!513 = distinct !{!513, !514, !"set_offset: %fat_ptr"}
!514 = distinct !{!514, !"set_offset"}
!515 = !{!516}
!516 = distinct !{!516, !517, !"set_offset: %fat_ptr"}
!517 = distinct !{!517, !"set_offset"}
!518 = !{!519}
!519 = distinct !{!519, !520, !"set_offset: %fat_ptr"}
!520 = distinct !{!520, !"set_offset"}
!521 = !{!522}
!522 = distinct !{!522, !523, !"set_offset: %fat_ptr"}
!523 = distinct !{!523, !"set_offset"}
!524 = !{!525}
!525 = distinct !{!525, !526, !"set_offset: %fat_ptr"}
!526 = distinct !{!526, !"set_offset"}
!527 = !{!528}
!528 = distinct !{!528, !529, !"set_offset: %fat_ptr"}
!529 = distinct !{!529, !"set_offset"}
!530 = !{!531}
!531 = distinct !{!531, !532, !"set_offset: %fat_ptr"}
!532 = distinct !{!532, !"set_offset"}
!533 = !{!534}
!534 = distinct !{!534, !535, !"set_offset: %fat_ptr"}
!535 = distinct !{!535, !"set_offset"}
!536 = !{!537}
!537 = distinct !{!537, !538, !"set_offset: %fat_ptr"}
!538 = distinct !{!538, !"set_offset"}
!539 = !{!540}
!540 = distinct !{!540, !541, !"set_offset: %fat_ptr"}
!541 = distinct !{!541, !"set_offset"}
!542 = !{}
!543 = !{!544}
!544 = distinct !{!544, !545, !"set_offset: %fat_ptr"}
!545 = distinct !{!545, !"set_offset"}
!546 = !{!547}
!547 = distinct !{!547, !548, !"set_offset: %fat_ptr"}
!548 = distinct !{!548, !"set_offset"}
!549 = !{!550}
!550 = distinct !{!550, !551, !"set_offset: %fat_ptr"}
!551 = distinct !{!551, !"set_offset"}
!552 = !{!553}
!553 = distinct !{!553, !554, !"set_offset: %fat_ptr"}
!554 = distinct !{!554, !"set_offset"}
!555 = !{!556}
!556 = distinct !{!556, !557, !"set_offset: %fat_ptr"}
!557 = distinct !{!557, !"set_offset"}
!558 = !{!559}
!559 = distinct !{!559, !560, !"set_offset: %fat_ptr"}
!560 = distinct !{!560, !"set_offset"}
!561 = !{!562}
!562 = distinct !{!562, !563, !"set_offset: %fat_ptr"}
!563 = distinct !{!563, !"set_offset"}
!564 = !{!565}
!565 = distinct !{!565, !566, !"set_offset: %fat_ptr"}
!566 = distinct !{!566, !"set_offset"}
!567 = !{!568}
!568 = distinct !{!568, !569, !"set_offset: %fat_ptr"}
!569 = distinct !{!569, !"set_offset"}
!570 = !{!571}
!571 = distinct !{!571, !572, !"set_offset: %fat_ptr"}
!572 = distinct !{!572, !"set_offset"}
!573 = !{!574}
!574 = distinct !{!574, !575, !"set_offset: %fat_ptr"}
!575 = distinct !{!575, !"set_offset"}
!576 = !{!577}
!577 = distinct !{!577, !578, !"set_offset: %fat_ptr"}
!578 = distinct !{!578, !"set_offset"}
!579 = !{!580}
!580 = distinct !{!580, !581, !"set_offset: %fat_ptr"}
!581 = distinct !{!581, !"set_offset"}
!582 = !{!583}
!583 = distinct !{!583, !584, !"set_offset: %fat_ptr"}
!584 = distinct !{!584, !"set_offset"}
!585 = !{!586}
!586 = distinct !{!586, !587, !"set_offset: %fat_ptr"}
!587 = distinct !{!587, !"set_offset"}
!588 = !{!589}
!589 = distinct !{!589, !590, !"set_offset: %fat_ptr"}
!590 = distinct !{!590, !"set_offset"}
!591 = !{!592}
!592 = distinct !{!592, !593, !"set_offset: %fat_ptr"}
!593 = distinct !{!593, !"set_offset"}
!594 = !{!595}
!595 = distinct !{!595, !596, !"set_offset: %fat_ptr"}
!596 = distinct !{!596, !"set_offset"}
!597 = !{!598}
!598 = distinct !{!598, !599, !"set_offset: %fat_ptr"}
!599 = distinct !{!599, !"set_offset"}
!600 = !{!601}
!601 = distinct !{!601, !602, !"set_offset: %fat_ptr"}
!602 = distinct !{!602, !"set_offset"}
!603 = !{!604}
!604 = distinct !{!604, !605, !"set_offset: %fat_ptr"}
!605 = distinct !{!605, !"set_offset"}
!606 = !{!607}
!607 = distinct !{!607, !608, !"set_offset: %fat_ptr"}
!608 = distinct !{!608, !"set_offset"}
!609 = !{!610}
!610 = distinct !{!610, !611, !"set_offset: %fat_ptr"}
!611 = distinct !{!611, !"set_offset"}
!612 = !{!613}
!613 = distinct !{!613, !614, !"set_offset: %fat_ptr"}
!614 = distinct !{!614, !"set_offset"}
!615 = !{!616}
!616 = distinct !{!616, !617, !"set_offset: %fat_ptr"}
!617 = distinct !{!617, !"set_offset"}
!618 = !{!619}
!619 = distinct !{!619, !620, !"set_offset: %fat_ptr"}
!620 = distinct !{!620, !"set_offset"}
!621 = !{!622}
!622 = distinct !{!622, !623, !"set_offset: %fat_ptr"}
!623 = distinct !{!623, !"set_offset"}
!624 = !{!625}
!625 = distinct !{!625, !626, !"set_offset: %fat_ptr"}
!626 = distinct !{!626, !"set_offset"}
!627 = !{!628}
!628 = distinct !{!628, !629, !"set_offset: %fat_ptr"}
!629 = distinct !{!629, !"set_offset"}
!630 = !{!631}
!631 = distinct !{!631, !632, !"set_offset: %fat_ptr"}
!632 = distinct !{!632, !"set_offset"}
!633 = !{!634}
!634 = distinct !{!634, !635, !"set_offset: %fat_ptr"}
!635 = distinct !{!635, !"set_offset"}
!636 = !{!637}
!637 = distinct !{!637, !638, !"set_offset: %fat_ptr"}
!638 = distinct !{!638, !"set_offset"}
!639 = !{!640}
!640 = distinct !{!640, !641, !"set_offset: %fat_ptr"}
!641 = distinct !{!641, !"set_offset"}
!642 = !{!643}
!643 = distinct !{!643, !644, !"set_offset: %fat_ptr"}
!644 = distinct !{!644, !"set_offset"}
!645 = !{!646}
!646 = distinct !{!646, !647, !"set_offset: %fat_ptr"}
!647 = distinct !{!647, !"set_offset"}
!648 = !{!649}
!649 = distinct !{!649, !650, !"set_offset: %fat_ptr"}
!650 = distinct !{!650, !"set_offset"}
!651 = !{!652}
!652 = distinct !{!652, !653, !"set_offset: %fat_ptr"}
!653 = distinct !{!653, !"set_offset"}
!654 = !{!655}
!655 = distinct !{!655, !656, !"set_offset: %fat_ptr"}
!656 = distinct !{!656, !"set_offset"}
!657 = !{!658}
!658 = distinct !{!658, !659, !"set_offset: %fat_ptr"}
!659 = distinct !{!659, !"set_offset"}
!660 = !{!661}
!661 = distinct !{!661, !662, !"set_offset: %fat_ptr"}
!662 = distinct !{!662, !"set_offset"}
!663 = !{!664}
!664 = distinct !{!664, !665, !"set_offset: %fat_ptr"}
!665 = distinct !{!665, !"set_offset"}
!666 = !{!667}
!667 = distinct !{!667, !668, !"set_offset: %fat_ptr"}
!668 = distinct !{!668, !"set_offset"}
!669 = !{!670}
!670 = distinct !{!670, !671, !"set_offset: %fat_ptr"}
!671 = distinct !{!671, !"set_offset"}
!672 = !{!673}
!673 = distinct !{!673, !674, !"set_offset: %fat_ptr"}
!674 = distinct !{!674, !"set_offset"}
!675 = !{!676}
!676 = distinct !{!676, !677, !"set_offset: %fat_ptr"}
!677 = distinct !{!677, !"set_offset"}
!678 = !{!679}
!679 = distinct !{!679, !680, !"set_offset: %fat_ptr"}
!680 = distinct !{!680, !"set_offset"}
!681 = !{!682}
!682 = distinct !{!682, !683, !"set_offset: %fat_ptr"}
!683 = distinct !{!683, !"set_offset"}
!684 = !{!685}
!685 = distinct !{!685, !686, !"set_offset: %fat_ptr"}
!686 = distinct !{!686, !"set_offset"}
!687 = !{!688}
!688 = distinct !{!688, !689, !"set_offset: %fat_ptr"}
!689 = distinct !{!689, !"set_offset"}
!690 = !{!691}
!691 = distinct !{!691, !692, !"set_offset: %fat_ptr"}
!692 = distinct !{!692, !"set_offset"}
!693 = !{!694}
!694 = distinct !{!694, !695, !"set_offset: %fat_ptr"}
!695 = distinct !{!695, !"set_offset"}
!696 = !{!697}
!697 = distinct !{!697, !698, !"set_offset: %fat_ptr"}
!698 = distinct !{!698, !"set_offset"}
!699 = !{!700}
!700 = distinct !{!700, !701, !"set_offset: %fat_ptr"}
!701 = distinct !{!701, !"set_offset"}
!702 = !{!703}
!703 = distinct !{!703, !704, !"set_offset: %fat_ptr"}
!704 = distinct !{!704, !"set_offset"}
!705 = !{!706}
!706 = distinct !{!706, !707, !"set_offset: %fat_ptr"}
!707 = distinct !{!707, !"set_offset"}
!708 = !{!709}
!709 = distinct !{!709, !710, !"set_offset: %fat_ptr"}
!710 = distinct !{!710, !"set_offset"}
!711 = !{!712}
!712 = distinct !{!712, !713, !"size_wrapper: argument 0"}
!713 = distinct !{!713, !"size_wrapper"}
!714 = !{!715}
!715 = distinct !{!715, !716, !"set_offset: %fat_ptr"}
!716 = distinct !{!716, !"set_offset"}
!717 = !{!718}
!718 = distinct !{!718, !719, !"set_offset: %fat_ptr"}
!719 = distinct !{!719, !"set_offset"}
!720 = !{!721}
!721 = distinct !{!721, !722, !"set_offset: %fat_ptr"}
!722 = distinct !{!722, !"set_offset"}
!723 = !{!724}
!724 = distinct !{!724, !725, !"set_offset: %fat_ptr"}
!725 = distinct !{!725, !"set_offset"}
!726 = !{!727}
!727 = distinct !{!727, !728, !"set_offset: %fat_ptr"}
!728 = distinct !{!728, !"set_offset"}
!729 = !{!730}
!730 = distinct !{!730, !731, !"set_offset: %fat_ptr"}
!731 = distinct !{!731, !"set_offset"}
!732 = !{!733}
!733 = distinct !{!733, !734, !"set_offset: %fat_ptr"}
!734 = distinct !{!734, !"set_offset"}
!735 = !{!736}
!736 = distinct !{!736, !737, !"set_offset: %fat_ptr"}
!737 = distinct !{!737, !"set_offset"}
!738 = !{!739}
!739 = distinct !{!739, !740, !"set_offset: %fat_ptr"}
!740 = distinct !{!740, !"set_offset"}
!741 = !{!742}
!742 = distinct !{!742, !743, !"set_offset: %fat_ptr"}
!743 = distinct !{!743, !"set_offset"}
!744 = !{!745}
!745 = distinct !{!745, !746, !"size_wrapper: argument 0"}
!746 = distinct !{!746, !"size_wrapper"}
!747 = !{!748}
!748 = distinct !{!748, !749, !"set_offset: %fat_ptr"}
!749 = distinct !{!749, !"set_offset"}
!750 = !{!751}
!751 = distinct !{!751, !752, !"set_offset: %fat_ptr"}
!752 = distinct !{!752, !"set_offset"}
!753 = !{!754}
!754 = distinct !{!754, !755, !"set_offset: %fat_ptr"}
!755 = distinct !{!755, !"set_offset"}
!756 = !{!757}
!757 = distinct !{!757, !758, !"set_offset: %fat_ptr"}
!758 = distinct !{!758, !"set_offset"}
!759 = !{!760}
!760 = distinct !{!760, !761, !"set_offset: %fat_ptr"}
!761 = distinct !{!761, !"set_offset"}
!762 = !{!763}
!763 = distinct !{!763, !764, !"set_offset: %fat_ptr"}
!764 = distinct !{!764, !"set_offset"}
!765 = !{!766}
!766 = distinct !{!766, !767, !"set_offset: %fat_ptr"}
!767 = distinct !{!767, !"set_offset"}
!768 = !{!769}
!769 = distinct !{!769, !770, !"set_offset: %fat_ptr"}
!770 = distinct !{!770, !"set_offset"}
!771 = !{!772}
!772 = distinct !{!772, !773, !"set_offset: %fat_ptr"}
!773 = distinct !{!773, !"set_offset"}
!774 = !{!775}
!775 = distinct !{!775, !776, !"set_offset: %fat_ptr"}
!776 = distinct !{!776, !"set_offset"}
!777 = !{!778}
!778 = distinct !{!778, !779, !"set_offset: %fat_ptr"}
!779 = distinct !{!779, !"set_offset"}
!780 = !{!781}
!781 = distinct !{!781, !782, !"set_offset: %fat_ptr"}
!782 = distinct !{!782, !"set_offset"}
!783 = !{!784}
!784 = distinct !{!784, !785, !"set_offset: %fat_ptr"}
!785 = distinct !{!785, !"set_offset"}
!786 = !{!787}
!787 = distinct !{!787, !788, !"set_offset: %fat_ptr"}
!788 = distinct !{!788, !"set_offset"}
!789 = !{!790}
!790 = distinct !{!790, !791, !"set_offset: %fat_ptr"}
!791 = distinct !{!791, !"set_offset"}
!792 = !{!793}
!793 = distinct !{!793, !794, !"set_offset: %fat_ptr"}
!794 = distinct !{!794, !"set_offset"}
!795 = !{!796}
!796 = distinct !{!796, !797, !"set_offset: %fat_ptr"}
!797 = distinct !{!797, !"set_offset"}
!798 = !{!799}
!799 = distinct !{!799, !800, !"set_offset: %fat_ptr"}
!800 = distinct !{!800, !"set_offset"}
!801 = !{!802}
!802 = distinct !{!802, !803, !"set_offset: %fat_ptr"}
!803 = distinct !{!803, !"set_offset"}
!804 = !{!805}
!805 = distinct !{!805, !806, !"set_offset: %fat_ptr"}
!806 = distinct !{!806, !"set_offset"}
!807 = !{!808}
!808 = distinct !{!808, !809, !"set_offset: %fat_ptr"}
!809 = distinct !{!809, !"set_offset"}
!810 = !{!811}
!811 = distinct !{!811, !812, !"set_offset: %fat_ptr"}
!812 = distinct !{!812, !"set_offset"}
!813 = !{!814}
!814 = distinct !{!814, !815, !"set_offset: %fat_ptr"}
!815 = distinct !{!815, !"set_offset"}
!816 = !{!817}
!817 = distinct !{!817, !818, !"set_offset: %fat_ptr"}
!818 = distinct !{!818, !"set_offset"}
!819 = !{!820}
!820 = distinct !{!820, !821, !"set_offset: %fat_ptr"}
!821 = distinct !{!821, !"set_offset"}
!822 = !{!823}
!823 = distinct !{!823, !824, !"set_offset: %fat_ptr"}
!824 = distinct !{!824, !"set_offset"}
!825 = !{!826}
!826 = distinct !{!826, !827, !"set_offset: %fat_ptr"}
!827 = distinct !{!827, !"set_offset"}
!828 = !{!829}
!829 = distinct !{!829, !830, !"set_offset: %fat_ptr"}
!830 = distinct !{!830, !"set_offset"}
!831 = !{!832}
!832 = distinct !{!832, !833, !"set_offset: %fat_ptr"}
!833 = distinct !{!833, !"set_offset"}
!834 = !{!835}
!835 = distinct !{!835, !836, !"set_offset: %fat_ptr"}
!836 = distinct !{!836, !"set_offset"}
!837 = !{!838}
!838 = distinct !{!838, !839, !"set_offset: %fat_ptr"}
!839 = distinct !{!839, !"set_offset"}
!840 = !{!841}
!841 = distinct !{!841, !842, !"set_offset: %fat_ptr"}
!842 = distinct !{!842, !"set_offset"}
!843 = !{!844}
!844 = distinct !{!844, !845, !"set_offset: %fat_ptr"}
!845 = distinct !{!845, !"set_offset"}
!846 = !{!847}
!847 = distinct !{!847, !848, !"set_offset: %fat_ptr"}
!848 = distinct !{!848, !"set_offset"}
!849 = !{!850}
!850 = distinct !{!850, !851, !"set_offset: %fat_ptr"}
!851 = distinct !{!851, !"set_offset"}
!852 = !{!853}
!853 = distinct !{!853, !854, !"set_offset: %fat_ptr"}
!854 = distinct !{!854, !"set_offset"}
!855 = !{!856}
!856 = distinct !{!856, !857, !"set_offset: %fat_ptr"}
!857 = distinct !{!857, !"set_offset"}
!858 = !{!859}
!859 = distinct !{!859, !860, !"set_offset: %fat_ptr"}
!860 = distinct !{!860, !"set_offset"}
!861 = !{!862}
!862 = distinct !{!862, !863, !"set_offset: %fat_ptr"}
!863 = distinct !{!863, !"set_offset"}
!864 = !{!865}
!865 = distinct !{!865, !866, !"set_offset: %fat_ptr"}
!866 = distinct !{!866, !"set_offset"}
!867 = !{!868}
!868 = distinct !{!868, !869, !"set_offset: %fat_ptr"}
!869 = distinct !{!869, !"set_offset"}
!870 = !{!871}
!871 = distinct !{!871, !872, !"set_offset: %fat_ptr"}
!872 = distinct !{!872, !"set_offset"}
!873 = !{!874}
!874 = distinct !{!874, !875, !"set_offset: %fat_ptr"}
!875 = distinct !{!875, !"set_offset"}
!876 = !{!877}
!877 = distinct !{!877, !878, !"set_offset: %fat_ptr"}
!878 = distinct !{!878, !"set_offset"}
!879 = !{!880}
!880 = distinct !{!880, !881, !"set_offset: %fat_ptr"}
!881 = distinct !{!881, !"set_offset"}
!882 = !{!883}
!883 = distinct !{!883, !884, !"set_offset: %fat_ptr"}
!884 = distinct !{!884, !"set_offset"}
!885 = !{!886}
!886 = distinct !{!886, !887, !"set_offset: %fat_ptr"}
!887 = distinct !{!887, !"set_offset"}
!888 = !{!889}
!889 = distinct !{!889, !890, !"set_offset: %fat_ptr"}
!890 = distinct !{!890, !"set_offset"}
!891 = !{!892}
!892 = distinct !{!892, !893, !"set_offset: %fat_ptr"}
!893 = distinct !{!893, !"set_offset"}
!894 = !{!895}
!895 = distinct !{!895, !896, !"set_offset: %fat_ptr"}
!896 = distinct !{!896, !"set_offset"}
!897 = !{!898}
!898 = distinct !{!898, !899, !"set_offset: %fat_ptr"}
!899 = distinct !{!899, !"set_offset"}
!900 = !{!901}
!901 = distinct !{!901, !902, !"set_offset: %fat_ptr"}
!902 = distinct !{!902, !"set_offset"}
!903 = !{!904}
!904 = distinct !{!904, !905, !"set_offset: %fat_ptr"}
!905 = distinct !{!905, !"set_offset"}
!906 = !{!907}
!907 = distinct !{!907, !908, !"set_offset: %fat_ptr"}
!908 = distinct !{!908, !"set_offset"}
!909 = !{!910}
!910 = distinct !{!910, !911, !"set_offset: %fat_ptr"}
!911 = distinct !{!911, !"set_offset"}
!912 = !{!913}
!913 = distinct !{!913, !914, !"set_offset: %fat_ptr"}
!914 = distinct !{!914, !"set_offset"}
!915 = !{!916}
!916 = distinct !{!916, !917, !"set_offset: %fat_ptr"}
!917 = distinct !{!917, !"set_offset"}
!918 = !{!919}
!919 = distinct !{!919, !920, !"set_offset: %fat_ptr"}
!920 = distinct !{!920, !"set_offset"}
!921 = !{!922}
!922 = distinct !{!922, !923, !"set_offset: %fat_ptr"}
!923 = distinct !{!923, !"set_offset"}
!924 = !{!925}
!925 = distinct !{!925, !926, !"set_offset: %fat_ptr"}
!926 = distinct !{!926, !"set_offset"}
!927 = !{!928}
!928 = distinct !{!928, !929, !"set_offset: %fat_ptr"}
!929 = distinct !{!929, !"set_offset"}
!930 = !{!931}
!931 = distinct !{!931, !932, !"set_offset: %fat_ptr"}
!932 = distinct !{!932, !"set_offset"}
!933 = !{!934}
!934 = distinct !{!934, !935, !"set_offset: %fat_ptr"}
!935 = distinct !{!935, !"set_offset"}
!936 = !{!937}
!937 = distinct !{!937, !938, !"set_offset: %fat_ptr"}
!938 = distinct !{!938, !"set_offset"}
!939 = !{!940}
!940 = distinct !{!940, !941, !"set_offset: %fat_ptr"}
!941 = distinct !{!941, !"set_offset"}
!942 = !{!943}
!943 = distinct !{!943, !944, !"set_offset: %fat_ptr"}
!944 = distinct !{!944, !"set_offset"}
!945 = !{!946}
!946 = distinct !{!946, !947, !"set_offset: %fat_ptr"}
!947 = distinct !{!947, !"set_offset"}
!948 = !{!949}
!949 = distinct !{!949, !950, !"set_offset: %fat_ptr"}
!950 = distinct !{!950, !"set_offset"}
!951 = !{!952}
!952 = distinct !{!952, !953, !"set_offset: %fat_ptr"}
!953 = distinct !{!953, !"set_offset"}
!954 = !{!955}
!955 = distinct !{!955, !956, !"set_offset: %fat_ptr"}
!956 = distinct !{!956, !"set_offset"}
!957 = !{!958}
!958 = distinct !{!958, !959, !"set_offset: %fat_ptr"}
!959 = distinct !{!959, !"set_offset"}
!960 = !{!961}
!961 = distinct !{!961, !962, !"set_offset: %fat_ptr"}
!962 = distinct !{!962, !"set_offset"}
!963 = !{!964}
!964 = distinct !{!964, !965, !"set_offset: %fat_ptr"}
!965 = distinct !{!965, !"set_offset"}
!966 = !{!967}
!967 = distinct !{!967, !968, !"set_offset: %fat_ptr"}
!968 = distinct !{!968, !"set_offset"}
!969 = !{!970}
!970 = distinct !{!970, !971, !"set_offset: %fat_ptr"}
!971 = distinct !{!971, !"set_offset"}
!972 = !{!973}
!973 = distinct !{!973, !974, !"set_offset: %fat_ptr"}
!974 = distinct !{!974, !"set_offset"}
!975 = !{!976}
!976 = distinct !{!976, !977, !"set_offset: %fat_ptr"}
!977 = distinct !{!977, !"set_offset"}
!978 = !{!979}
!979 = distinct !{!979, !980, !"set_offset: %fat_ptr"}
!980 = distinct !{!980, !"set_offset"}
!981 = !{!982}
!982 = distinct !{!982, !983, !"set_offset: %fat_ptr"}
!983 = distinct !{!983, !"set_offset"}
!984 = !{!985}
!985 = distinct !{!985, !986, !"set_offset: %fat_ptr"}
!986 = distinct !{!986, !"set_offset"}
!987 = !{!988}
!988 = distinct !{!988, !989, !"set_offset: %fat_ptr"}
!989 = distinct !{!989, !"set_offset"}
!990 = !{!991}
!991 = distinct !{!991, !992, !"set_offset: %fat_ptr"}
!992 = distinct !{!992, !"set_offset"}
!993 = !{!994}
!994 = distinct !{!994, !995, !"set_offset: %fat_ptr"}
!995 = distinct !{!995, !"set_offset"}
!996 = !{!997}
!997 = distinct !{!997, !998, !"set_offset: %fat_ptr"}
!998 = distinct !{!998, !"set_offset"}
!999 = !{!1000}
!1000 = distinct !{!1000, !1001, !"set_offset: %fat_ptr"}
!1001 = distinct !{!1001, !"set_offset"}
!1002 = !{!1003}
!1003 = distinct !{!1003, !1004, !"set_offset: %fat_ptr"}
!1004 = distinct !{!1004, !"set_offset"}
!1005 = !{!1006}
!1006 = distinct !{!1006, !1007, !"set_offset: %fat_ptr"}
!1007 = distinct !{!1007, !"set_offset"}
!1008 = !{!1009}
!1009 = distinct !{!1009, !1010, !"set_offset: %fat_ptr"}
!1010 = distinct !{!1010, !"set_offset"}
!1011 = !{!1012}
!1012 = distinct !{!1012, !1013, !"set_offset: %fat_ptr"}
!1013 = distinct !{!1013, !"set_offset"}
!1014 = !{!1015}
!1015 = distinct !{!1015, !1016, !"set_offset: %fat_ptr"}
!1016 = distinct !{!1016, !"set_offset"}
!1017 = !{!1018}
!1018 = distinct !{!1018, !1019, !"set_offset: %fat_ptr"}
!1019 = distinct !{!1019, !"set_offset"}
!1020 = !{!1021}
!1021 = distinct !{!1021, !1022, !"set_offset: %fat_ptr"}
!1022 = distinct !{!1022, !"set_offset"}
!1023 = !{!1024}
!1024 = distinct !{!1024, !1025, !"set_offset: %fat_ptr"}
!1025 = distinct !{!1025, !"set_offset"}
!1026 = !{!1027}
!1027 = distinct !{!1027, !1028, !"set_offset: %fat_ptr"}
!1028 = distinct !{!1028, !"set_offset"}
!1029 = !{!1030}
!1030 = distinct !{!1030, !1031, !"set_offset: %fat_ptr"}
!1031 = distinct !{!1031, !"set_offset"}
!1032 = !{!1033}
!1033 = distinct !{!1033, !1034, !"set_offset: %fat_ptr"}
!1034 = distinct !{!1034, !"set_offset"}
!1035 = !{!1036}
!1036 = distinct !{!1036, !1037, !"set_offset: %fat_ptr"}
!1037 = distinct !{!1037, !"set_offset"}
!1038 = !{!1039}
!1039 = distinct !{!1039, !1040, !"set_offset: %fat_ptr"}
!1040 = distinct !{!1040, !"set_offset"}
!1041 = !{!1042}
!1042 = distinct !{!1042, !1043, !"set_offset: %fat_ptr"}
!1043 = distinct !{!1043, !"set_offset"}
!1044 = !{!1045}
!1045 = distinct !{!1045, !1046, !"set_offset: %fat_ptr"}
!1046 = distinct !{!1046, !"set_offset"}
!1047 = !{!1048}
!1048 = distinct !{!1048, !1049, !"set_offset: %fat_ptr"}
!1049 = distinct !{!1049, !"set_offset"}
!1050 = !{!1051}
!1051 = distinct !{!1051, !1052, !"set_offset: %fat_ptr"}
!1052 = distinct !{!1052, !"set_offset"}
!1053 = !{!1054}
!1054 = distinct !{!1054, !1055, !"set_offset: %fat_ptr"}
!1055 = distinct !{!1055, !"set_offset"}
!1056 = !{!1057}
!1057 = distinct !{!1057, !1058, !"set_offset: %fat_ptr"}
!1058 = distinct !{!1058, !"set_offset"}
!1059 = !{!1060}
!1060 = distinct !{!1060, !1061, !"set_offset: %fat_ptr"}
!1061 = distinct !{!1061, !"set_offset"}
!1062 = !{!1063}
!1063 = distinct !{!1063, !1064, !"set_offset: %fat_ptr"}
!1064 = distinct !{!1064, !"set_offset"}
!1065 = !{!1066}
!1066 = distinct !{!1066, !1067, !"size_wrapper: argument 0"}
!1067 = distinct !{!1067, !"size_wrapper"}
!1068 = !{!1069}
!1069 = distinct !{!1069, !1070, !"set_offset: %fat_ptr"}
!1070 = distinct !{!1070, !"set_offset"}
!1071 = !{!1072}
!1072 = distinct !{!1072, !1073, !"set_offset: %fat_ptr"}
!1073 = distinct !{!1073, !"set_offset"}
!1074 = !{!1075}
!1075 = distinct !{!1075, !1076, !"set_offset: %fat_ptr"}
!1076 = distinct !{!1076, !"set_offset"}
!1077 = !{!1078}
!1078 = distinct !{!1078, !1079, !"set_offset: %fat_ptr"}
!1079 = distinct !{!1079, !"set_offset"}
!1080 = !{!1081}
!1081 = distinct !{!1081, !1082, !"set_offset: %fat_ptr"}
!1082 = distinct !{!1082, !"set_offset"}
!1083 = !{!1084}
!1084 = distinct !{!1084, !1085, !"set_offset: %fat_ptr"}
!1085 = distinct !{!1085, !"set_offset"}
!1086 = !{!1087}
!1087 = distinct !{!1087, !1088, !"set_offset: %fat_ptr"}
!1088 = distinct !{!1088, !"set_offset"}
!1089 = !{!1090}
!1090 = distinct !{!1090, !1091, !"set_offset: %fat_ptr"}
!1091 = distinct !{!1091, !"set_offset"}
!1092 = !{!1093}
!1093 = distinct !{!1093, !1094, !"set_offset: %fat_ptr"}
!1094 = distinct !{!1094, !"set_offset"}
!1095 = !{!1096}
!1096 = distinct !{!1096, !1097, !"set_offset: %fat_ptr"}
!1097 = distinct !{!1097, !"set_offset"}
!1098 = !{!1099}
!1099 = distinct !{!1099, !1100, !"set_offset: %fat_ptr"}
!1100 = distinct !{!1100, !"set_offset"}
!1101 = !{!1102}
!1102 = distinct !{!1102, !1103, !"set_offset: %fat_ptr"}
!1103 = distinct !{!1103, !"set_offset"}
!1104 = !{!1105}
!1105 = distinct !{!1105, !1106, !"set_offset: %fat_ptr"}
!1106 = distinct !{!1106, !"set_offset"}
!1107 = !{!1108}
!1108 = distinct !{!1108, !1109, !"set_offset: %fat_ptr"}
!1109 = distinct !{!1109, !"set_offset"}
!1110 = !{!1111}
!1111 = distinct !{!1111, !1112, !"set_offset: %fat_ptr"}
!1112 = distinct !{!1112, !"set_offset"}
!1113 = !{!1114}
!1114 = distinct !{!1114, !1115, !"set_offset: %fat_ptr"}
!1115 = distinct !{!1115, !"set_offset"}
!1116 = !{!1117}
!1117 = distinct !{!1117, !1118, !"set_offset: %fat_ptr"}
!1118 = distinct !{!1118, !"set_offset"}
!1119 = !{!1120}
!1120 = distinct !{!1120, !1121, !"set_offset: %fat_ptr"}
!1121 = distinct !{!1121, !"set_offset"}
!1122 = !{!1123}
!1123 = distinct !{!1123, !1124, !"set_offset: %fat_ptr"}
!1124 = distinct !{!1124, !"set_offset"}
!1125 = !{!1126}
!1126 = distinct !{!1126, !1127, !"set_offset: %fat_ptr"}
!1127 = distinct !{!1127, !"set_offset"}
!1128 = !{!1129}
!1129 = distinct !{!1129, !1130, !"set_offset: %fat_ptr"}
!1130 = distinct !{!1130, !"set_offset"}
!1131 = !{!1132}
!1132 = distinct !{!1132, !1133, !"set_offset: %fat_ptr"}
!1133 = distinct !{!1133, !"set_offset"}
!1134 = !{!1135}
!1135 = distinct !{!1135, !1136, !"size_wrapper: argument 0"}
!1136 = distinct !{!1136, !"size_wrapper"}
!1137 = !{!1138}
!1138 = distinct !{!1138, !1139, !"set_offset: %fat_ptr"}
!1139 = distinct !{!1139, !"set_offset"}
