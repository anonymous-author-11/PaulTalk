; ModuleID = 'C:\Users\PaulK\OneDrive\Documents\PL\PyPL\build\build\out_linked.ll'
source_filename = "llvm-link"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "aarch64-windows-msvc"

%struct._CONTEXT = type { i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i16, i16, i16, i16, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %union.anon, [26 x %struct._M128A], i64, i64, i64, i64, i64, i64 }
%union.anon = type { %struct._XSAVE_FORMAT }
%struct._XSAVE_FORMAT = type { i16, i16, i8, i8, i16, i32, i16, i16, i32, i16, i16, i32, i32, [8 x %struct._M128A], [16 x %struct._M128A], [96 x i8] }
%struct._M128A = type { i64, i64 }

@string_string = internal constant [4 x i8] c"%s\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local global ptr null
@always_one = linkonce thread_local global i1 true
@current_ptr = thread_local global ptr null
@backtrace_string = constant [16 x i8] c"%i: %s - 0x%0X\0A\00"
@_parameterization_iteration.Pairi32._Bool = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_Bool, ptr null]
@_parameterization_Functioni32._i32_to_Bool = linkonce_odr constant [5 x ptr] [ptr @function_typ, ptr @_parameterization_Bool, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@_parameterization_Functioni32_to_i32 = linkonce_odr constant [4 x ptr] [ptr @function_typ, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@_parameterization_iteration.Pairi32._i32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedi32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedi32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@tuple_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @tuple_typ]
@tuple_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@_parameterization_Bool = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 24, i32 10, i32 10, i32 0]
@Container_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @any_typ, ptr @Container, ptr @Object]
@Iterator_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 13, i32 13]
@Iterable_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 35, i32 35]
@ConstantTimeIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @ConstantTimeIterator, ptr null]
@ConstantTimeIterator_offset_tbl = constant [8 x i32] [i32 16, i32 10, i32 0, i32 16, i32 0, i32 13, i32 10, i32 0]
@Enumeration_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @Enumeration, ptr @Object]
@Enumeration_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 0, i32 64, i32 0, i32 10, i32 64]
@Enumeration = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2805197119131967777, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumeration_hashtbl, ptr @Enumeration_offset_tbl, ptr @_data_size_Enumeration, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Enumeration_field_Enumeration_0, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_field_iterable, ptr @Enumeration_B_init_iterableIterableT, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_init_iterableIterableT, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Enumerator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @Enumerator]
@Enumerator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@MapIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@MapIterable_offset_tbl = constant [8 x i32] [i32 0, i32 65, i32 10, i32 40, i32 65, i32 0, i32 0, i32 10]
@MapIterable = constant { [3 x i64], [7 x ptr], [55 x ptr] } { [3 x i64] [i64 -7488770571603291722, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterable_hashtbl, ptr @MapIterable_offset_tbl, ptr @_data_size_MapIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [55 x ptr] [ptr @MapIterable_field_MapIterable_0, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_field_iterable, ptr @MapIterable_field_f, ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterator, ptr @Container, ptr null, ptr @Iterator, ptr null, ptr null]
@MapIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 10, i32 21, i32 0, i32 18, i32 0, i32 0]
@FilterIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @FilterIterable, ptr null, ptr @Container, ptr @Iterable, ptr null]
@FilterIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 10, i32 0, i32 64, i32 39, i32 0]
@FilterIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 8498466713076104350, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterable_hashtbl, ptr @FilterIterable_offset_tbl, ptr @_data_size_FilterIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_field_iterable, ptr @FilterIterable_field_f, ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@FilterIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @FilterIterator, ptr null]
@FilterIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@FilterIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -1221365496900303883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterator_hashtbl, ptr @FilterIterator_offset_tbl, ptr @_data_size_FilterIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_field_iterator, ptr @FilterIterator_field_f, ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_B_next_, ptr @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_next_, ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_B_next_, ptr @FilterIterator_next_] }
@ChainIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ChainIterable, ptr @Container, ptr null, ptr null, ptr @Object]
@ChainIterable_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 10, i32 64, i32 0, i32 0, i32 64]
@ChainIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2370247058431047815, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterable_hashtbl, ptr @ChainIterable_offset_tbl, ptr @_data_size_ChainIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_field_first, ptr @ChainIterable_field_second, ptr @ChainIterable_B_init_firstIterableT_secondIterableT, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_init_firstIterableT_secondIterableT, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ChainIterator]
@ChainIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@InterleaveIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @InterleaveIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@InterleaveIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 39, i32 64, i32 0, i32 0, i32 10]
@InterleaveIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 4936782714255954462, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterable_hashtbl, ptr @InterleaveIterable_offset_tbl, ptr @_data_size_InterleaveIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_field_first, ptr @InterleaveIterable_field_second, ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleaveIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleaveIterator, ptr @Iterator, ptr null, ptr null]
@InterleaveIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 0, i32 21, i32 10, i32 18, i32 0, i32 0]
@ZipIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @ZipIterable, ptr @Object]
@ZipIterable_offset_tbl = constant [8 x i32] [i32 10, i32 41, i32 0, i32 0, i32 66, i32 0, i32 10, i32 66]
@ZipIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 35232740166152944, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterable_hashtbl, ptr @ZipIterable_offset_tbl, ptr @_data_size_ZipIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ZipIterable_field_ZipIterable_0, ptr @ZipIterable_field_ZipIterable_1, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_field_first, ptr @ZipIterable_field_second, ptr @ZipIterable_B_init_firstIterableT_secondIterableU, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_init_firstIterableT_secondIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZipIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ZipIterator]
@ZipIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 22, i32 19, i32 22, i32 0, i32 10, i32 10]
@ProductIterable_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ProductIterable, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr null]
@ProductIterable_offset_tbl = constant [8 x i32] [i32 66, i32 10, i32 10, i32 66, i32 0, i32 41, i32 0, i32 0]
@ProductIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 4128338911757318636, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterable_hashtbl, ptr @ProductIterable_offset_tbl, ptr @_data_size_ProductIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ProductIterable_field_ProductIterable_0, ptr @ProductIterable_field_ProductIterable_1, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_field_first, ptr @ProductIterable_field_second, ptr @ProductIterable_B_init_firstIterableT_secondIterableU, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_init_firstIterableT_secondIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr null, ptr @Container, ptr @Object, ptr null, ptr @ProductIterator]
@ProductIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 21, i32 0, i32 24, i32 24, i32 0, i32 10]
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Enumeration_field_iterable = internal constant { ptr, ptr } { ptr @Enumeration_getter_iterable, ptr @Enumeration_setter_iterable }
@Enumerator_field_iterator = internal constant { ptr, ptr } { ptr @Enumerator_getter_iterator, ptr @Enumerator_setter_iterator }
@Enumerator_field_index = internal constant { ptr, ptr } { ptr @Enumerator_getter_index, ptr @Enumerator_setter_index }
@MapIterable_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable_getter_iterable, ptr @MapIterable_setter_iterable }
@MapIterable_field_f = internal constant { ptr, ptr } { ptr @MapIterable_getter_f, ptr @MapIterable_setter_f }
@MapIterator_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator_getter_iterator, ptr @MapIterator_setter_iterator }
@MapIterator_field_f = internal constant { ptr, ptr } { ptr @MapIterator_getter_f, ptr @MapIterator_setter_f }
@FilterIterable_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable_getter_iterable, ptr @FilterIterable_setter_iterable }
@FilterIterable_field_f = internal constant { ptr, ptr } { ptr @FilterIterable_getter_f, ptr @FilterIterable_setter_f }
@FilterIterator_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator_getter_iterator, ptr @FilterIterator_setter_iterator }
@FilterIterator_field_f = internal constant { ptr, ptr } { ptr @FilterIterator_getter_f, ptr @FilterIterator_setter_f }
@ChainIterable_field_first = internal constant { ptr, ptr } { ptr @ChainIterable_getter_first, ptr @ChainIterable_setter_first }
@ChainIterable_field_second = internal constant { ptr, ptr } { ptr @ChainIterable_getter_second, ptr @ChainIterable_setter_second }
@ChainIterator_field_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_first, ptr @ChainIterator_setter_first }
@ChainIterator_field_second = internal constant { ptr, ptr } { ptr @ChainIterator_getter_second, ptr @ChainIterator_setter_second }
@ChainIterator_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_on_first, ptr @ChainIterator_setter_on_first }
@InterleaveIterable_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_first, ptr @InterleaveIterable_setter_first }
@InterleaveIterable_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_second, ptr @InterleaveIterable_setter_second }
@InterleaveIterator_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_first, ptr @InterleaveIterator_setter_first }
@InterleaveIterator_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_second, ptr @InterleaveIterator_setter_second }
@InterleaveIterator_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_on_first, ptr @InterleaveIterator_setter_on_first }
@ZipIterable_field_first = internal constant { ptr, ptr } { ptr @ZipIterable_getter_first, ptr @ZipIterable_setter_first }
@ZipIterable_field_second = internal constant { ptr, ptr } { ptr @ZipIterable_getter_second, ptr @ZipIterable_setter_second }
@ZipIterator_field_first = internal constant { ptr, ptr } { ptr @ZipIterator_getter_first, ptr @ZipIterator_setter_first }
@ZipIterator_field_second = internal constant { ptr, ptr } { ptr @ZipIterator_getter_second, ptr @ZipIterator_setter_second }
@ProductIterable_field_first = internal constant { ptr, ptr } { ptr @ProductIterable_getter_first, ptr @ProductIterable_setter_first }
@ProductIterable_field_second = internal constant { ptr, ptr } { ptr @ProductIterable_getter_second, ptr @ProductIterable_setter_second }
@ProductIterator_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_first_iterator, ptr @ProductIterator_setter_first_iterator }
@ProductIterator_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterator, ptr @ProductIterator_setter_second_iterator }
@ProductIterator_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterable, ptr @ProductIterator_setter_second_iterable }
@ProductIterator_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator_getter_current_first, ptr @ProductIterator_setter_current_first }
@Enumerator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3435222131909153872, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumerator_hashtbl, ptr @Enumerator_offset_tbl, ptr @_data_size_Enumerator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Enumerator_field_Enumerator_0, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_field_iterator, ptr @Enumerator_field_index, ptr @Enumerator_B_init_iteratorIteratorT, ptr @Enumerator_B_next_, ptr @Enumerator_init_iteratorIteratorT, ptr @Enumerator_next_, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_B_next_, ptr @Enumerator_next_] }
@MapIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -146553482626734782, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterator_hashtbl, ptr @MapIterator_offset_tbl, ptr @_data_size_MapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @MapIterator_field_MapIterator_0, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_field_iterator, ptr @MapIterator_field_f, ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_B_next_, ptr @MapIterator_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_next_, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_B_next_, ptr @MapIterator_next_] }
@ChainIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6043157723929225452, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterator_hashtbl, ptr @ChainIterator_offset_tbl, ptr @_data_size_ChainIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_field_first, ptr @ChainIterator_field_second, ptr @ChainIterator_field_on_first, ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_B_next_, ptr @ChainIterator_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_next_, ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_B_next_, ptr @ChainIterator_next_] }
@InterleaveIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3924664358248524505, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterator_hashtbl, ptr @InterleaveIterator_offset_tbl, ptr @_data_size_InterleaveIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_field_first, ptr @InterleaveIterator_field_second, ptr @InterleaveIterator_field_on_first, ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_next_, ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_next_] }
@ZipIterator = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 -2141114445739585318, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterator_hashtbl, ptr @ZipIterator_offset_tbl, ptr @_data_size_ZipIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @ZipIterator_field_ZipIterator_0, ptr @ZipIterator_field_ZipIterator_1, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_field_first, ptr @ZipIterator_field_second, ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_B_next_, ptr @ZipIterator_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_next_, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_B_next_, ptr @ZipIterator_next_] }
@ProductIterator = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 1697250377212095568, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterator_hashtbl, ptr @ProductIterator_offset_tbl, ptr @_data_size_ProductIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @ProductIterator_field_ProductIterator_0, ptr @ProductIterator_field_ProductIterator_1, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_field_first_iterator, ptr @ProductIterator_field_second_iterator, ptr @ProductIterator_field_second_iterable, ptr @ProductIterator_field_current_first, ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_B_next_, ptr @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_next_, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_B_next_, ptr @ProductIterator_next_] }
@Collection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr @Collection]
@Collection_offset_tbl = constant [8 x i32] [i32 69, i32 10, i32 0, i32 69, i32 0, i32 44, i32 0, i32 10]
@EnumeratedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr @EnumeratedCollection, ptr null, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@EnumeratedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 107, i32 10, i32 0, i32 132, i32 0, i32 48, i32 132]
@EnumeratedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 7081690788784801875, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @EnumeratedCollection_hashtbl, ptr @EnumeratedCollection_offset_tbl, ptr @_data_size_EnumeratedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @EnumeratedCollection_field_EnumeratedCollection_0, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_field_collection, ptr @EnumeratedCollection_B_init_collectionCollectionT, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_init_collectionCollectionT, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MappedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr @MappedCollection, ptr @Collection]
@MappedCollection_offset_tbl = constant [8 x i32] [i32 133, i32 10, i32 0, i32 133, i32 0, i32 108, i32 10, i32 49]
@MappedCollection = constant { [3 x i64], [7 x ptr], [123 x ptr] } { [3 x i64] [i64 5460697656559120915, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MappedCollection_hashtbl, ptr @MappedCollection_offset_tbl, ptr @_data_size_MappedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [123 x ptr] [ptr @MappedCollection_field_MappedCollection_0, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_field_collection, ptr @MappedCollection_field_f, ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainedCollection_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr @ChainedCollection, ptr @Container, ptr @Iterable, ptr null]
@ChainedCollection_offset_tbl = constant [8 x i32] [i32 0, i32 132, i32 10, i32 48, i32 10, i32 132, i32 107, i32 0]
@ChainedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 -4136536984535342799, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainedCollection_hashtbl, ptr @ChainedCollection_offset_tbl, ptr @_data_size_ChainedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_field_first, ptr @ChainedCollection_field_second, ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleavedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleavedCollection, ptr @Iterable, ptr null, ptr @Collection]
@InterleavedCollection_offset_tbl = constant [8 x i32] [i32 132, i32 10, i32 0, i32 132, i32 10, i32 107, i32 0, i32 48]
@InterleavedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 8589355597059143861, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleavedCollection_hashtbl, ptr @InterleavedCollection_offset_tbl, ptr @_data_size_InterleavedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_field_first, ptr @InterleavedCollection_field_second, ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZippedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Collection, ptr @Object, ptr @Container, ptr @ZippedCollection, ptr @Iterable, ptr null, ptr null]
@ZippedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 50, i32 134, i32 134, i32 10, i32 109, i32 0, i32 0]
@ZippedCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 880335312586431241, i64 4611686018427388513, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZippedCollection_hashtbl, ptr @ZippedCollection_offset_tbl, ptr @_data_size_ZippedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ZippedCollection_field_ZippedCollection_0, ptr @ZippedCollection_field_ZippedCollection_1, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_field_first, ptr @ZippedCollection_field_second, ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ProductCollection, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@ProductCollection_offset_tbl = constant [8 x i32] [i32 10, i32 109, i32 0, i32 10, i32 134, i32 0, i32 50, i32 134]
@ProductCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 -310975631771072937, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductCollection_hashtbl, ptr @ProductCollection_offset_tbl, ptr @_data_size_ProductCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ProductCollection_field_ProductCollection_0, ptr @ProductCollection_field_ProductCollection_1, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_field_first, ptr @ProductCollection_field_second, ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherCollectionU_zip_otherIterableU, ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@EnumeratedCollection_field_collection = internal constant { ptr, ptr } { ptr @EnumeratedCollection_getter_collection, ptr @EnumeratedCollection_setter_collection }
@MappedCollection_field_collection = internal constant { ptr, ptr } { ptr @MappedCollection_getter_collection, ptr @MappedCollection_setter_collection }
@MappedCollection_field_f = internal constant { ptr, ptr } { ptr @MappedCollection_getter_f, ptr @MappedCollection_setter_f }
@ChainedCollection_field_first = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_first, ptr @ChainedCollection_setter_first }
@ChainedCollection_field_second = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_second, ptr @ChainedCollection_setter_second }
@InterleavedCollection_field_first = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_first, ptr @InterleavedCollection_setter_first }
@InterleavedCollection_field_second = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_second, ptr @InterleavedCollection_setter_second }
@ZippedCollection_field_first = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_first, ptr @ZippedCollection_setter_first }
@ZippedCollection_field_second = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_second, ptr @ZippedCollection_setter_second }
@ProductCollection_field_first = internal constant { ptr, ptr } { ptr @ProductCollection_getter_first, ptr @ProductCollection_setter_first }
@ProductCollection_field_second = internal constant { ptr, ptr } { ptr @ProductCollection_getter_second, ptr @ProductCollection_setter_second }
@List_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr @List, ptr @Collection]
@List_offset_tbl = constant [8 x i32] [i32 146, i32 10, i32 0, i32 146, i32 0, i32 121, i32 10, i32 62]
@Indexable_hashtbl = constant [4 x ptr] [ptr @Object, ptr @Indexable, ptr @any_typ, ptr null]
@Indexable_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 10, i32 0]
@IndexableCollection_hashtbl = constant [8 x ptr] [ptr @Indexable, ptr null, ptr @IndexableCollection, ptr @Container, ptr @Collection, ptr @Iterable, ptr @any_typ, ptr @Object]
@IndexableCollection_offset_tbl = constant [8 x i32] [i32 54, i32 0, i32 10, i32 144, i32 60, i32 119, i32 10, i32 60]
@Range_hashtbl = constant [16 x ptr] [ptr null, ptr @Object, ptr null, ptr @Range, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @Container, ptr null, ptr @Collection, ptr null, ptr @Iterable, ptr @any_typ, ptr null]
@Range_offset_tbl = constant [16 x i32] [i32 0, i32 137, i32 0, i32 10, i32 0, i32 0, i32 0, i32 0, i32 0, i32 137, i32 0, i32 53, i32 0, i32 112, i32 10, i32 0]
@RangeIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr @RangeIterator, ptr @Container, ptr @Object, ptr null, ptr null]
@RangeIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 18, i32 10, i32 21, i32 21, i32 0, i32 0]
@Range_field_start = internal constant { ptr, ptr } { ptr @Range_getter_start, ptr @Range_setter_start }
@Range_field_end = internal constant { ptr, ptr } { ptr @Range_getter_end, ptr @Range_setter_end }
@Range_field_step = internal constant { ptr, ptr } { ptr @Range_getter_step, ptr @Range_setter_step }
@RangeIterator_field_counter = internal constant { ptr, ptr } { ptr @RangeIterator_getter_counter, ptr @RangeIterator_setter_counter }
@RangeIterator_field_end = internal constant { ptr, ptr } { ptr @RangeIterator_getter_end, ptr @RangeIterator_setter_end }
@RangeIterator_field_step = internal constant { ptr, ptr } { ptr @RangeIterator_getter_step, ptr @RangeIterator_setter_step }
@_parameterization_i8 = linkonce_odr constant [2 x ptr] [ptr @i8_typ, ptr null]
@_parameterization_core.Character = linkonce_odr constant [2 x ptr] [ptr @Character, ptr null]
@_parameterization_iteration.Iterablecore.Character = linkonce_odr constant [3 x ptr] [ptr @Iterable, ptr @_parameterization_core.Character, ptr null]
@tuple_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3422634369532007740, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @tuple_typ_hashtbl, ptr @tuple_typ_offset_tbl, ptr @_data_size_tuple_typ, ptr @_box_tuple_typ, ptr @_unbox_tuple_typ, ptr @_data_size_tuple_typ], [0 x ptr] undef }
@RangeIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -913562485944406675, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @RangeIterator_hashtbl, ptr @RangeIterator_offset_tbl, ptr @_data_size_RangeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @RangeIterator_field_counter, ptr @RangeIterator_field_end, ptr @RangeIterator_field_step, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_init_counteri32_endi32_stepi32, ptr @RangeIterator_B_next_, ptr @RangeIterator_init_counteri32_endi32_stepi32, ptr @RangeIterator_next_, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_next_, ptr @RangeIterator_next_] }
@Unicode_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Unicode]
@Unicode_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 0, i32 10]
@Unicode = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -7454226071548845319, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Unicode_hashtbl, ptr @Unicode_offset_tbl, ptr @_data_size_Unicode, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Unicode_B__Self_replacement_codepoint_, ptr @Unicode_B__Self_replacement_str_, ptr @Unicode_B__Self_replacement_buf_, ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode_B__Self_encode_one_cpi32, ptr @Unicode__Self_replacement_codepoint_, ptr @Unicode__Self_replacement_str_, ptr @Unicode__Self_replacement_buf_, ptr @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode__Self_encode_one_cpi32] }
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [16 x ptr] [ptr @Iterable, ptr @List, ptr null, ptr null, ptr null, ptr null, ptr @Object, ptr @Collection, ptr @any_typ, ptr null, ptr null, ptr null, ptr @String, ptr null, ptr @Container, ptr @Representable]
@String_offset_tbl = constant [16 x i32] [i32 297, i32 102, i32 0, i32 0, i32 0, i32 0, i32 322, i32 238, i32 10, i32 0, i32 0, i32 0, i32 10, i32 0, i32 322, i32 322]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 21, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [8 x ptr] [ptr @StringIterator, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr @ConstantTimeIterator, ptr @any_typ, ptr null]
@StringIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 26, i32 23, i32 26, i32 17, i32 10, i32 0]
@StringIterator = constant { [3 x i64], [7 x ptr], [16 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [16 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_byte_index, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_] }
@Stacktrace_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Stacktrace]
@Stacktrace_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 0, i32 10]
@Stacktrace = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 -59384212523717097, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Stacktrace_hashtbl, ptr @Stacktrace_offset_tbl, ptr @_data_size_Stacktrace, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @Stacktrace_field_stacktrace, ptr @Stacktrace_field_n_frames, ptr @Stacktrace_B_init_, ptr @Stacktrace_B_print_, ptr @Stacktrace_init_, ptr @Stacktrace_print_] }
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 24, i32 0, i32 10, i32 10]
@InvalidUTF8Error_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @InvalidUTF8Error, ptr @Object]
@InvalidUTF8Error_offset_tbl = constant [4 x i32] [i32 10, i32 24, i32 10, i32 38]
@InvalidUTF8Error = constant { [3 x i64], [7 x ptr], [28 x ptr] } { [3 x i64] [i64 4104693287331019315, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @InvalidUTF8Error_hashtbl, ptr @InvalidUTF8Error_offset_tbl, ptr @_data_size_InvalidUTF8Error, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [28 x ptr] [ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@OutOfBounds_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @OutOfBounds, ptr @Object]
@OutOfBounds_offset_tbl = constant [4 x i32] [i32 10, i32 27, i32 10, i32 41]
@OutOfBoundsDetails_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @OutOfBoundsDetails]
@OutOfBoundsDetails_offset_tbl = constant [4 x i32] [i32 16, i32 0, i32 10, i32 10]
@OutOfBoundsDetails = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 4650630525701360429, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBoundsDetails_hashtbl, ptr @OutOfBoundsDetails_offset_tbl, ptr @_data_size_OutOfBoundsDetails, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @OutOfBoundsDetails_field_bounds, ptr @OutOfBoundsDetails_field_index, ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_B_report_, ptr @OutOfBoundsDetails_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_report_] }
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_byte_length = internal constant { ptr, ptr } { ptr @String_getter_byte_length, ptr @String_setter_byte_length }
@String_field_char_length = internal constant { ptr, ptr } { ptr @String_getter_char_length, ptr @String_setter_char_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_codepoint = internal constant { ptr, ptr } { ptr @Character_getter_codepoint, ptr @Character_setter_codepoint }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_byte_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_byte_index, ptr @StringIterator_setter_byte_index }
@Stacktrace_field_stacktrace = internal constant { ptr, ptr } { ptr @Stacktrace_getter_stacktrace, ptr @Stacktrace_setter_stacktrace }
@Stacktrace_field_n_frames = internal constant { ptr, ptr } { ptr @Stacktrace_getter_n_frames, ptr @Stacktrace_setter_n_frames }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@Exception_field_stacktrace = internal constant { ptr, ptr } { ptr @Exception_getter_stacktrace, ptr @Exception_setter_stacktrace }
@InvalidUTF8Error_field_line_number = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_line_number, ptr @InvalidUTF8Error_setter_line_number }
@InvalidUTF8Error_field_file_name = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_file_name, ptr @InvalidUTF8Error_setter_file_name }
@InvalidUTF8Error_field_message = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_message, ptr @InvalidUTF8Error_setter_message }
@InvalidUTF8Error_field_stacktrace = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_stacktrace, ptr @InvalidUTF8Error_setter_stacktrace }
@OutOfBounds_field_details = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_details, ptr @OutOfBounds_setter_details }
@OutOfBounds_field_line_number = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_line_number, ptr @OutOfBounds_setter_line_number }
@OutOfBounds_field_file_name = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_file_name, ptr @OutOfBounds_setter_file_name }
@OutOfBounds_field_message = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_message, ptr @OutOfBounds_setter_message }
@OutOfBounds_field_stacktrace = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_stacktrace, ptr @OutOfBounds_setter_stacktrace }
@OutOfBoundsDetails_field_bounds = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_bounds, ptr @OutOfBoundsDetails_setter_bounds }
@OutOfBoundsDetails_field_index = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_index, ptr @OutOfBoundsDetails_setter_index }
@KeyNotFound_hashtbl = constant [4 x ptr] [ptr @Object, ptr @KeyNotFound, ptr @any_typ, ptr @Exception]
@KeyNotFound_offset_tbl = constant [4 x i32] [i32 38, i32 10, i32 10, i32 24]
@KeyNotFound = constant { [3 x i64], [7 x ptr], [28 x ptr] } { [3 x i64] [i64 2946564862774055400, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @KeyNotFound_hashtbl, ptr @KeyNotFound_offset_tbl, ptr @_data_size_KeyNotFound, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [28 x ptr] [ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@Map_hashtbl = constant [8 x ptr] [ptr @Indexable, ptr @Map, ptr @IndexableCollection, ptr @Container, ptr @Collection, ptr @Iterable, ptr @any_typ, ptr @Object]
@Map_offset_tbl = constant [8 x i32] [i32 198, i32 10, i32 64, i32 288, i32 204, i32 263, i32 10, i32 204]
@MapKeys_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr @MapKeys, ptr @Container, ptr @Iterable, ptr null]
@MapKeys_offset_tbl = constant [8 x i32] [i32 0, i32 132, i32 10, i32 48, i32 10, i32 132, i32 107, i32 0]
@MapKeys = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 -6755415596079746205, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapKeys_hashtbl, ptr @MapKeys_offset_tbl, ptr @_data_size_MapKeys, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @MapKeys_field_MapKeys_1, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_field_map, ptr @MapKeys_B_init_mapMapK._V, ptr @MapKeys_B_size_, ptr @MapKeys_B_is_empty_, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_init_mapMapK._V, ptr @MapKeys_size_, ptr @Collection_is_empty_, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_size_, ptr @MapKeys_B_is_empty_, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_size_, ptr @Collection_is_empty_, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapKeys_field_MapKeys_0, ptr @MapKeys_B_iterator_, ptr @MapKeys_B_each_fFunctionT_to_Nothing, ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapKeys_B_all_fFunctionT_to_Bool, ptr @MapKeys_B_any_fFunctionT_to_Bool, ptr @MapKeys_B_enumerate_, ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapKeys_B_filter_fFunctionT_to_Bool, ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapKeys_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU, ptr @MapKeys_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapValues_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @MapValues, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@MapValues_offset_tbl = constant [8 x i32] [i32 10, i32 107, i32 0, i32 10, i32 132, i32 0, i32 48, i32 132]
@MapValues = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 2074062704914054732, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapValues_hashtbl, ptr @MapValues_offset_tbl, ptr @_data_size_MapValues, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @MapValues_field_MapValues_0, ptr @MapValues_field_MapValues_1, ptr @MapValues_field_map, ptr @MapValues_B_init_mapMapK._V, ptr @MapValues_B_size_, ptr @MapValues_B_is_empty_, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_init_mapMapK._V, ptr @MapValues_size_, ptr @Collection_is_empty_, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_size_, ptr @MapValues_B_is_empty_, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_size_, ptr @Collection_is_empty_, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapValues_field_MapValues_1, ptr @MapValues_B_iterator_, ptr @MapValues_B_each_fFunctionT_to_Nothing, ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapValues_B_all_fFunctionT_to_Bool, ptr @MapValues_B_any_fFunctionT_to_Bool, ptr @MapValues_B_enumerate_, ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MapValues_B_filter_fFunctionT_to_Bool, ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT, ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MapValues_B_zip_otherCollectionU_zip_otherIterableU, ptr @MapValues_B_product_otherCollectionU_product_otherIterableU, ptr @MapValues_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapKeyIterator_hashtbl = constant [8 x ptr] [ptr null, ptr @MapKeyIterator, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr null]
@MapKeyIterator_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 20, i32 17, i32 20, i32 0, i32 10, i32 0]
@MapKeyIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 7211362081012783701, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapKeyIterator_hashtbl, ptr @MapKeyIterator_offset_tbl, ptr @_data_size_MapKeyIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @MapKeyIterator_field_MapKeyIterator_1, ptr @MapKeyIterator_field_MapKeyIterator_0, ptr @MapKeyIterator_field_map_iterator, ptr @MapKeyIterator_B_init_map_iteratorIteratorPairK._V, ptr @MapKeyIterator_B_next_, ptr @MapKeyIterator_init_map_iteratorIteratorPairK._V, ptr @MapKeyIterator_next_, ptr @MapKeyIterator_field_MapKeyIterator_0, ptr @MapKeyIterator_B_next_, ptr @MapKeyIterator_next_] }
@MapValueIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @MapValueIterator, ptr @Iterator, ptr null, ptr @Container, ptr @Object, ptr null, ptr null]
@MapValueIterator_offset_tbl = constant [8 x i32] [i32 10, i32 10, i32 17, i32 0, i32 20, i32 20, i32 0, i32 0]
@MapValueIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -4981803053484113385, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapValueIterator_hashtbl, ptr @MapValueIterator_offset_tbl, ptr @_data_size_MapValueIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @MapValueIterator_field_MapValueIterator_0, ptr @MapValueIterator_field_MapValueIterator_1, ptr @MapValueIterator_field_map_iterator, ptr @MapValueIterator_B_init_map_iteratorIteratorPairK._V, ptr @MapValueIterator_B_next_, ptr @MapValueIterator_init_map_iteratorIteratorPairK._V, ptr @MapValueIterator_next_, ptr @MapValueIterator_field_MapValueIterator_1, ptr @MapValueIterator_B_next_, ptr @MapValueIterator_next_] }
@HashMap_hashtbl = constant [16 x ptr] [ptr null, ptr @Container, ptr null, ptr null, ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr null, ptr @Map, ptr @IndexableCollection, ptr null, ptr null, ptr @Indexable, ptr @Iterable, ptr @HashMap]
@HashMap_offset_tbl = constant [16 x i32] [i32 0, i32 568, i32 0, i32 0, i32 0, i32 484, i32 10, i32 484, i32 0, i32 66, i32 344, i32 0, i32 0, i32 478, i32 543, i32 10]
@KeyNotFound_field_line_number = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_line_number, ptr @KeyNotFound_setter_line_number }
@KeyNotFound_field_file_name = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_file_name, ptr @KeyNotFound_setter_file_name }
@KeyNotFound_field_message = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_message, ptr @KeyNotFound_setter_message }
@KeyNotFound_field_stacktrace = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_stacktrace, ptr @KeyNotFound_setter_stacktrace }
@MapKeys_field_map = internal constant { ptr, ptr } { ptr @MapKeys_getter_map, ptr @MapKeys_setter_map }
@MapValues_field_map = internal constant { ptr, ptr } { ptr @MapValues_getter_map, ptr @MapValues_setter_map }
@MapKeyIterator_field_map_iterator = internal constant { ptr, ptr } { ptr @MapKeyIterator_getter_map_iterator, ptr @MapKeyIterator_setter_map_iterator }
@MapValueIterator_field_map_iterator = internal constant { ptr, ptr } { ptr @MapValueIterator_getter_map_iterator, ptr @MapValueIterator_setter_map_iterator }
@Pair = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_B__set_first_valueT, ptr @Pair_B__set_second_valueU, ptr @Pair_B_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_, ptr @Pair__set_first_valueT, ptr @Pair__set_second_valueU, ptr @Pair_init_firstT_secondU] }
@Map = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5249855671126779970, i64 4611686018427389201, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Map_hashtbl, ptr @Map_offset_tbl, ptr @_data_size_Map, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@HashMap = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388447, i64 15], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 25, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [15 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [15 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_primary_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueV_primary_hashi32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_primary_hash_, ptr @Entry_B_to_pair_, ptr @Entry_init_keyK_valueV_primary_hashi32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_primary_hash_, ptr @Entry_to_pair_] }
@CuckooMap_hashtbl = constant [16 x ptr] [ptr null, ptr @Container, ptr null, ptr null, ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr null, ptr @Map, ptr @IndexableCollection, ptr @CuckooMap, ptr null, ptr @Indexable, ptr @Iterable, ptr @HashMap]
@CuckooMap_offset_tbl = constant [16 x i32] [i32 0, i32 1154, i32 0, i32 0, i32 0, i32 1070, i32 10, i32 1070, i32 0, i32 652, i32 930, i32 10, i32 0, i32 1064, i32 1129, i32 94]
@CuckooMap = constant { [3 x i64], [7 x ptr], [1144 x ptr] } { [3 x i64] [i64 3547150501766965522, i64 4611686018427388447, i64 15], [7 x ptr] [ptr @subtype_test, ptr @CuckooMap_hashtbl, ptr @CuckooMap_offset_tbl, ptr @_data_size_CuckooMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [1144 x ptr] [ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_field_table1, ptr @CuckooMap_field_table2, ptr @CuckooMap_field_table_len, ptr @CuckooMap_field_size, ptr @CuckooMap_field_hasher, ptr @CuckooMap_field_eq, ptr @CuckooMap_B__Self_max_displacements_, ptr @CuckooMap_B_hash1_keyK, ptr @CuckooMap_B_hash2_from_primary_primary_hashi32, ptr @CuckooMap_B_index1_primary_hashi32, ptr @CuckooMap_B_index2_primary_hashi32, ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_B_resize_, ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap__Self_max_displacements_, ptr @CuckooMap_hash1_keyK, ptr @CuckooMap_hash2_from_primary_primary_hashi32, ptr @CuckooMap_index1_primary_hashi32, ptr @CuckooMap_index2_primary_hashi32, ptr @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_resize_, ptr @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_keys_, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_get_keyK, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @Map_keys_, ptr @CuckooMap_clear_, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_indices_, ptr @CuckooMap_B_values_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @Map_indices_, ptr @Map_values_, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @Map__index_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_is_empty_, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_size_, ptr @Collection_is_empty_, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_8, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT, ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU, ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@CuckooMapIterator_hashtbl = constant [8 x ptr] [ptr @CuckooMapIterator, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr null]
@CuckooMapIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 27, i32 24, i32 27, i32 0, i32 10, i32 0]
@CuckooMapIterator = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 -1975748647346050920, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMapIterator_hashtbl, ptr @CuckooMapIterator_offset_tbl, ptr @_data_size_CuckooMapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @CuckooMapIterator_field_CuckooMapIterator_0, ptr @CuckooMapIterator_field_CuckooMapIterator_1, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_field_map_table1, ptr @CuckooMapIterator_field_map_table2, ptr @CuckooMapIterator_field_table_len, ptr @CuckooMapIterator_field_index, ptr @CuckooMapIterator_field_on_second, ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_next_, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_next_] }
@Entry_field_primary_hash = internal constant { ptr, ptr } { ptr @Entry_getter_primary_hash, ptr @Entry_setter_primary_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@CuckooMap_field_table1 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table1, ptr @CuckooMap_setter_table1 }
@CuckooMap_field_table2 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table2, ptr @CuckooMap_setter_table2 }
@CuckooMap_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table_len, ptr @CuckooMap_setter_table_len }
@CuckooMap_field_size = internal constant { ptr, ptr } { ptr @CuckooMap_getter_size, ptr @CuckooMap_setter_size }
@CuckooMap_field_hasher = internal constant { ptr, ptr } { ptr @CuckooMap_getter_hasher, ptr @CuckooMap_setter_hasher }
@CuckooMap_field_eq = internal constant { ptr, ptr } { ptr @CuckooMap_getter_eq, ptr @CuckooMap_setter_eq }
@CuckooMapIterator_field_map_table1 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table1, ptr @CuckooMapIterator_setter_map_table1 }
@CuckooMapIterator_field_map_table2 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table2, ptr @CuckooMapIterator_setter_map_table2 }
@CuckooMapIterator_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_table_len, ptr @CuckooMapIterator_setter_table_len }
@CuckooMapIterator_field_index = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_index, ptr @CuckooMapIterator_setter_index }
@CuckooMapIterator_field_on_second = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_on_second, ptr @CuckooMapIterator_setter_on_second }
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@Character = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Character_field_codepoint, ptr @Character_B_codepoint_, ptr @Character_B_init_codepointi32, ptr @Character_B_to_string_, ptr @Character_B__EQ_otherCharacter, ptr @Character_B_n_bytes_, ptr @Character_codepoint_, ptr @Character_init_codepointi32, ptr @Character_to_string_, ptr @Character__EQ_otherCharacter, ptr @Character_n_bytes_] }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xNil__Self_print_xi32__Self_print_xRepresentable__Self_print_xCharacter__Self_print_xi8__Self_print_xBool__Self_print_xi64__Self_print_xString__Self_print_xf64, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xi32, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xi8, ptr @IO__Self_print_xBool, ptr @IO__Self_print_xi64, ptr @IO__Self_print_xString, ptr @IO__Self_print_xf64] }
@Container = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_data_size_Container, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388349, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388477, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@ConstantTimeIterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7049076106841707882, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ConstantTimeIterator_hashtbl, ptr @ConstantTimeIterator_offset_tbl, ptr @_data_size_ConstantTimeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Collection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 1375598993350293883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Collection_hashtbl, ptr @Collection_offset_tbl, ptr @_data_size_Collection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@List = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -83120161364696977, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @List_hashtbl, ptr @List_offset_tbl, ptr @_data_size_List, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Indexable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8246772220324864030, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Indexable_hashtbl, ptr @Indexable_offset_tbl, ptr @_data_size_Indexable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@IndexableCollection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -307435881317861917, i64 4611686018427389201, i64 7], [7 x ptr] [ptr @subtype_test, ptr @IndexableCollection_hashtbl, ptr @IndexableCollection_offset_tbl, ptr @_data_size_IndexableCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Range = constant { [3 x i64], [7 x ptr], [127 x ptr] } { [3 x i64] [i64 5490049236840671069, i64 4611686018427389989, i64 15], [7 x ptr] [ptr @subtype_test, ptr @Range_hashtbl, ptr @Range_offset_tbl, ptr @_data_size_Range, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [127 x ptr] [ptr @Range_field_start, ptr @Range_field_end, ptr @Range_field_step, ptr @Range_field_Range_0, ptr @Range_B_init_endi32, ptr @Range_B_init_starti32_endi32, ptr @Range_B_step_stepi32, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherCollectionU_zip_otherIterableU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_init_endi32, ptr @Range_init_starti32_endi32, ptr @Range_step_stepi32, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherCollectionU_zip_otherIterableU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherCollectionU_zip_otherIterableU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherIterableT_chain_otherCollectionT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherCollectionU_zip_otherIterableU, ptr @Range_B_product_otherCollectionU_product_otherIterableU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@OutOfBounds = constant { [3 x i64], [7 x ptr], [31 x ptr] } { [3 x i64] [i64 5348403617834207535, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBounds_hashtbl, ptr @OutOfBounds_offset_tbl, ptr @_data_size_OutOfBounds, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [31 x ptr] [ptr @OutOfBounds_field_details, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_boundsi32_indexi32, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @OutOfBounds_init_boundsi32_indexi32, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_] }
@Array_hashtbl = constant [32 x ptr] [ptr null, ptr @Representable, ptr @List, ptr null, ptr null, ptr @Container, ptr @Array, ptr null, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @IndexableCollection, ptr null, ptr @Collection, ptr @any_typ, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @Indexable, ptr null, ptr null, ptr null, ptr null]
@Array_offset_tbl = constant [32 x i32] [i32 0, i32 537, i32 93, i32 0, i32 0, i32 313, i32 10, i32 0, i32 0, i32 288, i32 313, i32 0, i32 0, i32 0, i32 0, i32 0, i32 313, i32 0, i32 229, i32 10, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 447, i32 0, i32 0, i32 0, i32 0]
@Array = constant { [3 x i64], [7 x ptr], [529 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427389773, i64 31], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [529 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_field_Array_2, ptr @Array_B_capacity_, ptr @Array_B_init_, ptr @Array_B_init_capacityi32, ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_B_reserve_new_capacityi32, ptr @Array_B_bounds_check_indexi32, ptr @Array_B_unchecked_index_indexi32, ptr @Array_B_unchecked_insert_indexi32_valueT, ptr @Array_B__Self_empty_, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_append_xT, ptr @Array_B_length_, ptr @Array_B_first_, ptr @Array_B_last_, ptr @Array_B_extend_otherIterableT_extend_otherCollectionT, ptr @Array_B_get_indexi32, ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_B_indices_, ptr @Array_B_values_, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_capacity_, ptr @Array_init_, ptr @Array_init_capacityi32, ptr @Array_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_reserve_new_capacityi32, ptr @Array_bounds_check_indexi32, ptr @Array_unchecked_index_indexi32, ptr @Array_unchecked_insert_indexi32_valueT, ptr @Array__Self_empty_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_append_xT, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @Array_extend_otherCollectionT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_indices_, ptr @Array_values_, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_repr_, ptr @Array_field_Array_0, ptr @Array_B__Self_empty_, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_append_xT, ptr @Array_B_length_, ptr @Array_B_first_, ptr @Array_B_last_, ptr @Array_B_extend_otherIterableT_extend_otherCollectionT, ptr @Array_B_get_indexi32, ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array__Self_empty_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_append_xT, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_field_Array_0, ptr @Array_B_indices_, ptr @Array_B_values_, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_indices_, ptr @Array_values_, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_2, ptr @Array_field_Array_0, ptr @Array_B__index_indexi32, ptr @Array_B__set_index_indexi32_valueT, ptr @Array__index_indexi32, ptr @Array__set_index_indexi32_valueT, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_is_empty_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_size_, ptr @Collection_is_empty_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherCollectionU_zip_otherIterableU, ptr @Array_B_product_otherCollectionU_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_repr_] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr @Iterator, ptr @ConstantTimeIterator, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 26, i32 10, i32 0, i32 26, i32 10, i32 23, i32 17, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [16 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [16 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@_parameterization_i64 = linkonce_odr constant [2 x ptr] [ptr @i64_typ, ptr null]
@_parameterization_core.String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@_parameterization_Bufferi8 = linkonce_odr constant [2 x ptr] [ptr @buffer_typ, ptr null]
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@String = constant { [3 x i64], [7 x ptr], [314 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427390361, i64 15], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [314 x ptr] [ptr @String_field_bytes, ptr @String_field_byte_length, ptr @String_field_char_length, ptr @String_field_capacity, ptr @String_field_String_0, ptr @String_B_byte_length_, ptr @String_B_capacity_, ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_c_string_c_stringBufferi8, ptr @String_B_init_, ptr @String_B_init_capacityi32, ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_B_c_string_, ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_B_reserve_new_capacityi32, ptr @String_B__EQ_otherString, ptr @String_B_decode_at_byte_indexi32, ptr @String_B_unchecked_index_xi32, ptr @String_B_unchecked_insert_xi32_valuei8, ptr @String_B_copy_, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherIterableT_extend_otherCollectionCharacter_extend_otherString, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_B_repr_, ptr @String_byte_length_, ptr @String_capacity_, ptr @String__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String__Self_from_c_string_c_stringBufferi8, ptr @String_init_, ptr @String_init_capacityi32, ptr @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_c_string_, ptr @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_reserve_new_capacityi32, ptr @String__EQ_otherString, ptr @String_decode_at_byte_indexi32, ptr @String_unchecked_index_xi32, ptr @String_unchecked_insert_xi32_valuei8, ptr @String_copy_, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @String_extend_otherCollectionCharacter, ptr @String_extend_otherString, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_repr_, ptr @String_field_String_0, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherIterableT_extend_otherCollectionCharacter_extend_otherString, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Collection_zip_otherCollectionU, ptr @Iterable_zip_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherCollectionU_zip_otherIterableU, ptr @String_B_product_otherCollectionU_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_B_repr_, ptr @String_repr_] }
@Exception = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_field_stacktrace, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberi32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #0 {
  %hash = call i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id)
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

define { ptr, i160 } @_box_Default(ptr %fat_ptr, ptr %parameterization) {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 4
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr %parameterization, ptr %destination) {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 4
  ret void
}

define { i64, i64 } @_size_Default(ptr %parameterization) {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @PRNG_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(120) @PRNG)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %. = call i32 @llvm.smax.i32(i32 %3, i32 1)
  call void %11(ptr %.fca.1.extract, i32 %.) #30
  ret void
}

define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(120) @PRNG)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #31
  %11 = mul i32 %10, 1103515245
  %12 = add i32 %11, 12345
  %13 = and i32 %12, 2147483647
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract)
  %15 = getelementptr i8, ptr %8, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 %13) #30
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract)
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr %.fca.1.extract) #31
  ret i32 %20
}

define i32 @get_offset(ptr %vptr, ptr %id_ptr) {
  %id = load i64, ptr %id_ptr, align 4
  %id_of_casted = load i64, ptr %vptr, align 4
  %hash_coef_ptr = getelementptr i64, ptr %vptr, i32 1
  %tbl_size_ptr = getelementptr i64, ptr %vptr, i32 2
  %offset_tbl_ptr = getelementptr ptr, ptr %vptr, i32 5
  %hash_coef = load i64, ptr %hash_coef_ptr, align 4
  %tbl_size = load i64, ptr %tbl_size_ptr, align 4
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %index = call i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %id)
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %index
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #4

define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %product, %shifted
  %hash = and i64 %xored, %tbl_size
  %bug = icmp sgt i64 %hash, %tbl_size
  ret i64 %hash
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #5

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr %f, ptr nocapture nofree noundef nonnull readonly %0) #8 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #32
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr %f, ptr nocapture nofree readonly %0) #8 {
  %result = call { i64, i64 } %f(ptr nocapture nofree readonly %0) #32
  ret { i64, i64 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #8 {
  %result = call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #32
  ret { ptr, i160 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @unbox_wrapper(ptr %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #9 {
  call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #33
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #10 {
  %result = call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #34
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr %f, ptr nocapture nofree noundef nonnull %0) #10 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull %0) #34
  ret ptr %result
}

; Function Attrs: alwaysinline
define ptr @adjust_trampoline(ptr %tramp) #11 {
  %ret = call ptr @llvm.adjust.trampoline(ptr %tramp) #35
  ret ptr %ret
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #12

; Function Attrs: alwaysinline mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc(i64 noundef %size) #13 {
  %result = call noalias ptr @bump_malloc_wrapper(i64 noundef %size) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc_wrapper(i64 noundef %size) #14 {
  %result = call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr @current_ptr) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr %current_ptr) #14 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_data_size_tuple_typ(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add nuw i64 %11, %.reg2mem22.011
  %19 = add nuw i64 %18, %17
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem20.0.lcssa = phi i64 [ 1, %1 ], [ %13, %.lr.ph ]
  %.reg2mem22.0.lcssa = phi i64 [ 0, %1 ], [ %19, %.lr.ph ]
  %24 = urem i64 %.reg2mem22.0.lcssa, %.reg2mem20.0.lcssa
  %25 = icmp eq i64 %24, 0
  %26 = sub nuw i64 %.reg2mem20.0.lcssa, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add nuw i64 %27, %.reg2mem22.0.lcssa
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa, 1
  ret { i64, i64 } %30
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #5

define { i64, i64 } @_data_size_union_typ(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 noundef %12, i64 noundef %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = call i64 @llvm.umax.i64(i64 noundef %11, i64 noundef %.reg2mem22.011)
  %19 = call i64 @llvm.umax.i64(i64 noundef %18, i64 noundef %17)
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem20.0.lcssa = phi i64 [ 1, %1 ], [ %13, %.lr.ph ]
  %.reg2mem22.0.lcssa = phi i64 [ 0, %1 ], [ %19, %.lr.ph ]
  %right_size = icmp eq i64 %.reg2mem22.0.lcssa, 32
  %flag_size = select i1 %right_size, i64 0, i64 8
  %final_size = add i64 %.reg2mem22.0.lcssa, %flag_size
  %24 = urem i64 %final_size, %.reg2mem20.0.lcssa
  %25 = icmp eq i64 %24, 0
  %26 = sub nuw i64 %.reg2mem20.0.lcssa, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add nuw i64 %27, %final_size
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa, 1
  ret { i64, i64 } %30
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr %1, ptr %dest) {
  %3 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %3, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @_data_size_union_typ(ptr %1)
  %size = extractvalue { i64, i64 } %6, 0
  %7 = icmp sle i64 %size, 16
  %8 = icmp eq i64 %size, 32
  %9 = select i1 %7, ptr %4, ptr %5
  %source = select i1 %8, ptr %3, ptr %9
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %dest, ptr %source, i64 %size, i1 false)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #15

define ptr @coroutine_create(ptr %func, ptr %arg_passer) {
  %stack = call noalias ptr @virtual_reserve(i64 8388608) #16
  %func_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 0
  store ptr %func, ptr %func_ptr, align 8
  %stack_top = getelementptr i8, ptr %stack, i64 8388512
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 1
  %arg_passer_slot = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 2
  %into_callee_first_word = getelementptr [3 x ptr], ptr %into_callee_buf, i32 0, i32 0
  %into_callee_second_word = getelementptr [3 x ptr], ptr %into_callee_buf, i32 0, i32 1
  %into_callee_third_word = getelementptr [3 x ptr], ptr %into_callee_buf, i32 0, i32 2
  store i64 %stack_top_aligned, ptr %into_callee_first_word, align 4
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 4
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 3
  store i1 false, ptr %is_finished, align 1
  call void @coroutine_trampoline(ptr %into_callee_second_word)
  ret ptr %stack
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @virtual_reserve(i64 %size) #16 {
  %result = call noalias ptr @VirtualAlloc(ptr null, i64 %size, i32 12288, i32 4) #19
  ret ptr %result
}

define void @coroutine_trampoline(ptr %into_callee_second_word) {
  store ptr blockaddress(@coroutine_trampoline, %trampoline), ptr %into_callee_second_word, align 8
  %result = call i1 @returns_one()
  br i1 %result, label %exit, label %trampoline

trampoline:                                       ; preds = %0
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  %arg_passer_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine, i32 0, i32 2
  %arg_passer = load ptr, ptr %arg_passer_ptr, align 8
  call void %arg_passer(ptr %current_coroutine)
  %current_coroutine2 = load ptr, ptr @current_coroutine, align 8
  %is_finished_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine2, i32 0, i32 3
  store i1 true, ptr %is_finished_ptr, align 1
  call void @llvm.eh.sjlj.longjmp(ptr @into_caller_buf) #18
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: noinline
define i1 @returns_one() #17 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #18

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) #19

define void @setup_landing_pad() {
  %region = call noalias ptr @virtual_reserve(i64 5368709120) #16
  store ptr %region, ptr @current_ptr, align 8
  %buf_first_word = getelementptr [3 x ptr], ptr @into_caller_buf, i32 0, i32 0
  %buf_second_word = getelementptr [3 x ptr], ptr @into_caller_buf, i32 0, i32 1
  %buf_third_word = getelementptr [3 x ptr], ptr @into_caller_buf, i32 0, i32 2
  %sp = call ptr @llvm.stacksave.p0() #36
  store ptr %sp, ptr %buf_first_word, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr %buf_second_word, align 8
  store ptr %sp, ptr %buf_third_word, align 8
  %current_coroutine = call ptr @coroutine_create(ptr @setup_landing_pad, ptr @arg_passer)
  store ptr %current_coroutine, ptr @current_coroutine, align 8
  %result = call i1 @returns_one()
  br i1 %result, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = call i32 @printf(ptr @string_string, ptr @exception_message)
  %cc = load { ptr }, ptr @current_coroutine, align 8
  call void @report_exception({ ptr } %cc)
  call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #20

define void @arg_passer(ptr %current_coroutine) {
  %func_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine, i32 0, i32 0
  %func = load ptr, ptr %func_ptr, align 8
  call void %func()
  ret void
}

declare i32 @printf(ptr, ...)

declare void @exit()

define void @assume_offset(ptr %fat_ptr, ptr %id_ptr) {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id_of_casted = load i64, ptr %vptr, align 4
  %offset = call i32 @get_offset(ptr %vptr, ptr %id_ptr)
  %destination = getelementptr { ptr, ptr, ptr, i32 }, ptr %fat_ptr, i32 0, i32 3
  %dest_value = load i32, ptr %destination, align 4
  %slot = alloca i32, align 4
  store i32 %dest_value, ptr %slot, align 4
  %slotval = load i32, ptr %slot, align 4
  %eq = icmp eq i32 %slotval, %offset
  call void @llvm.assume(i1 %eq) #37
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)
declare void @llvm.assume(i1 noundef) #21

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #8 {
  %result = call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #32
  ret i1 %result
}

define void @arg_buffer_filler(ptr %coroutine) {
  ret void
}

define ptr @get_current_coroutine() {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture writeonly %from_buf, ptr %to_buf) #22 {
  %from_buf_first_word = getelementptr [3 x ptr], ptr %from_buf, i32 0, i32 0
  %from_buf_second_word = getelementptr [3 x ptr], ptr %from_buf, i32 0, i32 1
  %from_buf_third_word = getelementptr [3 x ptr], ptr %from_buf, i32 0, i32 2
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = call ptr @llvm.stacksave.p0() #36
  store ptr %sp, ptr %from_buf_first_word, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %is_first_time = call i1 @returns_one()
  br i1 %is_first_time, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #18
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

define void @coroutine_yield(ptr %current_coroutine) {
  %into_callee_buf = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine, i32 0, i32 1
  call preserve_nonecc void @context_switch(ptr nocapture writeonly %into_callee_buf, ptr @into_caller_buf) #38
  ret void
}

; Function Attrs: cold noinline
define void @coroutine_yield_cold(ptr %current_coroutine) #23 {
  call void @coroutine_yield(ptr %current_coroutine)
  ret void
}

define void @coroutine_call(ptr %coroutine) {
  %old_into_caller = load [3 x ptr], ptr @into_caller_buf, align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %coroutine, i32 0, i32 1
  call preserve_nonecc void @context_switch(ptr nocapture writeonly @into_caller_buf, ptr %into_callee_buf) #38
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store [3 x ptr] %old_into_caller, ptr @into_caller_buf, align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr %tramp) #24 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr %tramp, i64 16, i32 64, ptr %oldProtect)
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) #24

define void @print_backtrace(ptr %backtrace, i64 %n_frames) {
  %start_indvar = sub i64 %n_frames, 1
  %handle = tail call ptr @GetCurrentProcess()
  %1 = tail call i32 @SymInitialize(ptr %handle, ptr null, i32 1)
  %2 = alloca [344 x i8], align 1
  call void @llvm.memset.p0.i64(ptr %2, i8 0, i64 344, i1 false)
  %3 = getelementptr inbounds i8, ptr %2, i64 80
  store i32 255, ptr %3, align 4
  store i32 88, ptr %2, align 4
  %.not = icmp eq i64 %n_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %0
  %4 = getelementptr inbounds i8, ptr %2, i64 56
  %5 = getelementptr inbounds i8, ptr %2, i64 84
  br label %6

6:                                                ; preds = %6, %.lr.ph
  %indvars.iv = phi i64 [ %start_indvar, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %7 = getelementptr inbounds [100 x ptr], ptr %backtrace, i64 0, i64 %indvars.iv
  %8 = load ptr, ptr %7, align 8
  %9 = ptrtoint ptr %8 to i64
  %10 = call i32 @SymFromAddr(ptr %handle, i64 %9, ptr null, ptr %2)
  %11 = load i64, ptr %4, align 8
  %12 = call i32 (ptr, ...) @printf(ptr @backtrace_string, i64 %indvars.iv, ptr %5, i64 %11)
  %indvars.iv.next = sub nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp slt i64 %indvars.iv.next, 0
  br i1 %exitcond.not, label %._crit_edge, label %6

._crit_edge:                                      ; preds = %6, %0
  %13 = call i32 @SymCleanup(ptr %handle)
  ret void
}

declare ptr @GetCurrentProcess() local_unnamed_addr

declare i32 @SymInitialize(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #25

declare i32 @SymFromAddr(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr

declare i32 @SymCleanup(ptr) local_unnamed_addr

define i64 @capture_backtrace(i64 %max_frames, ptr %backtrace) {
entry:
  %context = alloca %struct._CONTEXT, align 16
  call void @RtlCaptureContext(ptr %context)
  %rip = getelementptr inbounds %struct._CONTEXT, ptr %context, i32 0, i32 37
  %img_base_ptr = alloca i64, align 8
  %0 = alloca ptr, align 8
  %1 = alloca i64, align 8
  %.not = icmp eq i64 %max_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %entry
  %.pre = load i64, ptr %rip, align 8
  br label %.lr.ph

.lr.ph:                                           ; preds = %3, %.lr.ph.preheader
  %2 = phi i64 [ %.pre, %.lr.ph.preheader ], [ %6, %3 ]
  %indvars.iv = phi i64 [ 0, %.lr.ph.preheader ], [ %indvars.iv.next, %3 ]
  %n_captured = sub i64 %indvars.iv, 4
  %fentry = call ptr @RtlLookupFunctionEntry(i64 %2, ptr %img_base_ptr, ptr null)
  %img_base = load i64, ptr %img_base_ptr, align 8
  %fentry_null = icmp eq ptr %fentry, null
  %img_base_null = icmp eq i64 %img_base, 0
  %either = or i1 %fentry_null, %img_base_null
  br i1 %either, label %._crit_edge, label %3

3:                                                ; preds = %.lr.ph
  %4 = load i64, ptr %rip, align 8
  %5 = call ptr @RtlVirtualUnwind(i32 0, i64 %img_base, i64 %4, ptr %fentry, ptr %context, ptr %0, ptr %1, ptr null)
  %6 = load i64, ptr %rip, align 8
  %7 = inttoptr i64 %6 to ptr
  %8 = getelementptr inbounds ptr, ptr %backtrace, i64 %indvars.iv
  store ptr %7, ptr %8, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %max_frames
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %3, %.lr.ph, %entry
  %.0.lcssa = phi i64 [ 0, %entry ], [ %n_captured, %.lr.ph ], [ %max_frames, %3 ]
  ret i64 %.0.lcssa
}

declare void @RtlCaptureContext(ptr)

declare ptr @RtlLookupFunctionEntry(i64, ptr, ptr)

declare ptr @RtlVirtualUnwind(i32, i64, i64, ptr, ptr, ptr, ptr, ptr)

define i1 @zoeqkrwugn(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @tdfasjexas(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @wryurxzenj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @xfctfcdhgs(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @hyaxmlzbks(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @cuugdpgnny(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ufjhiswmua(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @mdpnoafjfh(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @oxrtkwaxjb(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @pdosxztqjt(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @qarfwzkrsv(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ooeaxdzlkj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ylighrwwhd(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @xehcsxgghh(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @gbsaiaroxn(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @guwgpxjitl(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @estoarvlyn(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @kjfeexdjxl(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @jspfeujlja(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ovvmwieice(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #3 {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca [4 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca [4 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %16 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @String)
  %17 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %18 = ptrtoint ptr %.fca.1.extract to i64
  %19 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.667.8.insert.ext = zext i32 %16 to i160
  %.sroa.667.8.insert.shift = shl nuw i160 %.sroa.667.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %19 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.667.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.366.8.insert.ext = zext i64 %18 to i160
  %.sroa.366.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.366.8.insert.ext
  %20 = insertvalue { ptr, i160 } %17, i160 %.sroa.366.8.insert.insert, 1
  %21 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %24 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  %25 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %25, align 8
  %26 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %25)
  call void %26(ptr nonnull %21, { ptr, i160 } %20)
  %27 = call ptr @bump_malloc(i64 noundef 15)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %27, align 1
  %28 = alloca [1 x ptr], align 8
  store ptr @String, ptr %28, align 8
  %29 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %30 = call { i64, i64 } @size_wrapper(ptr %29, ptr noundef nonnull align 8 dereferenceable(8) %28)
  %31 = extractvalue { i64, i64 } %30, 0
  %32 = call ptr @bump_malloc(i64 %31)
  %33 = insertvalue { ptr } undef, ptr %27, 0
  %34 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %32, 1
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr undef, 2
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 10, 3
  %37 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %37, i64 8
  store ptr @_parameterization_i32, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %37, i64 16
  store ptr @_parameterization_i32, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %37, i64 24
  store ptr @_parameterization_i32, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %37)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %43 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  %44 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %44, i64 8
  store ptr @i32_typ, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 16
  store ptr @i32_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %44, i64 24
  store ptr @i32_typ, ptr %47, align 8
  %48 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %36, ptr noundef nonnull align 8 dereferenceable(32) %44)
  call void %48({ ptr, ptr, ptr, i32 } %36, { ptr, ptr, ptr, i32 } %36, ptr nonnull %37, { ptr } %33, i32 14, i32 14, i32 15)
  %49 = ptrtoint ptr %32 to i64
  %.sroa.346.8.insert.ext = zext i64 %49 to i160
  %.sroa.346.8.insert.insert = or disjoint i160 %.sroa.346.8.insert.ext, 3402823669209384634633746074317682114560
  %50 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.346.8.insert.insert, 1
  %51 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %54 = alloca { ptr }, align 8
  store ptr @String, ptr %54, align 8
  %55 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %54)
  call void %55(ptr nonnull %51, { ptr, i160 } %50)
  %.sroa.035.0.insert.ext = zext i32 %1 to i160
  %56 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.035.0.insert.ext, 1
  %57 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %60 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %60, align 8
  %61 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %60)
  call void %61(ptr nonnull %57, { ptr, i160 } %56)
  %62 = call ptr @bump_malloc(i64 noundef 15)
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %62, align 1
  %63 = alloca [1 x ptr], align 8
  store ptr @String, ptr %63, align 8
  %64 = call { i64, i64 } @size_wrapper(ptr %29, ptr noundef nonnull align 8 dereferenceable(8) %63)
  %65 = extractvalue { i64, i64 } %64, 0
  %66 = call ptr @bump_malloc(i64 %65)
  %67 = insertvalue { ptr } undef, ptr %62, 0
  %68 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %66, 1
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr undef, 2
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, i32 10, 3
  %71 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %71, i64 8
  store ptr @_parameterization_i32, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %71, i64 16
  store ptr @_parameterization_i32, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %71, i64 24
  store ptr @_parameterization_i32, ptr %74, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %77 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %77, i64 8
  store ptr @i32_typ, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %77, i64 16
  store ptr @i32_typ, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %77, i64 24
  store ptr @i32_typ, ptr %80, align 8
  %81 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %70, ptr noundef nonnull align 8 dereferenceable(32) %77)
  call void %81({ ptr, ptr, ptr, i32 } %70, { ptr, ptr, ptr, i32 } %70, ptr nonnull %71, { ptr } %67, i32 14, i32 14, i32 15)
  %82 = ptrtoint ptr %66 to i64
  %.sroa.321.8.insert.ext = zext i64 %82 to i160
  %.sroa.321.8.insert.insert = or disjoint i160 %.sroa.321.8.insert.ext, 3402823669209384634633746074317682114560
  %83 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.321.8.insert.insert, 1
  %84 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %84)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %87 = alloca { ptr }, align 8
  store ptr @String, ptr %87, align 8
  %88 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %87)
  call void %88(ptr nonnull %84, { ptr, i160 } %83)
  %.sroa.015.0.insert.ext = zext i64 %2 to i160
  %89 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.015.0.insert.ext, 1
  %90 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i64, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %90)
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %93 = alloca { ptr }, align 8
  store ptr @i64_typ, ptr %93, align 8
  %94 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %93)
  call void %94(ptr nonnull %90, { ptr, i160 } %89)
  %95 = call ptr @bump_malloc(i64 noundef 4)
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %95, align 1
  %96 = alloca [1 x ptr], align 8
  store ptr @String, ptr %96, align 8
  %97 = call { i64, i64 } @size_wrapper(ptr %29, ptr noundef nonnull align 8 dereferenceable(8) %96)
  %98 = extractvalue { i64, i64 } %97, 0
  %99 = call ptr @bump_malloc(i64 %98)
  %100 = insertvalue { ptr } undef, ptr %95, 0
  %101 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %99, 1
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, ptr undef, 2
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 10, 3
  %104 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %104, align 8
  %105 = getelementptr inbounds i8, ptr %104, i64 8
  store ptr @_parameterization_i32, ptr %105, align 8
  %106 = getelementptr inbounds i8, ptr %104, i64 16
  store ptr @_parameterization_i32, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %104, i64 24
  store ptr @_parameterization_i32, ptr %107, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %104)
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %110 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr @i32_typ, ptr %111, align 8
  %112 = getelementptr inbounds i8, ptr %110, i64 16
  store ptr @i32_typ, ptr %112, align 8
  %113 = getelementptr inbounds i8, ptr %110, i64 24
  store ptr @i32_typ, ptr %113, align 8
  %114 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 dereferenceable(32) %110)
  call void %114({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull %104, { ptr } %100, i32 3, i32 3, i32 4)
  %115 = ptrtoint ptr %99 to i64
  %.sroa.3.8.insert.ext = zext i64 %115 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %116 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  %117 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %117, align 8
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %117)
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %120 = alloca { ptr }, align 8
  store ptr @String, ptr %120, align 8
  %121 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %120)
  call void %121(ptr nonnull %117, { ptr, i160 } %116)
  %122 = icmp sgt i32 %1, 0
  br i1 %122, label %123, label %._crit_edge

123:                                              ; preds = %3
  %124 = mul i64 %2, 1000000
  %125 = zext nneg i32 %1 to i64
  %126 = sdiv i64 %124, %125
  %127 = call ptr @bump_malloc(i64 noundef 16)
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %127, align 1
  store ptr @String, ptr %4, align 8
  %128 = call { i64, i64 } @size_wrapper(ptr %29, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %129 = extractvalue { i64, i64 } %128, 0
  %130 = call ptr @bump_malloc(i64 %129)
  %131 = insertvalue { ptr } undef, ptr %127, 0
  %132 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %130, 1
  %133 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr undef, 2
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  %135 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %135, align 8
  %136 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr @_parameterization_i32, ptr %136, align 8
  %137 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @_parameterization_i32, ptr %137, align 8
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %5)
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %6, align 8
  %140 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %140, align 8
  %141 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr @i32_typ, ptr %141, align 8
  %142 = getelementptr inbounds i8, ptr %6, i64 24
  store ptr @i32_typ, ptr %142, align 8
  %143 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %134, ptr noundef nonnull align 8 dereferenceable(32) %6)
  call void %143({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr nonnull %5, { ptr } %131, i32 15, i32 15, i32 16)
  %144 = ptrtoint ptr %130 to i64
  %.sroa.396.8.insert.ext = zext i64 %144 to i160
  %.sroa.396.8.insert.insert = or disjoint i160 %.sroa.396.8.insert.ext, 3402823669209384634633746074317682114560
  %145 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.396.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %7, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %8, align 8
  %148 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %8)
  call void %148(ptr nonnull %7, { ptr, i160 } %145)
  %.sroa.089.0.insert.ext = zext i64 %126 to i160
  %149 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.089.0.insert.ext, 1
  store ptr @_parameterization_i64, ptr %9, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i64_typ, ptr %10, align 8
  %152 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %10)
  call void %152(ptr nonnull %9, { ptr, i160 } %149)
  %153 = call ptr @bump_malloc(i64 noundef 4)
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %153, align 1
  store ptr @String, ptr %11, align 8
  %154 = call { i64, i64 } @size_wrapper(ptr %29, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %155 = extractvalue { i64, i64 } %154, 0
  %156 = call ptr @bump_malloc(i64 %155)
  %157 = insertvalue { ptr } undef, ptr %153, 0
  %158 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %156, 1
  %159 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr undef, 2
  %160 = insertvalue { ptr, ptr, ptr, i32 } %159, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %12, align 8
  %161 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @_parameterization_i32, ptr %161, align 8
  %162 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %162, align 8
  %163 = getelementptr inbounds i8, ptr %12, i64 24
  store ptr @_parameterization_i32, ptr %163, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %12)
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %13, align 8
  %166 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr @i32_typ, ptr %166, align 8
  %167 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %167, align 8
  %168 = getelementptr inbounds i8, ptr %13, i64 24
  store ptr @i32_typ, ptr %168, align 8
  %169 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %160, ptr noundef nonnull align 8 dereferenceable(32) %13)
  call void %169({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull %12, { ptr } %157, i32 3, i32 3, i32 4)
  %170 = ptrtoint ptr %156 to i64
  %.sroa.375.8.insert.ext = zext i64 %170 to i160
  %.sroa.375.8.insert.insert = or disjoint i160 %.sroa.375.8.insert.ext, 3402823669209384634633746074317682114560
  %171 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.375.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %14, align 8
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %15, align 8
  %174 = call ptr @class_behavior_wrapper(ptr %24, ptr noundef nonnull align 8 dereferenceable(8) %15)
  call void %174(ptr nonnull %14, { ptr, i160 } %171)
  br label %._crit_edge

._crit_edge:                                      ; preds = %123, %3
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca [4 x ptr], align 8
  %12 = alloca { ptr, ptr, ptr, ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca { ptr }, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca [4 x ptr], align 8
  %17 = alloca { ptr, ptr, ptr, ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca { ptr }, align 8
  %20 = alloca [1 x ptr], align 8
  %21 = alloca [4 x ptr], align 8
  %22 = alloca { ptr, ptr, ptr, ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %25, i64 8
  store ptr @_parameterization_i32, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %25, i64 16
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %25, i64 24
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %28, align 8
  %29 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 48), align 8
  %30 = call { i64, i64 } @size_wrapper(ptr %29, ptr noundef nonnull align 8 dereferenceable(32) %25)
  %31 = extractvalue { i64, i64 } %30, 0
  %32 = call ptr @bump_malloc(i64 %31)
  store ptr @_parameterization_i32, ptr %32, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = getelementptr i8, ptr %32, i64 16
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %32)
  %36 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %36)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %36, ptr noalias nofree noundef nonnull readnone @ovvmwieice, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %37 = call ptr @adjust_trampoline(ptr %36)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %36)
  %39 = insertvalue { ptr } undef, ptr %37, 0
  %40 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %40)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %40, ptr noalias nofree noundef nonnull readnone @jspfeujlja, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %41 = call ptr @adjust_trampoline(ptr %40)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %40)
  %43 = insertvalue { ptr } undef, ptr %41, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %32, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr undef, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 10, 3
  %47 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %47)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %51 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 240), align 8
  %52 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @function_typ, ptr %53, align 8
  %54 = call ptr @behavior_wrapper(ptr %51, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(16) %52)
  call void %54({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %47, { ptr } %39, { ptr } %43)
  %55 = call i64 @clock()
  %.sroa.gep = getelementptr inbounds i8, ptr %22, i64 8
  %.sroa.gep308 = getelementptr inbounds i8, ptr %22, i64 16
  %.sroa.gep311 = getelementptr inbounds i8, ptr %22, i64 24
  %.sroa.gep314 = getelementptr inbounds i8, ptr %21, i64 8
  %.sroa.gep317 = getelementptr inbounds i8, ptr %21, i64 16
  %.sroa.gep320 = getelementptr inbounds i8, ptr %21, i64 24
  %56 = getelementptr inbounds i8, ptr %3, i64 8
  %57 = getelementptr inbounds i8, ptr %4, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %1
  %.0 = phi i32 [ 0, %1 ], [ %.1, %._crit_edge ]
  %58 = icmp slt i32 %.0, %0
  br i1 %58, label %59, label %._crit_edge

59:                                               ; preds = %._crit_edge1
  %60 = add nsw i32 %.0, 1
  %.sroa.0283.0.insert.ext = zext i32 %.0 to i160
  %61 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0283.0.insert.ext, 1
  %.sroa.0280.0.insert.ext = zext i32 %60 to i160
  %62 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0280.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %56, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %65 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 256), align 8
  store ptr @i32_typ, ptr %4, align 8
  store ptr @i32_typ, ptr %57, align 8
  %66 = call ptr @behavior_wrapper(ptr %65, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(16) %4)
  call void %66({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %3, { ptr, i160 } %61, { ptr, i160 } %62)
  br label %._crit_edge

._crit_edge:                                      ; preds = %59, %._crit_edge1
  %.1 = phi i32 [ %60, %59 ], [ %.0, %._crit_edge1 ]
  br i1 %58, label %._crit_edge1, label %67

67:                                               ; preds = %._crit_edge
  %.sroa.gep306 = getelementptr inbounds i8, ptr %17, i64 8
  %.sroa.gep309 = getelementptr inbounds i8, ptr %17, i64 16
  %.sroa.gep312 = getelementptr inbounds i8, ptr %17, i64 24
  %.sroa.gep315 = getelementptr inbounds i8, ptr %16, i64 8
  %.sroa.gep318 = getelementptr inbounds i8, ptr %16, i64 16
  %.sroa.gep321 = getelementptr inbounds i8, ptr %16, i64 24
  %68 = call i64 @clock()
  %69 = icmp sgt i32 %0, 0
  br i1 %69, label %._crit_edge2, label %87

._crit_edge2:                                     ; preds = %67
  %70 = add nsw i32 %0, -1
  %.sroa.0269.0.insert.ext = zext nneg i32 %70 to i160
  %71 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0269.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %74 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %6, align 8
  %75 = call ptr @behavior_wrapper(ptr %74, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %76 = call { ptr, i160 } %75({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %5, { ptr, i160 } %71)
  %.fca.0.extract265 = extractvalue { ptr, i160 } %76, 0
  %77 = icmp ne ptr %.fca.0.extract265, @nil_typ
  %78 = icmp ne ptr %.fca.0.extract265, null
  %.not299 = and i1 %77, %78
  %79 = icmp ne ptr %.fca.0.extract265, @nil_typ
  %80 = and i1 %78, %79
  br i1 %80, label %._crit_edge4, label %._crit_edge3

._crit_edge4:                                     ; preds = %._crit_edge2
  %.fca.1.extract266 = extractvalue { ptr, i160 } %76, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract266 to i32
  %.not303 = icmp eq i32 %0, %.sroa.2.8.extract.trunc
  %spec.select305 = and i1 %.not303, %.not299
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge4, %._crit_edge2
  %.2 = phi i1 [ %spec.select305, %._crit_edge4 ], [ %.not299, %._crit_edge2 ]
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %83 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 320), align 8
  %84 = call ptr @behavior_wrapper(ptr %83, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 %2)
  %85 = call i32 %84({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %2)
  %.not304 = icmp eq i32 %85, %0
  %86 = select i1 %.not304, i1 %.2, i1 false
  br label %.cont166

87:                                               ; preds = %67
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %90 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 320), align 8
  %91 = call ptr @behavior_wrapper(ptr %90, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 %2)
  %92 = call i32 %91({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %2)
  %.not = icmp eq i32 %92, 0
  br label %.cont166

.cont166:                                         ; preds = %87, %._crit_edge3
  %.reg2mem15.0.in = phi i1 [ %86, %._crit_edge3 ], [ %.not, %87 ]
  %93 = call ptr @bump_malloc(i64 noundef 18)
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %93, align 1
  store ptr @String, ptr %7, align 8
  %94 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %95 = call { i64, i64 } @size_wrapper(ptr %94, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %96 = extractvalue { i64, i64 } %95, 0
  %97 = call ptr @bump_malloc(i64 %96)
  %98 = insertvalue { ptr } undef, ptr %93, 0
  %99 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %97, 1
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr undef, 2
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %8, align 8
  %102 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @_parameterization_i32, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @_parameterization_i32, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @_parameterization_i32, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %107 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %9, align 8
  %108 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @i32_typ, ptr %108, align 8
  %109 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @i32_typ, ptr %109, align 8
  %110 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @i32_typ, ptr %110, align 8
  %111 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %101, ptr noundef nonnull align 8 dereferenceable(32) %9)
  call void %111({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr nonnull %8, { ptr } %98, i32 17, i32 17, i32 18)
  %112 = sub i64 %68, %55
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %101, i32 %0, i64 %112)
  %113 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %113, align 1
  store ptr @String, ptr %10, align 8
  %114 = call { i64, i64 } @size_wrapper(ptr %94, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %115 = extractvalue { i64, i64 } %114, 0
  %116 = call ptr @bump_malloc(i64 %115)
  %117 = insertvalue { ptr } undef, ptr %113, 0
  %118 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %116, 1
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr undef, 2
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %11, align 8
  %121 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_i32, ptr %121, align 8
  %122 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @_parameterization_i32, ptr %122, align 8
  %123 = getelementptr inbounds i8, ptr %11, i64 24
  store ptr @_parameterization_i32, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %11)
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %12, align 8
  %126 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @i32_typ, ptr %126, align 8
  %127 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @i32_typ, ptr %127, align 8
  %128 = getelementptr inbounds i8, ptr %12, i64 24
  store ptr @i32_typ, ptr %128, align 8
  %129 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %120, ptr noundef nonnull align 8 dereferenceable(32) %12)
  call void %129({ ptr, ptr, ptr, i32 } %120, { ptr, ptr, ptr, i32 } %120, ptr nonnull %11, { ptr } %117, i32 18, i32 18, i32 19)
  %130 = ptrtoint ptr %116 to i64
  %.sroa.3207.8.insert.ext = zext i64 %130 to i160
  %.sroa.3207.8.insert.insert = or disjoint i160 %.sroa.3207.8.insert.ext, 3402823669209384634633746074317682114560
  %131 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3207.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %13, align 8
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %134 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %14, align 8
  %135 = call ptr @class_behavior_wrapper(ptr %134, ptr noundef nonnull align 8 dereferenceable(8) %14)
  call void %135(ptr nonnull %13, { ptr, i160 } %131)
  %136 = select i1 %.reg2mem15.0.in, ptr %15, ptr %20
  %137 = call ptr @bump_malloc(i64 noundef 5)
  %.fca.0.extract = select i1 %.reg2mem15.0.in, i8 80, i8 70
  %.sroa.0197.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.3 = select i1 %.reg2mem15.0.in, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>, <4 x i8> %.sroa.0.0.vec.insert
  %.sroa.0197.3 = select i1 %.reg2mem15.0.in, <4 x i8> %.sroa.0197.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0197.1.vec.insert = insertelement <4 x i8> %.sroa.0197.3, i8 65, i64 1
  %.sroa.0.1.vec.insert = insertelement <4 x i8> %.sroa.0.3, i8 65, i64 1
  %.sroa.0.2 = select i1 %.reg2mem15.0.in, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>, <4 x i8> %.sroa.0.1.vec.insert
  %.fca.2.extract = select i1 %.reg2mem15.0.in, i8 83, i8 73
  %.sroa.0197.2 = select i1 %.reg2mem15.0.in, <4 x i8> %.sroa.0197.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0197.2.vec.insert = insertelement <4 x i8> %.sroa.0197.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.2.vec.insert = insertelement <4 x i8> %.sroa.0.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.1 = select i1 %.reg2mem15.0.in, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>, <4 x i8> %.sroa.0.2.vec.insert
  %.fca.3.extract = select i1 %.reg2mem15.0.in, i8 83, i8 76
  %.sroa.0197.1 = select i1 %.reg2mem15.0.in, <4 x i8> %.sroa.0197.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0197.3.vec.insert = insertelement <4 x i8> %.sroa.0197.1, i8 %.fca.3.extract, i64 3
  %.sroa.0.3.vec.insert = insertelement <4 x i8> %.sroa.0.1, i8 %.fca.3.extract, i64 3
  %.sroa.speculated196 = select i1 %.reg2mem15.0.in, <4 x i8> %.sroa.0197.3.vec.insert, <4 x i8> %.sroa.0.3.vec.insert
  store <4 x i8> %.sroa.speculated196, ptr %137, align 1
  store ptr @String, ptr %136, align 8
  %138 = call { i64, i64 } @size_wrapper(ptr %94, ptr noundef nonnull align 8 dereferenceable(8) %136)
  %139 = extractvalue { i64, i64 } %138, 0
  %140 = call ptr @bump_malloc(i64 %139)
  br i1 %.reg2mem15.0.in, label %.cont, label %.else

.else:                                            ; preds = %.cont166
  br label %.cont

.cont:                                            ; preds = %.else, %.cont166
  %141 = phi ptr [ %24, %.else ], [ %19, %.cont166 ]
  %142 = phi ptr [ %23, %.else ], [ %18, %.cont166 ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %.else ], [ %.sroa.gep306, %.cont166 ]
  %.sroa.phi307 = phi ptr [ %.sroa.gep308, %.else ], [ %.sroa.gep309, %.cont166 ]
  %.sroa.phi310 = phi ptr [ %.sroa.gep311, %.else ], [ %.sroa.gep312, %.cont166 ]
  %143 = phi ptr [ %22, %.else ], [ %17, %.cont166 ]
  %.sroa.phi313 = phi ptr [ %.sroa.gep314, %.else ], [ %.sroa.gep315, %.cont166 ]
  %.sroa.phi316 = phi ptr [ %.sroa.gep317, %.else ], [ %.sroa.gep318, %.cont166 ]
  %.sroa.phi319 = phi ptr [ %.sroa.gep320, %.else ], [ %.sroa.gep321, %.cont166 ]
  %144 = phi ptr [ %21, %.else ], [ %16, %.cont166 ]
  %145 = insertvalue { ptr } undef, ptr %137, 0
  %146 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %140, 1
  %147 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr undef, 2
  %148 = insertvalue { ptr, ptr, ptr, i32 } %147, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %144, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi313, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi316, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi319, align 8
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %144)
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %143, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi307, align 8
  store ptr @i32_typ, ptr %.sroa.phi310, align 8
  %151 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %148, ptr noundef nonnull align 8 dereferenceable(32) %143)
  call void %151({ ptr, ptr, ptr, i32 } %148, { ptr, ptr, ptr, i32 } %148, ptr nonnull %144, { ptr } %145, i32 4, i32 4, i32 5)
  %152 = ptrtoint ptr %140 to i64
  %.sroa.3.8.insert.ext = zext i64 %152 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %153 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %142, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %142)
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %141, align 8
  %156 = call ptr @class_behavior_wrapper(ptr %134, ptr noundef nonnull align 8 dereferenceable(8) %141)
  call void %156(ptr nonnull %142, { ptr, i160 } %153)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #4

declare i64 @clock() local_unnamed_addr #3

define void @benchmark_insert_random(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %.sroa.0393.sroa.0 = alloca i8, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca [4 x ptr], align 8
  %15 = alloca { ptr, ptr, ptr, ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca [4 x ptr], align 8
  %18 = alloca { ptr, ptr, ptr, ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca [4 x ptr], align 8
  %23 = alloca { ptr, ptr, ptr, ptr }, align 8
  %24 = alloca [1 x ptr], align 8
  %25 = alloca { ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca [4 x ptr], align 8
  %28 = alloca { ptr, ptr, ptr, ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca [4 x ptr], align 8
  %33 = alloca { ptr, ptr, ptr, ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca { ptr }, align 8
  %36 = alloca [1 x ptr], align 8
  %37 = alloca { ptr }, align 8
  %38 = alloca [1 x ptr], align 8
  %39 = alloca [4 x ptr], align 8
  %40 = alloca { ptr, ptr, ptr, ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %43 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %43, i64 8
  store ptr @_parameterization_i32, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 16
  store ptr @_parameterization_i32, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %43, i64 24
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %46, align 8
  %47 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 48), align 8
  %48 = call { i64, i64 } @size_wrapper(ptr %47, ptr noundef nonnull align 8 dereferenceable(32) %43)
  %49 = extractvalue { i64, i64 } %48, 0
  %50 = call ptr @bump_malloc(i64 %49)
  store ptr @_parameterization_i32, ptr %50, align 8
  %51 = getelementptr i8, ptr %50, i64 8
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = getelementptr i8, ptr %50, i64 16
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %50)
  %54 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %54)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %54, ptr noalias nofree noundef nonnull readnone @kjfeexdjxl, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %55 = call ptr @adjust_trampoline(ptr %54)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %54)
  %57 = insertvalue { ptr } undef, ptr %55, 0
  %58 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %58)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %58, ptr noalias nofree noundef nonnull readnone @estoarvlyn, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %59 = call ptr @adjust_trampoline(ptr %58)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %58)
  %61 = insertvalue { ptr } undef, ptr %59, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %50, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr undef, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 10, 3
  %65 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %65)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %69 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 240), align 8
  %70 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %70, i64 8
  store ptr @function_typ, ptr %71, align 8
  %72 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 dereferenceable(16) %70)
  call void %72({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %65, { ptr } %57, { ptr } %61)
  %73 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %73, align 8
  %74 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %73)
  %75 = extractvalue { i64, i64 } %74, 0
  %76 = call ptr @bump_malloc(i64 %75)
  %77 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %76, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr undef, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 10, 3
  %80 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %80)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %83 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %83, align 8
  %84 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %79, ptr noundef nonnull align 8 dereferenceable(8) %83)
  call void %84({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %80, i32 123)
  %85 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %85, i64 8
  store ptr @_parameterization_i32, ptr %86, align 8
  %87 = load ptr, ptr getelementptr (i8, ptr @Array, i64 48), align 8
  %88 = call { i64, i64 } @size_wrapper(ptr %87, ptr noundef nonnull align 8 dereferenceable(16) %85)
  %89 = extractvalue { i64, i64 } %88, 0
  %90 = call ptr @bump_malloc(i64 %89)
  store ptr @_parameterization_i32, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %90)
  %92 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %90, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr undef, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 10, 3
  %95 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %95, align 8
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %95)
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %98 = load ptr, ptr getelementptr (i8, ptr @Array, i64 136), align 8
  %99 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %99, align 8
  %100 = call ptr @behavior_wrapper(ptr %98, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(8) %99)
  call void %100({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %95, i32 %0)
  %101 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %101, align 8
  %102 = getelementptr inbounds i8, ptr %101, i64 8
  store ptr @_parameterization_i32, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %101, i64 16
  store ptr @_parameterization_Bool, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %101, i64 24
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %104, align 8
  %105 = call { i64, i64 } @size_wrapper(ptr %47, ptr noundef nonnull align 8 dereferenceable(32) %101)
  %106 = extractvalue { i64, i64 } %105, 0
  %107 = call ptr @bump_malloc(i64 %106)
  store ptr @_parameterization_i32, ptr %107, align 8
  %108 = getelementptr i8, ptr %107, i64 8
  store ptr @_parameterization_Bool, ptr %108, align 8
  %109 = getelementptr i8, ptr %107, i64 16
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %109, align 8
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %107)
  %111 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %111)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %111, ptr noalias nofree noundef nonnull readnone @guwgpxjitl, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %112 = call ptr @adjust_trampoline(ptr %111)
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %111)
  %114 = insertvalue { ptr } undef, ptr %112, 0
  %115 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %115)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %115, ptr noalias nofree noundef nonnull readnone @gbsaiaroxn, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %116 = call ptr @adjust_trampoline(ptr %115)
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %115)
  %118 = insertvalue { ptr } undef, ptr %116, 0
  %119 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %107, 1
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr undef, 2
  %121 = insertvalue { ptr, ptr, ptr, i32 } %120, i32 10, 3
  %122 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %122, align 8
  %123 = getelementptr inbounds i8, ptr %122, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %122)
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %126 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %126, align 8
  %127 = getelementptr inbounds i8, ptr %126, i64 8
  store ptr @function_typ, ptr %127, align 8
  %128 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %121, ptr noundef nonnull align 8 dereferenceable(16) %126)
  call void %128({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull %122, { ptr } %114, { ptr } %118)
  %.sroa.gep = getelementptr inbounds i8, ptr %28, i64 8
  %.sroa.gep436 = getelementptr inbounds i8, ptr %28, i64 16
  %.sroa.gep439 = getelementptr inbounds i8, ptr %28, i64 24
  %.sroa.gep442 = getelementptr inbounds i8, ptr %27, i64 8
  %.sroa.gep445 = getelementptr inbounds i8, ptr %27, i64 16
  %.sroa.gep448 = getelementptr inbounds i8, ptr %27, i64 24
  %129 = getelementptr inbounds i8, ptr %3, i64 8
  %130 = getelementptr inbounds i8, ptr %4, i64 8
  %131 = add i32 %0, -1
  %132 = getelementptr inbounds i8, ptr %5, i64 8
  %133 = getelementptr inbounds i8, ptr %6, i64 8
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %._crit_edge, %1
  %.0409 = phi i32 [ 0, %1 ], [ %.1410, %._crit_edge ]
  %.0 = phi i32 [ -1, %1 ], [ %.2, %._crit_edge ]
  %134 = icmp slt i32 %.0409, %0
  br i1 %134, label %._crit_edge1, label %._crit_edge

._crit_edge1:                                     ; preds = %._crit_edge2
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %137 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %79, ptr noundef nonnull align 8 %2)
  %138 = call i32 %137({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %2)
  %.sroa.0403.0.insert.ext = zext i32 %138 to i160
  %139 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0403.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %129, align 8
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3)
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %142 = load ptr, ptr getelementptr (i8, ptr @Array, i64 176), align 8
  store ptr @i32_typ, ptr %4, align 8
  store ptr @i32_typ, ptr %130, align 8
  %143 = call ptr @behavior_wrapper(ptr %142, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(16) %4)
  call void %143({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %3, i32 %.0409, { ptr, i160 } %139)
  %144 = icmp eq i32 %.0409, %131
  %spec.select = select i1 %144, i32 %138, i32 %.0
  store i1 true, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. = load i8, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.0.insert.ext = zext i8 %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. to i160
  %145 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0393.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_Bool, ptr %132, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %148 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 256), align 8
  store ptr @i32_typ, ptr %6, align 8
  store ptr @bool_typ, ptr %133, align 8
  %149 = call ptr @behavior_wrapper(ptr %148, { ptr, ptr, ptr, i32 } %121, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %149({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull %5, { ptr, i160 } %139, { ptr, i160 } %145)
  %150 = add nsw i32 %.0409, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge1, %._crit_edge2
  %.1410 = phi i32 [ %150, %._crit_edge1 ], [ %.0409, %._crit_edge2 ]
  %.2 = phi i32 [ %spec.select, %._crit_edge1 ], [ %.0, %._crit_edge2 ]
  br i1 %134, label %._crit_edge2, label %151

151:                                              ; preds = %._crit_edge
  %.sroa.gep434 = getelementptr inbounds i8, ptr %23, i64 8
  %.sroa.gep440 = getelementptr inbounds i8, ptr %23, i64 24
  %.sroa.gep446 = getelementptr inbounds i8, ptr %22, i64 16
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %154 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 320), align 8
  %155 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %121, ptr noundef nonnull align 8 %2)
  %156 = call i32 %155({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull align 8 %2)
  %157 = call i64 @clock()
  %158 = getelementptr inbounds i8, ptr %9, i64 8
  %159 = getelementptr inbounds i8, ptr %10, i64 8
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3, %151
  %.2411 = phi i32 [ 0, %151 ], [ %.3, %._crit_edge3 ]
  %160 = icmp slt i32 %.2411, %0
  br i1 %160, label %161, label %._crit_edge3

161:                                              ; preds = %._crit_edge4
  store ptr @_parameterization_i32, ptr %7, align 8
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %163 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %164 = load ptr, ptr getelementptr (i8, ptr @Array, i64 168), align 8
  store ptr @i32_typ, ptr %8, align 8
  %165 = call ptr @behavior_wrapper(ptr %164, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %166 = call { ptr, i160 } %165({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %7, i32 %.2411)
  %.fca.1.extract383 = extractvalue { ptr, i160 } %166, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract383 to i32
  %167 = add i32 %.sroa.1.8.extract.trunc, 1
  %.sroa.0376.0.insert.ext = and i160 %.fca.1.extract383, 4294967295
  %168 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0376.0.insert.ext, 1
  %.sroa.0373.0.insert.ext = zext i32 %167 to i160
  %169 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0373.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %9, align 8
  store ptr @_parameterization_i32, ptr %158, align 8
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %172 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 256), align 8
  store ptr @i32_typ, ptr %10, align 8
  store ptr @i32_typ, ptr %159, align 8
  %173 = call ptr @behavior_wrapper(ptr %172, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 dereferenceable(16) %10)
  call void %173({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %9, { ptr, i160 } %168, { ptr, i160 } %169)
  %174 = add nsw i32 %.2411, 1
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %161, %._crit_edge4
  %.3 = phi i32 [ %174, %161 ], [ %.2411, %._crit_edge4 ]
  br i1 %160, label %._crit_edge4, label %175

175:                                              ; preds = %._crit_edge3
  %.sroa.gep437 = getelementptr inbounds i8, ptr %23, i64 16
  %.sroa.gep443 = getelementptr inbounds i8, ptr %22, i64 8
  %.sroa.gep449 = getelementptr inbounds i8, ptr %22, i64 24
  %176 = call i64 @clock()
  %177 = icmp sgt i32 %0, 0
  br i1 %177, label %._crit_edge5, label %194

._crit_edge5:                                     ; preds = %175
  %.sroa.0364.0.insert.ext = zext i32 %.2 to i160
  %178 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0364.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %11, align 8
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %181 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %12, align 8
  %182 = call ptr @behavior_wrapper(ptr %181, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 dereferenceable(8) %12)
  %183 = call { ptr, i160 } %182({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %11, { ptr, i160 } %178)
  %.fca.0.extract360 = extractvalue { ptr, i160 } %183, 0
  %184 = icmp ne ptr %.fca.0.extract360, @nil_typ
  %185 = icmp ne ptr %.fca.0.extract360, null
  %.not426 = and i1 %184, %185
  %186 = icmp ne ptr %.fca.0.extract360, @nil_typ
  %187 = and i1 %185, %186
  br i1 %187, label %._crit_edge7, label %._crit_edge6

._crit_edge7:                                     ; preds = %._crit_edge5
  %.fca.1.extract361 = extractvalue { ptr, i160 } %183, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract361 to i32
  %188 = add i32 %.2, 1
  %.not430 = icmp eq i32 %188, %.sroa.2.8.extract.trunc
  %spec.select433 = and i1 %.not430, %.not426
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge7, %._crit_edge5
  %.2414 = phi i1 [ %spec.select433, %._crit_edge7 ], [ %.not426, %._crit_edge5 ]
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %190 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %191 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 %2)
  %192 = call i32 %191({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %2)
  %.not431 = icmp eq i32 %192, %156
  %193 = select i1 %.not431, i1 %.2414, i1 false
  br label %.cont256

194:                                              ; preds = %175
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %197 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 %2)
  %198 = call i32 %197({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %2)
  %.not = icmp eq i32 %198, 0
  br label %.cont256

.cont256:                                         ; preds = %194, %._crit_edge6
  %.reg2mem21.0.in = phi i1 [ %193, %._crit_edge6 ], [ %.not, %194 ]
  %199 = call ptr @bump_malloc(i64 noundef 14)
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %199, align 1
  store ptr @String, ptr %13, align 8
  %200 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %201 = call { i64, i64 } @size_wrapper(ptr %200, ptr noundef nonnull align 8 dereferenceable(8) %13)
  %202 = extractvalue { i64, i64 } %201, 0
  %203 = call ptr @bump_malloc(i64 %202)
  %204 = insertvalue { ptr } undef, ptr %199, 0
  %205 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %203, 1
  %206 = insertvalue { ptr, ptr, ptr, i32 } %205, ptr undef, 2
  %207 = insertvalue { ptr, ptr, ptr, i32 } %206, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %14, align 8
  %208 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_i32, ptr %208, align 8
  %209 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr @_parameterization_i32, ptr %209, align 8
  %210 = getelementptr inbounds i8, ptr %14, i64 24
  store ptr @_parameterization_i32, ptr %210, align 8
  %211 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %14)
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %213 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %15, align 8
  %214 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @i32_typ, ptr %214, align 8
  %215 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @i32_typ, ptr %215, align 8
  %216 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @i32_typ, ptr %216, align 8
  %217 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %207, ptr noundef nonnull align 8 dereferenceable(32) %15)
  call void %217({ ptr, ptr, ptr, i32 } %207, { ptr, ptr, ptr, i32 } %207, ptr nonnull %14, { ptr } %204, i32 13, i32 13, i32 14)
  %218 = sub i64 %176, %157
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %207, i32 %0, i64 %218)
  %219 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %219, align 1
  store ptr @String, ptr %16, align 8
  %220 = call { i64, i64 } @size_wrapper(ptr %200, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %221 = extractvalue { i64, i64 } %220, 0
  %222 = call ptr @bump_malloc(i64 %221)
  %223 = insertvalue { ptr } undef, ptr %219, 0
  %224 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %222, 1
  %225 = insertvalue { ptr, ptr, ptr, i32 } %224, ptr undef, 2
  %226 = insertvalue { ptr, ptr, ptr, i32 } %225, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %227 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %227, align 8
  %228 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %228, align 8
  %229 = getelementptr inbounds i8, ptr %17, i64 24
  store ptr @_parameterization_i32, ptr %229, align 8
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %17)
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %18, align 8
  %232 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @i32_typ, ptr %232, align 8
  %233 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @i32_typ, ptr %233, align 8
  %234 = getelementptr inbounds i8, ptr %18, i64 24
  store ptr @i32_typ, ptr %234, align 8
  %235 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %226, ptr noundef nonnull align 8 dereferenceable(32) %18)
  call void %235({ ptr, ptr, ptr, i32 } %226, { ptr, ptr, ptr, i32 } %226, ptr nonnull %17, { ptr } %223, i32 18, i32 18, i32 19)
  %236 = ptrtoint ptr %222 to i64
  %.sroa.3300.8.insert.ext = zext i64 %236 to i160
  %.sroa.3300.8.insert.insert = or disjoint i160 %.sroa.3300.8.insert.ext, 3402823669209384634633746074317682114560
  %237 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3300.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %19, align 8
  %238 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %239 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %240 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %20, align 8
  %241 = call ptr @class_behavior_wrapper(ptr %240, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %241(ptr nonnull %19, { ptr, i160 } %237)
  %242 = select i1 %.reg2mem21.0.in, ptr %21, ptr %26
  %243 = call ptr @bump_malloc(i64 noundef 5)
  %.fca.0.extract = select i1 %.reg2mem21.0.in, i8 80, i8 70
  %.sroa.0290.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.3 = select i1 %.reg2mem21.0.in, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>, <4 x i8> %.sroa.0.0.vec.insert
  %.sroa.0290.3 = select i1 %.reg2mem21.0.in, <4 x i8> %.sroa.0290.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0290.1.vec.insert = insertelement <4 x i8> %.sroa.0290.3, i8 65, i64 1
  %.sroa.0.1.vec.insert = insertelement <4 x i8> %.sroa.0.3, i8 65, i64 1
  %.sroa.0.2 = select i1 %.reg2mem21.0.in, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>, <4 x i8> %.sroa.0.1.vec.insert
  %.fca.2.extract = select i1 %.reg2mem21.0.in, i8 83, i8 73
  %.sroa.0290.2 = select i1 %.reg2mem21.0.in, <4 x i8> %.sroa.0290.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0290.2.vec.insert = insertelement <4 x i8> %.sroa.0290.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.2.vec.insert = insertelement <4 x i8> %.sroa.0.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.1 = select i1 %.reg2mem21.0.in, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>, <4 x i8> %.sroa.0.2.vec.insert
  %.fca.3.extract = select i1 %.reg2mem21.0.in, i8 83, i8 76
  %.sroa.0290.1 = select i1 %.reg2mem21.0.in, <4 x i8> %.sroa.0290.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0290.3.vec.insert = insertelement <4 x i8> %.sroa.0290.1, i8 %.fca.3.extract, i64 3
  %.sroa.0.3.vec.insert = insertelement <4 x i8> %.sroa.0.1, i8 %.fca.3.extract, i64 3
  %.sroa.speculated289 = select i1 %.reg2mem21.0.in, <4 x i8> %.sroa.0290.3.vec.insert, <4 x i8> %.sroa.0.3.vec.insert
  store <4 x i8> %.sroa.speculated289, ptr %243, align 1
  store ptr @String, ptr %242, align 8
  %244 = call { i64, i64 } @size_wrapper(ptr %200, ptr noundef nonnull align 8 dereferenceable(8) %242)
  %245 = extractvalue { i64, i64 } %244, 0
  %246 = call ptr @bump_malloc(i64 %245)
  br i1 %.reg2mem21.0.in, label %.cont, label %.else

.else:                                            ; preds = %.cont256
  br label %.cont

.cont:                                            ; preds = %.else, %.cont256
  %247 = phi ptr [ %30, %.else ], [ %25, %.cont256 ]
  %248 = phi ptr [ %29, %.else ], [ %24, %.cont256 ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %.else ], [ %.sroa.gep434, %.cont256 ]
  %.sroa.phi435 = phi ptr [ %.sroa.gep436, %.else ], [ %.sroa.gep437, %.cont256 ]
  %.sroa.phi438 = phi ptr [ %.sroa.gep439, %.else ], [ %.sroa.gep440, %.cont256 ]
  %249 = phi ptr [ %28, %.else ], [ %23, %.cont256 ]
  %.sroa.phi441 = phi ptr [ %.sroa.gep442, %.else ], [ %.sroa.gep443, %.cont256 ]
  %.sroa.phi444 = phi ptr [ %.sroa.gep445, %.else ], [ %.sroa.gep446, %.cont256 ]
  %.sroa.phi447 = phi ptr [ %.sroa.gep448, %.else ], [ %.sroa.gep449, %.cont256 ]
  %250 = phi ptr [ %27, %.else ], [ %22, %.cont256 ]
  %251 = insertvalue { ptr } undef, ptr %243, 0
  %252 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %246, 1
  %253 = insertvalue { ptr, ptr, ptr, i32 } %252, ptr undef, 2
  %254 = insertvalue { ptr, ptr, ptr, i32 } %253, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %250, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi441, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi444, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi447, align 8
  %255 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %250)
  %256 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %249, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi435, align 8
  store ptr @i32_typ, ptr %.sroa.phi438, align 8
  %257 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %254, ptr noundef nonnull align 8 dereferenceable(32) %249)
  call void %257({ ptr, ptr, ptr, i32 } %254, { ptr, ptr, ptr, i32 } %254, ptr nonnull %250, { ptr } %251, i32 4, i32 4, i32 5)
  %258 = ptrtoint ptr %246 to i64
  %.sroa.3264.8.insert.ext = zext i64 %258 to i160
  %.sroa.3264.8.insert.insert = or disjoint i160 %.sroa.3264.8.insert.ext, 3402823669209384634633746074317682114560
  %259 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3264.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %248, align 8
  %260 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %248)
  %261 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %247, align 8
  %262 = call ptr @class_behavior_wrapper(ptr %240, ptr noundef nonnull align 8 dereferenceable(8) %247)
  call void %262(ptr nonnull %248, { ptr, i160 } %259)
  %263 = call ptr @bump_malloc(i64 noundef 28)
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %263, align 1
  store ptr @String, ptr %31, align 8
  %264 = call { i64, i64 } @size_wrapper(ptr %200, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %265 = extractvalue { i64, i64 } %264, 0
  %266 = call ptr @bump_malloc(i64 %265)
  %267 = insertvalue { ptr } undef, ptr %263, 0
  %268 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %266, 1
  %269 = insertvalue { ptr, ptr, ptr, i32 } %268, ptr undef, 2
  %270 = insertvalue { ptr, ptr, ptr, i32 } %269, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %32, align 8
  %271 = getelementptr inbounds i8, ptr %32, i64 8
  store ptr @_parameterization_i32, ptr %271, align 8
  %272 = getelementptr inbounds i8, ptr %32, i64 16
  store ptr @_parameterization_i32, ptr %272, align 8
  %273 = getelementptr inbounds i8, ptr %32, i64 24
  store ptr @_parameterization_i32, ptr %273, align 8
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %32)
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %33, align 8
  %276 = getelementptr inbounds i8, ptr %33, i64 8
  store ptr @i32_typ, ptr %276, align 8
  %277 = getelementptr inbounds i8, ptr %33, i64 16
  store ptr @i32_typ, ptr %277, align 8
  %278 = getelementptr inbounds i8, ptr %33, i64 24
  store ptr @i32_typ, ptr %278, align 8
  %279 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %270, ptr noundef nonnull align 8 dereferenceable(32) %33)
  call void %279({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } %270, ptr nonnull %32, { ptr } %267, i32 27, i32 27, i32 28)
  %280 = ptrtoint ptr %266 to i64
  %.sroa.3112.8.insert.ext = zext i64 %280 to i160
  %.sroa.3112.8.insert.insert = or disjoint i160 %.sroa.3112.8.insert.ext, 3402823669209384634633746074317682114560
  %281 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3112.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %34, align 8
  %282 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %283 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %35, align 8
  %284 = call ptr @class_behavior_wrapper(ptr %240, ptr noundef nonnull align 8 dereferenceable(8) %35)
  call void %284(ptr nonnull %34, { ptr, i160 } %281)
  %.sroa.0106.0.insert.ext = zext i32 %156 to i160
  %285 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0106.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %36, align 8
  %286 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  %287 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %37, align 8
  %288 = call ptr @class_behavior_wrapper(ptr %240, ptr noundef nonnull align 8 dereferenceable(8) %37)
  call void %288(ptr nonnull %36, { ptr, i160 } %285)
  %289 = call ptr @bump_malloc(i64 noundef 2)
  store <1 x i8> <i8 41>, ptr %289, align 1
  store ptr @String, ptr %38, align 8
  %290 = call { i64, i64 } @size_wrapper(ptr %200, ptr noundef nonnull align 8 dereferenceable(8) %38)
  %291 = extractvalue { i64, i64 } %290, 0
  %292 = call ptr @bump_malloc(i64 %291)
  %293 = insertvalue { ptr } undef, ptr %289, 0
  %294 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %292, 1
  %295 = insertvalue { ptr, ptr, ptr, i32 } %294, ptr undef, 2
  %296 = insertvalue { ptr, ptr, ptr, i32 } %295, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %39, align 8
  %297 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @_parameterization_i32, ptr %297, align 8
  %298 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @_parameterization_i32, ptr %298, align 8
  %299 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr @_parameterization_i32, ptr %299, align 8
  %300 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %39)
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %40, align 8
  %302 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr @i32_typ, ptr %302, align 8
  %303 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr @i32_typ, ptr %303, align 8
  %304 = getelementptr inbounds i8, ptr %40, i64 24
  store ptr @i32_typ, ptr %304, align 8
  %305 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %296, ptr noundef nonnull align 8 dereferenceable(32) %40)
  call void %305({ ptr, ptr, ptr, i32 } %296, { ptr, ptr, ptr, i32 } %296, ptr nonnull %39, { ptr } %293, i32 1, i32 1, i32 2)
  %306 = ptrtoint ptr %292 to i64
  %.sroa.3.8.insert.ext = zext i64 %306 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %307 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %41, align 8
  %308 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %42, align 8
  %310 = call ptr @class_behavior_wrapper(ptr %240, ptr noundef nonnull align 8 dereferenceable(8) %42)
  call void %310(ptr nonnull %41, { ptr, i160 } %307)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [2 x ptr], align 8
  %3 = alloca { ptr, ptr }, align 8
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca [4 x ptr], align 8
  %15 = alloca { ptr, ptr, ptr, ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca [4 x ptr], align 8
  %18 = alloca { ptr, ptr, ptr, ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca [4 x ptr], align 8
  %23 = alloca { ptr, ptr, ptr, ptr }, align 8
  %24 = alloca [1 x ptr], align 8
  %25 = alloca { ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca [4 x ptr], align 8
  %28 = alloca { ptr, ptr, ptr, ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %31, i64 8
  store ptr @_parameterization_i32, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %31, i64 16
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %31, i64 24
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %34, align 8
  %35 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 48), align 8
  %36 = call { i64, i64 } @size_wrapper(ptr %35, ptr noundef nonnull align 8 dereferenceable(32) %31)
  %37 = extractvalue { i64, i64 } %36, 0
  %38 = call ptr @bump_malloc(i64 %37)
  store ptr @_parameterization_i32, ptr %38, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  store ptr @_parameterization_i32, ptr %39, align 8
  %40 = getelementptr i8, ptr %38, i64 16
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %38)
  %42 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %42)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %42, ptr noalias nofree noundef nonnull readnone @xehcsxgghh, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %43 = call ptr @adjust_trampoline(ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %42)
  %45 = insertvalue { ptr } undef, ptr %43, 0
  %46 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %46)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %46, ptr noalias nofree noundef nonnull readnone @ylighrwwhd, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %47 = call ptr @adjust_trampoline(ptr %46)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %46)
  %49 = insertvalue { ptr } undef, ptr %47, 0
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %38, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 10, 3
  %53 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %53, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %54, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %53)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %57 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 240), align 8
  %58 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %58, i64 8
  store ptr @function_typ, ptr %59, align 8
  %60 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 dereferenceable(16) %58)
  call void %60({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %53, { ptr } %45, { ptr } %49)
  %.sroa.gep = getelementptr inbounds i8, ptr %28, i64 8
  %.sroa.gep316 = getelementptr inbounds i8, ptr %28, i64 16
  %.sroa.gep319 = getelementptr inbounds i8, ptr %28, i64 24
  %.sroa.gep322 = getelementptr inbounds i8, ptr %27, i64 8
  %.sroa.gep325 = getelementptr inbounds i8, ptr %27, i64 16
  %.sroa.gep328 = getelementptr inbounds i8, ptr %27, i64 24
  %61 = getelementptr inbounds i8, ptr %2, i64 8
  %62 = getelementptr inbounds i8, ptr %3, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %1
  %.0298 = phi i64 [ 0, %1 ], [ %.1299, %._crit_edge ]
  %.0 = phi i32 [ 0, %1 ], [ %.1, %._crit_edge ]
  %63 = icmp slt i32 %.0, %0
  br i1 %63, label %64, label %._crit_edge

64:                                               ; preds = %._crit_edge1
  %65 = add nsw i32 %.0, 1
  %.sroa.0292.0.insert.ext = zext i32 %.0 to i160
  %66 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0292.0.insert.ext, 1
  %.sroa.0289.0.insert.ext = zext i32 %65 to i160
  %67 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0289.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %2, align 8
  store ptr @_parameterization_i32, ptr %61, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %2)
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %70 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 256), align 8
  store ptr @i32_typ, ptr %3, align 8
  store ptr @i32_typ, ptr %62, align 8
  %71 = call ptr @behavior_wrapper(ptr %70, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 dereferenceable(16) %3)
  call void %71({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %2, { ptr, i160 } %66, { ptr, i160 } %67)
  %72 = sext i32 %65 to i64
  %73 = add i64 %.0298, %72
  br label %._crit_edge

._crit_edge:                                      ; preds = %64, %._crit_edge1
  %.1299 = phi i64 [ %73, %64 ], [ %.0298, %._crit_edge1 ]
  %.1 = phi i32 [ %65, %64 ], [ %.0, %._crit_edge1 ]
  br i1 %63, label %._crit_edge1, label %74

74:                                               ; preds = %._crit_edge
  %.sroa.gep314 = getelementptr inbounds i8, ptr %23, i64 8
  %.sroa.gep320 = getelementptr inbounds i8, ptr %23, i64 24
  %.sroa.gep326 = getelementptr inbounds i8, ptr %22, i64 16
  %75 = call i64 @clock()
  %76 = getelementptr inbounds i8, ptr %7, i64 8
  %77 = getelementptr inbounds i8, ptr %7, i64 16
  %78 = getelementptr inbounds i8, ptr %7, i64 24
  %79 = getelementptr inbounds i8, ptr %8, i64 8
  %80 = getelementptr inbounds i8, ptr %8, i64 16
  %81 = getelementptr inbounds i8, ptr %8, i64 24
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge2, %74
  %.0303 = phi i1 [ true, %74 ], [ %.2305, %._crit_edge2 ]
  %.0300 = phi i64 [ 0, %74 ], [ %.2302, %._crit_edge2 ]
  %.2 = phi i32 [ 0, %74 ], [ %.3, %._crit_edge2 ]
  %82 = icmp slt i32 %.2, %0
  br i1 %82, label %83, label %._crit_edge2

83:                                               ; preds = %._crit_edge3
  %.sroa.0276.0.insert.ext = zext i32 %.2 to i160
  %84 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0276.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %4, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %87 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %5, align 8
  %88 = call ptr @behavior_wrapper(ptr %87, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %89 = call { ptr, i160 } %88({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %4, { ptr, i160 } %84)
  %.fca.0.extract272 = extractvalue { ptr, i160 } %89, 0
  %90 = icmp ne ptr %.fca.0.extract272, @nil_typ
  %91 = icmp ne ptr %.fca.0.extract272, null
  %.not313 = and i1 %90, %91
  br i1 %.not313, label %92, label %95

92:                                               ; preds = %83
  %.fca.1.extract273 = extractvalue { ptr, i160 } %89, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract273 to i32
  %93 = sext i32 %.sroa.2.8.extract.trunc to i64
  %94 = add i64 %.0300, %93
  br label %118

95:                                               ; preds = %83
  %96 = call ptr @bump_malloc(i64 noundef 56)
  store <55 x i8> <i8 69, i8 114, i8 114, i8 111, i8 114, i8 58, i8 32, i8 78, i8 105, i8 108, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %96, align 1
  store ptr @String, ptr %6, align 8
  %97 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %98 = call { i64, i64 } @size_wrapper(ptr %97, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %99 = extractvalue { i64, i64 } %98, 0
  %100 = call ptr @bump_malloc(i64 %99)
  %101 = insertvalue { ptr } undef, ptr %96, 0
  %102 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %100, 1
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr undef, 2
  %104 = insertvalue { ptr, ptr, ptr, i32 } %103, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %76, align 8
  store ptr @_parameterization_i32, ptr %77, align 8
  store ptr @_parameterization_i32, ptr %78, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %107 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %79, align 8
  store ptr @i32_typ, ptr %80, align 8
  store ptr @i32_typ, ptr %81, align 8
  %108 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %104, ptr noundef nonnull align 8 dereferenceable(32) %8)
  call void %108({ ptr, ptr, ptr, i32 } %104, { ptr, ptr, ptr, i32 } %104, ptr nonnull %7, { ptr } %101, i32 55, i32 55, i32 56)
  %109 = ptrtoint ptr %100 to i64
  %.sroa.3249.8.insert.ext = zext i64 %109 to i160
  %.sroa.3249.8.insert.insert = or disjoint i160 %.sroa.3249.8.insert.ext, 3402823669209384634633746074317682114560
  %110 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3249.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %9, align 8
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %113 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %10, align 8
  %114 = call ptr @class_behavior_wrapper(ptr %113, ptr noundef nonnull align 8 dereferenceable(8) %10)
  call void %114(ptr nonnull %9, { ptr, i160 } %110)
  store ptr @_parameterization_i32, ptr %11, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %116 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %12, align 8
  %117 = call ptr @class_behavior_wrapper(ptr %113, ptr noundef nonnull align 8 dereferenceable(8) %12)
  call void %117(ptr nonnull %11, { ptr, i160 } %84)
  br label %118

118:                                              ; preds = %95, %92
  %.1304 = phi i1 [ %.0303, %92 ], [ false, %95 ]
  %.1301 = phi i64 [ %94, %92 ], [ %.0300, %95 ]
  %119 = add i32 %.2, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %118, %._crit_edge3
  %.2305 = phi i1 [ %.1304, %118 ], [ %.0303, %._crit_edge3 ]
  %.2302 = phi i64 [ %.1301, %118 ], [ %.0300, %._crit_edge3 ]
  %.3 = phi i32 [ %119, %118 ], [ %.2, %._crit_edge3 ]
  br i1 %82, label %._crit_edge3, label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge2
  %.sroa.gep317 = getelementptr inbounds i8, ptr %23, i64 16
  %.sroa.gep323 = getelementptr inbounds i8, ptr %22, i64 8
  %.sroa.gep329 = getelementptr inbounds i8, ptr %22, i64 24
  %120 = call i64 @clock()
  %.not = icmp eq i64 %.2302, %.1299
  %spec.select = select i1 %.not, i1 %.2305, i1 false
  %121 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %121, align 1
  store ptr @String, ptr %13, align 8
  %122 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %123 = call { i64, i64 } @size_wrapper(ptr %122, ptr noundef nonnull align 8 dereferenceable(8) %13)
  %124 = extractvalue { i64, i64 } %123, 0
  %125 = call ptr @bump_malloc(i64 %124)
  %126 = insertvalue { ptr } undef, ptr %121, 0
  %127 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %125, 1
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, ptr undef, 2
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %14, align 8
  %130 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_i32, ptr %130, align 8
  %131 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr @_parameterization_i32, ptr %131, align 8
  %132 = getelementptr inbounds i8, ptr %14, i64 24
  store ptr @_parameterization_i32, ptr %132, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %14)
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %135 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %15, align 8
  %136 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @i32_typ, ptr %136, align 8
  %137 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @i32_typ, ptr %137, align 8
  %138 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @i32_typ, ptr %138, align 8
  %139 = call ptr @behavior_wrapper(ptr %135, { ptr, ptr, ptr, i32 } %129, ptr noundef nonnull align 8 dereferenceable(32) %15)
  call void %139({ ptr, ptr, ptr, i32 } %129, { ptr, ptr, ptr, i32 } %129, ptr nonnull %14, { ptr } %126, i32 18, i32 18, i32 19)
  %140 = sub i64 %120, %75
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %129, i32 %0, i64 %140)
  %141 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %141, align 1
  store ptr @String, ptr %16, align 8
  %142 = call { i64, i64 } @size_wrapper(ptr %122, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %143 = extractvalue { i64, i64 } %142, 0
  %144 = call ptr @bump_malloc(i64 %143)
  %145 = insertvalue { ptr } undef, ptr %141, 0
  %146 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %144, 1
  %147 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr undef, 2
  %148 = insertvalue { ptr, ptr, ptr, i32 } %147, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %149 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %149, align 8
  %150 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %150, align 8
  %151 = getelementptr inbounds i8, ptr %17, i64 24
  store ptr @_parameterization_i32, ptr %151, align 8
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %17)
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %18, align 8
  %154 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @i32_typ, ptr %154, align 8
  %155 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @i32_typ, ptr %155, align 8
  %156 = getelementptr inbounds i8, ptr %18, i64 24
  store ptr @i32_typ, ptr %156, align 8
  %157 = call ptr @behavior_wrapper(ptr %135, { ptr, ptr, ptr, i32 } %148, ptr noundef nonnull align 8 dereferenceable(32) %18)
  call void %157({ ptr, ptr, ptr, i32 } %148, { ptr, ptr, ptr, i32 } %148, ptr nonnull %17, { ptr } %145, i32 18, i32 18, i32 19)
  %158 = ptrtoint ptr %144 to i64
  %.sroa.3201.8.insert.ext = zext i64 %158 to i160
  %.sroa.3201.8.insert.insert = or disjoint i160 %.sroa.3201.8.insert.ext, 3402823669209384634633746074317682114560
  %159 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3201.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %19, align 8
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %162 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %20, align 8
  %163 = call ptr @class_behavior_wrapper(ptr %162, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %163(ptr nonnull %19, { ptr, i160 } %159)
  %164 = select i1 %spec.select, ptr %21, ptr %26
  %165 = call ptr @bump_malloc(i64 noundef 5)
  %.fca.0.extract = select i1 %spec.select, i8 80, i8 70
  %.sroa.0191.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.3 = select i1 %spec.select, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>, <4 x i8> %.sroa.0.0.vec.insert
  %.sroa.0191.3 = select i1 %spec.select, <4 x i8> %.sroa.0191.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0191.1.vec.insert = insertelement <4 x i8> %.sroa.0191.3, i8 65, i64 1
  %.sroa.0.1.vec.insert = insertelement <4 x i8> %.sroa.0.3, i8 65, i64 1
  %.sroa.0.2 = select i1 %spec.select, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>, <4 x i8> %.sroa.0.1.vec.insert
  %.fca.2.extract = select i1 %spec.select, i8 83, i8 73
  %.sroa.0191.2 = select i1 %spec.select, <4 x i8> %.sroa.0191.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0191.2.vec.insert = insertelement <4 x i8> %.sroa.0191.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.2.vec.insert = insertelement <4 x i8> %.sroa.0.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.1 = select i1 %spec.select, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>, <4 x i8> %.sroa.0.2.vec.insert
  %.fca.3.extract = select i1 %spec.select, i8 83, i8 76
  %.sroa.0191.1 = select i1 %spec.select, <4 x i8> %.sroa.0191.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0191.3.vec.insert = insertelement <4 x i8> %.sroa.0191.1, i8 %.fca.3.extract, i64 3
  %.sroa.0.3.vec.insert = insertelement <4 x i8> %.sroa.0.1, i8 %.fca.3.extract, i64 3
  %.sroa.speculated190 = select i1 %spec.select, <4 x i8> %.sroa.0191.3.vec.insert, <4 x i8> %.sroa.0.3.vec.insert
  store <4 x i8> %.sroa.speculated190, ptr %165, align 1
  store ptr @String, ptr %164, align 8
  %166 = call { i64, i64 } @size_wrapper(ptr %122, ptr noundef nonnull align 8 dereferenceable(8) %164)
  %167 = extractvalue { i64, i64 } %166, 0
  %168 = call ptr @bump_malloc(i64 %167)
  br i1 %spec.select, label %._crit_edge4.cont, label %._crit_edge4.else

._crit_edge4.else:                                ; preds = %._crit_edge4
  br label %._crit_edge4.cont

._crit_edge4.cont:                                ; preds = %._crit_edge4.else, %._crit_edge4
  %169 = phi ptr [ %30, %._crit_edge4.else ], [ %25, %._crit_edge4 ]
  %170 = phi ptr [ %29, %._crit_edge4.else ], [ %24, %._crit_edge4 ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %._crit_edge4.else ], [ %.sroa.gep314, %._crit_edge4 ]
  %.sroa.phi315 = phi ptr [ %.sroa.gep316, %._crit_edge4.else ], [ %.sroa.gep317, %._crit_edge4 ]
  %.sroa.phi318 = phi ptr [ %.sroa.gep319, %._crit_edge4.else ], [ %.sroa.gep320, %._crit_edge4 ]
  %171 = phi ptr [ %28, %._crit_edge4.else ], [ %23, %._crit_edge4 ]
  %.sroa.phi321 = phi ptr [ %.sroa.gep322, %._crit_edge4.else ], [ %.sroa.gep323, %._crit_edge4 ]
  %.sroa.phi324 = phi ptr [ %.sroa.gep325, %._crit_edge4.else ], [ %.sroa.gep326, %._crit_edge4 ]
  %.sroa.phi327 = phi ptr [ %.sroa.gep328, %._crit_edge4.else ], [ %.sroa.gep329, %._crit_edge4 ]
  %172 = phi ptr [ %27, %._crit_edge4.else ], [ %22, %._crit_edge4 ]
  %173 = insertvalue { ptr } undef, ptr %165, 0
  %174 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %168, 1
  %175 = insertvalue { ptr, ptr, ptr, i32 } %174, ptr undef, 2
  %176 = insertvalue { ptr, ptr, ptr, i32 } %175, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %172, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi321, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi324, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi327, align 8
  %177 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %172)
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %171, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi315, align 8
  store ptr @i32_typ, ptr %.sroa.phi318, align 8
  %179 = call ptr @behavior_wrapper(ptr %135, { ptr, ptr, ptr, i32 } %176, ptr noundef nonnull align 8 dereferenceable(32) %171)
  call void %179({ ptr, ptr, ptr, i32 } %176, { ptr, ptr, ptr, i32 } %176, ptr nonnull %172, { ptr } %173, i32 4, i32 4, i32 5)
  %180 = ptrtoint ptr %168 to i64
  %.sroa.3.8.insert.ext = zext i64 %180 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %181 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %170, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %170)
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %169, align 8
  %184 = call ptr @class_behavior_wrapper(ptr %162, ptr noundef nonnull align 8 dereferenceable(8) %169)
  call void %184(ptr nonnull %170, { ptr, i160 } %181)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %.sroa.0393.sroa.0 = alloca i8, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca [4 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca [4 x ptr], align 8
  %20 = alloca { ptr, ptr, ptr, ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca [4 x ptr], align 8
  %29 = alloca { ptr, ptr, ptr, ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca { ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca [4 x ptr], align 8
  %36 = alloca { ptr, ptr, ptr, ptr }, align 8
  %37 = alloca [1 x ptr], align 8
  %38 = alloca [4 x ptr], align 8
  %39 = alloca { ptr, ptr, ptr, ptr }, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca { ptr }, align 8
  %42 = alloca [1 x ptr], align 8
  %43 = alloca [4 x ptr], align 8
  %44 = alloca { ptr, ptr, ptr, ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca { ptr }, align 8
  %47 = alloca [1 x ptr], align 8
  %48 = alloca [4 x ptr], align 8
  %49 = alloca { ptr, ptr, ptr, ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 16
  store ptr @_parameterization_i32, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %52, i64 24
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %55, align 8
  %56 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 48), align 8
  %57 = call { i64, i64 } @size_wrapper(ptr %56, ptr noundef nonnull align 8 dereferenceable(32) %52)
  %58 = extractvalue { i64, i64 } %57, 0
  %59 = call ptr @bump_malloc(i64 %58)
  store ptr @_parameterization_i32, ptr %59, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  store ptr @_parameterization_i32, ptr %60, align 8
  %61 = getelementptr i8, ptr %59, i64 16
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %61, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %59)
  %63 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %63)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %63, ptr noalias nofree noundef nonnull readnone @ooeaxdzlkj, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %64 = call ptr @adjust_trampoline(ptr %63)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %63)
  %66 = insertvalue { ptr } undef, ptr %64, 0
  %67 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %67)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %67, ptr noalias nofree noundef nonnull readnone @qarfwzkrsv, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %68 = call ptr @adjust_trampoline(ptr %67)
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %67)
  %70 = insertvalue { ptr } undef, ptr %68, 0
  %71 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %59, 1
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr undef, 2
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, i32 10, 3
  %74 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %74, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %75, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %74)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %78 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 240), align 8
  %79 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr @function_typ, ptr %80, align 8
  %81 = call ptr @behavior_wrapper(ptr %78, { ptr, ptr, ptr, i32 } %73, ptr noundef nonnull align 8 dereferenceable(16) %79)
  call void %81({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull %74, { ptr } %66, { ptr } %70)
  %82 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %82, align 8
  %83 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %82)
  %84 = extractvalue { i64, i64 } %83, 0
  %85 = call ptr @bump_malloc(i64 %84)
  %86 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %85, 1
  %87 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr undef, 2
  %88 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 10, 3
  %89 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %92 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %92, align 8
  %93 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 dereferenceable(8) %92)
  call void %93({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull %89, i32 456)
  %94 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %94, i64 8
  store ptr @_parameterization_i32, ptr %95, align 8
  %96 = load ptr, ptr getelementptr (i8, ptr @Array, i64 48), align 8
  %97 = call { i64, i64 } @size_wrapper(ptr %96, ptr noundef nonnull align 8 dereferenceable(16) %94)
  %98 = extractvalue { i64, i64 } %97, 0
  %99 = call ptr @bump_malloc(i64 %98)
  store ptr @_parameterization_i32, ptr %99, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %99)
  %101 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %99, 1
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, ptr undef, 2
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 10, 3
  %104 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %104)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %107 = load ptr, ptr getelementptr (i8, ptr @Array, i64 136), align 8
  %108 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %108, align 8
  %109 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 dereferenceable(8) %108)
  call void %109({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull %104, i32 %0)
  %110 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr @_parameterization_i32, ptr %111, align 8
  %112 = getelementptr inbounds i8, ptr %110, i64 16
  store ptr @_parameterization_Bool, ptr %112, align 8
  %113 = getelementptr inbounds i8, ptr %110, i64 24
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %113, align 8
  %114 = call { i64, i64 } @size_wrapper(ptr %56, ptr noundef nonnull align 8 dereferenceable(32) %110)
  %115 = extractvalue { i64, i64 } %114, 0
  %116 = call ptr @bump_malloc(i64 %115)
  store ptr @_parameterization_i32, ptr %116, align 8
  %117 = getelementptr i8, ptr %116, i64 8
  store ptr @_parameterization_Bool, ptr %117, align 8
  %118 = getelementptr i8, ptr %116, i64 16
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %118, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %116)
  %120 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %120)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %120, ptr noalias nofree noundef nonnull readnone @pdosxztqjt, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %121 = call ptr @adjust_trampoline(ptr %120)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %120)
  %123 = insertvalue { ptr } undef, ptr %121, 0
  %124 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %124)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %124, ptr noalias nofree noundef nonnull readnone @oxrtkwaxjb, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %125 = call ptr @adjust_trampoline(ptr %124)
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %124)
  %127 = insertvalue { ptr } undef, ptr %125, 0
  %128 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %116, 1
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr undef, 2
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 10, 3
  %131 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %131, align 8
  %132 = getelementptr inbounds i8, ptr %131, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %132, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %131)
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %135 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %135, align 8
  %136 = getelementptr inbounds i8, ptr %135, i64 8
  store ptr @function_typ, ptr %136, align 8
  %137 = call ptr @behavior_wrapper(ptr %78, { ptr, ptr, ptr, i32 } %130, ptr noundef nonnull align 8 dereferenceable(16) %135)
  call void %137({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull %131, { ptr } %123, { ptr } %127)
  %138 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %49, i64 8
  %.sroa.gep457 = getelementptr inbounds i8, ptr %49, i64 16
  %.sroa.gep460 = getelementptr inbounds i8, ptr %49, i64 24
  %.sroa.gep463 = getelementptr inbounds i8, ptr %48, i64 8
  %.sroa.gep466 = getelementptr inbounds i8, ptr %48, i64 16
  %.sroa.gep469 = getelementptr inbounds i8, ptr %48, i64 24
  %139 = getelementptr inbounds i8, ptr %5, i64 8
  %140 = getelementptr inbounds i8, ptr %6, i64 8
  %141 = getelementptr inbounds i8, ptr %7, i64 8
  %142 = getelementptr inbounds i8, ptr %8, i64 8
  %143 = getelementptr inbounds i8, ptr %9, i64 8
  %144 = getelementptr inbounds i8, ptr %10, i64 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge1, %1
  %.0444 = phi i64 [ 0, %1 ], [ %.2446, %._crit_edge1 ]
  %.0432 = phi i32 [ 0, %1 ], [ %.2, %._crit_edge1 ]
  %.0431 = phi i32 [ 0, %1 ], [ %.1, %._crit_edge1 ]
  %145 = icmp slt i32 %.0432, %0
  %146 = icmp slt i32 %.0431, %138
  %spec.select = select i1 %145, i1 %146, i1 false
  br i1 %spec.select, label %147, label %._crit_edge1

147:                                              ; preds = %._crit_edge3
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %150 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 %2)
  %151 = call i32 %150({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull %2)
  %.sroa.0421.0.insert.ext = zext i32 %151 to i160
  %152 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0421.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %155 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %4, align 8
  %156 = call ptr @behavior_wrapper(ptr %155, { ptr, ptr, ptr, i32 } %130, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %157 = call { ptr, i160 } %156({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull %3, { ptr, i160 } %152)
  %.fca.0.extract413 = extractvalue { ptr, i160 } %157, 0
  %158 = icmp eq ptr %.fca.0.extract413, @nil_typ
  %159 = icmp eq ptr %.fca.0.extract413, null
  %160 = or i1 %158, %159
  br i1 %160, label %161, label %._crit_edge2

161:                                              ; preds = %147
  %162 = add i32 %151, 1
  %.sroa.0403.0.insert.ext = zext i32 %162 to i160
  %163 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0403.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %139, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %166 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 256), align 8
  store ptr @i32_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %140, align 8
  %167 = call ptr @behavior_wrapper(ptr %166, { ptr, ptr, ptr, i32 } %73, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %167({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull %5, { ptr, i160 } %152, { ptr, i160 } %163)
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %141, align 8
  %168 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %170 = load ptr, ptr getelementptr (i8, ptr @Array, i64 176), align 8
  store ptr @i32_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %142, align 8
  %171 = call ptr @behavior_wrapper(ptr %170, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %171({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull %7, i32 %.0432, { ptr, i160 } %152)
  store i1 true, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. = load i8, ptr %.sroa.0393.sroa.0, align 8
  %.sroa.0393.0.insert.ext = zext i8 %.sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.sroa.0.0..sroa.0393.0. to i160
  %172 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0393.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %9, align 8
  store ptr @_parameterization_Bool, ptr %143, align 8
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  store ptr @i32_typ, ptr %10, align 8
  store ptr @bool_typ, ptr %144, align 8
  %175 = call ptr @behavior_wrapper(ptr %166, { ptr, ptr, ptr, i32 } %130, ptr noundef nonnull align 8 dereferenceable(16) %10)
  call void %175({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull %9, { ptr, i160 } %152, { ptr, i160 } %172)
  %176 = sext i32 %162 to i64
  %177 = add i64 %.0444, %176
  %178 = add nsw i32 %.0432, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %161, %147
  %.1445 = phi i64 [ %177, %161 ], [ %.0444, %147 ]
  %.1433 = phi i32 [ %178, %161 ], [ %.0432, %147 ]
  %179 = add i32 %.0431, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge2, %._crit_edge3
  %.2446 = phi i64 [ %.1445, %._crit_edge2 ], [ %.0444, %._crit_edge3 ]
  %.2 = phi i32 [ %.1433, %._crit_edge2 ], [ %.0432, %._crit_edge3 ]
  %.1 = phi i32 [ %179, %._crit_edge2 ], [ %.0431, %._crit_edge3 ]
  br i1 %spec.select, label %._crit_edge3, label %180

180:                                              ; preds = %._crit_edge1
  %.sroa.gep455 = getelementptr inbounds i8, ptr %44, i64 8
  %.sroa.gep458 = getelementptr inbounds i8, ptr %44, i64 16
  %.sroa.gep461 = getelementptr inbounds i8, ptr %44, i64 24
  %.sroa.gep464 = getelementptr inbounds i8, ptr %43, i64 8
  %.sroa.gep467 = getelementptr inbounds i8, ptr %43, i64 16
  %.sroa.gep470 = getelementptr inbounds i8, ptr %43, i64 24
  %181 = icmp slt i32 %.2, %0
  br i1 %181, label %182, label %._crit_edge4

182:                                              ; preds = %180
  %183 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %183, align 1
  store ptr @String, ptr %11, align 8
  %184 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %185 = call { i64, i64 } @size_wrapper(ptr %184, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %186 = extractvalue { i64, i64 } %185, 0
  %187 = call ptr @bump_malloc(i64 %186)
  %188 = insertvalue { ptr } undef, ptr %183, 0
  %189 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %187, 1
  %190 = insertvalue { ptr, ptr, ptr, i32 } %189, ptr undef, 2
  %191 = insertvalue { ptr, ptr, ptr, i32 } %190, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %12, align 8
  %192 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @_parameterization_i32, ptr %192, align 8
  %193 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %193, align 8
  %194 = getelementptr inbounds i8, ptr %12, i64 24
  store ptr @_parameterization_i32, ptr %194, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %12)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %197 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %13, align 8
  %198 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr @i32_typ, ptr %198, align 8
  %199 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %199, align 8
  %200 = getelementptr inbounds i8, ptr %13, i64 24
  store ptr @i32_typ, ptr %200, align 8
  %201 = call ptr @behavior_wrapper(ptr %197, { ptr, ptr, ptr, i32 } %191, ptr noundef nonnull align 8 dereferenceable(32) %13)
  call void %201({ ptr, ptr, ptr, i32 } %191, { ptr, ptr, ptr, i32 } %191, ptr nonnull %12, { ptr } %188, i32 29, i32 29, i32 30)
  %202 = ptrtoint ptr %187 to i64
  %.sroa.3372.8.insert.ext = zext i64 %202 to i160
  %.sroa.3372.8.insert.insert = or disjoint i160 %.sroa.3372.8.insert.ext, 3402823669209384634633746074317682114560
  %203 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3372.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %14, align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %206 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %15, align 8
  %207 = call ptr @class_behavior_wrapper(ptr %206, ptr noundef nonnull align 8 dereferenceable(8) %15)
  call void %207(ptr nonnull %14, { ptr, i160 } %203)
  %.sroa.0365.0.insert.ext = zext i32 %.2 to i160
  %208 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0365.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %16, align 8
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %210 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %17, align 8
  %211 = call ptr @class_behavior_wrapper(ptr %206, ptr noundef nonnull align 8 dereferenceable(8) %17)
  call void %211(ptr nonnull %16, { ptr, i160 } %208)
  %212 = call ptr @bump_malloc(i64 noundef 34)
  store <33 x i8> <i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %212, align 1
  store ptr @String, ptr %18, align 8
  %213 = call { i64, i64 } @size_wrapper(ptr %184, ptr noundef nonnull align 8 dereferenceable(8) %18)
  %214 = extractvalue { i64, i64 } %213, 0
  %215 = call ptr @bump_malloc(i64 %214)
  %216 = insertvalue { ptr } undef, ptr %212, 0
  %217 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %215, 1
  %218 = insertvalue { ptr, ptr, ptr, i32 } %217, ptr undef, 2
  %219 = insertvalue { ptr, ptr, ptr, i32 } %218, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %19, align 8
  %220 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr @_parameterization_i32, ptr %220, align 8
  %221 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr @_parameterization_i32, ptr %221, align 8
  %222 = getelementptr inbounds i8, ptr %19, i64 24
  store ptr @_parameterization_i32, ptr %222, align 8
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %19)
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %20, align 8
  %225 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @i32_typ, ptr %225, align 8
  %226 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr @i32_typ, ptr %226, align 8
  %227 = getelementptr inbounds i8, ptr %20, i64 24
  store ptr @i32_typ, ptr %227, align 8
  %228 = call ptr @behavior_wrapper(ptr %197, { ptr, ptr, ptr, i32 } %219, ptr noundef nonnull align 8 dereferenceable(32) %20)
  call void %228({ ptr, ptr, ptr, i32 } %219, { ptr, ptr, ptr, i32 } %219, ptr nonnull %19, { ptr } %216, i32 33, i32 33, i32 34)
  %229 = ptrtoint ptr %215 to i64
  %.sroa.3351.8.insert.ext = zext i64 %229 to i160
  %.sroa.3351.8.insert.insert = or disjoint i160 %.sroa.3351.8.insert.ext, 3402823669209384634633746074317682114560
  %230 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3351.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %21, align 8
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %232 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %22, align 8
  %233 = call ptr @class_behavior_wrapper(ptr %206, ptr noundef nonnull align 8 dereferenceable(8) %22)
  call void %233(ptr nonnull %21, { ptr, i160 } %230)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %182, %180
  %.0449 = phi i32 [ %.2, %182 ], [ %0, %180 ]
  %234 = call i64 @clock()
  %235 = getelementptr inbounds i8, ptr %28, i64 8
  %236 = getelementptr inbounds i8, ptr %28, i64 16
  %237 = getelementptr inbounds i8, ptr %28, i64 24
  %238 = getelementptr inbounds i8, ptr %29, i64 8
  %239 = getelementptr inbounds i8, ptr %29, i64 16
  %240 = getelementptr inbounds i8, ptr %29, i64 24
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0440 = phi i32 [ 0, %._crit_edge4 ], [ %.1441, %._crit_edge5 ]
  %.0437 = phi i1 [ true, %._crit_edge4 ], [ %.2439, %._crit_edge5 ]
  %.0434 = phi i64 [ 0, %._crit_edge4 ], [ %.2436, %._crit_edge5 ]
  %241 = icmp slt i32 %.0440, %.0449
  br i1 %241, label %242, label %._crit_edge5

242:                                              ; preds = %._crit_edge6
  store ptr @_parameterization_i32, ptr %23, align 8
  %243 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %245 = load ptr, ptr getelementptr (i8, ptr @Array, i64 168), align 8
  store ptr @i32_typ, ptr %24, align 8
  %246 = call ptr @behavior_wrapper(ptr %245, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %247 = call { ptr, i160 } %246({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull %23, i32 %.0440)
  %.fca.1.extract335 = extractvalue { ptr, i160 } %247, 1
  %.sroa.0330.0.insert.ext = and i160 %.fca.1.extract335, 4294967295
  %248 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0330.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %25, align 8
  %249 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %250 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %251 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %26, align 8
  %252 = call ptr @behavior_wrapper(ptr %251, { ptr, ptr, ptr, i32 } %73, ptr noundef nonnull align 8 dereferenceable(8) %26)
  %253 = call { ptr, i160 } %252({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull %25, { ptr, i160 } %248)
  %.fca.0.extract326 = extractvalue { ptr, i160 } %253, 0
  %254 = icmp ne ptr %.fca.0.extract326, @nil_typ
  %255 = icmp ne ptr %.fca.0.extract326, null
  %.not453 = and i1 %254, %255
  br i1 %.not453, label %256, label %259

256:                                              ; preds = %242
  %.fca.1.extract327 = extractvalue { ptr, i160 } %253, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract327 to i32
  %257 = sext i32 %.sroa.2.8.extract.trunc to i64
  %258 = add i64 %.0434, %257
  br label %282

259:                                              ; preds = %242
  %260 = call ptr @bump_malloc(i64 noundef 52)
  store <51 x i8> <i8 69, i8 114, i8 114, i8 111, i8 114, i8 58, i8 32, i8 78, i8 105, i8 108, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 114, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 104, i8 105, i8 116, i8 32, i8 116, i8 101, i8 115, i8 116, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %260, align 1
  store ptr @String, ptr %27, align 8
  %261 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %262 = call { i64, i64 } @size_wrapper(ptr %261, ptr noundef nonnull align 8 dereferenceable(8) %27)
  %263 = extractvalue { i64, i64 } %262, 0
  %264 = call ptr @bump_malloc(i64 %263)
  %265 = insertvalue { ptr } undef, ptr %260, 0
  %266 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %264, 1
  %267 = insertvalue { ptr, ptr, ptr, i32 } %266, ptr undef, 2
  %268 = insertvalue { ptr, ptr, ptr, i32 } %267, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %28, align 8
  store ptr @_parameterization_i32, ptr %235, align 8
  store ptr @_parameterization_i32, ptr %236, align 8
  store ptr @_parameterization_i32, ptr %237, align 8
  %269 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %28)
  %270 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %271 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %29, align 8
  store ptr @i32_typ, ptr %238, align 8
  store ptr @i32_typ, ptr %239, align 8
  store ptr @i32_typ, ptr %240, align 8
  %272 = call ptr @behavior_wrapper(ptr %271, { ptr, ptr, ptr, i32 } %268, ptr noundef nonnull align 8 dereferenceable(32) %29)
  call void %272({ ptr, ptr, ptr, i32 } %268, { ptr, ptr, ptr, i32 } %268, ptr nonnull %28, { ptr } %265, i32 51, i32 51, i32 52)
  %273 = ptrtoint ptr %264 to i64
  %.sroa.3303.8.insert.ext = zext i64 %273 to i160
  %.sroa.3303.8.insert.insert = or disjoint i160 %.sroa.3303.8.insert.ext, 3402823669209384634633746074317682114560
  %274 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3303.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %30, align 8
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %277 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %31, align 8
  %278 = call ptr @class_behavior_wrapper(ptr %277, ptr noundef nonnull align 8 dereferenceable(8) %31)
  call void %278(ptr nonnull %30, { ptr, i160 } %274)
  store ptr @_parameterization_i32, ptr %32, align 8
  %279 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %33, align 8
  %281 = call ptr @class_behavior_wrapper(ptr %277, ptr noundef nonnull align 8 dereferenceable(8) %33)
  call void %281(ptr nonnull %32, { ptr, i160 } %248)
  br label %282

282:                                              ; preds = %259, %256
  %.1438 = phi i1 [ %.0437, %256 ], [ false, %259 ]
  %.1435 = phi i64 [ %258, %256 ], [ %.0434, %259 ]
  %283 = add i32 %.0440, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %282, %._crit_edge6
  %.1441 = phi i32 [ %283, %282 ], [ %.0440, %._crit_edge6 ]
  %.2439 = phi i1 [ %.1438, %282 ], [ %.0437, %._crit_edge6 ]
  %.2436 = phi i64 [ %.1435, %282 ], [ %.0434, %._crit_edge6 ]
  br i1 %241, label %._crit_edge6, label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5
  %284 = call i64 @clock()
  %.not = icmp eq i64 %.2436, %.2446
  %spec.select454 = select i1 %.not, i1 %.2439, i1 false
  %285 = call ptr @bump_malloc(i64 noundef 15)
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %285, align 1
  store ptr @String, ptr %34, align 8
  %286 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %287 = call { i64, i64 } @size_wrapper(ptr %286, ptr noundef nonnull align 8 dereferenceable(8) %34)
  %288 = extractvalue { i64, i64 } %287, 0
  %289 = call ptr @bump_malloc(i64 %288)
  %290 = insertvalue { ptr } undef, ptr %285, 0
  %291 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %289, 1
  %292 = insertvalue { ptr, ptr, ptr, i32 } %291, ptr undef, 2
  %293 = insertvalue { ptr, ptr, ptr, i32 } %292, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %35, align 8
  %294 = getelementptr inbounds i8, ptr %35, i64 8
  store ptr @_parameterization_i32, ptr %294, align 8
  %295 = getelementptr inbounds i8, ptr %35, i64 16
  store ptr @_parameterization_i32, ptr %295, align 8
  %296 = getelementptr inbounds i8, ptr %35, i64 24
  store ptr @_parameterization_i32, ptr %296, align 8
  %297 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %35)
  %298 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %299 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %36, align 8
  %300 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr @i32_typ, ptr %300, align 8
  %301 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr @i32_typ, ptr %301, align 8
  %302 = getelementptr inbounds i8, ptr %36, i64 24
  store ptr @i32_typ, ptr %302, align 8
  %303 = call ptr @behavior_wrapper(ptr %299, { ptr, ptr, ptr, i32 } %293, ptr noundef nonnull align 8 dereferenceable(32) %36)
  call void %303({ ptr, ptr, ptr, i32 } %293, { ptr, ptr, ptr, i32 } %293, ptr nonnull %35, { ptr } %290, i32 14, i32 14, i32 15)
  %304 = sub i64 %284, %234
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %293, i32 %.0449, i64 %304)
  %305 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %305, align 1
  store ptr @String, ptr %37, align 8
  %306 = call { i64, i64 } @size_wrapper(ptr %286, ptr noundef nonnull align 8 dereferenceable(8) %37)
  %307 = extractvalue { i64, i64 } %306, 0
  %308 = call ptr @bump_malloc(i64 %307)
  %309 = insertvalue { ptr } undef, ptr %305, 0
  %310 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %308, 1
  %311 = insertvalue { ptr, ptr, ptr, i32 } %310, ptr undef, 2
  %312 = insertvalue { ptr, ptr, ptr, i32 } %311, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %38, align 8
  %313 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr @_parameterization_i32, ptr %313, align 8
  %314 = getelementptr inbounds i8, ptr %38, i64 16
  store ptr @_parameterization_i32, ptr %314, align 8
  %315 = getelementptr inbounds i8, ptr %38, i64 24
  store ptr @_parameterization_i32, ptr %315, align 8
  %316 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %38)
  %317 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %39, align 8
  %318 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @i32_typ, ptr %318, align 8
  %319 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @i32_typ, ptr %319, align 8
  %320 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr @i32_typ, ptr %320, align 8
  %321 = call ptr @behavior_wrapper(ptr %299, { ptr, ptr, ptr, i32 } %312, ptr noundef nonnull align 8 dereferenceable(32) %39)
  call void %321({ ptr, ptr, ptr, i32 } %312, { ptr, ptr, ptr, i32 } %312, ptr nonnull %38, { ptr } %309, i32 18, i32 18, i32 19)
  %322 = ptrtoint ptr %308 to i64
  %.sroa.3255.8.insert.ext = zext i64 %322 to i160
  %.sroa.3255.8.insert.insert = or disjoint i160 %.sroa.3255.8.insert.ext, 3402823669209384634633746074317682114560
  %323 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3255.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %40, align 8
  %324 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %326 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %41, align 8
  %327 = call ptr @class_behavior_wrapper(ptr %326, ptr noundef nonnull align 8 dereferenceable(8) %41)
  call void %327(ptr nonnull %40, { ptr, i160 } %323)
  %328 = select i1 %spec.select454, ptr %42, ptr %47
  %329 = call ptr @bump_malloc(i64 noundef 5)
  %.fca.0.extract = select i1 %spec.select454, i8 80, i8 70
  %.sroa.0245.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.3 = select i1 %spec.select454, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>, <4 x i8> %.sroa.0.0.vec.insert
  %.sroa.0245.3 = select i1 %spec.select454, <4 x i8> %.sroa.0245.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0245.1.vec.insert = insertelement <4 x i8> %.sroa.0245.3, i8 65, i64 1
  %.sroa.0.1.vec.insert = insertelement <4 x i8> %.sroa.0.3, i8 65, i64 1
  %.sroa.0.2 = select i1 %spec.select454, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>, <4 x i8> %.sroa.0.1.vec.insert
  %.fca.2.extract = select i1 %spec.select454, i8 83, i8 73
  %.sroa.0245.2 = select i1 %spec.select454, <4 x i8> %.sroa.0245.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0245.2.vec.insert = insertelement <4 x i8> %.sroa.0245.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.2.vec.insert = insertelement <4 x i8> %.sroa.0.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.1 = select i1 %spec.select454, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>, <4 x i8> %.sroa.0.2.vec.insert
  %.fca.3.extract = select i1 %spec.select454, i8 83, i8 76
  %.sroa.0245.1 = select i1 %spec.select454, <4 x i8> %.sroa.0245.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0245.3.vec.insert = insertelement <4 x i8> %.sroa.0245.1, i8 %.fca.3.extract, i64 3
  %.sroa.0.3.vec.insert = insertelement <4 x i8> %.sroa.0.1, i8 %.fca.3.extract, i64 3
  %.sroa.speculated244 = select i1 %spec.select454, <4 x i8> %.sroa.0245.3.vec.insert, <4 x i8> %.sroa.0.3.vec.insert
  store <4 x i8> %.sroa.speculated244, ptr %329, align 1
  store ptr @String, ptr %328, align 8
  %330 = call { i64, i64 } @size_wrapper(ptr %286, ptr noundef nonnull align 8 dereferenceable(8) %328)
  %331 = extractvalue { i64, i64 } %330, 0
  %332 = call ptr @bump_malloc(i64 %331)
  br i1 %spec.select454, label %._crit_edge7.cont, label %._crit_edge7.else

._crit_edge7.else:                                ; preds = %._crit_edge7
  br label %._crit_edge7.cont

._crit_edge7.cont:                                ; preds = %._crit_edge7.else, %._crit_edge7
  %333 = phi ptr [ %51, %._crit_edge7.else ], [ %46, %._crit_edge7 ]
  %334 = phi ptr [ %50, %._crit_edge7.else ], [ %45, %._crit_edge7 ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %._crit_edge7.else ], [ %.sroa.gep455, %._crit_edge7 ]
  %.sroa.phi456 = phi ptr [ %.sroa.gep457, %._crit_edge7.else ], [ %.sroa.gep458, %._crit_edge7 ]
  %.sroa.phi459 = phi ptr [ %.sroa.gep460, %._crit_edge7.else ], [ %.sroa.gep461, %._crit_edge7 ]
  %335 = phi ptr [ %49, %._crit_edge7.else ], [ %44, %._crit_edge7 ]
  %.sroa.phi462 = phi ptr [ %.sroa.gep463, %._crit_edge7.else ], [ %.sroa.gep464, %._crit_edge7 ]
  %.sroa.phi465 = phi ptr [ %.sroa.gep466, %._crit_edge7.else ], [ %.sroa.gep467, %._crit_edge7 ]
  %.sroa.phi468 = phi ptr [ %.sroa.gep469, %._crit_edge7.else ], [ %.sroa.gep470, %._crit_edge7 ]
  %336 = phi ptr [ %48, %._crit_edge7.else ], [ %43, %._crit_edge7 ]
  %337 = insertvalue { ptr } undef, ptr %329, 0
  %338 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %332, 1
  %339 = insertvalue { ptr, ptr, ptr, i32 } %338, ptr undef, 2
  %340 = insertvalue { ptr, ptr, ptr, i32 } %339, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %336, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi462, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi465, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi468, align 8
  %341 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %336)
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %335, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi456, align 8
  store ptr @i32_typ, ptr %.sroa.phi459, align 8
  %343 = call ptr @behavior_wrapper(ptr %299, { ptr, ptr, ptr, i32 } %340, ptr noundef nonnull align 8 dereferenceable(32) %335)
  call void %343({ ptr, ptr, ptr, i32 } %340, { ptr, ptr, ptr, i32 } %340, ptr nonnull %336, { ptr } %337, i32 4, i32 4, i32 5)
  %344 = ptrtoint ptr %332 to i64
  %.sroa.3.8.insert.ext = zext i64 %344 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %345 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %334, align 8
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %334)
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %333, align 8
  %348 = call ptr @class_behavior_wrapper(ptr %326, ptr noundef nonnull align 8 dereferenceable(8) %333)
  call void %348(ptr nonnull %334, { ptr, i160 } %345)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.sroa.0509.sroa.0 = alloca i8, align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %14 = alloca [2 x ptr], align 8
  %15 = alloca { ptr, ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca [4 x ptr], align 8
  %18 = alloca { ptr, ptr, ptr, ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca [4 x ptr], align 8
  %25 = alloca { ptr, ptr, ptr, ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca { ptr }, align 8
  %28 = alloca [1 x ptr], align 8
  %29 = alloca { ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca [4 x ptr], align 8
  %34 = alloca { ptr, ptr, ptr, ptr }, align 8
  %35 = alloca [1 x ptr], align 8
  %36 = alloca [4 x ptr], align 8
  %37 = alloca { ptr, ptr, ptr, ptr }, align 8
  %38 = alloca [1 x ptr], align 8
  %39 = alloca { ptr }, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca [4 x ptr], align 8
  %42 = alloca { ptr, ptr, ptr, ptr }, align 8
  %43 = alloca [1 x ptr], align 8
  %44 = alloca { ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca [4 x ptr], align 8
  %47 = alloca { ptr, ptr, ptr, ptr }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca [4 x ptr], align 8
  %52 = alloca { ptr, ptr, ptr, ptr }, align 8
  %53 = alloca [1 x ptr], align 8
  %54 = alloca { ptr }, align 8
  %55 = alloca [1 x ptr], align 8
  %56 = alloca { ptr }, align 8
  %57 = alloca [1 x ptr], align 8
  %58 = alloca [4 x ptr], align 8
  %59 = alloca { ptr, ptr, ptr, ptr }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [1 x ptr], align 8
  %63 = alloca { ptr }, align 8
  %64 = alloca [1 x ptr], align 8
  %65 = alloca [4 x ptr], align 8
  %66 = alloca { ptr, ptr, ptr, ptr }, align 8
  %67 = alloca [1 x ptr], align 8
  %68 = alloca { ptr }, align 8
  %69 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %69, i64 8
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %69, i64 16
  store ptr @_parameterization_i32, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %69, i64 24
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %72, align 8
  %73 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 48), align 8
  %74 = call { i64, i64 } @size_wrapper(ptr %73, ptr noundef nonnull align 8 dereferenceable(32) %69)
  %75 = extractvalue { i64, i64 } %74, 0
  %76 = call ptr @bump_malloc(i64 %75)
  store ptr @_parameterization_i32, ptr %76, align 8
  %77 = getelementptr i8, ptr %76, i64 8
  store ptr @_parameterization_i32, ptr %77, align 8
  %78 = getelementptr i8, ptr %76, i64 16
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %78, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %76)
  %80 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %80)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %80, ptr noalias nofree noundef nonnull readnone @mdpnoafjfh, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %81 = call ptr @adjust_trampoline(ptr %80)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %80)
  %83 = insertvalue { ptr } undef, ptr %81, 0
  %84 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %84)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %84, ptr noalias nofree noundef nonnull readnone @ufjhiswmua, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %85 = call ptr @adjust_trampoline(ptr %84)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %84)
  %87 = insertvalue { ptr } undef, ptr %85, 0
  %88 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %76, 1
  %89 = insertvalue { ptr, ptr, ptr, i32 } %88, ptr undef, 2
  %90 = insertvalue { ptr, ptr, ptr, i32 } %89, i32 10, 3
  %91 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %91, align 8
  %92 = getelementptr inbounds i8, ptr %91, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %92, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %91)
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %95 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 240), align 8
  %96 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %96, align 8
  %97 = getelementptr inbounds i8, ptr %96, i64 8
  store ptr @function_typ, ptr %97, align 8
  %98 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %90, ptr noundef nonnull align 8 dereferenceable(16) %96)
  call void %98({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %91, { ptr } %83, { ptr } %87)
  %99 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %99, align 8
  %100 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %99)
  %101 = extractvalue { i64, i64 } %100, 0
  %102 = call ptr @bump_malloc(i64 %101)
  %103 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %102, 1
  %104 = insertvalue { ptr, ptr, ptr, i32 } %103, ptr undef, 2
  %105 = insertvalue { ptr, ptr, ptr, i32 } %104, i32 10, 3
  %106 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %106, align 8
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %106)
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %109 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %109, align 8
  %110 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %105, ptr noundef nonnull align 8 dereferenceable(8) %109)
  call void %110({ ptr, ptr, ptr, i32 } %105, { ptr, ptr, ptr, i32 } %105, ptr nonnull %106, i32 789)
  %111 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %111, align 8
  %112 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %111)
  %113 = extractvalue { i64, i64 } %112, 0
  %114 = call ptr @bump_malloc(i64 %113)
  %115 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %114, 1
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr undef, 2
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 10, 3
  %118 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %118, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %118)
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %121 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %121, align 8
  %122 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %117, ptr noundef nonnull align 8 dereferenceable(8) %121)
  call void %122({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull %118, i32 987)
  %123 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %123, align 8
  %124 = getelementptr inbounds i8, ptr %123, i64 8
  store ptr @_parameterization_i32, ptr %124, align 8
  %125 = getelementptr inbounds i8, ptr %123, i64 16
  store ptr @_parameterization_Bool, ptr %125, align 8
  %126 = getelementptr inbounds i8, ptr %123, i64 24
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %126, align 8
  %127 = call { i64, i64 } @size_wrapper(ptr %73, ptr noundef nonnull align 8 dereferenceable(32) %123)
  %128 = extractvalue { i64, i64 } %127, 0
  %129 = call ptr @bump_malloc(i64 %128)
  store ptr @_parameterization_i32, ptr %129, align 8
  %130 = getelementptr i8, ptr %129, i64 8
  store ptr @_parameterization_Bool, ptr %130, align 8
  %131 = getelementptr i8, ptr %129, i64 16
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %131, align 8
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %129)
  %133 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %133)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %133, ptr noalias nofree noundef nonnull readnone @cuugdpgnny, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %134 = call ptr @adjust_trampoline(ptr %133)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %133)
  %136 = insertvalue { ptr } undef, ptr %134, 0
  %137 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %137)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %137, ptr noalias nofree noundef nonnull readnone @hyaxmlzbks, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %138 = call ptr @adjust_trampoline(ptr %137)
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %137)
  %140 = insertvalue { ptr } undef, ptr %138, 0
  %141 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %129, 1
  %142 = insertvalue { ptr, ptr, ptr, i32 } %141, ptr undef, 2
  %143 = insertvalue { ptr, ptr, ptr, i32 } %142, i32 10, 3
  %144 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %144, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %145, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %144)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %148 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %148, align 8
  %149 = getelementptr inbounds i8, ptr %148, i64 8
  store ptr @function_typ, ptr %149, align 8
  %150 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(16) %148)
  call void %150({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %144, { ptr } %136, { ptr } %140)
  %151 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %47, i64 8
  %.sroa.gep576 = getelementptr inbounds i8, ptr %47, i64 16
  %.sroa.gep579 = getelementptr inbounds i8, ptr %47, i64 24
  %.sroa.gep582 = getelementptr inbounds i8, ptr %46, i64 8
  %.sroa.gep585 = getelementptr inbounds i8, ptr %46, i64 16
  %.sroa.gep588 = getelementptr inbounds i8, ptr %46, i64 24
  %152 = getelementptr inbounds i8, ptr %5, i64 8
  %153 = getelementptr inbounds i8, ptr %6, i64 8
  %154 = getelementptr inbounds i8, ptr %7, i64 8
  %155 = getelementptr inbounds i8, ptr %8, i64 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge1, %1
  %.0546 = phi i32 [ 0, %1 ], [ %.2548, %._crit_edge1 ]
  %.0543 = phi i32 [ 0, %1 ], [ %.1544, %._crit_edge1 ]
  %156 = icmp slt i32 %.0546, %0
  %157 = icmp slt i32 %.0543, %151
  %spec.select = select i1 %156, i1 %157, i1 false
  br i1 %spec.select, label %158, label %._crit_edge1

158:                                              ; preds = %._crit_edge3
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %161 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %105, ptr noundef nonnull align 8 %2)
  %162 = call i32 %161({ ptr, ptr, ptr, i32 } %105, { ptr, ptr, ptr, i32 } %105, ptr nonnull %2)
  %.sroa.0533.0.insert.ext = zext i32 %162 to i160
  %163 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0533.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %166 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %4, align 8
  %167 = call ptr @behavior_wrapper(ptr %166, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %168 = call { ptr, i160 } %167({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %3, { ptr, i160 } %163)
  %.fca.0.extract525 = extractvalue { ptr, i160 } %168, 0
  %169 = icmp eq ptr %.fca.0.extract525, @nil_typ
  %170 = icmp eq ptr %.fca.0.extract525, null
  %171 = or i1 %169, %170
  br i1 %171, label %172, label %._crit_edge2

172:                                              ; preds = %158
  %173 = add i32 %162, 1
  %.sroa.0516.0.insert.ext = zext i32 %173 to i160
  %174 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0516.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %152, align 8
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %177 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 256), align 8
  store ptr @i32_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %153, align 8
  %178 = call ptr @behavior_wrapper(ptr %177, { ptr, ptr, ptr, i32 } %90, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %178({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %5, { ptr, i160 } %163, { ptr, i160 } %174)
  store i1 true, ptr %.sroa.0509.sroa.0, align 8
  %.sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.0. = load i8, ptr %.sroa.0509.sroa.0, align 8
  %.sroa.0509.0.insert.ext = zext i8 %.sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.sroa.0.0..sroa.0509.0. to i160
  %179 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0509.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_Bool, ptr %154, align 8
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  store ptr @i32_typ, ptr %8, align 8
  store ptr @bool_typ, ptr %155, align 8
  %182 = call ptr @behavior_wrapper(ptr %177, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %182({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %7, { ptr, i160 } %163, { ptr, i160 } %179)
  %183 = add nsw i32 %.0546, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %172, %158
  %.1547 = phi i32 [ %183, %172 ], [ %.0546, %158 ]
  %184 = add i32 %.0543, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge2, %._crit_edge3
  %.2548 = phi i32 [ %.1547, %._crit_edge2 ], [ %.0546, %._crit_edge3 ]
  %.1544 = phi i32 [ %184, %._crit_edge2 ], [ %.0543, %._crit_edge3 ]
  br i1 %spec.select, label %._crit_edge3, label %185

185:                                              ; preds = %._crit_edge1
  %.sroa.gep574 = getelementptr inbounds i8, ptr %42, i64 8
  %.sroa.gep580 = getelementptr inbounds i8, ptr %42, i64 24
  %.sroa.gep586 = getelementptr inbounds i8, ptr %41, i64 16
  store ptr @Array, ptr %9, align 8
  %186 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @_parameterization_i32, ptr %186, align 8
  %187 = load ptr, ptr getelementptr (i8, ptr @Array, i64 48), align 8
  %188 = call { i64, i64 } @size_wrapper(ptr %187, ptr noundef nonnull align 8 dereferenceable(16) %9)
  %189 = extractvalue { i64, i64 } %188, 0
  %190 = call ptr @bump_malloc(i64 %189)
  store ptr @_parameterization_i32, ptr %190, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %190)
  %192 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %190, 1
  %193 = insertvalue { ptr, ptr, ptr, i32 } %192, ptr undef, 2
  %194 = insertvalue { ptr, ptr, ptr, i32 } %193, i32 10, 3
  store ptr @_parameterization_i32, ptr %10, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %197 = load ptr, ptr getelementptr (i8, ptr @Array, i64 136), align 8
  store ptr @i32_typ, ptr %11, align 8
  %198 = call ptr @behavior_wrapper(ptr %197, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 dereferenceable(8) %11)
  call void %198({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %10, i32 %0)
  %199 = mul i32 %0, 20
  %200 = getelementptr inbounds i8, ptr %14, i64 8
  %201 = getelementptr inbounds i8, ptr %15, i64 8
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5, %185
  %.2545 = phi i32 [ 0, %185 ], [ %.3, %._crit_edge5 ]
  %.0542 = phi i32 [ 0, %185 ], [ %.2, %._crit_edge5 ]
  %202 = icmp slt i32 %.0542, %0
  %203 = icmp slt i32 %.2545, %199
  %spec.select573 = select i1 %202, i1 %203, i1 false
  br i1 %spec.select573, label %204, label %._crit_edge5

204:                                              ; preds = %._crit_edge7
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %207 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %117, ptr noundef nonnull align 8 %2)
  %208 = call i32 %207({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull %2)
  %.sroa.0472.0.insert.ext = zext i32 %208 to i160
  %209 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0472.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %12, align 8
  %210 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  %211 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %212 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %13, align 8
  %213 = call ptr @behavior_wrapper(ptr %212, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(8) %13)
  %214 = call { ptr, i160 } %213({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %12, { ptr, i160 } %209)
  %.fca.0.extract464 = extractvalue { ptr, i160 } %214, 0
  %215 = icmp eq ptr %.fca.0.extract464, @nil_typ
  %216 = icmp eq ptr %.fca.0.extract464, null
  %217 = or i1 %215, %216
  br i1 %217, label %218, label %._crit_edge6

218:                                              ; preds = %204
  store ptr @_parameterization_i32, ptr %14, align 8
  store ptr @_parameterization_i32, ptr %200, align 8
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %14)
  %220 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %221 = load ptr, ptr getelementptr (i8, ptr @Array, i64 176), align 8
  store ptr @i32_typ, ptr %15, align 8
  store ptr @i32_typ, ptr %201, align 8
  %222 = call ptr @behavior_wrapper(ptr %221, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 dereferenceable(16) %15)
  call void %222({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %14, i32 %.0542, { ptr, i160 } %209)
  %223 = add nsw i32 %.0542, 1
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %218, %204
  %.1 = phi i32 [ %223, %218 ], [ %.0542, %204 ]
  %224 = add i32 %.2545, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge6, %._crit_edge7
  %.3 = phi i32 [ %224, %._crit_edge6 ], [ %.2545, %._crit_edge7 ]
  %.2 = phi i32 [ %.1, %._crit_edge6 ], [ %.0542, %._crit_edge7 ]
  br i1 %spec.select573, label %._crit_edge7, label %225

225:                                              ; preds = %._crit_edge5
  %.sroa.gep577 = getelementptr inbounds i8, ptr %42, i64 16
  %.sroa.gep583 = getelementptr inbounds i8, ptr %41, i64 8
  %.sroa.gep589 = getelementptr inbounds i8, ptr %41, i64 24
  %226 = icmp slt i32 %.2, %0
  br i1 %226, label %227, label %._crit_edge8

227:                                              ; preds = %225
  %228 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %228, align 1
  store ptr @String, ptr %16, align 8
  %229 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %230 = call { i64, i64 } @size_wrapper(ptr %229, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %231 = extractvalue { i64, i64 } %230, 0
  %232 = call ptr @bump_malloc(i64 %231)
  %233 = insertvalue { ptr } undef, ptr %228, 0
  %234 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %232, 1
  %235 = insertvalue { ptr, ptr, ptr, i32 } %234, ptr undef, 2
  %236 = insertvalue { ptr, ptr, ptr, i32 } %235, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %237 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %237, align 8
  %238 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %238, align 8
  %239 = getelementptr inbounds i8, ptr %17, i64 24
  store ptr @_parameterization_i32, ptr %239, align 8
  %240 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %17)
  %241 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %242 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %18, align 8
  %243 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @i32_typ, ptr %243, align 8
  %244 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @i32_typ, ptr %244, align 8
  %245 = getelementptr inbounds i8, ptr %18, i64 24
  store ptr @i32_typ, ptr %245, align 8
  %246 = call ptr @behavior_wrapper(ptr %242, { ptr, ptr, ptr, i32 } %236, ptr noundef nonnull align 8 dereferenceable(32) %18)
  call void %246({ ptr, ptr, ptr, i32 } %236, { ptr, ptr, ptr, i32 } %236, ptr nonnull %17, { ptr } %233, i32 29, i32 29, i32 30)
  %247 = ptrtoint ptr %232 to i64
  %.sroa.3441.8.insert.ext = zext i64 %247 to i160
  %.sroa.3441.8.insert.insert = or disjoint i160 %.sroa.3441.8.insert.ext, 3402823669209384634633746074317682114560
  %248 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3441.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %19, align 8
  %249 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %250 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %251 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %20, align 8
  %252 = call ptr @class_behavior_wrapper(ptr %251, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %252(ptr nonnull %19, { ptr, i160 } %248)
  %.sroa.0434.0.insert.ext = zext i32 %.2 to i160
  %253 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0434.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %21, align 8
  %254 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %255 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %22, align 8
  %256 = call ptr @class_behavior_wrapper(ptr %251, ptr noundef nonnull align 8 dereferenceable(8) %22)
  call void %256(ptr nonnull %21, { ptr, i160 } %253)
  %257 = call ptr @bump_malloc(i64 noundef 23)
  store <22 x i8> <i8 32, i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %257, align 1
  store ptr @String, ptr %23, align 8
  %258 = call { i64, i64 } @size_wrapper(ptr %229, ptr noundef nonnull align 8 dereferenceable(8) %23)
  %259 = extractvalue { i64, i64 } %258, 0
  %260 = call ptr @bump_malloc(i64 %259)
  %261 = insertvalue { ptr } undef, ptr %257, 0
  %262 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %260, 1
  %263 = insertvalue { ptr, ptr, ptr, i32 } %262, ptr undef, 2
  %264 = insertvalue { ptr, ptr, ptr, i32 } %263, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %24, align 8
  %265 = getelementptr inbounds i8, ptr %24, i64 8
  store ptr @_parameterization_i32, ptr %265, align 8
  %266 = getelementptr inbounds i8, ptr %24, i64 16
  store ptr @_parameterization_i32, ptr %266, align 8
  %267 = getelementptr inbounds i8, ptr %24, i64 24
  store ptr @_parameterization_i32, ptr %267, align 8
  %268 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %24)
  %269 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %25, align 8
  %270 = getelementptr inbounds i8, ptr %25, i64 8
  store ptr @i32_typ, ptr %270, align 8
  %271 = getelementptr inbounds i8, ptr %25, i64 16
  store ptr @i32_typ, ptr %271, align 8
  %272 = getelementptr inbounds i8, ptr %25, i64 24
  store ptr @i32_typ, ptr %272, align 8
  %273 = call ptr @behavior_wrapper(ptr %242, { ptr, ptr, ptr, i32 } %264, ptr noundef nonnull align 8 dereferenceable(32) %25)
  call void %273({ ptr, ptr, ptr, i32 } %264, { ptr, ptr, ptr, i32 } %264, ptr nonnull %24, { ptr } %261, i32 22, i32 22, i32 23)
  %274 = ptrtoint ptr %260 to i64
  %.sroa.3420.8.insert.ext = zext i64 %274 to i160
  %.sroa.3420.8.insert.insert = or disjoint i160 %.sroa.3420.8.insert.ext, 3402823669209384634633746074317682114560
  %275 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3420.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %26, align 8
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %27, align 8
  %278 = call ptr @class_behavior_wrapper(ptr %251, ptr noundef nonnull align 8 dereferenceable(8) %27)
  call void %278(ptr nonnull %26, { ptr, i160 } %275)
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %227, %225
  %.0569 = phi i32 [ %.2, %227 ], [ %0, %225 ]
  %279 = call i64 @clock()
  br label %._crit_edge10

._crit_edge10:                                    ; preds = %._crit_edge9, %._crit_edge8
  %.0556 = phi i32 [ 0, %._crit_edge8 ], [ %.1557, %._crit_edge9 ]
  %.0553 = phi i32 [ 0, %._crit_edge8 ], [ %.1554, %._crit_edge9 ]
  %.0550 = phi i32 [ 0, %._crit_edge8 ], [ %.1551, %._crit_edge9 ]
  %280 = icmp slt i32 %.0556, %.0569
  br i1 %280, label %.cont380, label %._crit_edge9

.cont380:                                         ; preds = %._crit_edge10
  store ptr @_parameterization_i32, ptr %28, align 8
  %281 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %282 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %283 = load ptr, ptr getelementptr (i8, ptr @Array, i64 168), align 8
  store ptr @i32_typ, ptr %29, align 8
  %284 = call ptr @behavior_wrapper(ptr %283, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 dereferenceable(8) %29)
  %285 = call { ptr, i160 } %284({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %28, i32 %.0556)
  %.fca.1.extract396 = extractvalue { ptr, i160 } %285, 1
  %.sroa.0392.0.insert.ext = and i160 %.fca.1.extract396, 4294967295
  %286 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0392.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %30, align 8
  %287 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %288 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %289 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %31, align 8
  %290 = call ptr @behavior_wrapper(ptr %289, { ptr, ptr, ptr, i32 } %90, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %291 = call { ptr, i160 } %290({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %30, { ptr, i160 } %286)
  %.fca.0.extract388 = extractvalue { ptr, i160 } %291, 0
  %292 = icmp eq ptr %.fca.0.extract388, @nil_typ
  %293 = icmp eq ptr %.fca.0.extract388, null
  %294 = or i1 %292, %293
  %.0550..0553 = select i1 %294, i32 %.0550, i32 %.0553
  %295 = add i32 %.0550..0553, 1
  %.2555 = select i1 %294, i32 %.0553, i32 %295
  %.2552 = select i1 %294, i32 %295, i32 %.0550
  %296 = add nsw i32 %.0556, 1
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %.cont380, %._crit_edge10
  %.1557 = phi i32 [ %296, %.cont380 ], [ %.0556, %._crit_edge10 ]
  %.1554 = phi i32 [ %.2555, %.cont380 ], [ %.0553, %._crit_edge10 ]
  %.1551 = phi i32 [ %.2552, %.cont380 ], [ %.0550, %._crit_edge10 ]
  br i1 %280, label %._crit_edge10, label %297

297:                                              ; preds = %._crit_edge9
  %298 = call i64 @clock()
  %299 = icmp sgt i32 %.0569, 0
  br i1 %299, label %300, label %304

300:                                              ; preds = %297
  %301 = mul i32 %.1554, 100
  %302 = sdiv i32 %301, %.0569
  %303 = icmp slt i32 %302, 5
  br label %.cont275

304:                                              ; preds = %297
  %.not = icmp eq i32 %.1554, 0
  br label %.cont275

.cont275:                                         ; preds = %304, %300
  %.reg2mem27.0.in = phi i1 [ %303, %300 ], [ %.not, %304 ]
  %305 = select i1 %.reg2mem27.0.in, ptr %40, ptr %45
  %306 = call ptr @bump_malloc(i64 noundef 16)
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %306, align 1
  store ptr @String, ptr %32, align 8
  %307 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %308 = call { i64, i64 } @size_wrapper(ptr %307, ptr noundef nonnull align 8 dereferenceable(8) %32)
  %309 = extractvalue { i64, i64 } %308, 0
  %310 = call ptr @bump_malloc(i64 %309)
  %311 = insertvalue { ptr } undef, ptr %306, 0
  %312 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %310, 1
  %313 = insertvalue { ptr, ptr, ptr, i32 } %312, ptr undef, 2
  %314 = insertvalue { ptr, ptr, ptr, i32 } %313, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %33, align 8
  %315 = getelementptr inbounds i8, ptr %33, i64 8
  store ptr @_parameterization_i32, ptr %315, align 8
  %316 = getelementptr inbounds i8, ptr %33, i64 16
  store ptr @_parameterization_i32, ptr %316, align 8
  %317 = getelementptr inbounds i8, ptr %33, i64 24
  store ptr @_parameterization_i32, ptr %317, align 8
  %318 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %33)
  %319 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %320 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %34, align 8
  %321 = getelementptr inbounds i8, ptr %34, i64 8
  store ptr @i32_typ, ptr %321, align 8
  %322 = getelementptr inbounds i8, ptr %34, i64 16
  store ptr @i32_typ, ptr %322, align 8
  %323 = getelementptr inbounds i8, ptr %34, i64 24
  store ptr @i32_typ, ptr %323, align 8
  %324 = call ptr @behavior_wrapper(ptr %320, { ptr, ptr, ptr, i32 } %314, ptr noundef nonnull align 8 dereferenceable(32) %34)
  call void %324({ ptr, ptr, ptr, i32 } %314, { ptr, ptr, ptr, i32 } %314, ptr nonnull %33, { ptr } %311, i32 15, i32 15, i32 16)
  %325 = sub i64 %298, %279
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %314, i32 %.0569, i64 %325)
  %326 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %326, align 1
  store ptr @String, ptr %35, align 8
  %327 = call { i64, i64 } @size_wrapper(ptr %307, ptr noundef nonnull align 8 dereferenceable(8) %35)
  %328 = extractvalue { i64, i64 } %327, 0
  %329 = call ptr @bump_malloc(i64 %328)
  %330 = insertvalue { ptr } undef, ptr %326, 0
  %331 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %329, 1
  %332 = insertvalue { ptr, ptr, ptr, i32 } %331, ptr undef, 2
  %333 = insertvalue { ptr, ptr, ptr, i32 } %332, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %36, align 8
  %334 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr @_parameterization_i32, ptr %334, align 8
  %335 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr @_parameterization_i32, ptr %335, align 8
  %336 = getelementptr inbounds i8, ptr %36, i64 24
  store ptr @_parameterization_i32, ptr %336, align 8
  %337 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %36)
  %338 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %37, align 8
  %339 = getelementptr inbounds i8, ptr %37, i64 8
  store ptr @i32_typ, ptr %339, align 8
  %340 = getelementptr inbounds i8, ptr %37, i64 16
  store ptr @i32_typ, ptr %340, align 8
  %341 = getelementptr inbounds i8, ptr %37, i64 24
  store ptr @i32_typ, ptr %341, align 8
  %342 = call ptr @behavior_wrapper(ptr %320, { ptr, ptr, ptr, i32 } %333, ptr noundef nonnull align 8 dereferenceable(32) %37)
  call void %342({ ptr, ptr, ptr, i32 } %333, { ptr, ptr, ptr, i32 } %333, ptr nonnull %36, { ptr } %330, i32 18, i32 18, i32 19)
  %343 = ptrtoint ptr %329 to i64
  %.sroa.3319.8.insert.ext = zext i64 %343 to i160
  %.sroa.3319.8.insert.insert = or disjoint i160 %.sroa.3319.8.insert.ext, 3402823669209384634633746074317682114560
  %344 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3319.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %38, align 8
  %345 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %347 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %39, align 8
  %348 = call ptr @class_behavior_wrapper(ptr %347, ptr noundef nonnull align 8 dereferenceable(8) %39)
  call void %348(ptr nonnull %38, { ptr, i160 } %344)
  %349 = call ptr @bump_malloc(i64 noundef 5)
  %.fca.0.extract = select i1 %.reg2mem27.0.in, i8 80, i8 70
  %.sroa.0309.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.3 = select i1 %.reg2mem27.0.in, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>, <4 x i8> %.sroa.0.0.vec.insert
  %.sroa.0309.3 = select i1 %.reg2mem27.0.in, <4 x i8> %.sroa.0309.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0309.1.vec.insert = insertelement <4 x i8> %.sroa.0309.3, i8 65, i64 1
  %.sroa.0.1.vec.insert = insertelement <4 x i8> %.sroa.0.3, i8 65, i64 1
  %.sroa.0.2 = select i1 %.reg2mem27.0.in, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>, <4 x i8> %.sroa.0.1.vec.insert
  %.sroa.0309.2 = select i1 %.reg2mem27.0.in, <4 x i8> %.sroa.0309.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.fca.2.extract = select i1 %.reg2mem27.0.in, i8 83, i8 73
  %.sroa.0309.2.vec.insert = insertelement <4 x i8> %.sroa.0309.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.2.vec.insert = insertelement <4 x i8> %.sroa.0.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.1 = select i1 %.reg2mem27.0.in, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>, <4 x i8> %.sroa.0.2.vec.insert
  %.sroa.0309.1 = select i1 %.reg2mem27.0.in, <4 x i8> %.sroa.0309.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.fca.3.extract = select i1 %.reg2mem27.0.in, i8 83, i8 76
  %.sroa.0309.3.vec.insert = insertelement <4 x i8> %.sroa.0309.1, i8 %.fca.3.extract, i64 3
  %.sroa.0.3.vec.insert = insertelement <4 x i8> %.sroa.0.1, i8 %.fca.3.extract, i64 3
  %.sroa.speculated308 = select i1 %.reg2mem27.0.in, <4 x i8> %.sroa.0309.3.vec.insert, <4 x i8> %.sroa.0.3.vec.insert
  store <4 x i8> %.sroa.speculated308, ptr %349, align 1
  store ptr @String, ptr %305, align 8
  %350 = call { i64, i64 } @size_wrapper(ptr %307, ptr noundef nonnull align 8 dereferenceable(8) %305)
  %351 = extractvalue { i64, i64 } %350, 0
  %352 = call ptr @bump_malloc(i64 %351)
  br i1 %.reg2mem27.0.in, label %.cont, label %.else

.else:                                            ; preds = %.cont275
  br label %.cont

.cont:                                            ; preds = %.else, %.cont275
  %353 = phi ptr [ %49, %.else ], [ %44, %.cont275 ]
  %354 = phi ptr [ %48, %.else ], [ %43, %.cont275 ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %.else ], [ %.sroa.gep574, %.cont275 ]
  %.sroa.phi575 = phi ptr [ %.sroa.gep576, %.else ], [ %.sroa.gep577, %.cont275 ]
  %.sroa.phi578 = phi ptr [ %.sroa.gep579, %.else ], [ %.sroa.gep580, %.cont275 ]
  %355 = phi ptr [ %47, %.else ], [ %42, %.cont275 ]
  %.sroa.phi581 = phi ptr [ %.sroa.gep582, %.else ], [ %.sroa.gep583, %.cont275 ]
  %.sroa.phi584 = phi ptr [ %.sroa.gep585, %.else ], [ %.sroa.gep586, %.cont275 ]
  %.sroa.phi587 = phi ptr [ %.sroa.gep588, %.else ], [ %.sroa.gep589, %.cont275 ]
  %356 = phi ptr [ %46, %.else ], [ %41, %.cont275 ]
  %357 = insertvalue { ptr } undef, ptr %349, 0
  %358 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %352, 1
  %359 = insertvalue { ptr, ptr, ptr, i32 } %358, ptr undef, 2
  %360 = insertvalue { ptr, ptr, ptr, i32 } %359, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %356, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi581, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi584, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi587, align 8
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %356)
  %362 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %355, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi575, align 8
  store ptr @i32_typ, ptr %.sroa.phi578, align 8
  %363 = call ptr @behavior_wrapper(ptr %320, { ptr, ptr, ptr, i32 } %360, ptr noundef nonnull align 8 dereferenceable(32) %355)
  call void %363({ ptr, ptr, ptr, i32 } %360, { ptr, ptr, ptr, i32 } %360, ptr nonnull %356, { ptr } %357, i32 4, i32 4, i32 5)
  %364 = ptrtoint ptr %352 to i64
  %.sroa.3283.8.insert.ext = zext i64 %364 to i160
  %.sroa.3283.8.insert.insert = or disjoint i160 %.sroa.3283.8.insert.ext, 3402823669209384634633746074317682114560
  %365 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3283.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %354, align 8
  %366 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %354)
  %367 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %353, align 8
  %368 = call ptr @class_behavior_wrapper(ptr %347, ptr noundef nonnull align 8 dereferenceable(8) %353)
  call void %368(ptr nonnull %354, { ptr, i160 } %365)
  %369 = call ptr @bump_malloc(i64 noundef 14)
  store <13 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %369, align 1
  store ptr @String, ptr %50, align 8
  %370 = call { i64, i64 } @size_wrapper(ptr %307, ptr noundef nonnull align 8 dereferenceable(8) %50)
  %371 = extractvalue { i64, i64 } %370, 0
  %372 = call ptr @bump_malloc(i64 %371)
  %373 = insertvalue { ptr } undef, ptr %369, 0
  %374 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %372, 1
  %375 = insertvalue { ptr, ptr, ptr, i32 } %374, ptr undef, 2
  %376 = insertvalue { ptr, ptr, ptr, i32 } %375, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %51, align 8
  %377 = getelementptr inbounds i8, ptr %51, i64 8
  store ptr @_parameterization_i32, ptr %377, align 8
  %378 = getelementptr inbounds i8, ptr %51, i64 16
  store ptr @_parameterization_i32, ptr %378, align 8
  %379 = getelementptr inbounds i8, ptr %51, i64 24
  store ptr @_parameterization_i32, ptr %379, align 8
  %380 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %51)
  %381 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %52, align 8
  %382 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @i32_typ, ptr %382, align 8
  %383 = getelementptr inbounds i8, ptr %52, i64 16
  store ptr @i32_typ, ptr %383, align 8
  %384 = getelementptr inbounds i8, ptr %52, i64 24
  store ptr @i32_typ, ptr %384, align 8
  %385 = call ptr @behavior_wrapper(ptr %320, { ptr, ptr, ptr, i32 } %376, ptr noundef nonnull align 8 dereferenceable(32) %52)
  call void %385({ ptr, ptr, ptr, i32 } %376, { ptr, ptr, ptr, i32 } %376, ptr nonnull %51, { ptr } %373, i32 13, i32 13, i32 14)
  %386 = ptrtoint ptr %372 to i64
  %.sroa.3131.8.insert.ext = zext i64 %386 to i160
  %.sroa.3131.8.insert.insert = or disjoint i160 %.sroa.3131.8.insert.ext, 3402823669209384634633746074317682114560
  %387 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3131.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %53, align 8
  %388 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  %389 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %54, align 8
  %390 = call ptr @class_behavior_wrapper(ptr %347, ptr noundef nonnull align 8 dereferenceable(8) %54)
  call void %390(ptr nonnull %53, { ptr, i160 } %387)
  %.sroa.0120.0.insert.ext = zext i32 %.1551 to i160
  %391 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0120.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %55, align 8
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %393 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %56, align 8
  %394 = call ptr @class_behavior_wrapper(ptr %347, ptr noundef nonnull align 8 dereferenceable(8) %56)
  call void %394(ptr nonnull %55, { ptr, i160 } %391)
  %395 = call ptr @bump_malloc(i64 noundef 9)
  store <8 x i8> <i8 44, i8 32, i8 72, i8 105, i8 116, i8 115, i8 58, i8 32>, ptr %395, align 1
  store ptr @String, ptr %57, align 8
  %396 = call { i64, i64 } @size_wrapper(ptr %307, ptr noundef nonnull align 8 dereferenceable(8) %57)
  %397 = extractvalue { i64, i64 } %396, 0
  %398 = call ptr @bump_malloc(i64 %397)
  %399 = insertvalue { ptr } undef, ptr %395, 0
  %400 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %398, 1
  %401 = insertvalue { ptr, ptr, ptr, i32 } %400, ptr undef, 2
  %402 = insertvalue { ptr, ptr, ptr, i32 } %401, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %58, align 8
  %403 = getelementptr inbounds i8, ptr %58, i64 8
  store ptr @_parameterization_i32, ptr %403, align 8
  %404 = getelementptr inbounds i8, ptr %58, i64 16
  store ptr @_parameterization_i32, ptr %404, align 8
  %405 = getelementptr inbounds i8, ptr %58, i64 24
  store ptr @_parameterization_i32, ptr %405, align 8
  %406 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %58)
  %407 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %59, align 8
  %408 = getelementptr inbounds i8, ptr %59, i64 8
  store ptr @i32_typ, ptr %408, align 8
  %409 = getelementptr inbounds i8, ptr %59, i64 16
  store ptr @i32_typ, ptr %409, align 8
  %410 = getelementptr inbounds i8, ptr %59, i64 24
  store ptr @i32_typ, ptr %410, align 8
  %411 = call ptr @behavior_wrapper(ptr %320, { ptr, ptr, ptr, i32 } %402, ptr noundef nonnull align 8 dereferenceable(32) %59)
  call void %411({ ptr, ptr, ptr, i32 } %402, { ptr, ptr, ptr, i32 } %402, ptr nonnull %58, { ptr } %399, i32 8, i32 8, i32 9)
  %412 = ptrtoint ptr %398 to i64
  %.sroa.3106.8.insert.ext = zext i64 %412 to i160
  %.sroa.3106.8.insert.insert = or disjoint i160 %.sroa.3106.8.insert.ext, 3402823669209384634633746074317682114560
  %413 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3106.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %60, align 8
  %414 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  %415 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %61, align 8
  %416 = call ptr @class_behavior_wrapper(ptr %347, ptr noundef nonnull align 8 dereferenceable(8) %61)
  call void %416(ptr nonnull %60, { ptr, i160 } %413)
  %.sroa.0100.0.insert.ext = zext i32 %.1554 to i160
  %417 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0100.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %62, align 8
  %418 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  %419 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %63, align 8
  %420 = call ptr @class_behavior_wrapper(ptr %347, ptr noundef nonnull align 8 dereferenceable(8) %63)
  call void %420(ptr nonnull %62, { ptr, i160 } %417)
  %421 = call ptr @bump_malloc(i64 noundef 2)
  store <1 x i8> <i8 41>, ptr %421, align 1
  store ptr @String, ptr %64, align 8
  %422 = call { i64, i64 } @size_wrapper(ptr %307, ptr noundef nonnull align 8 dereferenceable(8) %64)
  %423 = extractvalue { i64, i64 } %422, 0
  %424 = call ptr @bump_malloc(i64 %423)
  %425 = insertvalue { ptr } undef, ptr %421, 0
  %426 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %424, 1
  %427 = insertvalue { ptr, ptr, ptr, i32 } %426, ptr undef, 2
  %428 = insertvalue { ptr, ptr, ptr, i32 } %427, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %65, align 8
  %429 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr @_parameterization_i32, ptr %429, align 8
  %430 = getelementptr inbounds i8, ptr %65, i64 16
  store ptr @_parameterization_i32, ptr %430, align 8
  %431 = getelementptr inbounds i8, ptr %65, i64 24
  store ptr @_parameterization_i32, ptr %431, align 8
  %432 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %65)
  %433 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %66, align 8
  %434 = getelementptr inbounds i8, ptr %66, i64 8
  store ptr @i32_typ, ptr %434, align 8
  %435 = getelementptr inbounds i8, ptr %66, i64 16
  store ptr @i32_typ, ptr %435, align 8
  %436 = getelementptr inbounds i8, ptr %66, i64 24
  store ptr @i32_typ, ptr %436, align 8
  %437 = call ptr @behavior_wrapper(ptr %320, { ptr, ptr, ptr, i32 } %428, ptr noundef nonnull align 8 dereferenceable(32) %66)
  call void %437({ ptr, ptr, ptr, i32 } %428, { ptr, ptr, ptr, i32 } %428, ptr nonnull %65, { ptr } %425, i32 1, i32 1, i32 2)
  %438 = ptrtoint ptr %424 to i64
  %.sroa.3.8.insert.ext = zext i64 %438 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %439 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %67, align 8
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %441 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %68, align 8
  %442 = call ptr @class_behavior_wrapper(ptr %347, ptr noundef nonnull align 8 dereferenceable(8) %68)
  call void %442(ptr nonnull %67, { ptr, i160 } %439)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %.sroa.0500.sroa.0 = alloca i8, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca [4 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca [4 x ptr], align 8
  %20 = alloca { ptr, ptr, ptr, ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca [4 x ptr], align 8
  %29 = alloca { ptr, ptr, ptr, ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca { ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca [4 x ptr], align 8
  %36 = alloca { ptr, ptr, ptr, ptr }, align 8
  %37 = alloca [1 x ptr], align 8
  %38 = alloca { ptr }, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %43 = alloca [1 x ptr], align 8
  %44 = alloca { ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca [4 x ptr], align 8
  %47 = alloca { ptr, ptr, ptr, ptr }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca [4 x ptr], align 8
  %50 = alloca { ptr, ptr, ptr, ptr }, align 8
  %51 = alloca [1 x ptr], align 8
  %52 = alloca { ptr }, align 8
  %53 = alloca [1 x ptr], align 8
  %54 = alloca [4 x ptr], align 8
  %55 = alloca { ptr, ptr, ptr, ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca [1 x ptr], align 8
  %59 = alloca [4 x ptr], align 8
  %60 = alloca { ptr, ptr, ptr, ptr }, align 8
  %61 = alloca [1 x ptr], align 8
  %62 = alloca { ptr }, align 8
  %63 = alloca [1 x ptr], align 8
  %64 = alloca [4 x ptr], align 8
  %65 = alloca { ptr, ptr, ptr, ptr }, align 8
  %66 = alloca [1 x ptr], align 8
  %67 = alloca { ptr }, align 8
  %68 = alloca [1 x ptr], align 8
  %69 = alloca { ptr }, align 8
  %70 = alloca [1 x ptr], align 8
  %71 = alloca [4 x ptr], align 8
  %72 = alloca { ptr, ptr, ptr, ptr }, align 8
  %73 = alloca [1 x ptr], align 8
  %74 = alloca { ptr }, align 8
  %75 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %75, i64 8
  store ptr @_parameterization_i32, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %75, i64 16
  store ptr @_parameterization_i32, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %75, i64 24
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %78, align 8
  %79 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 48), align 8
  %80 = call { i64, i64 } @size_wrapper(ptr %79, ptr noundef nonnull align 8 dereferenceable(32) %75)
  %81 = extractvalue { i64, i64 } %80, 0
  %82 = call ptr @bump_malloc(i64 %81)
  store ptr @_parameterization_i32, ptr %82, align 8
  %83 = getelementptr i8, ptr %82, i64 8
  store ptr @_parameterization_i32, ptr %83, align 8
  %84 = getelementptr i8, ptr %82, i64 16
  store ptr @_parameterization_iteration.Pairi32._i32, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  %86 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %86)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %86, ptr noalias nofree noundef nonnull readnone @xfctfcdhgs, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %87 = call ptr @adjust_trampoline(ptr %86)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %86)
  %89 = insertvalue { ptr } undef, ptr %87, 0
  %90 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %90)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %90, ptr noalias nofree noundef nonnull readnone @wryurxzenj, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %91 = call ptr @adjust_trampoline(ptr %90)
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %90)
  %93 = insertvalue { ptr } undef, ptr %91, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %82, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr undef, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 10, 3
  %97 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %97, align 8
  %98 = getelementptr inbounds i8, ptr %97, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %97)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %101 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 240), align 8
  %102 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %102, i64 8
  store ptr @function_typ, ptr %103, align 8
  %104 = call ptr @behavior_wrapper(ptr %101, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(16) %102)
  call void %104({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %97, { ptr } %89, { ptr } %93)
  %105 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %105, align 8
  %106 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %105)
  %107 = extractvalue { i64, i64 } %106, 0
  %108 = call ptr @bump_malloc(i64 %107)
  %109 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %108, 1
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr undef, 2
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, i32 10, 3
  %112 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %112, align 8
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %112)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %115 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %115, align 8
  %116 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %111, ptr noundef nonnull align 8 dereferenceable(8) %115)
  call void %116({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull %112, i32 101112)
  %117 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %117, align 8
  %118 = getelementptr inbounds i8, ptr %117, i64 8
  store ptr @_parameterization_i32, ptr %118, align 8
  %119 = load ptr, ptr getelementptr (i8, ptr @Array, i64 48), align 8
  %120 = call { i64, i64 } @size_wrapper(ptr %119, ptr noundef nonnull align 8 dereferenceable(16) %117)
  %121 = extractvalue { i64, i64 } %120, 0
  %122 = call ptr @bump_malloc(i64 %121)
  store ptr @_parameterization_i32, ptr %122, align 8
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %122)
  %124 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %122, 1
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, ptr undef, 2
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 10, 3
  %127 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %127, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %127)
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %130 = load ptr, ptr getelementptr (i8, ptr @Array, i64 136), align 8
  %131 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %131, align 8
  %132 = call ptr @behavior_wrapper(ptr %130, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(8) %131)
  call void %132({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %127, i32 %0)
  %133 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %133, align 8
  %134 = getelementptr inbounds i8, ptr %133, i64 8
  store ptr @_parameterization_i32, ptr %134, align 8
  %135 = getelementptr inbounds i8, ptr %133, i64 16
  store ptr @_parameterization_Bool, ptr %135, align 8
  %136 = getelementptr inbounds i8, ptr %133, i64 24
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %136, align 8
  %137 = call { i64, i64 } @size_wrapper(ptr %79, ptr noundef nonnull align 8 dereferenceable(32) %133)
  %138 = extractvalue { i64, i64 } %137, 0
  %139 = call ptr @bump_malloc(i64 %138)
  store ptr @_parameterization_i32, ptr %139, align 8
  %140 = getelementptr i8, ptr %139, i64 8
  store ptr @_parameterization_Bool, ptr %140, align 8
  %141 = getelementptr i8, ptr %139, i64 16
  store ptr @_parameterization_iteration.Pairi32._Bool, ptr %141, align 8
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %139)
  %143 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %143)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %143, ptr noalias nofree noundef nonnull readnone @tdfasjexas, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %144 = call ptr @adjust_trampoline(ptr %143)
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %143)
  %146 = insertvalue { ptr } undef, ptr %144, 0
  %147 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %147)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %147, ptr noalias nofree noundef nonnull readnone @zoeqkrwugn, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %148 = call ptr @adjust_trampoline(ptr %147)
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %147)
  %150 = insertvalue { ptr } undef, ptr %148, 0
  %151 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %139, 1
  %152 = insertvalue { ptr, ptr, ptr, i32 } %151, ptr undef, 2
  %153 = insertvalue { ptr, ptr, ptr, i32 } %152, i32 10, 3
  %154 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %154, align 8
  %155 = getelementptr inbounds i8, ptr %154, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %155, align 8
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %154)
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %158 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %158, align 8
  %159 = getelementptr inbounds i8, ptr %158, i64 8
  store ptr @function_typ, ptr %159, align 8
  %160 = call ptr @behavior_wrapper(ptr %101, { ptr, ptr, ptr, i32 } %153, ptr noundef nonnull align 8 dereferenceable(16) %158)
  call void %160({ ptr, ptr, ptr, i32 } %153, { ptr, ptr, ptr, i32 } %153, ptr nonnull %154, { ptr } %146, { ptr } %150)
  %161 = mul i32 %0, 10
  %.sroa.gep = getelementptr inbounds i8, ptr %60, i64 8
  %.sroa.gep567 = getelementptr inbounds i8, ptr %60, i64 16
  %.sroa.gep570 = getelementptr inbounds i8, ptr %60, i64 24
  %.sroa.gep573 = getelementptr inbounds i8, ptr %59, i64 8
  %.sroa.gep576 = getelementptr inbounds i8, ptr %59, i64 16
  %.sroa.gep579 = getelementptr inbounds i8, ptr %59, i64 24
  %162 = getelementptr inbounds i8, ptr %5, i64 8
  %163 = getelementptr inbounds i8, ptr %6, i64 8
  %164 = getelementptr inbounds i8, ptr %7, i64 8
  %165 = getelementptr inbounds i8, ptr %8, i64 8
  %166 = getelementptr inbounds i8, ptr %9, i64 8
  %167 = getelementptr inbounds i8, ptr %10, i64 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge1, %1
  %.0538 = phi i32 [ 0, %1 ], [ %.2, %._crit_edge1 ]
  %.0537 = phi i32 [ 0, %1 ], [ %.1, %._crit_edge1 ]
  %168 = icmp slt i32 %.0538, %0
  %169 = icmp slt i32 %.0537, %161
  %spec.select = select i1 %168, i1 %169, i1 false
  br i1 %spec.select, label %170, label %._crit_edge1

170:                                              ; preds = %._crit_edge3
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %173 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %111, ptr noundef nonnull align 8 %2)
  %174 = call i32 %173({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull %2)
  %.sroa.0527.0.insert.ext = zext i32 %174 to i160
  %175 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0527.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  %177 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %178 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %4, align 8
  %179 = call ptr @behavior_wrapper(ptr %178, { ptr, ptr, ptr, i32 } %153, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %180 = call { ptr, i160 } %179({ ptr, ptr, ptr, i32 } %153, { ptr, ptr, ptr, i32 } %153, ptr nonnull %3, { ptr, i160 } %175)
  %.fca.0.extract519 = extractvalue { ptr, i160 } %180, 0
  %181 = icmp eq ptr %.fca.0.extract519, @nil_typ
  %182 = icmp eq ptr %.fca.0.extract519, null
  %183 = or i1 %181, %182
  br i1 %183, label %184, label %._crit_edge2

184:                                              ; preds = %170
  %185 = add i32 %174, 1
  %.sroa.0510.0.insert.ext = zext i32 %185 to i160
  %186 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0510.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %162, align 8
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %189 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 256), align 8
  store ptr @i32_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %163, align 8
  %190 = call ptr @behavior_wrapper(ptr %189, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %190({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %5, { ptr, i160 } %175, { ptr, i160 } %186)
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %164, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %193 = load ptr, ptr getelementptr (i8, ptr @Array, i64 176), align 8
  store ptr @i32_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %165, align 8
  %194 = call ptr @behavior_wrapper(ptr %193, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %194({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %7, i32 %.0538, { ptr, i160 } %175)
  store i1 true, ptr %.sroa.0500.sroa.0, align 8
  %.sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.0. = load i8, ptr %.sroa.0500.sroa.0, align 8
  %.sroa.0500.0.insert.ext = zext i8 %.sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.sroa.0.0..sroa.0500.0. to i160
  %195 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0500.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %9, align 8
  store ptr @_parameterization_Bool, ptr %166, align 8
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  store ptr @i32_typ, ptr %10, align 8
  store ptr @bool_typ, ptr %167, align 8
  %198 = call ptr @behavior_wrapper(ptr %189, { ptr, ptr, ptr, i32 } %153, ptr noundef nonnull align 8 dereferenceable(16) %10)
  call void %198({ ptr, ptr, ptr, i32 } %153, { ptr, ptr, ptr, i32 } %153, ptr nonnull %9, { ptr, i160 } %175, { ptr, i160 } %195)
  %199 = add nsw i32 %.0538, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %184, %170
  %.1539 = phi i32 [ %199, %184 ], [ %.0538, %170 ]
  %200 = add i32 %.0537, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge2, %._crit_edge3
  %.2 = phi i32 [ %.1539, %._crit_edge2 ], [ %.0538, %._crit_edge3 ]
  %.1 = phi i32 [ %200, %._crit_edge2 ], [ %.0537, %._crit_edge3 ]
  br i1 %spec.select, label %._crit_edge3, label %201

201:                                              ; preds = %._crit_edge1
  %.sroa.gep565 = getelementptr inbounds i8, ptr %55, i64 8
  %.sroa.gep568 = getelementptr inbounds i8, ptr %55, i64 16
  %.sroa.gep571 = getelementptr inbounds i8, ptr %55, i64 24
  %.sroa.gep574 = getelementptr inbounds i8, ptr %54, i64 8
  %.sroa.gep577 = getelementptr inbounds i8, ptr %54, i64 16
  %.sroa.gep580 = getelementptr inbounds i8, ptr %54, i64 24
  %202 = icmp slt i32 %.2, %0
  br i1 %202, label %203, label %._crit_edge4

203:                                              ; preds = %201
  %204 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %204, align 1
  store ptr @String, ptr %11, align 8
  %205 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %206 = call { i64, i64 } @size_wrapper(ptr %205, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %207 = extractvalue { i64, i64 } %206, 0
  %208 = call ptr @bump_malloc(i64 %207)
  %209 = insertvalue { ptr } undef, ptr %204, 0
  %210 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %208, 1
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, ptr undef, 2
  %212 = insertvalue { ptr, ptr, ptr, i32 } %211, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %12, align 8
  %213 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @_parameterization_i32, ptr %213, align 8
  %214 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %214, align 8
  %215 = getelementptr inbounds i8, ptr %12, i64 24
  store ptr @_parameterization_i32, ptr %215, align 8
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %12)
  %217 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %218 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %13, align 8
  %219 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr @i32_typ, ptr %219, align 8
  %220 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %220, align 8
  %221 = getelementptr inbounds i8, ptr %13, i64 24
  store ptr @i32_typ, ptr %221, align 8
  %222 = call ptr @behavior_wrapper(ptr %218, { ptr, ptr, ptr, i32 } %212, ptr noundef nonnull align 8 dereferenceable(32) %13)
  call void %222({ ptr, ptr, ptr, i32 } %212, { ptr, ptr, ptr, i32 } %212, ptr nonnull %12, { ptr } %209, i32 29, i32 29, i32 30)
  %223 = ptrtoint ptr %208 to i64
  %.sroa.3481.8.insert.ext = zext i64 %223 to i160
  %.sroa.3481.8.insert.insert = or disjoint i160 %.sroa.3481.8.insert.ext, 3402823669209384634633746074317682114560
  %224 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3481.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %14, align 8
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %226 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %227 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %15, align 8
  %228 = call ptr @class_behavior_wrapper(ptr %227, ptr noundef nonnull align 8 dereferenceable(8) %15)
  call void %228(ptr nonnull %14, { ptr, i160 } %224)
  %.sroa.0474.0.insert.ext = zext i32 %.2 to i160
  %229 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0474.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %16, align 8
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %17, align 8
  %232 = call ptr @class_behavior_wrapper(ptr %227, ptr noundef nonnull align 8 dereferenceable(8) %17)
  call void %232(ptr nonnull %16, { ptr, i160 } %229)
  %233 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %233, align 1
  store ptr @String, ptr %18, align 8
  %234 = call { i64, i64 } @size_wrapper(ptr %205, ptr noundef nonnull align 8 dereferenceable(8) %18)
  %235 = extractvalue { i64, i64 } %234, 0
  %236 = call ptr @bump_malloc(i64 %235)
  %237 = insertvalue { ptr } undef, ptr %233, 0
  %238 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %236, 1
  %239 = insertvalue { ptr, ptr, ptr, i32 } %238, ptr undef, 2
  %240 = insertvalue { ptr, ptr, ptr, i32 } %239, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %19, align 8
  %241 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr @_parameterization_i32, ptr %241, align 8
  %242 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr @_parameterization_i32, ptr %242, align 8
  %243 = getelementptr inbounds i8, ptr %19, i64 24
  store ptr @_parameterization_i32, ptr %243, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %19)
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %20, align 8
  %246 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @i32_typ, ptr %246, align 8
  %247 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr @i32_typ, ptr %247, align 8
  %248 = getelementptr inbounds i8, ptr %20, i64 24
  store ptr @i32_typ, ptr %248, align 8
  %249 = call ptr @behavior_wrapper(ptr %218, { ptr, ptr, ptr, i32 } %240, ptr noundef nonnull align 8 dereferenceable(32) %20)
  call void %249({ ptr, ptr, ptr, i32 } %240, { ptr, ptr, ptr, i32 } %240, ptr nonnull %19, { ptr } %237, i32 29, i32 29, i32 30)
  %250 = ptrtoint ptr %236 to i64
  %.sroa.3460.8.insert.ext = zext i64 %250 to i160
  %.sroa.3460.8.insert.insert = or disjoint i160 %.sroa.3460.8.insert.ext, 3402823669209384634633746074317682114560
  %251 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3460.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %21, align 8
  %252 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %253 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %22, align 8
  %254 = call ptr @class_behavior_wrapper(ptr %227, ptr noundef nonnull align 8 dereferenceable(8) %22)
  call void %254(ptr nonnull %21, { ptr, i160 } %251)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %203, %201
  %.0552 = phi i32 [ %.2, %203 ], [ %0, %201 ]
  %255 = call i64 @clock()
  %256 = getelementptr inbounds i8, ptr %35, i64 8
  %257 = getelementptr inbounds i8, ptr %35, i64 16
  %258 = getelementptr inbounds i8, ptr %35, i64 24
  %259 = getelementptr inbounds i8, ptr %36, i64 8
  %260 = getelementptr inbounds i8, ptr %36, i64 16
  %261 = getelementptr inbounds i8, ptr %36, i64 24
  %262 = getelementptr inbounds i8, ptr %28, i64 8
  %263 = getelementptr inbounds i8, ptr %28, i64 16
  %264 = getelementptr inbounds i8, ptr %28, i64 24
  %265 = getelementptr inbounds i8, ptr %29, i64 8
  %266 = getelementptr inbounds i8, ptr %29, i64 16
  %267 = getelementptr inbounds i8, ptr %29, i64 24
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0546 = phi i32 [ 0, %._crit_edge4 ], [ %.1547, %._crit_edge5 ]
  %.0543 = phi i1 [ true, %._crit_edge4 ], [ %.3, %._crit_edge5 ]
  %.0540 = phi i32 [ 0, %._crit_edge4 ], [ %.2542, %._crit_edge5 ]
  %268 = icmp slt i32 %.0546, %.0552
  br i1 %268, label %269, label %._crit_edge5

269:                                              ; preds = %._crit_edge7
  store ptr @_parameterization_i32, ptr %23, align 8
  %270 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  %271 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %272 = load ptr, ptr getelementptr (i8, ptr @Array, i64 168), align 8
  store ptr @i32_typ, ptr %24, align 8
  %273 = call ptr @behavior_wrapper(ptr %272, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %274 = call { ptr, i160 } %273({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %23, i32 %.0546)
  %.fca.1.extract442 = extractvalue { ptr, i160 } %274, 1
  %.sroa.0435.0.insert.ext = and i160 %.fca.1.extract442, 4294967295
  %275 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0435.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %25, align 8
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %278 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 264), align 8
  store ptr @i32_typ, ptr %26, align 8
  %279 = call ptr @behavior_wrapper(ptr %278, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(8) %26)
  %280 = call { ptr, i160 } %279({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %25, { ptr, i160 } %275)
  %.fca.0.extract427 = extractvalue { ptr, i160 } %280, 0
  %281 = icmp ne ptr %.fca.0.extract427, @nil_typ
  %282 = icmp ne ptr %.fca.0.extract427, null
  %.not556 = and i1 %281, %282
  br i1 %.not556, label %283, label %309

283:                                              ; preds = %269
  %.fca.1.extract428 = extractvalue { ptr, i160 } %280, 1
  %.sroa.2430.8.extract.trunc = trunc i160 %.fca.1.extract428 to i32
  %.sroa.1444.8.extract.trunc = trunc i160 %.fca.1.extract442 to i32
  %284 = add i32 %.sroa.1444.8.extract.trunc, 1
  %.not = icmp eq i32 %284, %.sroa.2430.8.extract.trunc
  br i1 %.not, label %._crit_edge6, label %285

285:                                              ; preds = %283
  %286 = call ptr @bump_malloc(i64 noundef 46)
  store <45 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 119, i8 114, i8 111, i8 110, i8 103, i8 32, i8 118, i8 97, i8 108, i8 117, i8 101, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %286, align 1
  store ptr @String, ptr %27, align 8
  %287 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %288 = call { i64, i64 } @size_wrapper(ptr %287, ptr noundef nonnull align 8 dereferenceable(8) %27)
  %289 = extractvalue { i64, i64 } %288, 0
  %290 = call ptr @bump_malloc(i64 %289)
  %291 = insertvalue { ptr } undef, ptr %286, 0
  %292 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %290, 1
  %293 = insertvalue { ptr, ptr, ptr, i32 } %292, ptr undef, 2
  %294 = insertvalue { ptr, ptr, ptr, i32 } %293, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %28, align 8
  store ptr @_parameterization_i32, ptr %262, align 8
  store ptr @_parameterization_i32, ptr %263, align 8
  store ptr @_parameterization_i32, ptr %264, align 8
  %295 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %28)
  %296 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %297 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %29, align 8
  store ptr @i32_typ, ptr %265, align 8
  store ptr @i32_typ, ptr %266, align 8
  store ptr @i32_typ, ptr %267, align 8
  %298 = call ptr @behavior_wrapper(ptr %297, { ptr, ptr, ptr, i32 } %294, ptr noundef nonnull align 8 dereferenceable(32) %29)
  call void %298({ ptr, ptr, ptr, i32 } %294, { ptr, ptr, ptr, i32 } %294, ptr nonnull %28, { ptr } %291, i32 45, i32 45, i32 46)
  %299 = ptrtoint ptr %290 to i64
  %.sroa.3405.8.insert.ext = zext i64 %299 to i160
  %.sroa.3405.8.insert.insert = or disjoint i160 %.sroa.3405.8.insert.ext, 3402823669209384634633746074317682114560
  %300 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3405.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %30, align 8
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %302 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %303 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %31, align 8
  %304 = call ptr @class_behavior_wrapper(ptr %303, ptr noundef nonnull align 8 dereferenceable(8) %31)
  call void %304(ptr nonnull %30, { ptr, i160 } %300)
  store ptr @_parameterization_i32, ptr %32, align 8
  %305 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  %306 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %33, align 8
  %307 = call ptr @class_behavior_wrapper(ptr %303, ptr noundef nonnull align 8 dereferenceable(8) %33)
  call void %307(ptr nonnull %32, { ptr, i160 } %275)
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %285, %283
  %.1544 = phi i1 [ false, %285 ], [ %.0543, %283 ]
  %308 = add i32 %.0540, 1
  br label %332

309:                                              ; preds = %269
  %310 = call ptr @bump_malloc(i64 noundef 38)
  store <37 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 114, i8 101, i8 116, i8 117, i8 114, i8 110, i8 101, i8 100, i8 32, i8 78, i8 105, i8 108, i8 32, i8 102, i8 111, i8 114, i8 32, i8 107, i8 101, i8 121, i8 32>, ptr %310, align 1
  store ptr @String, ptr %34, align 8
  %311 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %312 = call { i64, i64 } @size_wrapper(ptr %311, ptr noundef nonnull align 8 dereferenceable(8) %34)
  %313 = extractvalue { i64, i64 } %312, 0
  %314 = call ptr @bump_malloc(i64 %313)
  %315 = insertvalue { ptr } undef, ptr %310, 0
  %316 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %314, 1
  %317 = insertvalue { ptr, ptr, ptr, i32 } %316, ptr undef, 2
  %318 = insertvalue { ptr, ptr, ptr, i32 } %317, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %35, align 8
  store ptr @_parameterization_i32, ptr %256, align 8
  store ptr @_parameterization_i32, ptr %257, align 8
  store ptr @_parameterization_i32, ptr %258, align 8
  %319 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %35)
  %320 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %321 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %36, align 8
  store ptr @i32_typ, ptr %259, align 8
  store ptr @i32_typ, ptr %260, align 8
  store ptr @i32_typ, ptr %261, align 8
  %322 = call ptr @behavior_wrapper(ptr %321, { ptr, ptr, ptr, i32 } %318, ptr noundef nonnull align 8 dereferenceable(32) %36)
  call void %322({ ptr, ptr, ptr, i32 } %318, { ptr, ptr, ptr, i32 } %318, ptr nonnull %35, { ptr } %315, i32 37, i32 37, i32 38)
  %323 = ptrtoint ptr %314 to i64
  %.sroa.3379.8.insert.ext = zext i64 %323 to i160
  %.sroa.3379.8.insert.insert = or disjoint i160 %.sroa.3379.8.insert.ext, 3402823669209384634633746074317682114560
  %324 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3379.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %37, align 8
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  %326 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %327 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %38, align 8
  %328 = call ptr @class_behavior_wrapper(ptr %327, ptr noundef nonnull align 8 dereferenceable(8) %38)
  call void %328(ptr nonnull %37, { ptr, i160 } %324)
  store ptr @_parameterization_i32, ptr %39, align 8
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  %330 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %40, align 8
  %331 = call ptr @class_behavior_wrapper(ptr %327, ptr noundef nonnull align 8 dereferenceable(8) %40)
  call void %331(ptr nonnull %39, { ptr, i160 } %275)
  br label %332

332:                                              ; preds = %309, %._crit_edge6
  %.2545 = phi i1 [ %.1544, %._crit_edge6 ], [ false, %309 ]
  %.1541 = phi i32 [ %308, %._crit_edge6 ], [ %.0540, %309 ]
  %333 = add i32 %.0546, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %332, %._crit_edge7
  %.1547 = phi i32 [ %333, %332 ], [ %.0546, %._crit_edge7 ]
  %.3 = phi i1 [ %.2545, %332 ], [ %.0543, %._crit_edge7 ]
  %.2542 = phi i32 [ %.1541, %332 ], [ %.0540, %._crit_edge7 ]
  br i1 %268, label %._crit_edge7, label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge5
  %334 = call i64 @clock()
  %.not557 = icmp eq i32 %.2542, %.0552
  %335 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %337 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 320), align 8
  %338 = call ptr @behavior_wrapper(ptr %337, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 %2)
  %339 = call i32 %338({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %2)
  %.not558 = icmp eq i32 %339, 0
  %340 = select i1 %.not558, i1 %.not557, i1 false
  %spec.select564 = select i1 %340, i1 %.3, i1 false
  %341 = icmp sgt i32 %.0552, 0
  br i1 %341, label %342, label %._crit_edge10

342:                                              ; preds = %._crit_edge8
  store ptr @_parameterization_i32, ptr %41, align 8
  %343 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %344 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull @Array)
  %345 = load ptr, ptr getelementptr (i8, ptr @Array, i64 168), align 8
  store ptr @i32_typ, ptr %42, align 8
  %346 = call ptr @behavior_wrapper(ptr %345, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(8) %42)
  %347 = call { ptr, i160 } %346({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %41, i32 0)
  %.fca.1.extract354 = extractvalue { ptr, i160 } %347, 1
  %.sroa.0350.0.insert.ext = and i160 %.fca.1.extract354, 4294967295
  %348 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0350.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %43, align 8
  %349 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  %350 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull @CuckooMap)
  %351 = load ptr, ptr getelementptr (i8, ptr @CuckooMap, i64 248), align 8
  store ptr @i32_typ, ptr %44, align 8
  %352 = call ptr @behavior_wrapper(ptr %351, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(8) %44)
  %353 = call { ptr, i160 } %352({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %43, { ptr, i160 } %348)
  %.fca.0.extract346 = extractvalue { ptr, i160 } %353, 0
  %354 = icmp eq ptr %.fca.0.extract346, @nil_typ
  %355 = icmp eq ptr %.fca.0.extract346, null
  %.not561.not = or i1 %354, %355
  %spec.select563 = select i1 %.not561.not, i1 %spec.select564, i1 false
  br label %._crit_edge10

._crit_edge10:                                    ; preds = %342, %._crit_edge8
  %.6 = phi i1 [ %spec.select564, %._crit_edge8 ], [ %spec.select563, %342 ]
  %356 = call ptr @bump_malloc(i64 noundef 14)
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %356, align 1
  store ptr @String, ptr %45, align 8
  %357 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %358 = call { i64, i64 } @size_wrapper(ptr %357, ptr noundef nonnull align 8 dereferenceable(8) %45)
  %359 = extractvalue { i64, i64 } %358, 0
  %360 = call ptr @bump_malloc(i64 %359)
  %361 = insertvalue { ptr } undef, ptr %356, 0
  %362 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %360, 1
  %363 = insertvalue { ptr, ptr, ptr, i32 } %362, ptr undef, 2
  %364 = insertvalue { ptr, ptr, ptr, i32 } %363, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %46, align 8
  %365 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @_parameterization_i32, ptr %365, align 8
  %366 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @_parameterization_i32, ptr %366, align 8
  %367 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr @_parameterization_i32, ptr %367, align 8
  %368 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %46)
  %369 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %370 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %47, align 8
  %371 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @i32_typ, ptr %371, align 8
  %372 = getelementptr inbounds i8, ptr %47, i64 16
  store ptr @i32_typ, ptr %372, align 8
  %373 = getelementptr inbounds i8, ptr %47, i64 24
  store ptr @i32_typ, ptr %373, align 8
  %374 = call ptr @behavior_wrapper(ptr %370, { ptr, ptr, ptr, i32 } %364, ptr noundef nonnull align 8 dereferenceable(32) %47)
  call void %374({ ptr, ptr, ptr, i32 } %364, { ptr, ptr, ptr, i32 } %364, ptr nonnull %46, { ptr } %361, i32 13, i32 13, i32 14)
  %375 = sub i64 %334, %255
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %364, i32 %.0552, i64 %375)
  %376 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %376, align 1
  store ptr @String, ptr %48, align 8
  %377 = call { i64, i64 } @size_wrapper(ptr %357, ptr noundef nonnull align 8 dereferenceable(8) %48)
  %378 = extractvalue { i64, i64 } %377, 0
  %379 = call ptr @bump_malloc(i64 %378)
  %380 = insertvalue { ptr } undef, ptr %376, 0
  %381 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %379, 1
  %382 = insertvalue { ptr, ptr, ptr, i32 } %381, ptr undef, 2
  %383 = insertvalue { ptr, ptr, ptr, i32 } %382, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %49, align 8
  %384 = getelementptr inbounds i8, ptr %49, i64 8
  store ptr @_parameterization_i32, ptr %384, align 8
  %385 = getelementptr inbounds i8, ptr %49, i64 16
  store ptr @_parameterization_i32, ptr %385, align 8
  %386 = getelementptr inbounds i8, ptr %49, i64 24
  store ptr @_parameterization_i32, ptr %386, align 8
  %387 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %49)
  %388 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %50, align 8
  %389 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr @i32_typ, ptr %389, align 8
  %390 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr @i32_typ, ptr %390, align 8
  %391 = getelementptr inbounds i8, ptr %50, i64 24
  store ptr @i32_typ, ptr %391, align 8
  %392 = call ptr @behavior_wrapper(ptr %370, { ptr, ptr, ptr, i32 } %383, ptr noundef nonnull align 8 dereferenceable(32) %50)
  call void %392({ ptr, ptr, ptr, i32 } %383, { ptr, ptr, ptr, i32 } %383, ptr nonnull %49, { ptr } %380, i32 18, i32 18, i32 19)
  %393 = ptrtoint ptr %379 to i64
  %.sroa.3305.8.insert.ext = zext i64 %393 to i160
  %.sroa.3305.8.insert.insert = or disjoint i160 %.sroa.3305.8.insert.ext, 3402823669209384634633746074317682114560
  %394 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3305.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %51, align 8
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %396 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %397 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %52, align 8
  %398 = call ptr @class_behavior_wrapper(ptr %397, ptr noundef nonnull align 8 dereferenceable(8) %52)
  call void %398(ptr nonnull %51, { ptr, i160 } %394)
  %399 = select i1 %.6, ptr %53, ptr %58
  %400 = call ptr @bump_malloc(i64 noundef 5)
  %.fca.0.extract = select i1 %.6, i8 80, i8 70
  %.sroa.0295.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.0.vec.insert = insertelement <4 x i8> poison, i8 %.fca.0.extract, i64 0
  %.sroa.0.3 = select i1 %.6, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>, <4 x i8> %.sroa.0.0.vec.insert
  %.sroa.0295.3 = select i1 %.6, <4 x i8> %.sroa.0295.0.vec.insert, <4 x i8> <i8 undef, i8 poison, i8 poison, i8 poison>
  %.sroa.0295.1.vec.insert = insertelement <4 x i8> %.sroa.0295.3, i8 65, i64 1
  %.sroa.0.1.vec.insert = insertelement <4 x i8> %.sroa.0.3, i8 65, i64 1
  %.sroa.0.2 = select i1 %.6, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>, <4 x i8> %.sroa.0.1.vec.insert
  %.fca.2.extract = select i1 %.6, i8 83, i8 73
  %.sroa.0295.2 = select i1 %.6, <4 x i8> %.sroa.0295.1.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 poison, i8 poison>
  %.sroa.0295.2.vec.insert = insertelement <4 x i8> %.sroa.0295.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.2.vec.insert = insertelement <4 x i8> %.sroa.0.2, i8 %.fca.2.extract, i64 2
  %.sroa.0.1 = select i1 %.6, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>, <4 x i8> %.sroa.0.2.vec.insert
  %.fca.3.extract = select i1 %.6, i8 83, i8 76
  %.sroa.0295.1 = select i1 %.6, <4 x i8> %.sroa.0295.2.vec.insert, <4 x i8> <i8 undef, i8 undef, i8 undef, i8 poison>
  %.sroa.0295.3.vec.insert = insertelement <4 x i8> %.sroa.0295.1, i8 %.fca.3.extract, i64 3
  %.sroa.0.3.vec.insert = insertelement <4 x i8> %.sroa.0.1, i8 %.fca.3.extract, i64 3
  %.sroa.speculated294 = select i1 %.6, <4 x i8> %.sroa.0295.3.vec.insert, <4 x i8> %.sroa.0.3.vec.insert
  store <4 x i8> %.sroa.speculated294, ptr %400, align 1
  store ptr @String, ptr %399, align 8
  %401 = call { i64, i64 } @size_wrapper(ptr %357, ptr noundef nonnull align 8 dereferenceable(8) %399)
  %402 = extractvalue { i64, i64 } %401, 0
  %403 = call ptr @bump_malloc(i64 %402)
  br i1 %.6, label %._crit_edge10.cont, label %._crit_edge10.else

._crit_edge10.else:                               ; preds = %._crit_edge10
  br label %._crit_edge10.cont

._crit_edge10.cont:                               ; preds = %._crit_edge10.else, %._crit_edge10
  %404 = phi ptr [ %62, %._crit_edge10.else ], [ %57, %._crit_edge10 ]
  %405 = phi ptr [ %61, %._crit_edge10.else ], [ %56, %._crit_edge10 ]
  %.sroa.phi = phi ptr [ %.sroa.gep, %._crit_edge10.else ], [ %.sroa.gep565, %._crit_edge10 ]
  %.sroa.phi566 = phi ptr [ %.sroa.gep567, %._crit_edge10.else ], [ %.sroa.gep568, %._crit_edge10 ]
  %.sroa.phi569 = phi ptr [ %.sroa.gep570, %._crit_edge10.else ], [ %.sroa.gep571, %._crit_edge10 ]
  %406 = phi ptr [ %60, %._crit_edge10.else ], [ %55, %._crit_edge10 ]
  %.sroa.phi572 = phi ptr [ %.sroa.gep573, %._crit_edge10.else ], [ %.sroa.gep574, %._crit_edge10 ]
  %.sroa.phi575 = phi ptr [ %.sroa.gep576, %._crit_edge10.else ], [ %.sroa.gep577, %._crit_edge10 ]
  %.sroa.phi578 = phi ptr [ %.sroa.gep579, %._crit_edge10.else ], [ %.sroa.gep580, %._crit_edge10 ]
  %407 = phi ptr [ %59, %._crit_edge10.else ], [ %54, %._crit_edge10 ]
  %408 = insertvalue { ptr } undef, ptr %400, 0
  %409 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %403, 1
  %410 = insertvalue { ptr, ptr, ptr, i32 } %409, ptr undef, 2
  %411 = insertvalue { ptr, ptr, ptr, i32 } %410, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %407, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi572, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi575, align 8
  store ptr @_parameterization_i32, ptr %.sroa.phi578, align 8
  %412 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %407)
  %413 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %406, align 8
  store ptr @i32_typ, ptr %.sroa.phi, align 8
  store ptr @i32_typ, ptr %.sroa.phi566, align 8
  store ptr @i32_typ, ptr %.sroa.phi569, align 8
  %414 = call ptr @behavior_wrapper(ptr %370, { ptr, ptr, ptr, i32 } %411, ptr noundef nonnull align 8 dereferenceable(32) %406)
  call void %414({ ptr, ptr, ptr, i32 } %411, { ptr, ptr, ptr, i32 } %411, ptr nonnull %407, { ptr } %408, i32 4, i32 4, i32 5)
  %415 = ptrtoint ptr %403 to i64
  %.sroa.3269.8.insert.ext = zext i64 %415 to i160
  %.sroa.3269.8.insert.insert = or disjoint i160 %.sroa.3269.8.insert.ext, 3402823669209384634633746074317682114560
  %416 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3269.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %405, align 8
  %417 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %405)
  %418 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %404, align 8
  %419 = call ptr @class_behavior_wrapper(ptr %397, ptr noundef nonnull align 8 dereferenceable(8) %404)
  call void %419(ptr nonnull %405, { ptr, i160 } %416)
  %420 = call ptr @bump_malloc(i64 noundef 21)
  store <20 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %420, align 1
  store ptr @String, ptr %63, align 8
  %421 = call { i64, i64 } @size_wrapper(ptr %357, ptr noundef nonnull align 8 dereferenceable(8) %63)
  %422 = extractvalue { i64, i64 } %421, 0
  %423 = call ptr @bump_malloc(i64 %422)
  %424 = insertvalue { ptr } undef, ptr %420, 0
  %425 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %423, 1
  %426 = insertvalue { ptr, ptr, ptr, i32 } %425, ptr undef, 2
  %427 = insertvalue { ptr, ptr, ptr, i32 } %426, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %64, align 8
  %428 = getelementptr inbounds i8, ptr %64, i64 8
  store ptr @_parameterization_i32, ptr %428, align 8
  %429 = getelementptr inbounds i8, ptr %64, i64 16
  store ptr @_parameterization_i32, ptr %429, align 8
  %430 = getelementptr inbounds i8, ptr %64, i64 24
  store ptr @_parameterization_i32, ptr %430, align 8
  %431 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %64)
  %432 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %65, align 8
  %433 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr @i32_typ, ptr %433, align 8
  %434 = getelementptr inbounds i8, ptr %65, i64 16
  store ptr @i32_typ, ptr %434, align 8
  %435 = getelementptr inbounds i8, ptr %65, i64 24
  store ptr @i32_typ, ptr %435, align 8
  %436 = call ptr @behavior_wrapper(ptr %370, { ptr, ptr, ptr, i32 } %427, ptr noundef nonnull align 8 dereferenceable(32) %65)
  call void %436({ ptr, ptr, ptr, i32 } %427, { ptr, ptr, ptr, i32 } %427, ptr nonnull %64, { ptr } %424, i32 20, i32 20, i32 21)
  %437 = ptrtoint ptr %423 to i64
  %.sroa.3117.8.insert.ext = zext i64 %437 to i160
  %.sroa.3117.8.insert.insert = or disjoint i160 %.sroa.3117.8.insert.ext, 3402823669209384634633746074317682114560
  %438 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3117.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %66, align 8
  %439 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %67, align 8
  %441 = call ptr @class_behavior_wrapper(ptr %397, ptr noundef nonnull align 8 dereferenceable(8) %67)
  call void %441(ptr nonnull %66, { ptr, i160 } %438)
  %.sroa.0111.0.insert.ext = zext i32 %.2542 to i160
  %442 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0111.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %68, align 8
  %443 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %68)
  %444 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @i32_typ, ptr %69, align 8
  %445 = call ptr @class_behavior_wrapper(ptr %397, ptr noundef nonnull align 8 dereferenceable(8) %69)
  call void %445(ptr nonnull %68, { ptr, i160 } %442)
  %446 = call ptr @bump_malloc(i64 noundef 2)
  store <1 x i8> <i8 41>, ptr %446, align 1
  store ptr @String, ptr %70, align 8
  %447 = call { i64, i64 } @size_wrapper(ptr %357, ptr noundef nonnull align 8 dereferenceable(8) %70)
  %448 = extractvalue { i64, i64 } %447, 0
  %449 = call ptr @bump_malloc(i64 %448)
  %450 = insertvalue { ptr } undef, ptr %446, 0
  %451 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %449, 1
  %452 = insertvalue { ptr, ptr, ptr, i32 } %451, ptr undef, 2
  %453 = insertvalue { ptr, ptr, ptr, i32 } %452, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %71, align 8
  %454 = getelementptr inbounds i8, ptr %71, i64 8
  store ptr @_parameterization_i32, ptr %454, align 8
  %455 = getelementptr inbounds i8, ptr %71, i64 16
  store ptr @_parameterization_i32, ptr %455, align 8
  %456 = getelementptr inbounds i8, ptr %71, i64 24
  store ptr @_parameterization_i32, ptr %456, align 8
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %71)
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  store ptr @buffer_typ, ptr %72, align 8
  %459 = getelementptr inbounds i8, ptr %72, i64 8
  store ptr @i32_typ, ptr %459, align 8
  %460 = getelementptr inbounds i8, ptr %72, i64 16
  store ptr @i32_typ, ptr %460, align 8
  %461 = getelementptr inbounds i8, ptr %72, i64 24
  store ptr @i32_typ, ptr %461, align 8
  %462 = call ptr @behavior_wrapper(ptr %370, { ptr, ptr, ptr, i32 } %453, ptr noundef nonnull align 8 dereferenceable(32) %72)
  call void %462({ ptr, ptr, ptr, i32 } %453, { ptr, ptr, ptr, i32 } %453, ptr nonnull %71, { ptr } %450, i32 1, i32 1, i32 2)
  %463 = ptrtoint ptr %449 to i64
  %.sroa.3.8.insert.ext = zext i64 %463 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %464 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_core.String, ptr %73, align 8
  %465 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %73)
  %466 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  store ptr @String, ptr %74, align 8
  %467 = call ptr @class_behavior_wrapper(ptr %397, ptr noundef nonnull align 8 dereferenceable(8) %74)
  call void %467(ptr nonnull %73, { ptr, i160 } %464)
  ret void
}

define noundef i32 @main() local_unnamed_addr #3 {
  call void @setup_landing_pad()
  %1 = call ptr @bump_malloc(i64 noundef 23)
  store <22 x i8> <i8 45, i8 45, i8 45, i8 32, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %1, align 1
  %2 = alloca [1 x ptr], align 8
  store ptr @String, ptr %2, align 8
  %3 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %4 = call { i64, i64 } @size_wrapper(ptr %3, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %5 = extractvalue { i64, i64 } %4, 0
  %6 = call ptr @bump_malloc(i64 %5)
  %7 = insertvalue { ptr } undef, ptr %1, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %6, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr undef, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 10, 3
  %11 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_i32, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @_parameterization_i32, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %11, i64 24
  store ptr @_parameterization_i32, ptr %14, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %11)
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %17 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  %18 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @i32_typ, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @i32_typ, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %18, i64 24
  store ptr @i32_typ, ptr %21, align 8
  %22 = call ptr @behavior_wrapper(ptr %17, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 dereferenceable(32) %18)
  call void %22({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull %11, { ptr } %7, i32 22, i32 22, i32 23)
  %23 = ptrtoint ptr %6 to i64
  %.sroa.323.8.insert.ext = zext i64 %23 to i160
  %.sroa.323.8.insert.insert = or disjoint i160 %.sroa.323.8.insert.ext, 3402823669209384634633746074317682114560
  %24 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.323.8.insert.insert, 1
  %25 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %28 = load ptr, ptr getelementptr (i8, ptr @IO, i64 80), align 8
  %29 = alloca { ptr }, align 8
  store ptr @String, ptr %29, align 8
  %30 = call ptr @class_behavior_wrapper(ptr %28, ptr noundef nonnull align 8 dereferenceable(8) %29)
  call void %30(ptr nonnull %25, { ptr, i160 } %24)
  call void @benchmark_insert_sequential(i32 noundef 1000000)
  call void @benchmark_insert_random(i32 noundef 1000000)
  call void @benchmark_get_sequential_hit(i32 noundef 1000000)
  call void @benchmark_get_random_hit(i32 noundef 1000000)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %31 = call ptr @bump_malloc(i64 noundef 28)
  store <27 x i8> <i8 45, i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %31, align 1
  %32 = alloca [1 x ptr], align 8
  store ptr @String, ptr %32, align 8
  %33 = call { i64, i64 } @size_wrapper(ptr %3, ptr noundef nonnull align 8 dereferenceable(8) %32)
  %34 = extractvalue { i64, i64 } %33, 0
  %35 = call ptr @bump_malloc(i64 %34)
  %36 = insertvalue { ptr } undef, ptr %31, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %35, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr undef, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 10, 3
  %40 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store ptr @_parameterization_i32, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %40)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %46 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @i32_typ, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr @i32_typ, ptr %49, align 8
  %50 = call ptr @behavior_wrapper(ptr %17, { ptr, ptr, ptr, i32 } %39, ptr noundef nonnull align 8 dereferenceable(32) %46)
  call void %50({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull %40, { ptr } %36, i32 27, i32 27, i32 28)
  %51 = ptrtoint ptr %35 to i64
  %.sroa.3.8.insert.ext = zext i64 %51 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %52 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  %53 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @IO)
  %56 = alloca { ptr }, align 8
  store ptr @String, ptr %56, align 8
  %57 = call ptr @class_behavior_wrapper(ptr %28, ptr noundef nonnull align 8 dereferenceable(8) %56)
  call void %57(ptr nonnull %53, { ptr, i160 } %52)
  ret i32 0
}

define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #3 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 16, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 16
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = extractvalue { i64, i64 } %21, 1
  %24 = call i64 @llvm.umax.i64(i64 %9, i64 %23)
  %25 = call i64 @llvm.umax.i64(i64 %24, i64 noundef 8), !range !1
  %26 = urem i64 %15, %23
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %23, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %22, %15
  %31 = add i64 %30, %29
  %32 = urem i64 %31, %25
  %33 = icmp eq i64 %32, 0
  %34 = sub i64 %25, %32
  %35 = select i1 %33, i64 0, i64 %34
  %36 = add i64 %31, %35
  %37 = insertvalue { i64, i64 } undef, i64 %36, 0
  %38 = insertvalue { i64, i64 } %37, i64 %25, 1
  ret { i64, i64 } %38
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Pair_B__set_first_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 168
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @Pair_B__set_second_valueU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 176
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 184
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(192) @Pair)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract7)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract8) #31
  ret { ptr, i160 } %11
}

define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(192) @Pair)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract7)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract8) #31
  ret { ptr, i160 } %11
}

define void @Pair__set_first_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(192) @Pair)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract7)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract7, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract8, { ptr, i160 } %3) #30
  ret void
}

define void @Pair__set_second_valueU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(192) @Pair)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract7)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract7, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract8, { ptr, i160 } %3) #30
  ret void
}

define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(192) @Pair)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract18)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract18, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract19, { ptr, i160 } %3) #30
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract18)
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract19, { ptr, i160 } %4) #30
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

define { ptr, i160 } @Pair_getter_second(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = extractvalue { i64, i64 } %6, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %20 = call { i64, i64 } @size_wrapper(ptr %19, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %21 = extractvalue { i64, i64 } %20, 1
  %22 = urem i64 %14, %21
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 %21, %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = getelementptr i8, ptr %0, i64 %14
  %27 = getelementptr i8, ptr %26, i64 %25
  %28 = load ptr, ptr %15, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = call { ptr, i160 } @box_wrapper(ptr %31, ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %28)
  ret { ptr, i160 } %32
}

define void @Pair_setter_second(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 16, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 16
  %15 = add i64 %14, %13
  %16 = getelementptr inbounds i8, ptr %0, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 1
  %23 = urem i64 %15, %22
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %22, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = getelementptr i8, ptr %0, i64 %15
  %28 = getelementptr i8, ptr %27, i64 %26
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  call void @unbox_wrapper(ptr %32, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %29, ptr %28)
  ret void
}

define { ptr, i160 } @Pair_getter_first(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = load ptr, ptr %0, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 56
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } @box_wrapper(ptr %16, ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %13)
  ret { ptr, i160 } %17
}

define void @Pair_setter_first(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %reass.sub = sub i64 %8, %9
  %11 = add i64 %reass.sub, 16
  %12 = select i1 %10, i64 16, i64 %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load ptr, ptr %0, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 64
  %17 = load ptr, ptr %16, align 8
  call void @unbox_wrapper(ptr %17, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %14, ptr %13)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_8(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @CuckooMap_B__Self_max_displacements_(ptr nocapture nofree %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #29
  ret ptr @CuckooMap__Self_max_displacements_
}

define ptr @CuckooMap_B_hash1_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 440
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 4015701072841558310, i64 noundef ptrtoint (ptr @Entry to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 472
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_resize_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 496
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 504
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 512
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 528
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 536
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @CuckooMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 544
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_keys_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_indices_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_values_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 584
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 592
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 616
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 624
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 632
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 648
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 656
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 74, i64 73
  %8 = getelementptr [1144 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 680
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 76, %22 ], [ 76, %15 ], [ 77, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [1144 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @CuckooMap_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 79, %22 ], [ 79, %15 ], [ 78, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [1144 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @CuckooMap_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 81, %22 ], [ 81, %15 ], [ 80, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [1144 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @CuckooMap_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 83, %22 ], [ 83, %15 ], [ 82, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [1144 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @CuckooMap__Self_max_displacements_(ptr nocapture nofree readnone %0) #1 {
  ret i32 100
}

define i32 @CuckooMap_hash1_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract10)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract10, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr %.fca.1.extract11) #31
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = call i32 %.fca.0.extract({ ptr, i160 } %3)
  ret i32 %13
}

define i32 @CuckooMap_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %6 = call i32 @i32_hasher(i32 %3)
  ret i32 %6
}

define i32 @CuckooMap_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 40
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call i32 %11(ptr %.fca.1.extract) #31
  %13 = add i32 %12, -1
  %14 = and i32 %13, %3
  ret i32 %14
}

define i32 @CuckooMap_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  %10 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %13 = sext i32 %5 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract, i64 %13
  %15 = getelementptr i8, ptr %14, i64 88
  %16 = load ptr, ptr %15, align 8
  %17 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %17, align 8
  %18 = call ptr @behavior_wrapper(ptr %16, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %19 = call i32 %18({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %10, i32 %3)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %21 = getelementptr i8, ptr %14, i64 40
  %22 = load ptr, ptr %21, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = call i32 %23(ptr %.fca.1.extract) #31
  %25 = add i32 %24, -1
  %26 = and i32 %25, %19
  ret i32 %26
}

define { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca {}, align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %.sroa.1.sroa.0 = alloca [8 x i8], align 8
  %.sroa.1.sroa.3 = alloca [8 x i8], align 8
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %11 = call i32 @get_offset(ptr %.fca.0.extract46, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %12 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %13 = getelementptr inbounds i8, ptr %6, i64 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %15 = sext i32 %11 to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract46, i64 %15
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract46, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract47, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract48, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %11, 3
  %22 = getelementptr i8, ptr %16, i64 104
  %23 = getelementptr i8, ptr %16, i64 32
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract46, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract47, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract48, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %11, 3
  %28 = getelementptr i8, ptr %16, i64 96
  %29 = getelementptr i8, ptr %16, i64 24
  br label %30

30:                                               ; preds = %113, %4
  %.sroa.3.0320 = phi i64 [ undef, %4 ], [ %.sroa.3.2321, %113 ]
  %.sroa.6318.0 = phi i64 [ undef, %4 ], [ %.sroa.6318.2, %113 ]
  %.sroa.0316.0 = phi ptr [ undef, %4 ], [ %.sroa.0316.2, %113 ]
  %.sroa.3.sroa.3.0 = phi i64 [ undef, %4 ], [ %.sroa.3.sroa.3.2, %113 ]
  %.sroa.3.sroa.0.0 = phi i64 [ undef, %4 ], [ %.sroa.3.sroa.0.2, %113 ]
  %.sroa.0275.0 = phi ptr [ undef, %4 ], [ %.sroa.0275.2, %113 ]
  %.sroa.17.0 = phi i32 [ %12, %4 ], [ %.sroa.17.2, %113 ]
  %.sroa.12.0 = phi ptr [ %.fca.2.extract, %4 ], [ %.sroa.12.2, %113 ]
  %.sroa.6.0 = phi ptr [ %.fca.1.extract, %4 ], [ %.sroa.6.2, %113 ]
  %.sroa.0.0 = phi ptr [ %.fca.0.extract, %4 ], [ %.sroa.0.2, %113 ]
  %.sroa.265.0 = phi ptr [ undef, %4 ], [ %.sroa.265.3, %113 ]
  %.sroa.3206.0 = phi ptr [ undef, %4 ], [ %.sroa.3206.3, %113 ]
  %.sroa.5207.0 = phi ptr [ undef, %4 ], [ %.sroa.5207.3, %113 ]
  %.0228 = phi i1 [ true, %4 ], [ %.3, %113 ]
  %.0 = phi i32 [ 0, %4 ], [ %.1, %113 ]
  %31 = load ptr, ptr %16, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %.fca.1.extract47)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %34 = load ptr, ptr %17, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract47)
  store ptr %32, ptr %6, align 8
  store ptr %35, ptr %13, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %38 = call ptr @class_behavior_wrapper(ptr noundef nonnull @CuckooMap_B__Self_max_displacements_, ptr noundef nonnull align 8 %5)
  %39 = call i32 %38(ptr nonnull %6)
  %40 = icmp slt i32 %.0, %39
  br i1 %40, label %41, label %113

41:                                               ; preds = %30
  %42 = add nsw i32 %.0, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.sroa.6.0, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.sroa.12.0, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.sroa.17.0, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0)
  %49 = sext i32 %.sroa.17.0 to i64
  %50 = getelementptr ptr, ptr %.sroa.0.0, i64 %49
  %51 = getelementptr i8, ptr %50, i64 64
  %52 = load ptr, ptr %51, align 8
  %53 = call ptr @behavior_wrapper(ptr %52, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 %5)
  %54 = call i32 %53({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %5)
  br i1 %.0228, label %55, label %71

55:                                               ; preds = %41
  store ptr @_parameterization_i32, ptr %7, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %58 = load ptr, ptr %28, align 8
  store ptr @i32_typ, ptr %8, align 8
  %59 = call ptr @behavior_wrapper(ptr %58, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %60 = call i32 %59({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull %7, i32 %54)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %62 = load ptr, ptr %29, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call { ptr } %63(ptr %.fca.1.extract47) #31
  %.fca.0.extract218 = extractvalue { ptr } %64, 0
  %65 = sext i32 %60 to i64
  %66 = shl nsw i64 %65, 5
  %67 = getelementptr i8, ptr %.fca.0.extract218, i64 %66
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %67, i64 8
  %70 = load i160, ptr %69, align 4
  %.sroa.3.8.extract.trunc = trunc i160 %70 to i64
  %.sroa.6318.8.extract.shift = lshr i160 %70, 64
  %.sroa.6318.8.extract.trunc = trunc i160 %.sroa.6318.8.extract.shift to i64
  br label %87

71:                                               ; preds = %41
  store ptr @_parameterization_i32, ptr %9, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %74 = load ptr, ptr %22, align 8
  store ptr @i32_typ, ptr %10, align 8
  %75 = call ptr @behavior_wrapper(ptr %74, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %76 = call i32 %75({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %9, i32 %54)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %78 = load ptr, ptr %23, align 8
  %79 = load ptr, ptr %78, align 8
  %80 = call { ptr } %79(ptr %.fca.1.extract47) #31
  %.fca.0.extract199 = extractvalue { ptr } %80, 0
  %81 = sext i32 %76 to i64
  %82 = shl nsw i64 %81, 5
  %83 = getelementptr i8, ptr %.fca.0.extract199, i64 %82
  %84 = load ptr, ptr %83, align 8
  %85 = getelementptr i8, ptr %83, i64 8
  %86 = load i160, ptr %85, align 4
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %86 to i64
  %.sroa.3.sroa.3.0.extract.shift = lshr i160 %86, 64
  %.sroa.3.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.sroa.3.0.extract.shift to i64
  br label %87

87:                                               ; preds = %71, %55
  %.sink332 = phi ptr [ %79, %71 ], [ %63, %55 ]
  %.sink331 = phi i64 [ %82, %71 ], [ %66, %55 ]
  %.sink324 = phi ptr [ %84, %71 ], [ %68, %55 ]
  %.sroa.0275.0..sroa.speculated315 = phi ptr [ %84, %71 ], [ %.sroa.0275.0, %55 ]
  %.sroa.speculated315..sroa.0316.0 = phi ptr [ %.sroa.0316.0, %71 ], [ %68, %55 ]
  %.sroa.3.1 = phi i64 [ %.sroa.3.0320, %71 ], [ %.sroa.3.8.extract.trunc, %55 ]
  %.sroa.6318.1 = phi i64 [ %.sroa.6318.0, %71 ], [ %.sroa.6318.8.extract.trunc, %55 ]
  %.sroa.3.sroa.3.1 = phi i64 [ %.sroa.3.sroa.3.0.extract.trunc, %71 ], [ %.sroa.3.sroa.3.0, %55 ]
  %.sroa.3.sroa.0.1 = phi i64 [ %.sroa.3.sroa.0.0.extract.trunc, %71 ], [ %.sroa.3.sroa.0.0, %55 ]
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %89 = call { ptr } %.sink332(ptr %.fca.1.extract47) #31
  %.fca.0.extract196 = extractvalue { ptr } %89, 0
  %90 = getelementptr i8, ptr %.fca.0.extract196, i64 %.sink331
  store ptr %.sroa.0.0, ptr %90, align 8
  %91 = getelementptr i8, ptr %90, i64 8
  %92 = ptrtoint ptr %.sroa.6.0 to i64
  %93 = ptrtoint ptr %.sroa.12.0 to i64
  store i64 %92, ptr %91, align 4
  %.sroa_idx256 = getelementptr i8, ptr %90, i64 16
  store i64 %93, ptr %.sroa_idx256, align 4
  %.sroa_idx257 = getelementptr i8, ptr %90, i64 24
  store i32 %.sroa.17.0, ptr %.sroa_idx257, align 4
  %94 = icmp ne ptr %.sink324, @nil_typ
  %95 = icmp ne ptr %.sink324, null
  %.not248 = and i1 %94, %95
  br i1 %.not248, label %.cont190, label %._crit_edge

.cont190:                                         ; preds = %87
  br i1 %.0228, label %.cont190.then, label %.cont190.else

.cont190.then:                                    ; preds = %.cont190
  %96 = inttoptr i64 %.sroa.3.1 to ptr
  %97 = inttoptr i64 %.sroa.6318.1 to ptr
  br label %.cont190.cont

.cont190.else:                                    ; preds = %.cont190
  store i64 %.sroa.3.sroa.0.1, ptr %.sroa.1.sroa.0, align 8
  store i64 %.sroa.3.sroa.3.1, ptr %.sroa.1.sroa.3, align 8
  br label %.cont190.cont

.cont190.cont:                                    ; preds = %.cont190.else, %.cont190.then
  %.sroa.5207.4 = phi ptr [ %97, %.cont190.then ], [ %.sroa.5207.0, %.cont190.else ]
  %.sroa.3206.4 = phi ptr [ %96, %.cont190.then ], [ %.sroa.3206.0, %.cont190.else ]
  %.sroa.speculated293 = phi ptr [ %.sroa.speculated315..sroa.0316.0, %.cont190.then ], [ %.sroa.0275.0..sroa.speculated315, %.cont190.else ]
  %98 = call i32 @get_offset(ptr nonnull %.sink324, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %99 = getelementptr i8, ptr %.sroa.speculated293, i64 8
  %100 = getelementptr i8, ptr %.sroa.speculated293, i64 16
  %101 = getelementptr i8, ptr %.sroa.speculated293, i64 24
  %102 = getelementptr i8, ptr %.sroa.speculated293, i64 32
  %103 = load i64, ptr %99, align 4
  %104 = load i64, ptr %100, align 4
  %105 = load ptr, ptr %101, align 8
  %106 = load ptr, ptr %102, align 8
  %107 = call i1 @subtype_test_wrapper(ptr %105, i64 %104, i64 %103, i64 noundef 4015701072841558310, i64 noundef ptrtoint (ptr @Entry to i64), ptr %106)
  br i1 %107, label %.cont175, label %._crit_edge

.cont175:                                         ; preds = %.cont190.cont
  %108 = xor i1 %.0228, true
  %.sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.speculate.load.false277 = load ptr, ptr %.sroa.1.sroa.0, align 8
  %.sroa.1.sroa.3.0..sroa.1.sroa.3.0..sroa.1.sroa.3.0..sroa.1.sroa.3.8..sroa.speculate.load.false = load ptr, ptr %.sroa.1.sroa.3, align 8
  %109 = call i32 @get_offset(ptr %.sroa.speculated293, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %110 = call i32 @get_offset(ptr %.sroa.speculated293, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %.sroa.speculated118 = select i1 %.0228, ptr %.sroa.5207.4, ptr %.sroa.1.sroa.3.0..sroa.1.sroa.3.0..sroa.1.sroa.3.0..sroa.1.sroa.3.8..sroa.speculate.load.false
  %.sroa.speculated124 = select i1 %.0228, ptr %.sroa.3206.4, ptr %.sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.speculate.load.false277
  %.sroa.265.4 = select i1 %.0228, ptr %.sroa.265.0, ptr %.sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.speculate.load.false277
  %111 = call i32 @get_offset(ptr %.sroa.speculated293, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  br i1 %.0228, label %._crit_edge, label %.cont175.else281

.cont175.else281:                                 ; preds = %.cont175
  store ptr %.sroa.265.4, ptr %.sroa.1.sroa.0, align 8
  store ptr %.sroa.1.sroa.3.0..sroa.1.sroa.3.0..sroa.1.sroa.3.0..sroa.1.sroa.3.8..sroa.speculate.load.false, ptr %.sroa.1.sroa.3, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %.cont175.else281, %.cont175, %.cont190.cont, %87
  %.sroa.0316.1 = phi ptr [ %.sroa.speculated315..sroa.0316.0, %.cont190.cont ], [ %.sroa.0316.0, %87 ], [ %.sroa.speculated315..sroa.0316.0, %.cont175.else281 ], [ %.sroa.speculated315..sroa.0316.0, %.cont175 ]
  %.sroa.0275.1 = phi ptr [ %.sroa.0275.0..sroa.speculated315, %.cont190.cont ], [ %.sroa.0275.0, %87 ], [ %.sroa.0275.0..sroa.speculated315, %.cont175.else281 ], [ %.sroa.0275.0..sroa.speculated315, %.cont175 ]
  %.sroa.17.1 = phi i32 [ %.sroa.17.0, %.cont190.cont ], [ %.sroa.17.0, %87 ], [ %110, %.cont175.else281 ], [ %110, %.cont175 ]
  %.sroa.12.1 = phi ptr [ %.sroa.12.0, %.cont190.cont ], [ %.sroa.12.0, %87 ], [ %.sroa.speculated118, %.cont175.else281 ], [ %.sroa.speculated118, %.cont175 ]
  %.sroa.6.1 = phi ptr [ %.sroa.6.0, %.cont190.cont ], [ %.sroa.6.0, %87 ], [ %.sroa.speculated124, %.cont175.else281 ], [ %.sroa.speculated124, %.cont175 ]
  %.sroa.0.1 = phi ptr [ %.sroa.0.0, %.cont190.cont ], [ %.sroa.0.0, %87 ], [ %.sroa.speculated293, %.cont175.else281 ], [ %.sroa.speculated293, %.cont175 ]
  %.sroa.265.2 = phi ptr [ %.sroa.265.0, %.cont190.cont ], [ %.sroa.265.0, %87 ], [ %.sroa.265.4, %.cont175.else281 ], [ %.sroa.265.4, %.cont175 ]
  %.sroa.3206.2 = phi ptr [ %.sroa.3206.0, %.cont190.cont ], [ %.sroa.3206.0, %87 ], [ %.sroa.3206.4, %.cont175.else281 ], [ %.sroa.3206.4, %.cont175 ]
  %.sroa.5207.2 = phi ptr [ %.sroa.5207.0, %.cont190.cont ], [ %.sroa.5207.0, %87 ], [ %.sroa.5207.4, %.cont175.else281 ], [ %.sroa.5207.4, %.cont175 ]
  %.2 = phi i1 [ %.0228, %.cont190.cont ], [ %.0228, %87 ], [ %108, %.cont175.else281 ], [ %108, %.cont175 ]
  %112 = xor i1 %.not248, true
  br label %113

113:                                              ; preds = %._crit_edge, %30
  %.sroa.3.2321 = phi i64 [ %.sroa.3.1, %._crit_edge ], [ %.sroa.3.0320, %30 ]
  %.sroa.6318.2 = phi i64 [ %.sroa.6318.1, %._crit_edge ], [ %.sroa.6318.0, %30 ]
  %.sroa.0316.2 = phi ptr [ %.sroa.0316.1, %._crit_edge ], [ %.sroa.0316.0, %30 ]
  %.sroa.3.sroa.3.2 = phi i64 [ %.sroa.3.sroa.3.1, %._crit_edge ], [ %.sroa.3.sroa.3.0, %30 ]
  %.sroa.3.sroa.0.2 = phi i64 [ %.sroa.3.sroa.0.1, %._crit_edge ], [ %.sroa.3.sroa.0.0, %30 ]
  %.sroa.0275.2 = phi ptr [ %.sroa.0275.1, %._crit_edge ], [ %.sroa.0275.0, %30 ]
  %.sroa.17.2 = phi i32 [ %.sroa.17.1, %._crit_edge ], [ %.sroa.17.0, %30 ]
  %.sroa.12.2 = phi ptr [ %.sroa.12.1, %._crit_edge ], [ %.sroa.12.0, %30 ]
  %.sroa.6.2 = phi ptr [ %.sroa.6.1, %._crit_edge ], [ %.sroa.6.0, %30 ]
  %.sroa.0.2 = phi ptr [ %.sroa.0.1, %._crit_edge ], [ %.sroa.0.0, %30 ]
  %.sroa.265.3 = phi ptr [ %.sroa.265.2, %._crit_edge ], [ %.sroa.265.0, %30 ]
  %.reg2mem125.0.off0 = phi i1 [ %.not248, %._crit_edge ], [ false, %30 ]
  %.reg2mem127.0 = phi i1 [ %112, %._crit_edge ], [ false, %30 ]
  %.sroa.3206.3 = phi ptr [ %.sroa.3206.2, %._crit_edge ], [ %.sroa.3206.0, %30 ]
  %.sroa.5207.3 = phi ptr [ %.sroa.5207.2, %._crit_edge ], [ %.sroa.5207.0, %30 ]
  %.3 = phi i1 [ %.2, %._crit_edge ], [ %.0228, %30 ]
  %.1 = phi i32 [ %42, %._crit_edge ], [ %.0, %30 ]
  br i1 %.reg2mem125.0.off0, label %30, label %114

114:                                              ; preds = %113
  br i1 %.reg2mem127.0, label %115, label %125

115:                                              ; preds = %114
  %116 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %117 = getelementptr i8, ptr %16, i64 48
  %118 = load ptr, ptr %117, align 8
  %119 = load ptr, ptr %118, align 8
  %120 = call i32 %119(ptr %.fca.1.extract47) #31
  %121 = add i32 %120, 1
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract46)
  %123 = getelementptr i8, ptr %118, i64 8
  %124 = load ptr, ptr %123, align 8
  call void %124(ptr %.fca.1.extract47, i32 %121) #30
  br label %128

125:                                              ; preds = %114
  %126 = ptrtoint ptr %.sroa.6.2 to i64
  %127 = ptrtoint ptr %.sroa.12.2 to i64
  %.sroa.17.8.insert.ext = zext i32 %.sroa.17.2 to i160
  %.sroa.17.8.insert.shift = shl nuw i160 %.sroa.17.8.insert.ext, 128
  %.sroa.12.8.insert.ext = zext i64 %127 to i160
  %.sroa.12.8.insert.shift = shl nuw nsw i160 %.sroa.12.8.insert.ext, 64
  %.sroa.12.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.shift, %.sroa.17.8.insert.shift
  %.sroa.6.8.insert.ext = zext i64 %126 to i160
  %.sroa.6.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.insert, %.sroa.6.8.insert.ext
  br label %128

128:                                              ; preds = %125, %115
  %.reg2mem123.sroa.3.0 = phi i160 [ undef, %115 ], [ %.sroa.6.8.insert.insert, %125 ]
  %.reg2mem123.sroa.0.0 = phi ptr [ @nil_typ, %115 ], [ %.sroa.0.2, %125 ]
  %.reload124.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem123.sroa.0.0, 0
  %.reload124.fca.1.insert = insertvalue { ptr, i160 } %.reload124.fca.0.insert, i160 %.reg2mem123.sroa.3.0, 1
  ret { ptr, i160 } %.reload124.fca.1.insert
}

define void @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4) #3 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %8 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %8, 3
  %13 = sext i32 %8 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract13, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = getelementptr i8, ptr %14, i64 112
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %._crit_edge, %5
  %.0 = phi i32 [ 0, %5 ], [ %.1, %._crit_edge ]
  %17 = icmp slt i32 %.0, %4
  br i1 %17, label %18, label %._crit_edge

18:                                               ; preds = %._crit_edge2
  %19 = sext i32 %.0 to i64
  %20 = shl nsw i64 %19, 5
  %21 = getelementptr i8, ptr %.fca.0.extract, i64 %20
  %22 = load ptr, ptr %21, align 8
  %23 = icmp ne ptr %22, @nil_typ
  %24 = icmp ne ptr %22, null
  %.not43 = and i1 %23, %24
  br i1 %.not43, label %25, label %._crit_edge1

25:                                               ; preds = %18
  %26 = getelementptr i8, ptr %21, i64 8
  %27 = load i160, ptr %26, align 4
  %.sroa.3.0.extract.shift = lshr i160 %27, 64
  %.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.0.extract.shift to i64
  %.sroa.039.0.extract.trunc = trunc i160 %27 to i64
  %28 = inttoptr i64 %.sroa.039.0.extract.trunc to ptr
  %29 = inttoptr i64 %.sroa.3.0.extract.trunc to ptr
  %30 = call i32 @get_offset(ptr nonnull %22, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %31 = call i32 @get_offset(ptr nonnull %22, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %22, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %28, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %29, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %31, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract13)
  %37 = load ptr, ptr %14, align 8
  %38 = call ptr @typegetter_wrapper(ptr %37, ptr %.fca.1.extract)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract13)
  %40 = load ptr, ptr %15, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %.fca.1.extract)
  %42 = call ptr @bump_malloc(i64 noundef 32)
  %43 = getelementptr i8, ptr %42, i64 16
  store ptr %41, ptr %43, align 8
  %44 = getelementptr i8, ptr %42, i64 8
  store ptr %38, ptr %44, align 8
  %45 = getelementptr i8, ptr %42, i64 24
  store ptr null, ptr %45, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %42)
  store ptr @Entry, ptr %42, align 8
  store ptr %42, ptr %6, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract13)
  %49 = load ptr, ptr %16, align 8
  store ptr %22, ptr %7, align 8
  %50 = call ptr @behavior_wrapper(ptr %49, { ptr, ptr, ptr, i32 } %12, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %51 = call { ptr, i160 } %50({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull %6, { ptr, ptr, ptr, i32 } %35)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %25, %18
  %52 = add i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge1, %._crit_edge2
  %.1 = phi i32 [ %52, %._crit_edge1 ], [ %.0, %._crit_edge2 ]
  br i1 %17, label %._crit_edge2, label %53

53:                                               ; preds = %._crit_edge
  ret void
}

define void @CuckooMap_resize_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
._crit_edge:
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract45, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %9 = sext i32 %7 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract45, i64 %9
  %11 = getelementptr i8, ptr %10, i64 24
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call { ptr } %13(ptr %.fca.1.extract) #31
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %16 = getelementptr i8, ptr %10, i64 32
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr } %18(ptr %.fca.1.extract) #31
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %21 = getelementptr i8, ptr %10, i64 40
  %22 = load ptr, ptr %21, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = call i32 %23(ptr %.fca.1.extract) #31
  %25 = shl i32 %24, 1
  %spec.select = call i32 @llvm.smax.i32(i32 %25, i32 16)
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %27 = getelementptr i8, ptr %22, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %.fca.1.extract, i32 %spec.select) #30
  %29 = zext nneg i32 %spec.select to i64
  %30 = shl nuw nsw i64 %29, 5
  %31 = call ptr @bump_malloc(i64 %30)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %33 = load ptr, ptr %11, align 8
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  %36 = insertvalue { ptr } undef, ptr %31, 0
  call void %35(ptr %.fca.1.extract, { ptr } %36) #30
  %37 = call ptr @bump_malloc(i64 %30)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %39 = load ptr, ptr %16, align 8
  %40 = getelementptr i8, ptr %39, i64 8
  %41 = load ptr, ptr %40, align 8
  %42 = insertvalue { ptr } undef, ptr %37, 0
  call void %41(ptr %.fca.1.extract, { ptr } %42) #30
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %44 = getelementptr i8, ptr %10, i64 48
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  call void %47(ptr %.fca.1.extract, i32 0) #30
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.1.extract, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.2.extract, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %7, 3
  %52 = call ptr @bump_malloc(i64 noundef 16)
  %53 = getelementptr i8, ptr %52, i64 8
  store ptr null, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %52)
  store ptr @buffer_typ, ptr %52, align 8
  store ptr %52, ptr %3, align 8
  %55 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %58 = getelementptr i8, ptr %10, i64 120
  %59 = load ptr, ptr %58, align 8
  store ptr @buffer_typ, ptr %4, align 8
  %60 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %60, align 8
  %61 = call ptr @behavior_wrapper(ptr %59, { ptr, ptr, ptr, i32 } %51, ptr noundef nonnull align 8 dereferenceable(16) %4)
  call void %61({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull %3, { ptr } %14, i32 %24)
  %62 = call ptr @bump_malloc(i64 noundef 16)
  %63 = getelementptr i8, ptr %62, i64 8
  store ptr null, ptr %63, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %62)
  store ptr @buffer_typ, ptr %62, align 8
  store ptr %62, ptr %5, align 8
  %65 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %65, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract45)
  %68 = load ptr, ptr %58, align 8
  store ptr @buffer_typ, ptr %6, align 8
  %69 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %69, align 8
  %70 = call ptr @behavior_wrapper(ptr %68, { ptr, ptr, ptr, i32 } %51, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %70({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull %5, { ptr } %19, i32 %24)
  ret void
}

define noundef i1 @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5, i32 %6, { ptr } %7) #3 {
  %9 = alloca [0 x ptr], align 8
  %10 = alloca [3 x ptr], align 8
  %11 = alloca [3 x ptr], align 8
  %12 = alloca { ptr, ptr, ptr }, align 8
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %13 = call i32 @get_offset(ptr %.fca.0.extract37, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract17 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract12 = extractvalue { ptr, i160 } %4, 0
  %.fca.0.extract = extractvalue { ptr } %7, 0
  %14 = sext i32 %6 to i64
  %15 = shl nsw i64 %14, 5
  %16 = getelementptr i8, ptr %.fca.0.extract, i64 %15
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %16, i64 8
  %19 = icmp ne ptr %17, @nil_typ
  %20 = icmp ne ptr %17, null
  %.not81 = and i1 %19, %20
  br i1 %.not81, label %21, label %.critedge

21:                                               ; preds = %8
  %22 = load i64, ptr %18, align 4
  %.sroa_idx = getelementptr i8, ptr %16, i64 16
  %23 = load i64, ptr %.sroa_idx, align 4
  %24 = inttoptr i64 %22 to ptr
  %25 = inttoptr i64 %23 to ptr
  %26 = call i32 @get_offset(ptr nonnull %17, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %17, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %24, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %25, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %26, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %17)
  %33 = sext i32 %26 to i64
  %34 = getelementptr ptr, ptr %17, i64 %33
  %35 = getelementptr i8, ptr %34, i64 64
  %36 = load ptr, ptr %35, align 8
  %37 = call ptr @behavior_wrapper(ptr %36, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 %9)
  %38 = call i32 %37({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 %9)
  %39 = icmp eq i32 %38, %5
  br i1 %39, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %21
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %17)
  %42 = getelementptr i8, ptr %34, i64 48
  %43 = load ptr, ptr %42, align 8
  %44 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 %9)
  %45 = call { ptr, i160 } %44({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %9)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract37)
  %47 = sext i32 %13 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 64
  %50 = load ptr, ptr %49, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = call { ptr } %51(ptr %.fca.1.extract38) #31
  %.fca.0.extract64 = extractvalue { ptr } %52, 0
  %53 = call i1 %.fca.0.extract64({ ptr, i160 } %45, { ptr, i160 } %3)
  br i1 %53, label %54, label %.critedge

54:                                               ; preds = %._crit_edge
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract37)
  %56 = sext i32 %13 to i64
  %57 = getelementptr ptr, ptr %.fca.0.extract37, i64 %56
  %58 = load ptr, ptr %57, align 8
  %59 = call ptr @typegetter_wrapper(ptr %58, ptr %.fca.1.extract38)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract37)
  %61 = getelementptr i8, ptr %57, i64 8
  %62 = load ptr, ptr %61, align 8
  %63 = call ptr @typegetter_wrapper(ptr %62, ptr %.fca.1.extract38)
  store ptr @Entry, ptr %10, align 8
  %64 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %59, ptr %64, align 8
  %65 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %63, ptr %65, align 8
  %66 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Entry, ptr noundef nonnull align 8 dereferenceable(24) %10)
  %67 = extractvalue { i64, i64 } %66, 0
  %68 = call ptr @bump_malloc(i64 %67)
  store ptr %59, ptr %68, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  store ptr %63, ptr %69, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %68)
  %71 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %68, 1
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr undef, 2
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, i32 10, 3
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract37)
  %75 = load ptr, ptr %57, align 8
  %76 = call ptr @typegetter_wrapper(ptr %75, ptr %.fca.1.extract38)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract37)
  %78 = load ptr, ptr %61, align 8
  %79 = call ptr @typegetter_wrapper(ptr %78, ptr %.fca.1.extract38)
  store ptr %76, ptr %11, align 8
  %80 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %79, ptr %80, align 8
  %81 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @_parameterization_i32, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %11)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry)
  store ptr %.fca.0.extract17, ptr %12, align 8
  %84 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %.fca.0.extract12, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @i32_typ, ptr %85, align 8
  %86 = call ptr @behavior_wrapper(ptr noundef nonnull @Entry_B_init_keyK_valueV_primary_hashi32, { ptr, ptr, ptr, i32 } %73, ptr noundef nonnull align 8 dereferenceable(24) %12)
  call void %86({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull %11, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5)
  store ptr @Entry, ptr %16, align 8
  %87 = ptrtoint ptr %68 to i64
  store i64 %87, ptr %18, align 4
  %.sroa_idx46 = getelementptr i8, ptr %16, i64 24
  store i32 10, ptr %.sroa_idx46, align 4
  br label %.critedge

.critedge:                                        ; preds = %54, %._crit_edge, %21, %8
  %.reg2mem32.0 = phi i1 [ false, %._crit_edge ], [ true, %54 ], [ false, %8 ], [ false, %21 ]
  ret i1 %.reg2mem32.0
}

define { ptr, i160 } @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #3 {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %9 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %10 = sext i32 %5 to i64
  %11 = shl nsw i64 %10, 5
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = icmp ne ptr %13, @nil_typ
  %15 = icmp ne ptr %13, null
  %.not48 = and i1 %14, %15
  br i1 %.not48, label %16, label %.critedge

16:                                               ; preds = %7
  %17 = getelementptr i8, ptr %12, i64 8
  %18 = load i64, ptr %17, align 4
  %.sroa_idx = getelementptr i8, ptr %12, i64 16
  %19 = load i64, ptr %.sroa_idx, align 4
  %20 = inttoptr i64 %18 to ptr
  %21 = inttoptr i64 %19 to ptr
  %22 = call i32 @get_offset(ptr nonnull %13, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %20, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %21, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %22, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %29 = sext i32 %22 to i64
  %30 = getelementptr ptr, ptr %13, i64 %29
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %8)
  %34 = call i32 %33({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %8)
  %35 = icmp eq i32 %34, %4
  br i1 %35, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %16
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %38 = getelementptr i8, ptr %30, i64 48
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %8)
  %41 = call { ptr, i160 } %40({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull %8)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract18)
  %43 = sext i32 %9 to i64
  %44 = getelementptr ptr, ptr %.fca.0.extract18, i64 %43
  %45 = getelementptr i8, ptr %44, i64 64
  %46 = load ptr, ptr %45, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr } %47(ptr %.fca.1.extract19) #31
  %.fca.0.extract31 = extractvalue { ptr } %48, 0
  %49 = call i1 %.fca.0.extract31({ ptr, i160 } %41, { ptr, i160 } %3)
  br i1 %49, label %50, label %.critedge

50:                                               ; preds = %._crit_edge
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %53 = getelementptr i8, ptr %30, i64 56
  %54 = load ptr, ptr %53, align 8
  %55 = call ptr @behavior_wrapper(ptr %54, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %8)
  %56 = call { ptr, i160 } %55({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull %8)
  %.fca.0.extract26 = extractvalue { ptr, i160 } %56, 0
  %.fca.1.extract27 = extractvalue { ptr, i160 } %56, 1
  br label %.critedge

.critedge:                                        ; preds = %50, %._crit_edge, %16, %7
  %.reg2mem38.sroa.3.0 = phi i160 [ %.fca.1.extract27, %50 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %16 ]
  %.reg2mem36.0 = phi ptr [ %.fca.0.extract26, %50 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %16 ]
  %.reload35.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem36.0, 0
  %.reload35.fca.1.insert = insertvalue { ptr, i160 } %.reload35.fca.0.insert, i160 %.reg2mem38.sroa.3.0, 1
  ret { ptr, i160 } %.reload35.fca.1.insert
}

define { ptr, i160 } @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #3 {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %9 = call i32 @get_offset(ptr %.fca.0.extract26, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %10 = sext i32 %5 to i64
  %11 = shl nsw i64 %10, 5
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = icmp ne ptr %13, @nil_typ
  %15 = icmp ne ptr %13, null
  %.not62 = and i1 %14, %15
  br i1 %.not62, label %16, label %.critedge

16:                                               ; preds = %7
  %17 = getelementptr i8, ptr %12, i64 8
  %18 = load i64, ptr %17, align 4
  %.sroa_idx = getelementptr i8, ptr %12, i64 16
  %19 = load i64, ptr %.sroa_idx, align 4
  %20 = inttoptr i64 %18 to ptr
  %21 = inttoptr i64 %19 to ptr
  %22 = call i32 @get_offset(ptr nonnull %13, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %20, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %21, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %22, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %29 = sext i32 %22 to i64
  %30 = getelementptr ptr, ptr %13, i64 %29
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %8)
  %34 = call i32 %33({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %8)
  %35 = icmp eq i32 %34, %4
  br i1 %35, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %16
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %38 = getelementptr i8, ptr %30, i64 48
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %8)
  %41 = call { ptr, i160 } %40({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull %8)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract26)
  %43 = sext i32 %9 to i64
  %44 = getelementptr ptr, ptr %.fca.0.extract26, i64 %43
  %45 = getelementptr i8, ptr %44, i64 64
  %46 = load ptr, ptr %45, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr } %47(ptr %.fca.1.extract27) #31
  %.fca.0.extract45 = extractvalue { ptr } %48, 0
  %49 = call i1 %.fca.0.extract45({ ptr, i160 } %41, { ptr, i160 } %3)
  br i1 %49, label %50, label %.critedge

50:                                               ; preds = %._crit_edge
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %53 = getelementptr i8, ptr %30, i64 56
  %54 = load ptr, ptr %53, align 8
  %55 = call ptr @behavior_wrapper(ptr %54, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %8)
  %56 = call { ptr, i160 } %55({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull %8)
  %.fca.0.extract40 = extractvalue { ptr, i160 } %56, 0
  %.fca.1.extract41 = extractvalue { ptr, i160 } %56, 1
  store ptr @nil_typ, ptr %12, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract26)
  %58 = sext i32 %9 to i64
  %59 = getelementptr ptr, ptr %.fca.0.extract26, i64 %58
  %60 = getelementptr i8, ptr %59, i64 48
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %61, align 8
  %63 = call i32 %62(ptr %.fca.1.extract27) #31
  %64 = add i32 %63, -1
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract26)
  %66 = getelementptr i8, ptr %61, i64 8
  %67 = load ptr, ptr %66, align 8
  call void %67(ptr %.fca.1.extract27, i32 %64) #30
  br label %.critedge

.critedge:                                        ; preds = %50, %._crit_edge, %16, %7
  %.reg2mem38.sroa.3.0 = phi i160 [ %.fca.1.extract41, %50 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %16 ]
  %.reg2mem36.0 = phi ptr [ %.fca.0.extract40, %50 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %16 ]
  %.reload35.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem36.0, 0
  %.reload35.fca.1.insert = insertvalue { ptr, i160 } %.reload35.fca.0.insert, i160 %.reg2mem38.sroa.3.0, 1
  ret { ptr, i160 } %.reload35.fca.1.insert
}

define void @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #3 {
  %.fca.0.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract29, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract29)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract29, i64 %8
  %10 = getelementptr i8, ptr %9, i64 56
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, { ptr } %3) #30
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract29)
  %15 = getelementptr i8, ptr %9, i64 64
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, { ptr } %4) #30
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract29)
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 8) #30
  %24 = call ptr @bump_malloc(i64 noundef 256)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract29)
  %26 = getelementptr i8, ptr %9, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = insertvalue { ptr } undef, ptr %24, 0
  call void %29(ptr %.fca.1.extract, { ptr } %30) #30
  %31 = call ptr @bump_malloc(i64 noundef 256)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract29)
  %33 = getelementptr i8, ptr %9, i64 32
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %31, 0
  call void %36(ptr %.fca.1.extract, { ptr } %37) #30
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract29)
  %39 = getelementptr i8, ptr %9, i64 48
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  call void %42(ptr %.fca.1.extract, i32 0) #30
  ret void
}

define { ptr, i160 } @CuckooMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract67 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %9 = call i32 @get_offset(ptr %.fca.0.extract67, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract67, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.1.extract68, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.2.extract, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %9, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %15 = sext i32 %9 to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract67, i64 %15
  %17 = load ptr, ptr %16, align 8
  %18 = call ptr @typegetter_wrapper(ptr %17, ptr %.fca.1.extract68)
  %19 = alloca [1 x ptr], align 8
  store ptr %18, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %22 = getelementptr i8, ptr %16, i64 80
  %23 = load ptr, ptr %22, align 8
  %24 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call i32 %25({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %19, { ptr, i160 } %3)
  %27 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %30 = getelementptr i8, ptr %16, i64 96
  %31 = load ptr, ptr %30, align 8
  %32 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %32, align 8
  %33 = call ptr @behavior_wrapper(ptr %31, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(8) %32)
  %34 = call i32 %33({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %27, i32 %26)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %36 = getelementptr i8, ptr %16, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %.fca.1.extract68) #31
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %41 = load ptr, ptr %16, align 8
  %42 = call ptr @typegetter_wrapper(ptr %41, ptr %.fca.1.extract68)
  %43 = call ptr @bump_malloc(i64 noundef 16)
  %44 = getelementptr i8, ptr %43, i64 8
  store ptr null, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %43)
  store ptr @buffer_typ, ptr %43, align 8
  %46 = alloca [4 x ptr], align 8
  store ptr %42, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr %43, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %46)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %52 = getelementptr i8, ptr %16, i64 144
  %53 = load ptr, ptr %52, align 8
  %54 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %54, i64 16
  store ptr @i32_typ, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %54, i64 24
  store ptr @buffer_typ, ptr %57, align 8
  %58 = call ptr @behavior_wrapper(ptr %53, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(32) %54)
  %59 = call { ptr, i160 } %58({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %46, { ptr, i160 } %3, i32 %26, i32 %34, { ptr } %39)
  %.fca.0.extract = extractvalue { ptr, i160 } %59, 0
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %61 = getelementptr i8, ptr %16, i64 8
  %62 = load ptr, ptr %61, align 8
  %63 = call ptr @typegetter_wrapper(ptr %62, ptr %.fca.1.extract68)
  %64 = icmp ne ptr %.fca.0.extract, @nil_typ
  %65 = icmp ne ptr %.fca.0.extract, null
  %.not99 = and i1 %64, %65
  br i1 %.not99, label %99, label %66

66:                                               ; preds = %4
  store ptr @_parameterization_i32, ptr %5, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %69 = getelementptr i8, ptr %16, i64 104
  %70 = load ptr, ptr %69, align 8
  store ptr @i32_typ, ptr %6, align 8
  %71 = call ptr @behavior_wrapper(ptr %70, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %72 = call i32 %71({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %5, i32 %26)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %74 = getelementptr i8, ptr %16, i64 32
  %75 = load ptr, ptr %74, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = call { ptr } %76(ptr %.fca.1.extract68) #31
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %79 = load ptr, ptr %16, align 8
  %80 = call ptr @typegetter_wrapper(ptr %79, ptr %.fca.1.extract68)
  %81 = call ptr @bump_malloc(i64 noundef 16)
  %82 = getelementptr i8, ptr %81, i64 8
  store ptr null, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %81)
  store ptr @buffer_typ, ptr %81, align 8
  store ptr %80, ptr %7, align 8
  %84 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %81, ptr %86, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %89 = load ptr, ptr %52, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %90 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %91, align 8
  %92 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %92, align 8
  %93 = call ptr @behavior_wrapper(ptr %89, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(32) %8)
  %94 = call { ptr, i160 } %93({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %7, { ptr, i160 } %3, i32 %26, i32 %72, { ptr } %77)
  %.fca.0.extract87 = extractvalue { ptr, i160 } %94, 0
  %.fca.1.extract88 = extractvalue { ptr, i160 } %94, 1
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %96 = load ptr, ptr %61, align 8
  %97 = call ptr @typegetter_wrapper(ptr %96, ptr %.fca.1.extract68)
  %.not = icmp eq ptr %.fca.0.extract87, null
  %98 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract87
  br label %99

99:                                               ; preds = %66, %4
  %.reg2mem17.0 = phi ptr [ %98, %66 ], [ %.fca.0.extract, %4 ]
  %.sroa.390.0 = phi i160 [ %.fca.1.extract88, %66 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %59, 1
  %.fca.1.extract..sroa.390.0 = select i1 %.not99, i160 %.fca.1.extract, i160 %.sroa.390.0
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem17.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.fca.1.extract..sroa.390.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

define void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [5 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [3 x ptr], align 8
  %12 = alloca [3 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %.fca.0.extract104 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %16 = call i32 @get_offset(ptr %.fca.0.extract104, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract29 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract20 = extractvalue { ptr, i160 } %4, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract104, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract105, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %16, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %22 = sext i32 %16 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract104, i64 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %.fca.1.extract105)
  %26 = alloca [1 x ptr], align 8
  store ptr %25, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %29 = getelementptr i8, ptr %23, i64 80
  %30 = load ptr, ptr %29, align 8
  %31 = alloca { ptr }, align 8
  store ptr %.fca.0.extract29, ptr %31, align 8
  %32 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call i32 %32({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %26, { ptr, i160 } %3)
  %34 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %37 = getelementptr i8, ptr %23, i64 96
  %38 = load ptr, ptr %37, align 8
  %39 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %39, align 8
  %40 = call ptr @behavior_wrapper(ptr %38, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(8) %39)
  %41 = call i32 %40({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %34, i32 %33)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %43 = getelementptr i8, ptr %23, i64 24
  %44 = load ptr, ptr %43, align 8
  %45 = load ptr, ptr %44, align 8
  %46 = call { ptr } %45(ptr %.fca.1.extract105) #31
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %48 = load ptr, ptr %23, align 8
  %49 = call ptr @typegetter_wrapper(ptr %48, ptr %.fca.1.extract105)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %51 = getelementptr i8, ptr %23, i64 8
  %52 = load ptr, ptr %51, align 8
  %53 = call ptr @typegetter_wrapper(ptr %52, ptr %.fca.1.extract105)
  %54 = call ptr @bump_malloc(i64 noundef 16)
  %55 = getelementptr i8, ptr %54, i64 8
  store ptr null, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %54)
  store ptr @buffer_typ, ptr %54, align 8
  %57 = alloca [5 x ptr], align 8
  store ptr %49, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %57, i64 8
  store ptr %53, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %57, i64 16
  store ptr @_parameterization_i32, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %57, i64 24
  store ptr @_parameterization_i32, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %57, i64 32
  store ptr %54, ptr %61, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %57)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %64 = getelementptr i8, ptr %23, i64 136
  %65 = load ptr, ptr %64, align 8
  %66 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract29, ptr %66, align 8
  %67 = getelementptr inbounds i8, ptr %66, i64 8
  store ptr %.fca.0.extract20, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %66, i64 16
  store ptr @i32_typ, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %66, i64 24
  store ptr @i32_typ, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %66, i64 32
  store ptr @buffer_typ, ptr %70, align 8
  %71 = call ptr @behavior_wrapper(ptr %65, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(40) %66)
  %72 = call i1 %71({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %57, { ptr, i160 } %3, { ptr, i160 } %4, i32 %33, i32 %41, { ptr } %46)
  br i1 %72, label %.loopexit, label %73

73:                                               ; preds = %5
  store ptr @_parameterization_i32, ptr %7, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %76 = getelementptr i8, ptr %23, i64 104
  %77 = load ptr, ptr %76, align 8
  store ptr @i32_typ, ptr %8, align 8
  %78 = call ptr @behavior_wrapper(ptr %77, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %79 = call i32 %78({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %7, i32 %33)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %81 = getelementptr i8, ptr %23, i64 32
  %82 = load ptr, ptr %81, align 8
  %83 = load ptr, ptr %82, align 8
  %84 = call { ptr } %83(ptr %.fca.1.extract105) #31
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %86 = load ptr, ptr %23, align 8
  %87 = call ptr @typegetter_wrapper(ptr %86, ptr %.fca.1.extract105)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %89 = load ptr, ptr %51, align 8
  %90 = call ptr @typegetter_wrapper(ptr %89, ptr %.fca.1.extract105)
  %91 = call ptr @bump_malloc(i64 noundef 16)
  %92 = getelementptr i8, ptr %91, i64 8
  store ptr null, ptr %92, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %91)
  store ptr @buffer_typ, ptr %91, align 8
  store ptr %87, ptr %9, align 8
  %94 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %90, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_i32, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @_parameterization_i32, ptr %96, align 8
  %97 = getelementptr inbounds i8, ptr %9, i64 32
  store ptr %91, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %9)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %100 = load ptr, ptr %64, align 8
  store ptr %.fca.0.extract29, ptr %10, align 8
  %101 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.0.extract20, ptr %101, align 8
  %102 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %10, i64 24
  store ptr @i32_typ, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %10, i64 32
  store ptr @buffer_typ, ptr %104, align 8
  %105 = call ptr @behavior_wrapper(ptr %100, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(40) %10)
  %106 = call i1 %105({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %9, { ptr, i160 } %3, { ptr, i160 } %4, i32 %33, i32 %79, { ptr } %84)
  br i1 %106, label %.loopexit, label %107

107:                                              ; preds = %73
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %109 = getelementptr i8, ptr %23, i64 48
  %110 = load ptr, ptr %109, align 8
  %111 = load ptr, ptr %110, align 8
  %112 = call i32 %111(ptr %.fca.1.extract105) #31
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %114 = getelementptr i8, ptr %23, i64 40
  %115 = load ptr, ptr %114, align 8
  %116 = load ptr, ptr %115, align 8
  %117 = call i32 %116(ptr %.fca.1.extract105) #31
  %.not = icmp slt i32 %112, %117
  br i1 %.not, label %._crit_edge, label %118

118:                                              ; preds = %107
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %121 = getelementptr i8, ptr %23, i64 128
  %122 = load ptr, ptr %121, align 8
  %123 = call ptr @behavior_wrapper(ptr %122, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 %6)
  call void %123({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %6)
  br label %._crit_edge

._crit_edge:                                      ; preds = %118, %107
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %125 = load ptr, ptr %23, align 8
  %126 = call ptr @typegetter_wrapper(ptr %125, ptr %.fca.1.extract105)
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %128 = load ptr, ptr %51, align 8
  %129 = call ptr @typegetter_wrapper(ptr %128, ptr %.fca.1.extract105)
  store ptr @Entry, ptr %11, align 8
  %130 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %126, ptr %130, align 8
  %131 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr %129, ptr %131, align 8
  %132 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Entry, ptr noundef nonnull align 8 dereferenceable(24) %11)
  %133 = extractvalue { i64, i64 } %132, 0
  %134 = call ptr @bump_malloc(i64 %133)
  store ptr %126, ptr %134, align 8
  %135 = getelementptr i8, ptr %134, i64 8
  store ptr %129, ptr %135, align 8
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %134)
  %137 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %134, 1
  %138 = insertvalue { ptr, ptr, ptr, i32 } %137, ptr undef, 2
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, i32 10, 3
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %141 = load ptr, ptr %23, align 8
  %142 = call ptr @typegetter_wrapper(ptr %141, ptr %.fca.1.extract105)
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %144 = load ptr, ptr %51, align 8
  %145 = call ptr @typegetter_wrapper(ptr %144, ptr %.fca.1.extract105)
  store ptr %142, ptr %12, align 8
  %146 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %145, ptr %146, align 8
  %147 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %147, align 8
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12)
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry)
  store ptr %.fca.0.extract29, ptr %13, align 8
  %150 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.0.extract20, ptr %150, align 8
  %151 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %151, align 8
  %152 = call ptr @behavior_wrapper(ptr noundef nonnull @Entry_B_init_keyK_valueV_primary_hashi32, { ptr, ptr, ptr, i32 } %139, ptr noundef nonnull align 8 dereferenceable(24) %13)
  call void %152({ ptr, ptr, ptr, i32 } %139, { ptr, ptr, ptr, i32 } %139, ptr nonnull %12, { ptr, i160 } %3, { ptr, i160 } %4, i32 %33)
  %153 = getelementptr i8, ptr %23, i64 112
  %154 = getelementptr i8, ptr %23, i64 128
  br label %155

155:                                              ; preds = %203, %._crit_edge
  %.0186 = phi i32 [ 0, %._crit_edge ], [ %.2188, %203 ]
  %.0182 = phi ptr [ @Entry, %._crit_edge ], [ %.3185, %203 ]
  %.0178 = phi ptr [ %134, %._crit_edge ], [ %.3181, %203 ]
  %.0174 = phi ptr [ undef, %._crit_edge ], [ %.3177, %203 ]
  %156 = icmp slt i32 %.0186, 2
  br i1 %156, label %157, label %203

157:                                              ; preds = %155
  %158 = call i32 @get_offset(ptr %.0182, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %159 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.0182, 0
  %160 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %.0178, 1
  %161 = insertvalue { ptr, ptr, ptr, i32 } %160, ptr %.0174, 2
  %162 = insertvalue { ptr, ptr, ptr, i32 } %161, i32 %158, 3
  %163 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %164 = load ptr, ptr %23, align 8
  %165 = call ptr @typegetter_wrapper(ptr %164, ptr %.fca.1.extract105)
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %167 = load ptr, ptr %51, align 8
  %168 = call ptr @typegetter_wrapper(ptr %167, ptr %.fca.1.extract105)
  %169 = call ptr @bump_malloc(i64 noundef 32)
  %170 = getelementptr i8, ptr %169, i64 16
  store ptr %168, ptr %170, align 8
  %171 = getelementptr i8, ptr %169, i64 8
  store ptr %165, ptr %171, align 8
  %172 = getelementptr i8, ptr %169, i64 24
  store ptr null, ptr %172, align 8
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %169)
  store ptr @Entry, ptr %169, align 8
  store ptr %169, ptr %14, align 8
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %176 = load ptr, ptr %153, align 8
  store ptr %.0182, ptr %15, align 8
  %177 = call ptr @behavior_wrapper(ptr %176, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %178 = call { ptr, i160 } %177({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %14, { ptr, ptr, ptr, i32 } %162)
  %.fca.0.extract131 = extractvalue { ptr, i160 } %178, 0
  %179 = icmp ne ptr %.fca.0.extract131, @nil_typ
  %180 = icmp ne ptr %.fca.0.extract131, null
  %.not192 = and i1 %179, %180
  br i1 %.not192, label %181, label %203

181:                                              ; preds = %157
  %182 = call i32 @get_offset(ptr nonnull %.fca.0.extract131, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract104)
  %185 = load ptr, ptr %154, align 8
  %186 = call ptr @behavior_wrapper(ptr %185, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 %6)
  call void %186({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %6)
  %187 = getelementptr i8, ptr %.fca.0.extract131, i64 8
  %188 = getelementptr i8, ptr %.fca.0.extract131, i64 16
  %189 = getelementptr i8, ptr %.fca.0.extract131, i64 24
  %190 = getelementptr i8, ptr %.fca.0.extract131, i64 32
  %191 = load i64, ptr %187, align 4
  %192 = load i64, ptr %188, align 4
  %193 = load ptr, ptr %189, align 8
  %194 = load ptr, ptr %190, align 8
  %195 = call i1 @subtype_test_wrapper(ptr %193, i64 %192, i64 %191, i64 noundef 4015701072841558310, i64 noundef ptrtoint (ptr @Entry to i64), ptr %194)
  br i1 %195, label %196, label %._crit_edge1

196:                                              ; preds = %181
  %.fca.1.extract132 = extractvalue { ptr, i160 } %178, 1
  %.sroa.7.8.extract.shift = lshr i160 %.fca.1.extract132, 64
  %.sroa.7.8.extract.trunc = trunc i160 %.sroa.7.8.extract.shift to i64
  %197 = inttoptr i64 %.sroa.7.8.extract.trunc to ptr
  %.sroa.4.8.extract.trunc = trunc i160 %.fca.1.extract132 to i64
  %198 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %199 = call i32 @get_offset(ptr nonnull %.fca.0.extract131, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %200 = call i32 @get_offset(ptr nonnull %.fca.0.extract131, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %201 = call i32 @get_offset(ptr nonnull %.fca.0.extract131, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %196, %181
  %.1183 = phi ptr [ %.fca.0.extract131, %196 ], [ %.0182, %181 ]
  %.1179 = phi ptr [ %198, %196 ], [ %.0178, %181 ]
  %.1175 = phi ptr [ %197, %196 ], [ %.0174, %181 ]
  %202 = add nsw i32 %.0186, 1
  br label %203

203:                                              ; preds = %._crit_edge1, %157, %155
  %.reg2mem19.0.off0 = phi i1 [ false, %157 ], [ true, %._crit_edge1 ], [ false, %155 ]
  %.2188 = phi i32 [ %.0186, %157 ], [ %202, %._crit_edge1 ], [ %.0186, %155 ]
  %.3185 = phi ptr [ %.0182, %157 ], [ %.1183, %._crit_edge1 ], [ %.0182, %155 ]
  %.3181 = phi ptr [ %.0178, %157 ], [ %.1179, %._crit_edge1 ], [ %.0178, %155 ]
  %.3177 = phi ptr [ %.0174, %157 ], [ %.1175, %._crit_edge1 ], [ %.0174, %155 ]
  br i1 %.reg2mem19.0.off0, label %155, label %.loopexit

.loopexit:                                        ; preds = %203, %73, %5
  ret void
}

define { ptr, i160 } @CuckooMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract67 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %9 = call i32 @get_offset(ptr %.fca.0.extract67, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract67, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.1.extract68, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.2.extract, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %9, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %15 = sext i32 %9 to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract67, i64 %15
  %17 = load ptr, ptr %16, align 8
  %18 = call ptr @typegetter_wrapper(ptr %17, ptr %.fca.1.extract68)
  %19 = alloca [1 x ptr], align 8
  store ptr %18, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %22 = getelementptr i8, ptr %16, i64 80
  %23 = load ptr, ptr %22, align 8
  %24 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call i32 %25({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %19, { ptr, i160 } %3)
  %27 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %27)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %30 = getelementptr i8, ptr %16, i64 96
  %31 = load ptr, ptr %30, align 8
  %32 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %32, align 8
  %33 = call ptr @behavior_wrapper(ptr %31, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(8) %32)
  %34 = call i32 %33({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %27, i32 %26)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %36 = getelementptr i8, ptr %16, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %.fca.1.extract68) #31
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %41 = load ptr, ptr %16, align 8
  %42 = call ptr @typegetter_wrapper(ptr %41, ptr %.fca.1.extract68)
  %43 = call ptr @bump_malloc(i64 noundef 16)
  %44 = getelementptr i8, ptr %43, i64 8
  store ptr null, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %43)
  store ptr @buffer_typ, ptr %43, align 8
  %46 = alloca [4 x ptr], align 8
  store ptr %42, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr %43, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %46)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %52 = getelementptr i8, ptr %16, i64 152
  %53 = load ptr, ptr %52, align 8
  %54 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %54, i64 16
  store ptr @i32_typ, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %54, i64 24
  store ptr @buffer_typ, ptr %57, align 8
  %58 = call ptr @behavior_wrapper(ptr %53, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(32) %54)
  %59 = call { ptr, i160 } %58({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %46, { ptr, i160 } %3, i32 %26, i32 %34, { ptr } %39)
  %.fca.0.extract = extractvalue { ptr, i160 } %59, 0
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %61 = getelementptr i8, ptr %16, i64 8
  %62 = load ptr, ptr %61, align 8
  %63 = call ptr @typegetter_wrapper(ptr %62, ptr %.fca.1.extract68)
  %64 = icmp ne ptr %.fca.0.extract, @nil_typ
  %65 = icmp ne ptr %.fca.0.extract, null
  %.not99 = and i1 %64, %65
  br i1 %.not99, label %99, label %66

66:                                               ; preds = %4
  store ptr @_parameterization_i32, ptr %5, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %69 = getelementptr i8, ptr %16, i64 104
  %70 = load ptr, ptr %69, align 8
  store ptr @i32_typ, ptr %6, align 8
  %71 = call ptr @behavior_wrapper(ptr %70, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %72 = call i32 %71({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %5, i32 %26)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %74 = getelementptr i8, ptr %16, i64 32
  %75 = load ptr, ptr %74, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = call { ptr } %76(ptr %.fca.1.extract68) #31
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %79 = load ptr, ptr %16, align 8
  %80 = call ptr @typegetter_wrapper(ptr %79, ptr %.fca.1.extract68)
  %81 = call ptr @bump_malloc(i64 noundef 16)
  %82 = getelementptr i8, ptr %81, i64 8
  store ptr null, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %81)
  store ptr @buffer_typ, ptr %81, align 8
  store ptr %80, ptr %7, align 8
  %84 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %81, ptr %86, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %89 = load ptr, ptr %52, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %90 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %91, align 8
  %92 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %92, align 8
  %93 = call ptr @behavior_wrapper(ptr %89, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(32) %8)
  %94 = call { ptr, i160 } %93({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %7, { ptr, i160 } %3, i32 %26, i32 %72, { ptr } %77)
  %.fca.0.extract87 = extractvalue { ptr, i160 } %94, 0
  %.fca.1.extract88 = extractvalue { ptr, i160 } %94, 1
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract67)
  %96 = load ptr, ptr %61, align 8
  %97 = call ptr @typegetter_wrapper(ptr %96, ptr %.fca.1.extract68)
  %.not = icmp eq ptr %.fca.0.extract87, null
  %98 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract87
  br label %99

99:                                               ; preds = %66, %4
  %.reg2mem17.0 = phi ptr [ %98, %66 ], [ %.fca.0.extract, %4 ]
  %.sroa.390.0 = phi i160 [ %.fca.1.extract88, %66 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %59, 1
  %.fca.1.extract..sroa.390.0 = select i1 %.not99, i160 %.fca.1.extract, i160 %.sroa.390.0
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem17.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.fca.1.extract..sroa.390.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

define { ptr, ptr, ptr, i32 } @Map_keys_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = call ptr @typegetter_wrapper(ptr %9, ptr %.fca.1.extract)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @typegetter_wrapper(ptr %12, ptr %.fca.1.extract)
  %14 = alloca [3 x ptr], align 8
  store ptr @MapKeys, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %10, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr %13, ptr %16, align 8
  %17 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapKeys, ptr noundef nonnull align 8 dereferenceable(24) %14)
  %18 = extractvalue { i64, i64 } %17, 0
  %19 = call ptr @bump_malloc(i64 %18)
  store ptr %10, ptr %19, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  store ptr %13, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %19)
  %22 = call i32 @get_offset(ptr noundef %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %22, 3
  %27 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapKeys, ptr undef, ptr undef, i32 undef }, ptr %19, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr undef, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 10, 3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %31 = load ptr, ptr %7, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %.fca.1.extract)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = load ptr, ptr %8, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract)
  %36 = call ptr @bump_malloc(i64 noundef 32)
  %37 = getelementptr i8, ptr %36, i64 16
  store ptr %35, ptr %37, align 8
  %38 = getelementptr i8, ptr %36, i64 8
  store ptr %32, ptr %38, align 8
  %39 = getelementptr i8, ptr %36, i64 24
  store ptr null, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %36)
  store ptr @Map, ptr %36, align 8
  %41 = alloca [1 x ptr], align 8
  store ptr %36, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @MapKeys)
  %44 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %44, align 8
  %45 = call ptr @behavior_wrapper(ptr noundef nonnull @MapKeys_B_init_mapMapK._V, { ptr, ptr, ptr, i32 } %29, ptr noundef nonnull align 8 dereferenceable(8) %44)
  call void %45({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull %41, { ptr, ptr, ptr, i32 } %26)
  %46 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1056) @MapKeys, ptr noundef nonnull @Collection)
  %47 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %46, 3
  ret { ptr, ptr, ptr, i32 } %47
}

define void @CuckooMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 8) #30
  %12 = call ptr @bump_malloc(i64 noundef 256)
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = getelementptr i8, ptr %7, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = insertvalue { ptr } undef, ptr %12, 0
  call void %17(ptr %.fca.1.extract, { ptr } %18) #30
  %19 = call ptr @bump_malloc(i64 noundef 256)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %21 = getelementptr i8, ptr %7, i64 32
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr } undef, ptr %19, 0
  call void %24(ptr %.fca.1.extract, { ptr } %25) #30
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %27 = getelementptr i8, ptr %7, i64 48
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract, i32 0) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @Map_indices_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract14, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract15, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract16, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract14)
  %12 = sext i32 %5 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract14, i64 %12
  %14 = getelementptr i8, ptr %13, i64 48
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @behavior_wrapper(ptr %15, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 %4)
  %17 = call { ptr, ptr, ptr, i32 } %16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %18 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Collection)
  %19 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Collection)
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %19, 3
  ret { ptr, ptr, ptr, i32 } %23
}

define { ptr, ptr, ptr, i32 } @Map_values_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = call ptr @typegetter_wrapper(ptr %8, ptr %.fca.1.extract)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %11 = getelementptr i8, ptr %7, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = call ptr @typegetter_wrapper(ptr %12, ptr %.fca.1.extract)
  %14 = alloca [3 x ptr], align 8
  store ptr @MapValues, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %9, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr %13, ptr %16, align 8
  %17 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapValues, ptr noundef nonnull align 8 dereferenceable(24) %14)
  %18 = extractvalue { i64, i64 } %17, 0
  %19 = call ptr @bump_malloc(i64 %18)
  store ptr %9, ptr %19, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  store ptr %13, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %19)
  %22 = call i32 @get_offset(ptr noundef %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %22, 3
  %27 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapValues, ptr undef, ptr undef, i32 undef }, ptr %19, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr undef, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 10, 3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %31 = load ptr, ptr %7, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %.fca.1.extract)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = load ptr, ptr %11, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract)
  %36 = call ptr @bump_malloc(i64 noundef 32)
  %37 = getelementptr i8, ptr %36, i64 16
  store ptr %35, ptr %37, align 8
  %38 = getelementptr i8, ptr %36, i64 8
  store ptr %32, ptr %38, align 8
  %39 = getelementptr i8, ptr %36, i64 24
  store ptr null, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %36)
  store ptr @Map, ptr %36, align 8
  %41 = alloca [1 x ptr], align 8
  store ptr %36, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @MapValues)
  %44 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %44, align 8
  %45 = call ptr @behavior_wrapper(ptr noundef nonnull @MapValues_B_init_mapMapK._V, { ptr, ptr, ptr, i32 } %29, ptr noundef nonnull align 8 dereferenceable(8) %44)
  call void %45({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull %41, { ptr, ptr, ptr, i32 } %26)
  %46 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1056) @MapValues, ptr noundef nonnull @Collection)
  %47 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %46, 3
  ret { ptr, ptr, ptr, i32 } %47
}

define { ptr, i160 } @Map__index_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %10 = alloca [2 x ptr], align 8
  %11 = alloca { ptr, ptr }, align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %12 = call i32 @get_offset(ptr %.fca.0.extract21, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %.fca.0.extract4 = extractvalue { ptr, i160 } %3, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract23, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %12, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract21)
  %18 = sext i32 %12 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract21, i64 %18
  %20 = load ptr, ptr %19, align 8
  %21 = call ptr @typegetter_wrapper(ptr %20, ptr %.fca.1.extract23)
  %22 = alloca [1 x ptr], align 8
  store ptr %21, ptr %22, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract21)
  %25 = getelementptr i8, ptr %19, i64 24
  %26 = load ptr, ptr %25, align 8
  %27 = alloca { ptr }, align 8
  store ptr %.fca.0.extract4, ptr %27, align 8
  %28 = call ptr @behavior_wrapper(ptr %26, { ptr, ptr, ptr, i32 } %16, ptr noundef nonnull align 8 dereferenceable(8) %27)
  %29 = call { ptr, i160 } %28({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %22, { ptr, i160 } %3)
  %.fca.0.extract = extractvalue { ptr, i160 } %29, 0
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %.fca.0.extract21)
  %31 = getelementptr i8, ptr %19, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract23)
  %34 = icmp ne ptr %.fca.0.extract, @nil_typ
  %35 = icmp ne ptr %.fca.0.extract, null
  %.not67 = and i1 %34, %35
  br i1 %.not67, label %36, label %37

36:                                               ; preds = %4
  ret { ptr, i160 } %29

37:                                               ; preds = %4
  %38 = getelementptr inbounds i8, ptr %8, i64 8
  %39 = getelementptr inbounds i8, ptr %8, i64 16
  %40 = getelementptr inbounds i8, ptr %8, i64 24
  %41 = getelementptr inbounds i8, ptr %9, i64 8
  %42 = getelementptr inbounds i8, ptr %9, i64 16
  %43 = getelementptr inbounds i8, ptr %9, i64 24
  %44 = getelementptr inbounds i8, ptr %10, i64 8
  %45 = getelementptr inbounds i8, ptr %11, i64 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %37
  store ptr @KeyNotFound, ptr %6, align 8
  %46 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_KeyNotFound, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %47 = extractvalue { i64, i64 } %46, 0
  %48 = call ptr @bump_malloc(i64 %47)
  %49 = insertvalue { ptr, ptr, ptr, i32 } { ptr @KeyNotFound, ptr undef, ptr undef, i32 undef }, ptr %48, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr undef, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 10, 3
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound)
  %54 = call ptr @behavior_wrapper(ptr noundef nonnull @KeyNotFound_B_init_, { ptr, ptr, ptr, i32 } %51, ptr noundef nonnull align 8 %5)
  call void %54({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull %5)
  %55 = call ptr @bump_malloc(i64 noundef 55)
  store <54 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 109, i8 97, i8 112, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %55, align 1
  store ptr @String, ptr %7, align 8
  %56 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %57 = call { i64, i64 } @size_wrapper(ptr %56, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %58 = extractvalue { i64, i64 } %57, 0
  %59 = call ptr @bump_malloc(i64 %58)
  %60 = insertvalue { ptr } undef, ptr %55, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %59, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr undef, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %8, align 8
  store ptr @_parameterization_i32, ptr %38, align 8
  store ptr @_parameterization_i32, ptr %39, align 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %66 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %9, align 8
  store ptr @i32_typ, ptr %41, align 8
  store ptr @i32_typ, ptr %42, align 8
  store ptr @i32_typ, ptr %43, align 8
  %67 = call ptr @behavior_wrapper(ptr %66, { ptr, ptr, ptr, i32 } %63, ptr noundef nonnull align 8 dereferenceable(32) %9)
  call void %67({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull %8, { ptr } %60, i32 54, i32 54, i32 55)
  %68 = call i32 @get_offset(ptr noundef nonnull @String, ptr noundef nonnull @String)
  %69 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %68, 3
  store ptr @_parameterization_i32, ptr %10, align 8
  store ptr @_parameterization_core.String, ptr %44, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %10)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @KeyNotFound)
  store ptr @i32_typ, ptr %11, align 8
  store ptr @String, ptr %45, align 8
  %72 = call ptr @behavior_wrapper(ptr noundef nonnull @KeyNotFound_B_set_info_line_numberi32_file_nameString, { ptr, ptr, ptr, i32 } %51, ptr noundef nonnull align 8 dereferenceable(16) %11)
  call void %72({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull %10, i32 26, { ptr, ptr, ptr, i32 } %69)
  %73 = ptrtoint ptr %48 to i64
  %74 = call ptr @get_current_coroutine()
  %75 = getelementptr i8, ptr %74, i64 48
  store ptr @KeyNotFound, ptr %75, align 8
  %76 = getelementptr i8, ptr %74, i64 56
  store i64 %73, ptr %76, align 4
  %.sroa_idx68 = getelementptr i8, ptr %74, i64 64
  store i96 184467440737095516160, ptr %.sroa_idx68, align 4
  call void @coroutine_yield_cold(ptr noundef align 8 %74)
  br label %._crit_edge
}

define void @CuckooMap__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract20, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %.fca.0.extract7 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract21, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract20)
  %12 = sext i32 %6 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract20, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = call ptr @typegetter_wrapper(ptr %14, ptr %.fca.1.extract21)
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract20)
  %17 = getelementptr i8, ptr %13, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = call ptr @typegetter_wrapper(ptr %18, ptr %.fca.1.extract21)
  %20 = alloca [2 x ptr], align 8
  store ptr %15, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr %19, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %20)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract20)
  %24 = getelementptr i8, ptr %13, i64 176
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract7, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr %.fca.0.extract, ptr %27, align 8
  %28 = call ptr @behavior_wrapper(ptr %25, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 dereferenceable(16) %26)
  call void %28({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull %20, { ptr, i160 } %3, { ptr, i160 } %4)
  ret void
}

define i32 @CuckooMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  ret i32 %11
}

define i1 @Collection_is_empty_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %12 = sext i32 %5 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @behavior_wrapper(ptr %15, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 %4)
  %17 = call i32 %16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %4)
  %18 = icmp eq i32 %17, 0
  ret i1 %18
}

define { ptr, ptr, ptr, i32 } @CuckooMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract49, ptr noundef nonnull align 16 dereferenceable(9232) @CuckooMap)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract49, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract) #31
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %13 = getelementptr i8, ptr %7, i64 32
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call { ptr } %15(ptr %.fca.1.extract) #31
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %18 = getelementptr i8, ptr %7, i64 40
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %.fca.1.extract) #31
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %23 = load ptr, ptr %7, align 8
  %24 = call ptr @typegetter_wrapper(ptr %23, ptr %.fca.1.extract)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %26 = getelementptr i8, ptr %7, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @typegetter_wrapper(ptr %27, ptr %.fca.1.extract)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %30 = load ptr, ptr %7, align 8
  %31 = call ptr @typegetter_wrapper(ptr %30, ptr %.fca.1.extract)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %33 = load ptr, ptr %26, align 8
  %34 = call ptr @typegetter_wrapper(ptr %33, ptr %.fca.1.extract)
  %35 = call ptr @bump_malloc(i64 noundef 32)
  %36 = getelementptr i8, ptr %35, i64 16
  store ptr %34, ptr %36, align 8
  %37 = getelementptr i8, ptr %35, i64 8
  store ptr %31, ptr %37, align 8
  %38 = getelementptr i8, ptr %35, i64 24
  store ptr null, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %35)
  store ptr @Pair, ptr %35, align 8
  %40 = alloca [4 x ptr], align 8
  store ptr @CuckooMapIterator, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %24, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %28, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store ptr %35, ptr %43, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_CuckooMapIterator, ptr noundef nonnull align 8 dereferenceable(32) %40)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  store ptr %24, ptr %46, align 8
  %47 = getelementptr i8, ptr %46, i64 8
  store ptr %28, ptr %47, align 8
  %48 = getelementptr i8, ptr %46, i64 16
  store ptr %35, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %46)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %51 = load ptr, ptr %8, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr %.fca.1.extract) #31
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %55 = load ptr, ptr %13, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = call { ptr } %56(ptr %.fca.1.extract) #31
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 9152, ptr nocapture nofree noundef %.fca.0.extract49)
  %59 = load ptr, ptr %18, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call i32 %60(ptr %.fca.1.extract) #31
  %62 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMapIterator, ptr undef, ptr undef, i32 undef }, ptr %46, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr undef, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 10, 3
  %65 = call ptr @bump_malloc(i64 noundef 16)
  %66 = getelementptr i8, ptr %65, i64 8
  store ptr null, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %65)
  store ptr @buffer_typ, ptr %65, align 8
  %68 = call ptr @bump_malloc(i64 noundef 16)
  %69 = getelementptr i8, ptr %68, i64 8
  store ptr null, ptr %69, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %68)
  store ptr @buffer_typ, ptr %68, align 8
  %71 = alloca [3 x ptr], align 8
  store ptr %65, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %71, i64 8
  store ptr %68, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %71, i64 16
  store ptr @_parameterization_i32, ptr %73, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %71)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %76 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %76, i64 8
  store ptr @buffer_typ, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %76, i64 16
  store ptr @i32_typ, ptr %78, align 8
  %79 = call ptr @behavior_wrapper(ptr noundef nonnull @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 dereferenceable(24) %76)
  call void %79({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %71, { ptr } %53, { ptr } %57, i32 %61)
  %80 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator, ptr noundef nonnull @Iterator)
  %81 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %80, 3
  ret { ptr, ptr, ptr, i32 } %81
}

define void @Iterable_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract19, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract20, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract18)
  %13 = sext i32 %6 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract18, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = call ptr @behavior_wrapper(ptr %16, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %5)
  %18 = call { ptr, ptr, ptr, i32 } %17({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %19 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %19, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract)
  %26 = sext i32 %19 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr @behavior_wrapper(ptr %29, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 %5)
  %31 = call { ptr, i160 } %30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %5)
  %.fca.0.extract33 = extractvalue { ptr, i160 } %31, 0
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract18)
  %33 = load ptr, ptr %14, align 8
  %34 = call ptr @typegetter_wrapper(ptr %33, ptr %.fca.1.extract19)
  %35 = icmp ne ptr %.fca.0.extract33, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract33, null
  %.not39 = and i1 %35, %36
  br i1 %.not39, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  call void %.fca.0.extract8({ ptr, i160 } %31)
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  ret void
}

define { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract26, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract14 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract15 = extractvalue { ptr, i160 } %3, 1
  %.fca.0.extract8 = extractvalue { ptr } %4, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract27, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract28, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %7, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract26)
  %14 = sext i32 %7 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract26, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = call ptr @behavior_wrapper(ptr %17, { ptr, ptr, ptr, i32 } %11, ptr noundef nonnull align 8 %6)
  %19 = call { ptr, ptr, ptr, i32 } %18({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 %6)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %20, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract)
  %27 = sext i32 %20 to i64
  %28 = getelementptr ptr, ptr %.fca.0.extract, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %5
  %.056 = phi ptr [ %.fca.0.extract14, %5 ], [ %.157, %._crit_edge ]
  %.0 = phi i160 [ %.fca.1.extract15, %5 ], [ %.1, %._crit_edge ]
  %30 = load ptr, ptr %29, align 8
  %31 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %24, ptr noundef nonnull align 8 %6)
  %32 = call { ptr, i160 } %31({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull %6)
  %.fca.0.extract51 = extractvalue { ptr, i160 } %32, 0
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract26)
  %34 = load ptr, ptr %15, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract27)
  %36 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %37 = icmp ne ptr %.fca.0.extract51, null
  %.not59 = and i1 %36, %37
  br i1 %.not59, label %38, label %._crit_edge

38:                                               ; preds = %._crit_edge1
  %39 = insertvalue { ptr, i160 } undef, ptr %.056, 0
  %40 = insertvalue { ptr, i160 } %39, i160 %.0, 1
  %41 = call { ptr, i160 } %.fca.0.extract8({ ptr, i160 } %40, { ptr, i160 } %32)
  %.fca.0.extract38 = extractvalue { ptr, i160 } %41, 0
  %.fca.1.extract39 = extractvalue { ptr, i160 } %41, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %38, %._crit_edge1
  %.157 = phi ptr [ %.fca.0.extract38, %38 ], [ %.056, %._crit_edge1 ]
  %.1 = phi i160 [ %.fca.1.extract39, %38 ], [ %.0, %._crit_edge1 ]
  br i1 %.not59, label %._crit_edge1, label %42

42:                                               ; preds = %._crit_edge
  %43 = insertvalue { ptr, i160 } undef, ptr %.157, 0
  %44 = insertvalue { ptr, i160 } %43, i160 %.1, 1
  ret { ptr, i160 } %44
}

define noundef i1 @Iterable_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract19, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract20, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract18)
  %13 = sext i32 %6 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract18, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = call ptr @behavior_wrapper(ptr %16, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %5)
  %18 = call { ptr, ptr, ptr, i32 } %17({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %19 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %19, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract)
  %26 = sext i32 %19 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  br label %29

29:                                               ; preds = %38, %4
  %30 = load ptr, ptr %28, align 8
  %31 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 %5)
  %32 = call { ptr, i160 } %31({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %5)
  %.fca.0.extract36 = extractvalue { ptr, i160 } %32, 0
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract18)
  %34 = load ptr, ptr %14, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract19)
  %36 = icmp eq ptr %.fca.0.extract36, @nil_typ
  %37 = icmp eq ptr %.fca.0.extract36, null
  %.not39.not = or i1 %36, %37
  br i1 %.not39.not, label %.critedge, label %38

38:                                               ; preds = %29
  %39 = call i1 %.fca.0.extract8({ ptr, i160 } %32)
  br i1 %39, label %29, label %.critedge

.critedge:                                        ; preds = %38, %29
  ret i1 %.not39.not
}

define noundef i1 @Iterable_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract8 = extractvalue { ptr } %3, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract19, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract20, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract18)
  %13 = sext i32 %6 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract18, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = call ptr @behavior_wrapper(ptr %16, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %5)
  %18 = call { ptr, ptr, ptr, i32 } %17({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %19 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %19, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract)
  %26 = sext i32 %19 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  br label %29

29:                                               ; preds = %38, %4
  %30 = load ptr, ptr %28, align 8
  %31 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 %5)
  %32 = call { ptr, i160 } %31({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %5)
  %.fca.0.extract34 = extractvalue { ptr, i160 } %32, 0
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract18)
  %34 = load ptr, ptr %14, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract19)
  %36 = icmp ne ptr %.fca.0.extract34, @nil_typ
  %37 = icmp ne ptr %.fca.0.extract34, null
  %.not37 = and i1 %36, %37
  br i1 %.not37, label %38, label %.critedge

38:                                               ; preds = %29
  %39 = call i1 %.fca.0.extract8({ ptr, i160 } %32)
  br i1 %39, label %.critedge, label %29

.critedge:                                        ; preds = %38, %29
  ret i1 %.not37
}

define { ptr, ptr, ptr, i32 } @Collection_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = call ptr @typegetter_wrapper(ptr %8, ptr %.fca.1.extract)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %11 = load ptr, ptr %7, align 8
  %12 = call ptr @typegetter_wrapper(ptr %11, ptr %.fca.1.extract)
  %13 = call ptr @bump_malloc(i64 noundef 32)
  %14 = getelementptr i8, ptr %13, i64 16
  store ptr %12, ptr %14, align 8
  %15 = getelementptr i8, ptr %13, i64 8
  store ptr @_parameterization_i32, ptr %15, align 8
  %16 = getelementptr i8, ptr %13, i64 24
  store ptr null, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %13)
  store ptr @Pair, ptr %13, align 8
  %18 = alloca [3 x ptr], align 8
  store ptr @EnumeratedCollection, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr %9, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr %13, ptr %20, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_EnumeratedCollection, ptr noundef nonnull align 8 dereferenceable(24) %18)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = call ptr @bump_malloc(i64 %22)
  store ptr %9, ptr %23, align 8
  %24 = getelementptr i8, ptr %23, i64 8
  store ptr %13, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %23)
  %26 = call i32 @get_offset(ptr noundef %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %26, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } { ptr @EnumeratedCollection, ptr undef, ptr undef, i32 undef }, ptr %23, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr undef, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 10, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract)
  %35 = load ptr, ptr %7, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract)
  %37 = call ptr @bump_malloc(i64 noundef 24)
  %38 = getelementptr i8, ptr %37, i64 8
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 16
  store ptr null, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %37)
  store ptr @Collection, ptr %37, align 8
  %41 = alloca [1 x ptr], align 8
  store ptr %37, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @EnumeratedCollection)
  %44 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %44, align 8
  %45 = call ptr @behavior_wrapper(ptr noundef nonnull @EnumeratedCollection_B_init_collectionCollectionT, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 dereferenceable(8) %44)
  call void %45({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull %41, { ptr, ptr, ptr, i32 } %30)
  %46 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1056) @EnumeratedCollection, ptr noundef nonnull @Iterable)
  %47 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %46, 3
  ret { ptr, ptr, ptr, i32 } %47
}

define { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readonly %2, { ptr } %3) #3 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract32)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract32, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = call ptr @typegetter_wrapper(ptr %9, ptr %.fca.1.extract)
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = alloca [3 x ptr], align 8
  store ptr @MappedCollection, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %10, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr %13, ptr %16, align 8
  %17 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MappedCollection, ptr noundef nonnull align 8 dereferenceable(24) %14)
  %18 = extractvalue { i64, i64 } %17, 0
  %19 = call ptr @bump_malloc(i64 %18)
  store ptr %10, ptr %19, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  store ptr %13, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %19)
  %22 = call i32 @get_offset(ptr noundef %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %22, 3
  %27 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MappedCollection, ptr undef, ptr undef, i32 undef }, ptr %19, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr undef, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 10, 3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract32)
  %31 = load ptr, ptr %8, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %.fca.1.extract)
  %33 = call ptr @bump_malloc(i64 noundef 24)
  %34 = getelementptr i8, ptr %33, i64 8
  store ptr %32, ptr %34, align 8
  %35 = getelementptr i8, ptr %33, i64 16
  store ptr null, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %33)
  store ptr @Collection, ptr %33, align 8
  %37 = load ptr, ptr %2, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract32)
  %41 = load ptr, ptr %8, align 8
  %42 = call ptr @typegetter_wrapper(ptr %41, ptr %.fca.1.extract)
  %43 = call ptr @bump_malloc(i64 noundef 32)
  %44 = getelementptr i8, ptr %43, i64 16
  store ptr %42, ptr %44, align 8
  %45 = getelementptr i8, ptr %43, i64 8
  store ptr %39, ptr %45, align 8
  %46 = getelementptr i8, ptr %43, i64 24
  store ptr null, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %43)
  store ptr @function_typ, ptr %43, align 8
  %48 = alloca [2 x ptr], align 8
  store ptr %33, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %48, i64 8
  store ptr %43, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %48)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1064) @MappedCollection)
  %52 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract32, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @function_typ, ptr %53, align 8
  %54 = call ptr @behavior_wrapper(ptr noundef nonnull @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U, { ptr, ptr, ptr, i32 } %29, ptr noundef nonnull align 8 dereferenceable(16) %52)
  call void %54({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull %48, { ptr, ptr, ptr, i32 } %26, { ptr } %3)
  %55 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1064) @MappedCollection, ptr noundef nonnull @Iterable)
  %56 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %55, 3
  ret { ptr, ptr, ptr, i32 } %56
}

define { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readonly %2, { ptr } %3) #3 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract32)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract32, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = call ptr @typegetter_wrapper(ptr %9, ptr %.fca.1.extract)
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = alloca [3 x ptr], align 8
  store ptr @MapIterable, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %10, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr %13, ptr %16, align 8
  %17 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapIterable, ptr noundef nonnull align 8 dereferenceable(24) %14)
  %18 = extractvalue { i64, i64 } %17, 0
  %19 = call ptr @bump_malloc(i64 %18)
  store ptr %10, ptr %19, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  store ptr %13, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %19)
  %22 = call i32 @get_offset(ptr noundef %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %22, 3
  %27 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable, ptr undef, ptr undef, i32 undef }, ptr %19, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr undef, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 10, 3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract32)
  %31 = load ptr, ptr %8, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %.fca.1.extract)
  %33 = call ptr @bump_malloc(i64 noundef 24)
  %34 = getelementptr i8, ptr %33, i64 8
  store ptr %32, ptr %34, align 8
  %35 = getelementptr i8, ptr %33, i64 16
  store ptr null, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %33)
  store ptr @Iterable, ptr %33, align 8
  %37 = load ptr, ptr %2, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract32)
  %41 = load ptr, ptr %8, align 8
  %42 = call ptr @typegetter_wrapper(ptr %41, ptr %.fca.1.extract)
  %43 = call ptr @bump_malloc(i64 noundef 32)
  %44 = getelementptr i8, ptr %43, i64 16
  store ptr %42, ptr %44, align 8
  %45 = getelementptr i8, ptr %43, i64 8
  store ptr %39, ptr %45, align 8
  %46 = getelementptr i8, ptr %43, i64 24
  store ptr null, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %43)
  store ptr @function_typ, ptr %43, align 8
  %48 = alloca [2 x ptr], align 8
  store ptr %33, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %48, i64 8
  store ptr %43, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %48)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef nonnull align 16 dereferenceable(520) @MapIterable)
  %52 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract32, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @function_typ, ptr %53, align 8
  %54 = call ptr @behavior_wrapper(ptr noundef nonnull @MapIterable_B_init_iterableIterableT_fFunctionT_to_U, { ptr, ptr, ptr, i32 } %29, ptr noundef nonnull align 8 dereferenceable(16) %52)
  call void %54({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull %48, { ptr, ptr, ptr, i32 } %26, { ptr } %3)
  %55 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(520) @MapIterable, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %56 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %55, 3
  ret { ptr, ptr, ptr, i32 } %56
}

define { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract32)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract32, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = call ptr @typegetter_wrapper(ptr %9, ptr %.fca.1.extract)
  %11 = alloca [2 x ptr], align 8
  store ptr @FilterIterable, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %10, ptr %12, align 8
  %13 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_FilterIterable, ptr noundef nonnull align 8 dereferenceable(16) %11)
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = call ptr @bump_malloc(i64 %14)
  store ptr %10, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  %17 = call i32 @get_offset(ptr noundef %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %17, 3
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable, ptr undef, ptr undef, i32 undef }, ptr %15, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 10, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract32)
  %26 = load ptr, ptr %8, align 8
  %27 = call ptr @typegetter_wrapper(ptr %26, ptr %.fca.1.extract)
  %28 = call ptr @bump_malloc(i64 noundef 24)
  %29 = getelementptr i8, ptr %28, i64 8
  store ptr %27, ptr %29, align 8
  %30 = getelementptr i8, ptr %28, i64 16
  store ptr null, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %28)
  store ptr @Iterable, ptr %28, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract32)
  %33 = load ptr, ptr %8, align 8
  %34 = call ptr @typegetter_wrapper(ptr %33, ptr %.fca.1.extract)
  %35 = call ptr @bump_malloc(i64 noundef 32)
  %36 = getelementptr i8, ptr %35, i64 16
  store ptr %34, ptr %36, align 8
  %37 = getelementptr i8, ptr %35, i64 8
  store ptr @_parameterization_Bool, ptr %37, align 8
  %38 = getelementptr i8, ptr %35, i64 24
  store ptr null, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %35)
  store ptr @function_typ, ptr %35, align 8
  %40 = alloca [2 x ptr], align 8
  store ptr %28, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %35, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %40)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @FilterIterable)
  %44 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract32, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %44, i64 8
  store ptr @function_typ, ptr %45, align 8
  %46 = call ptr @behavior_wrapper(ptr noundef nonnull @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool, { ptr, ptr, ptr, i32 } %24, ptr noundef nonnull align 8 dereferenceable(16) %44)
  call void %46({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull %40, { ptr, ptr, ptr, i32 } %21, { ptr } %3)
  %47 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(512) @FilterIterable, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %48 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %47, 3
  ret { ptr, ptr, ptr, i32 } %48
}

define { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract41)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract41, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract42)
  %12 = alloca [2 x ptr], align 8
  store ptr @ChainIterable, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %11, ptr %13, align 8
  %14 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ChainIterable, ptr noundef nonnull align 8 dereferenceable(16) %12)
  %15 = extractvalue { i64, i64 } %14, 0
  %16 = call ptr @bump_malloc(i64 %15)
  store ptr %11, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %18 = call i32 @get_offset(ptr noundef %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract42, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract43, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %18, 3
  %23 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %23, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable, ptr undef, ptr undef, i32 undef }, ptr %16, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr undef, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 10, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract41)
  %32 = load ptr, ptr %9, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract42)
  %34 = call ptr @bump_malloc(i64 noundef 24)
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %33, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr null, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  store ptr @Iterable, ptr %34, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract41)
  %39 = load ptr, ptr %9, align 8
  %40 = call ptr @typegetter_wrapper(ptr %39, ptr %.fca.1.extract42)
  %41 = call ptr @bump_malloc(i64 noundef 24)
  %42 = getelementptr i8, ptr %41, i64 8
  store ptr %40, ptr %42, align 8
  %43 = getelementptr i8, ptr %41, i64 16
  store ptr null, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %41)
  store ptr @Iterable, ptr %41, align 8
  %45 = alloca [2 x ptr], align 8
  store ptr %34, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr %41, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %45)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @ChainIterable)
  %49 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract41, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %49, i64 8
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = call ptr @behavior_wrapper(ptr noundef nonnull @ChainIterable_B_init_firstIterableT_secondIterableT, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 dereferenceable(16) %49)
  call void %51({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %45, { ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %27)
  %52 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(512) @ChainIterable, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %53 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %52, 3
  ret { ptr, ptr, ptr, i32 } %53
}

define { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract41)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract41, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract42)
  %12 = alloca [2 x ptr], align 8
  store ptr @ChainedCollection, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %11, ptr %13, align 8
  %14 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ChainedCollection, ptr noundef nonnull align 8 dereferenceable(16) %12)
  %15 = extractvalue { i64, i64 } %14, 0
  %16 = call ptr @bump_malloc(i64 %15)
  store ptr %11, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %18 = call i32 @get_offset(ptr noundef %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract42, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract43, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %18, 3
  %23 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %23, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainedCollection, ptr undef, ptr undef, i32 undef }, ptr %16, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr undef, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 10, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract41)
  %32 = load ptr, ptr %9, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract42)
  %34 = call ptr @bump_malloc(i64 noundef 24)
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %33, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr null, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  store ptr @Collection, ptr %34, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract41)
  %39 = load ptr, ptr %9, align 8
  %40 = call ptr @typegetter_wrapper(ptr %39, ptr %.fca.1.extract42)
  %41 = call ptr @bump_malloc(i64 noundef 24)
  %42 = getelementptr i8, ptr %41, i64 8
  store ptr %40, ptr %42, align 8
  %43 = getelementptr i8, ptr %41, i64 16
  store ptr null, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %41)
  store ptr @Collection, ptr %41, align 8
  %45 = alloca [2 x ptr], align 8
  store ptr %34, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr %41, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %45)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @ChainedCollection)
  %49 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract41, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %49, i64 8
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = call ptr @behavior_wrapper(ptr noundef nonnull @ChainedCollection_B_init_firstCollectionT_secondCollectionT, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 dereferenceable(16) %49)
  call void %51({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %45, { ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %27)
  %52 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1056) @ChainedCollection, ptr noundef nonnull @Iterable)
  %53 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %52, 3
  ret { ptr, ptr, ptr, i32 } %53
}

define { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract41)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract41, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract42)
  %12 = alloca [2 x ptr], align 8
  store ptr @InterleavedCollection, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %11, ptr %13, align 8
  %14 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_InterleavedCollection, ptr noundef nonnull align 8 dereferenceable(16) %12)
  %15 = extractvalue { i64, i64 } %14, 0
  %16 = call ptr @bump_malloc(i64 %15)
  store ptr %11, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %18 = call i32 @get_offset(ptr noundef %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract42, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract43, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %18, 3
  %23 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %23, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleavedCollection, ptr undef, ptr undef, i32 undef }, ptr %16, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr undef, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 10, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract41)
  %32 = load ptr, ptr %9, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract42)
  %34 = call ptr @bump_malloc(i64 noundef 24)
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %33, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr null, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  store ptr @Collection, ptr %34, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract41)
  %39 = load ptr, ptr %9, align 8
  %40 = call ptr @typegetter_wrapper(ptr %39, ptr %.fca.1.extract42)
  %41 = call ptr @bump_malloc(i64 noundef 24)
  %42 = getelementptr i8, ptr %41, i64 8
  store ptr %40, ptr %42, align 8
  %43 = getelementptr i8, ptr %41, i64 16
  store ptr null, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %41)
  store ptr @Collection, ptr %41, align 8
  %45 = alloca [2 x ptr], align 8
  store ptr %34, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr %41, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %45)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection)
  %49 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract41, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %49, i64 8
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = call ptr @behavior_wrapper(ptr noundef nonnull @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 dereferenceable(16) %49)
  call void %51({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %45, { ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %27)
  %52 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection, ptr noundef nonnull @Iterable)
  %53 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %52, 3
  ret { ptr, ptr, ptr, i32 } %53
}

define { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract41)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract41, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract42)
  %12 = alloca [2 x ptr], align 8
  store ptr @InterleaveIterable, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %11, ptr %13, align 8
  %14 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_InterleaveIterable, ptr noundef nonnull align 8 dereferenceable(16) %12)
  %15 = extractvalue { i64, i64 } %14, 0
  %16 = call ptr @bump_malloc(i64 %15)
  store ptr %11, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %18 = call i32 @get_offset(ptr noundef %.fca.0.extract41, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract42, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract43, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %18, 3
  %23 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %23, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable, ptr undef, ptr undef, i32 undef }, ptr %16, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr undef, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 10, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract41)
  %32 = load ptr, ptr %9, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract42)
  %34 = call ptr @bump_malloc(i64 noundef 24)
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %33, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr null, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  store ptr @Iterable, ptr %34, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract41)
  %39 = load ptr, ptr %9, align 8
  %40 = call ptr @typegetter_wrapper(ptr %39, ptr %.fca.1.extract42)
  %41 = call ptr @bump_malloc(i64 noundef 24)
  %42 = getelementptr i8, ptr %41, i64 8
  store ptr %40, ptr %42, align 8
  %43 = getelementptr i8, ptr %41, i64 16
  store ptr null, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %41)
  store ptr @Iterable, ptr %41, align 8
  %45 = alloca [2 x ptr], align 8
  store ptr %34, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr %41, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %45)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @InterleaveIterable)
  %49 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract41, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %49, i64 8
  store ptr %.fca.0.extract, ptr %50, align 8
  %51 = call ptr @behavior_wrapper(ptr noundef nonnull @InterleaveIterable_B_init_firstIterableT_secondIterableT, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 dereferenceable(16) %49)
  call void %51({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %45, { ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %27)
  %52 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(512) @InterleaveIterable, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %53 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %52, 3
  ret { ptr, ptr, ptr, i32 } %53
}

define { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract64, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract65)
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43)
  %13 = sext i32 %.fca.3.extract33 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract43, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %.fca.1.extract44)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64)
  %18 = load ptr, ptr %9, align 8
  %19 = call ptr @typegetter_wrapper(ptr %18, ptr %.fca.1.extract65)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43)
  %21 = load ptr, ptr %14, align 8
  %22 = call ptr @typegetter_wrapper(ptr %21, ptr %.fca.1.extract44)
  %23 = call ptr @bump_malloc(i64 noundef 32)
  %24 = getelementptr i8, ptr %23, i64 16
  store ptr %22, ptr %24, align 8
  %25 = getelementptr i8, ptr %23, i64 8
  store ptr %19, ptr %25, align 8
  %26 = getelementptr i8, ptr %23, i64 24
  store ptr null, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %23)
  store ptr @Pair, ptr %23, align 8
  %28 = alloca [4 x ptr], align 8
  store ptr @ZippedCollection, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %28, i64 8
  store ptr %11, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 16
  store ptr %16, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %28, i64 24
  store ptr %23, ptr %31, align 8
  %32 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ZippedCollection, ptr noundef nonnull align 8 dereferenceable(32) %28)
  %33 = extractvalue { i64, i64 } %32, 0
  %34 = call ptr @bump_malloc(i64 %33)
  store ptr %11, ptr %34, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %16, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr %23, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  %38 = call i32 @get_offset(ptr noundef %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract65, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract66, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %38, 3
  %43 = call i32 @get_offset(ptr noundef %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.1.extract44, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.2.extract45, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %43, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZippedCollection, ptr undef, ptr undef, i32 undef }, ptr %34, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr undef, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 10, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64)
  %52 = load ptr, ptr %9, align 8
  %53 = call ptr @typegetter_wrapper(ptr %52, ptr %.fca.1.extract65)
  %54 = call ptr @bump_malloc(i64 noundef 24)
  %55 = getelementptr i8, ptr %54, i64 8
  store ptr %53, ptr %55, align 8
  %56 = getelementptr i8, ptr %54, i64 16
  store ptr null, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %54)
  store ptr @Collection, ptr %54, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43)
  %59 = load ptr, ptr %14, align 8
  %60 = call ptr @typegetter_wrapper(ptr %59, ptr %.fca.1.extract44)
  %61 = call ptr @bump_malloc(i64 noundef 24)
  %62 = getelementptr i8, ptr %61, i64 8
  store ptr %60, ptr %62, align 8
  %63 = getelementptr i8, ptr %61, i64 16
  store ptr null, ptr %63, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %61)
  store ptr @Collection, ptr %61, align 8
  %65 = alloca [2 x ptr], align 8
  store ptr %54, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr %61, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %65)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ZippedCollection)
  %69 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract64, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %69, i64 8
  store ptr %.fca.0.extract43, ptr %70, align 8
  %71 = call ptr @behavior_wrapper(ptr noundef nonnull @ZippedCollection_B_init_firstCollectionT_secondCollectionU, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(16) %69)
  call void %71({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %65, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %47)
  %72 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1072) @ZippedCollection, ptr noundef nonnull @Iterable)
  %73 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %72, 3
  ret { ptr, ptr, ptr, i32 } %73
}

define { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract64, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract65)
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %13 = sext i32 %.fca.3.extract33 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract43, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %.fca.1.extract44)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64)
  %18 = load ptr, ptr %9, align 8
  %19 = call ptr @typegetter_wrapper(ptr %18, ptr %.fca.1.extract65)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %21 = load ptr, ptr %14, align 8
  %22 = call ptr @typegetter_wrapper(ptr %21, ptr %.fca.1.extract44)
  %23 = call ptr @bump_malloc(i64 noundef 32)
  %24 = getelementptr i8, ptr %23, i64 16
  store ptr %22, ptr %24, align 8
  %25 = getelementptr i8, ptr %23, i64 8
  store ptr %19, ptr %25, align 8
  %26 = getelementptr i8, ptr %23, i64 24
  store ptr null, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %23)
  store ptr @Pair, ptr %23, align 8
  %28 = alloca [4 x ptr], align 8
  store ptr @ZipIterable, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %28, i64 8
  store ptr %11, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 16
  store ptr %16, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %28, i64 24
  store ptr %23, ptr %31, align 8
  %32 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ZipIterable, ptr noundef nonnull align 8 dereferenceable(32) %28)
  %33 = extractvalue { i64, i64 } %32, 0
  %34 = call ptr @bump_malloc(i64 %33)
  store ptr %11, ptr %34, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %16, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr %23, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  %38 = call i32 @get_offset(ptr noundef %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract65, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract66, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %38, 3
  %43 = call i32 @get_offset(ptr noundef %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.1.extract44, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.2.extract45, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %43, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable, ptr undef, ptr undef, i32 undef }, ptr %34, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr undef, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 10, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64)
  %52 = load ptr, ptr %9, align 8
  %53 = call ptr @typegetter_wrapper(ptr %52, ptr %.fca.1.extract65)
  %54 = call ptr @bump_malloc(i64 noundef 24)
  %55 = getelementptr i8, ptr %54, i64 8
  store ptr %53, ptr %55, align 8
  %56 = getelementptr i8, ptr %54, i64 16
  store ptr null, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %54)
  store ptr @Iterable, ptr %54, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %59 = load ptr, ptr %14, align 8
  %60 = call ptr @typegetter_wrapper(ptr %59, ptr %.fca.1.extract44)
  %61 = call ptr @bump_malloc(i64 noundef 24)
  %62 = getelementptr i8, ptr %61, i64 8
  store ptr %60, ptr %62, align 8
  %63 = getelementptr i8, ptr %61, i64 16
  store ptr null, ptr %63, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %61)
  store ptr @Iterable, ptr %61, align 8
  %65 = alloca [2 x ptr], align 8
  store ptr %54, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr %61, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %65)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ZipIterable)
  %69 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract64, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %69, i64 8
  store ptr %.fca.0.extract43, ptr %70, align 8
  %71 = call ptr @behavior_wrapper(ptr noundef nonnull @ZipIterable_B_init_firstIterableT_secondIterableU, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(16) %69)
  call void %71({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %65, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %47)
  %72 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(528) @ZipIterable, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %73 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %72, 3
  ret { ptr, ptr, ptr, i32 } %73
}

define { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract64, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract65)
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43)
  %13 = sext i32 %.fca.3.extract33 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract43, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %.fca.1.extract44)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64)
  %18 = load ptr, ptr %9, align 8
  %19 = call ptr @typegetter_wrapper(ptr %18, ptr %.fca.1.extract65)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43)
  %21 = load ptr, ptr %14, align 8
  %22 = call ptr @typegetter_wrapper(ptr %21, ptr %.fca.1.extract44)
  %23 = call ptr @bump_malloc(i64 noundef 32)
  %24 = getelementptr i8, ptr %23, i64 16
  store ptr %22, ptr %24, align 8
  %25 = getelementptr i8, ptr %23, i64 8
  store ptr %19, ptr %25, align 8
  %26 = getelementptr i8, ptr %23, i64 24
  store ptr null, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %23)
  store ptr @Pair, ptr %23, align 8
  %28 = alloca [4 x ptr], align 8
  store ptr @ProductCollection, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %28, i64 8
  store ptr %11, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 16
  store ptr %16, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %28, i64 24
  store ptr %23, ptr %31, align 8
  %32 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ProductCollection, ptr noundef nonnull align 8 dereferenceable(32) %28)
  %33 = extractvalue { i64, i64 } %32, 0
  %34 = call ptr @bump_malloc(i64 %33)
  store ptr %11, ptr %34, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %16, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr %23, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  %38 = call i32 @get_offset(ptr noundef %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract65, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract66, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %38, 3
  %43 = call i32 @get_offset(ptr noundef %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.1.extract44, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.2.extract45, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %43, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductCollection, ptr undef, ptr undef, i32 undef }, ptr %34, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr undef, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 10, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract64)
  %52 = load ptr, ptr %9, align 8
  %53 = call ptr @typegetter_wrapper(ptr %52, ptr %.fca.1.extract65)
  %54 = call ptr @bump_malloc(i64 noundef 24)
  %55 = getelementptr i8, ptr %54, i64 8
  store ptr %53, ptr %55, align 8
  %56 = getelementptr i8, ptr %54, i64 16
  store ptr null, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %54)
  store ptr @Collection, ptr %54, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract43)
  %59 = load ptr, ptr %14, align 8
  %60 = call ptr @typegetter_wrapper(ptr %59, ptr %.fca.1.extract44)
  %61 = call ptr @bump_malloc(i64 noundef 24)
  %62 = getelementptr i8, ptr %61, i64 8
  store ptr %60, ptr %62, align 8
  %63 = getelementptr i8, ptr %61, i64 16
  store ptr null, ptr %63, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %61)
  store ptr @Collection, ptr %61, align 8
  %65 = alloca [2 x ptr], align 8
  store ptr %54, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr %61, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %65)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1072) @ProductCollection)
  %69 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract64, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %69, i64 8
  store ptr %.fca.0.extract43, ptr %70, align 8
  %71 = call ptr @behavior_wrapper(ptr noundef nonnull @ProductCollection_B_init_firstCollectionT_secondCollectionU, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(16) %69)
  call void %71({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %65, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %47)
  %72 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(1072) @ProductCollection, ptr noundef nonnull @Iterable)
  %73 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %72, 3
  ret { ptr, ptr, ptr, i32 } %73
}

define { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64)
  %8 = sext i32 %5 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract64, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = call ptr @typegetter_wrapper(ptr %10, ptr %.fca.1.extract65)
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %13 = sext i32 %.fca.3.extract33 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract43, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %.fca.1.extract44)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64)
  %18 = load ptr, ptr %9, align 8
  %19 = call ptr @typegetter_wrapper(ptr %18, ptr %.fca.1.extract65)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %21 = load ptr, ptr %14, align 8
  %22 = call ptr @typegetter_wrapper(ptr %21, ptr %.fca.1.extract44)
  %23 = call ptr @bump_malloc(i64 noundef 32)
  %24 = getelementptr i8, ptr %23, i64 16
  store ptr %22, ptr %24, align 8
  %25 = getelementptr i8, ptr %23, i64 8
  store ptr %19, ptr %25, align 8
  %26 = getelementptr i8, ptr %23, i64 24
  store ptr null, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %23)
  store ptr @Pair, ptr %23, align 8
  %28 = alloca [4 x ptr], align 8
  store ptr @ProductIterable, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %28, i64 8
  store ptr %11, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 16
  store ptr %16, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %28, i64 24
  store ptr %23, ptr %31, align 8
  %32 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ProductIterable, ptr noundef nonnull align 8 dereferenceable(32) %28)
  %33 = extractvalue { i64, i64 } %32, 0
  %34 = call ptr @bump_malloc(i64 %33)
  store ptr %11, ptr %34, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %16, ptr %35, align 8
  %36 = getelementptr i8, ptr %34, i64 16
  store ptr %23, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %34)
  %38 = call i32 @get_offset(ptr noundef %.fca.0.extract64, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract65, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract66, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %38, 3
  %43 = call i32 @get_offset(ptr noundef %.fca.0.extract43, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.1.extract44, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.2.extract45, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %43, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable, ptr undef, ptr undef, i32 undef }, ptr %34, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr undef, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 10, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract64)
  %52 = load ptr, ptr %9, align 8
  %53 = call ptr @typegetter_wrapper(ptr %52, ptr %.fca.1.extract65)
  %54 = call ptr @bump_malloc(i64 noundef 24)
  %55 = getelementptr i8, ptr %54, i64 8
  store ptr %53, ptr %55, align 8
  %56 = getelementptr i8, ptr %54, i64 16
  store ptr null, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %54)
  store ptr @Iterable, ptr %54, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract43)
  %59 = load ptr, ptr %14, align 8
  %60 = call ptr @typegetter_wrapper(ptr %59, ptr %.fca.1.extract44)
  %61 = call ptr @bump_malloc(i64 noundef 24)
  %62 = getelementptr i8, ptr %61, i64 8
  store ptr %60, ptr %62, align 8
  %63 = getelementptr i8, ptr %61, i64 16
  store ptr null, ptr %63, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %61)
  store ptr @Iterable, ptr %61, align 8
  %65 = alloca [2 x ptr], align 8
  store ptr %54, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr %61, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %65)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ProductIterable)
  %69 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract64, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %69, i64 8
  store ptr %.fca.0.extract43, ptr %70, align 8
  %71 = call ptr @behavior_wrapper(ptr noundef nonnull @ProductIterable_B_init_firstIterableT_secondIterableU, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(16) %69)
  call void %71({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %65, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %47)
  %72 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(528) @ProductIterable, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %73 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %72, 3
  ret { ptr, ptr, ptr, i32 } %73
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ProductIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 224
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 9197944775169318296, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 248
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ProductIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ProductIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 312
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ProductIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 320
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @ProductIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(528) @ProductIterable)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 32
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @ProductIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract103 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract103, ptr noundef nonnull align 16 dereferenceable(528) @ProductIterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract103, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract105) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract64, ptr %13, align 8
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep67 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract66, ptr %.fca.1.gep67, align 8
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep69 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract68, ptr %.fca.2.gep69, align 8
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep71 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract70, ptr %.fca.3.gep71, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep67, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep69, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep71, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract52, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %32 = getelementptr i8, ptr %8, i64 32
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract105) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract43, ptr %36, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %38 = load ptr, ptr %8, align 8
  %39 = call ptr @typegetter_wrapper(ptr %38, ptr %.fca.1.extract105)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %41 = getelementptr i8, ptr %8, i64 8
  %42 = load ptr, ptr %41, align 8
  %43 = call ptr @typegetter_wrapper(ptr %42, ptr %.fca.1.extract105)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %45 = load ptr, ptr %8, align 8
  %46 = call ptr @typegetter_wrapper(ptr %45, ptr %.fca.1.extract105)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %48 = load ptr, ptr %41, align 8
  %49 = call ptr @typegetter_wrapper(ptr %48, ptr %.fca.1.extract105)
  %50 = call ptr @bump_malloc(i64 noundef 32)
  %51 = getelementptr i8, ptr %50, i64 16
  store ptr %49, ptr %51, align 8
  %52 = getelementptr i8, ptr %50, i64 8
  store ptr %46, ptr %52, align 8
  %53 = getelementptr i8, ptr %50, i64 24
  store ptr null, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %50)
  store ptr @Pair, ptr %50, align 8
  %55 = alloca [4 x ptr], align 8
  store ptr @ProductIterator, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %55, i64 8
  store ptr %39, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %55, i64 16
  store ptr %43, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %55, i64 24
  store ptr %50, ptr %58, align 8
  %59 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ProductIterator, ptr noundef nonnull align 8 dereferenceable(32) %55)
  %60 = extractvalue { i64, i64 } %59, 0
  %61 = call ptr @bump_malloc(i64 %60)
  store ptr %39, ptr %61, align 8
  %62 = getelementptr i8, ptr %61, i64 8
  store ptr %43, ptr %62, align 8
  %63 = getelementptr i8, ptr %61, i64 16
  store ptr %50, ptr %63, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %61)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %66 = load ptr, ptr %9, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr, ptr, ptr, i32 } %67(ptr %.fca.1.extract105) #31
  %69 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  store ptr %.fca.0.extract27, ptr %69, align 8
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.1.gep30 = getelementptr inbounds i8, ptr %69, i64 8
  store ptr %.fca.1.extract29, ptr %.fca.1.gep30, align 8
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.2.gep32 = getelementptr inbounds i8, ptr %69, i64 16
  store ptr %.fca.2.extract31, ptr %.fca.2.gep32, align 8
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  %.fca.3.gep34 = getelementptr inbounds i8, ptr %69, i64 24
  store i32 %.fca.3.extract33, ptr %.fca.3.gep34, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %69, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %70 = load ptr, ptr %69, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %70, 0
  %72 = load ptr, ptr %.fca.1.gep30, align 8
  %73 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %72, 1
  %74 = load ptr, ptr %.fca.2.gep32, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %74, 2
  %76 = load i32, ptr %.fca.3.gep34, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } %75, i32 %76, 3
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %70)
  %80 = sext i32 %76 to i64
  %81 = getelementptr ptr, ptr %70, i64 %80
  %82 = getelementptr i8, ptr %81, i64 8
  %83 = load ptr, ptr %82, align 8
  %84 = call ptr @behavior_wrapper(ptr %83, { ptr, ptr, ptr, i32 } %77, ptr noundef nonnull align 8 %4)
  %85 = call { ptr, ptr, ptr, i32 } %84({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull %4)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %86 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %88 = load ptr, ptr %32, align 8
  %89 = load ptr, ptr %88, align 8
  %90 = call { ptr, ptr, ptr, i32 } %89(ptr %.fca.1.extract105) #31
  %91 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %90, 0
  store ptr %.fca.0.extract, ptr %91, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %90, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %91, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %90, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %91, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %90, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %91, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %91, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %92 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %.fca.1.extract21, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %.fca.2.extract23, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %92, 3
  %97 = load ptr, ptr %91, align 8
  %98 = load ptr, ptr %.fca.1.gep, align 8
  %99 = load ptr, ptr %.fca.2.gep, align 8
  %100 = call i32 @get_offset(ptr %97, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %101 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, ptr %98, 1
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %99, 2
  %104 = insertvalue { ptr, ptr, ptr, i32 } %103, i32 %100, 3
  %105 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %61, 1
  %106 = insertvalue { ptr, ptr, ptr, i32 } %105, ptr undef, 2
  %107 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 10, 3
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %109 = load ptr, ptr %8, align 8
  %110 = call ptr @typegetter_wrapper(ptr %109, ptr %.fca.1.extract105)
  %111 = call ptr @bump_malloc(i64 noundef 24)
  %112 = getelementptr i8, ptr %111, i64 8
  store ptr %110, ptr %112, align 8
  %113 = getelementptr i8, ptr %111, i64 16
  store ptr null, ptr %113, align 8
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %111)
  store ptr @Iterator, ptr %111, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract103)
  %116 = load ptr, ptr %41, align 8
  %117 = call ptr @typegetter_wrapper(ptr %116, ptr %.fca.1.extract105)
  %118 = call ptr @bump_malloc(i64 noundef 24)
  %119 = getelementptr i8, ptr %118, i64 8
  store ptr %117, ptr %119, align 8
  %120 = getelementptr i8, ptr %118, i64 16
  store ptr null, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %118)
  store ptr @Iterable, ptr %118, align 8
  %122 = alloca [2 x ptr], align 8
  store ptr %111, ptr %122, align 8
  %123 = getelementptr inbounds i8, ptr %122, i64 8
  store ptr %118, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %122)
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %126 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract19, ptr %126, align 8
  %127 = getelementptr inbounds i8, ptr %126, i64 8
  store ptr %97, ptr %127, align 8
  %128 = call ptr @behavior_wrapper(ptr noundef nonnull @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU, { ptr, ptr, ptr, i32 } %107, ptr noundef nonnull align 8 dereferenceable(16) %126)
  call void %128({ ptr, ptr, ptr, i32 } %107, { ptr, ptr, ptr, i32 } %107, ptr nonnull %122, { ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %104)
  %129 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(192) @ProductIterator, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %130 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 %129, 3
  ret { ptr, ptr, ptr, i32 } %130
}

define { ptr, ptr, ptr, i32 } @Iterable_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = call ptr @typegetter_wrapper(ptr %8, ptr %.fca.1.extract)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract)
  %11 = load ptr, ptr %7, align 8
  %12 = call ptr @typegetter_wrapper(ptr %11, ptr %.fca.1.extract)
  %13 = call ptr @bump_malloc(i64 noundef 32)
  %14 = getelementptr i8, ptr %13, i64 16
  store ptr %12, ptr %14, align 8
  %15 = getelementptr i8, ptr %13, i64 8
  store ptr @_parameterization_i32, ptr %15, align 8
  %16 = getelementptr i8, ptr %13, i64 24
  store ptr null, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %13)
  store ptr @Pair, ptr %13, align 8
  %18 = alloca [3 x ptr], align 8
  store ptr @Enumeration, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr %9, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr %13, ptr %20, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Enumeration, ptr noundef nonnull align 8 dereferenceable(24) %18)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = call ptr @bump_malloc(i64 %22)
  store ptr %9, ptr %23, align 8
  %24 = getelementptr i8, ptr %23, i64 8
  store ptr %13, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %23)
  %26 = call i32 @get_offset(ptr noundef %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %26, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumeration, ptr undef, ptr undef, i32 undef }, ptr %23, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr undef, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 10, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract)
  %35 = load ptr, ptr %7, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract)
  %37 = call ptr @bump_malloc(i64 noundef 24)
  %38 = getelementptr i8, ptr %37, i64 8
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 16
  store ptr null, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %37)
  store ptr @Iterable, ptr %37, align 8
  %41 = alloca [1 x ptr], align 8
  store ptr %37, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Enumeration)
  %44 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %44, align 8
  %45 = call ptr @behavior_wrapper(ptr noundef nonnull @Enumeration_B_init_iterableIterableT, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 dereferenceable(8) %44)
  call void %45({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull %41, { ptr, ptr, ptr, i32 } %30)
  %46 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(512) @Enumeration, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %47 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %46, 3
  ret { ptr, ptr, ptr, i32 } %47
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumeration(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @Enumeration_B_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 208
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 9197944775169318296, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 232
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Enumeration_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @Enumeration_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @Enumeration_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @Enumeration_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @Enumeration_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull align 16 dereferenceable(512) @Enumeration)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract13)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract13, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %18) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @Enumeration_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract63, ptr noundef nonnull align 16 dereferenceable(512) @Enumeration)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract63)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract63, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract65) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract39, ptr %13, align 8
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep42 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract41, ptr %.fca.1.gep42, align 8
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep44 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract43, ptr %.fca.2.gep44, align 8
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep46 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract45, ptr %.fca.3.gep46, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep42, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep44, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep46, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract27, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract63)
  %32 = load ptr, ptr %8, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract65)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract63)
  %35 = load ptr, ptr %8, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract65)
  %37 = call ptr @bump_malloc(i64 noundef 32)
  %38 = getelementptr i8, ptr %37, i64 16
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 8
  store ptr @_parameterization_i32, ptr %39, align 8
  %40 = getelementptr i8, ptr %37, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %37)
  store ptr @Pair, ptr %37, align 8
  %42 = alloca [3 x ptr], align 8
  store ptr @Enumerator, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %42, i64 8
  store ptr %33, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  store ptr %37, ptr %44, align 8
  %45 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Enumerator, ptr noundef nonnull align 8 dereferenceable(24) %42)
  %46 = extractvalue { i64, i64 } %45, 0
  %47 = call ptr @bump_malloc(i64 %46)
  store ptr %33, ptr %47, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  store ptr %37, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %47)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract63)
  %51 = load ptr, ptr %9, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr, ptr, ptr, i32 } %52(ptr %.fca.1.extract65) #31
  %54 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %53, 0
  store ptr %.fca.0.extract14, ptr %54, align 8
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %53, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %54, i64 8
  store ptr %.fca.1.extract15, ptr %.fca.1.gep, align 8
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %53, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %54, i64 16
  store ptr %.fca.2.extract16, ptr %.fca.2.gep, align 8
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %53, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %54, i64 24
  store i32 %.fca.3.extract17, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %54, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %55 = load ptr, ptr %54, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %.fca.1.gep, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %.fca.2.gep, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %.fca.3.gep, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %55)
  %65 = sext i32 %61 to i64
  %66 = getelementptr ptr, ptr %55, i64 %65
  %67 = getelementptr i8, ptr %66, i64 8
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @behavior_wrapper(ptr %68, { ptr, ptr, ptr, i32 } %62, ptr noundef nonnull align 8 %4)
  %70 = call { ptr, ptr, ptr, i32 } %69({ ptr, ptr, ptr, i32 } %62, { ptr, ptr, ptr, i32 } %62, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %70, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %70, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %70, 2
  %71 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %72 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %73 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.1.extract, 1
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %.fca.2.extract, 2
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, i32 %72, 3
  %77 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %47, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr undef, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 10, 3
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract63)
  %81 = load ptr, ptr %8, align 8
  %82 = call ptr @typegetter_wrapper(ptr %81, ptr %.fca.1.extract65)
  %83 = call ptr @bump_malloc(i64 noundef 24)
  %84 = getelementptr i8, ptr %83, i64 8
  store ptr %82, ptr %84, align 8
  %85 = getelementptr i8, ptr %83, i64 16
  store ptr null, ptr %85, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %83)
  store ptr @Iterator, ptr %83, align 8
  %87 = alloca [1 x ptr], align 8
  store ptr %83, ptr %87, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %87)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator)
  %90 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %90, align 8
  %91 = call ptr @behavior_wrapper(ptr noundef nonnull @Enumerator_B_init_iteratorIteratorT, { ptr, ptr, ptr, i32 } %79, ptr noundef nonnull align 8 dereferenceable(8) %90)
  call void %91({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %87, { ptr, ptr, ptr, i32 } %76)
  %92 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(168) @Enumerator, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %93 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %92, 3
  ret { ptr, ptr, ptr, i32 } %93
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumerator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @Enumerator_B_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 128
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Enumerator_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(168) @Enumerator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract17)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract17, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %18) #30
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract17)
  %20 = getelementptr i8, ptr %10, i64 24
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract18, i32 0) #30
  ret void
}

define { ptr, i160 } @Enumerator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %8 = call i32 @get_offset(ptr %.fca.0.extract33, ptr noundef nonnull align 16 dereferenceable(168) @Enumerator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract33)
  %10 = sext i32 %8 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract33, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr, ptr, ptr, i32 } %14(ptr %.fca.1.extract35) #31
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  store ptr %.fca.0.extract2, ptr %16, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %16, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %16, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %16, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %17 = load ptr, ptr %16, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %17, 0
  %19 = load ptr, ptr %.fca.1.gep, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %19, 1
  %21 = load ptr, ptr %.fca.2.gep, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 2
  %23 = load i32, ptr %.fca.3.gep, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %23, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %17)
  %27 = sext i32 %23 to i64
  %28 = getelementptr ptr, ptr %17, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %24, ptr noundef nonnull align 8 %4)
  %32 = call { ptr, i160 } %31({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %32, 0
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract33)
  %34 = load ptr, ptr %11, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract35)
  %36 = icmp ne ptr %.fca.0.extract, @nil_typ
  %37 = icmp ne ptr %.fca.0.extract, null
  %.not62 = and i1 %36, %37
  br i1 %.not62, label %38, label %73

38:                                               ; preds = %3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract33)
  %40 = getelementptr i8, ptr %11, i64 24
  %41 = load ptr, ptr %40, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %.fca.1.extract35) #31
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract33)
  %45 = call i32 %42(ptr %.fca.1.extract35) #31
  %46 = add i32 %45, 1
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract33)
  %48 = getelementptr i8, ptr %41, i64 8
  %49 = load ptr, ptr %48, align 8
  call void %49(ptr %.fca.1.extract35, i32 %46) #30
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract33)
  %51 = load ptr, ptr %11, align 8
  %52 = call ptr @typegetter_wrapper(ptr %51, ptr %.fca.1.extract35)
  store ptr @Pair, ptr %5, align 8
  %53 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %52, ptr %54, align 8
  %55 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Pair, ptr noundef nonnull align 8 dereferenceable(24) %5)
  %56 = extractvalue { i64, i64 } %55, 0
  %57 = call ptr @bump_malloc(i64 %56)
  store ptr @_parameterization_i32, ptr %57, align 8
  %58 = getelementptr i8, ptr %57, i64 8
  store ptr %52, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %57)
  %.sroa.047.0.insert.ext = zext i32 %43 to i160
  %60 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.047.0.insert.ext, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %57, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr undef, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 10, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract33)
  %65 = load ptr, ptr %11, align 8
  %66 = call ptr @typegetter_wrapper(ptr %65, ptr %.fca.1.extract35)
  store ptr @_parameterization_i32, ptr %6, align 8
  %67 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %66, ptr %67, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Pair)
  store ptr @i32_typ, ptr %7, align 8
  %70 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.0.extract, ptr %70, align 8
  %71 = call ptr @behavior_wrapper(ptr noundef nonnull @Pair_B_init_firstT_secondU, { ptr, ptr, ptr, i32 } %63, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %71({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull %6, { ptr, i160 } %60, { ptr, i160 } %32)
  %72 = ptrtoint ptr %57 to i64
  %.sroa.351.8.insert.ext = zext i64 %72 to i160
  %.sroa.351.8.insert.insert = or disjoint i160 %.sroa.351.8.insert.ext, 3402823669209384634633746074317682114560
  br label %73

73:                                               ; preds = %38, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @Pair, %38 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.351.8.insert.insert, %38 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i32_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_i32_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i32_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_nil_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @nil_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_nil_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_nil_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Enumerator_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumerator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Container(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumeration_getter_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumeration_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 152, i64 8 }
}

define ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 152
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract92 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract94 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract92, ptr noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %.fca.0.extract61 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract63 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract65 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %8 = call i32 @get_offset(ptr %.fca.0.extract61, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %9 = call i32 @get_offset(ptr %.fca.0.extract61, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract92)
  %11 = sext i32 %7 to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract92, i64 %11
  %13 = getelementptr i8, ptr %12, i64 24
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract61, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract63, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract65, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %9, 3
  call void %16(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %20) #30
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %21 = call i32 @get_offset(ptr %.fca.0.extract39, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = call i32 @get_offset(ptr %.fca.0.extract39, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract92)
  %24 = getelementptr i8, ptr %12, i64 40
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract41, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract43, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %22, 3
  call void %27(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %31) #30
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract92)
  %33 = load ptr, ptr %24, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract94) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract21, ptr %36, align 8
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep24 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract23, ptr %.fca.1.gep24, align 8
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep26 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract25, ptr %.fca.2.gep26, align 8
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep28 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract27, ptr %.fca.3.gep28, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep24, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep26, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep28, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %6)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %6)
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %52, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %52, 2
  %53 = call i32 @get_offset(ptr %.fca.0.extract11, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %54 = call i32 @get_offset(ptr %.fca.0.extract11, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract92)
  %56 = getelementptr i8, ptr %12, i64 32
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr i8, ptr %57, i64 8
  %59 = load ptr, ptr %58, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract13, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract15, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %54, 3
  call void %59(ptr %.fca.1.extract94, { ptr, ptr, ptr, i32 } %63) #30
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract92)
  %65 = load ptr, ptr %13, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr, ptr, ptr, i32 } %66(ptr %.fca.1.extract94) #31
  %68 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  store ptr %.fca.0.extract1, ptr %68, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %68, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %68, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %67, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %68, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %68, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %69 = load ptr, ptr %68, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %69, 0
  %71 = load ptr, ptr %.fca.1.gep, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %71, 1
  %73 = load ptr, ptr %.fca.2.gep, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 2
  %75 = load i32, ptr %.fca.3.gep, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %75, 3
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %69)
  %79 = sext i32 %75 to i64
  %80 = getelementptr ptr, ptr %69, i64 %79
  %81 = getelementptr i8, ptr %80, i64 8
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @behavior_wrapper(ptr %82, { ptr, ptr, ptr, i32 } %76, ptr noundef nonnull align 8 %6)
  %84 = call { ptr, i160 } %83({ ptr, ptr, ptr, i32 } %76, { ptr, ptr, ptr, i32 } %76, ptr nonnull %6)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract92)
  %86 = getelementptr i8, ptr %12, i64 48
  %87 = load ptr, ptr %86, align 8
  %88 = getelementptr i8, ptr %87, i64 8
  %89 = load ptr, ptr %88, align 8
  call void %89(ptr %.fca.1.extract94, { ptr, i160 } %84) #30
  ret void
}

define { ptr, i160 } @ProductIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [3 x ptr], align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %11 = call i32 @get_offset(ptr %.fca.0.extract47, ptr noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %13 = sext i32 %11 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract47, i64 %13
  %15 = getelementptr i8, ptr %14, i64 48
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, i160 } %17(ptr %.fca.1.extract48) #31
  %.fca.0.extract = extractvalue { ptr, i160 } %18, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %18, 1
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %20 = getelementptr i8, ptr %14, i64 32
  %.fca.1.gep116 = getelementptr inbounds i8, ptr %5, i64 8
  %.fca.2.gep118 = getelementptr inbounds i8, ptr %5, i64 16
  %.fca.3.gep120 = getelementptr inbounds i8, ptr %5, i64 24
  %21 = getelementptr i8, ptr %14, i64 8
  %22 = getelementptr i8, ptr %14, i64 24
  %.fca.1.gep90 = getelementptr inbounds i8, ptr %9, i64 8
  %.fca.2.gep92 = getelementptr inbounds i8, ptr %9, i64 16
  %.fca.3.gep94 = getelementptr inbounds i8, ptr %9, i64 24
  %23 = getelementptr i8, ptr %14, i64 40
  %.fca.1.gep = getelementptr inbounds i8, ptr %10, i64 8
  %.fca.2.gep = getelementptr inbounds i8, ptr %10, i64 16
  %.fca.3.gep = getelementptr inbounds i8, ptr %10, i64 24
  br label %24

24:                                               ; preds = %114, %3
  %.sroa.0110.0 = phi ptr [ undef, %3 ], [ %.sroa.0110.1, %114 ]
  %.sroa.3112.0 = phi i160 [ undef, %3 ], [ %.sroa.3112.1, %114 ]
  %.0129 = phi ptr [ undef, %3 ], [ %.1130, %114 ]
  %.0127 = phi i160 [ undef, %3 ], [ %.1128, %114 ]
  %.0124 = phi i160 [ %.fca.1.extract, %3 ], [ %.2126, %114 ]
  %.0 = phi ptr [ %.fca.0.extract, %3 ], [ %.2, %114 ]
  %25 = load ptr, ptr %14, align 8
  %26 = call ptr @typegetter_wrapper(ptr %25, ptr %.fca.1.extract48)
  %27 = icmp ne ptr %.0, @nil_typ
  %28 = icmp ne ptr %.0, null
  %.not132 = and i1 %27, %28
  br i1 %.not132, label %29, label %114

29:                                               ; preds = %24
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %31 = load ptr, ptr %20, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, ptr, ptr, i32 } %32(ptr %.fca.1.extract48) #31
  %.fca.0.extract113 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  store ptr %.fca.0.extract113, ptr %5, align 8
  %.fca.1.extract115 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  store ptr %.fca.1.extract115, ptr %.fca.1.gep116, align 8
  %.fca.2.extract117 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  store ptr %.fca.2.extract117, ptr %.fca.2.gep118, align 8
  %.fca.3.extract119 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  store i32 %.fca.3.extract119, ptr %.fca.3.gep120, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %34 = load ptr, ptr %5, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = load ptr, ptr %.fca.1.gep116, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 1
  %38 = load ptr, ptr %.fca.2.gep118, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 2
  %40 = load i32, ptr %.fca.3.gep120, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %34)
  %44 = sext i32 %40 to i64
  %45 = getelementptr ptr, ptr %34, i64 %44
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  %48 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr noundef nonnull align 8 %4)
  %49 = call { ptr, i160 } %48({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 %4)
  %.fca.0.extract106 = extractvalue { ptr, i160 } %49, 0
  %.fca.1.extract108 = extractvalue { ptr, i160 } %49, 1
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %51 = load ptr, ptr %21, align 8
  %52 = call ptr @typegetter_wrapper(ptr %51, ptr %.fca.1.extract48)
  %53 = icmp eq ptr %.fca.0.extract106, @nil_typ
  %54 = icmp eq ptr %.fca.0.extract106, null
  %.not134.not = or i1 %53, %54
  br i1 %.not134.not, label %55, label %114

55:                                               ; preds = %29
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %57 = load ptr, ptr %22, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, ptr, ptr, i32 } %58(ptr %.fca.1.extract48) #31
  %.fca.0.extract87 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  store ptr %.fca.0.extract87, ptr %9, align 8
  %.fca.1.extract89 = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  store ptr %.fca.1.extract89, ptr %.fca.1.gep90, align 8
  %.fca.2.extract91 = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  store ptr %.fca.2.extract91, ptr %.fca.2.gep92, align 8
  %.fca.3.extract93 = extractvalue { ptr, ptr, ptr, i32 } %59, 3
  store i32 %.fca.3.extract93, ptr %.fca.3.gep94, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %60 = load ptr, ptr %9, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %60, 0
  %62 = load ptr, ptr %.fca.1.gep90, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %62, 1
  %64 = load ptr, ptr %.fca.2.gep92, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 2
  %66 = load i32, ptr %.fca.3.gep94, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %66, 3
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %60)
  %70 = sext i32 %66 to i64
  %71 = getelementptr ptr, ptr %60, i64 %70
  %72 = getelementptr i8, ptr %71, i64 8
  %73 = load ptr, ptr %72, align 8
  %74 = call ptr @behavior_wrapper(ptr %73, { ptr, ptr, ptr, i32 } %67, ptr noundef nonnull align 8 %4)
  %75 = call { ptr, i160 } %74({ ptr, ptr, ptr, i32 } %67, { ptr, ptr, ptr, i32 } %67, ptr nonnull align 8 %4)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %77 = load ptr, ptr %15, align 8
  %78 = getelementptr i8, ptr %77, i64 8
  %79 = load ptr, ptr %78, align 8
  call void %79(ptr %.fca.1.extract48, { ptr, i160 } %75) #30
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %81 = load ptr, ptr %23, align 8
  %82 = load ptr, ptr %81, align 8
  %83 = call { ptr, ptr, ptr, i32 } %82(ptr %.fca.1.extract48) #31
  %.fca.0.extract77 = extractvalue { ptr, ptr, ptr, i32 } %83, 0
  store ptr %.fca.0.extract77, ptr %10, align 8
  %.fca.1.extract78 = extractvalue { ptr, ptr, ptr, i32 } %83, 1
  store ptr %.fca.1.extract78, ptr %.fca.1.gep, align 8
  %.fca.2.extract79 = extractvalue { ptr, ptr, ptr, i32 } %83, 2
  store ptr %.fca.2.extract79, ptr %.fca.2.gep, align 8
  %.fca.3.extract80 = extractvalue { ptr, ptr, ptr, i32 } %83, 3
  store i32 %.fca.3.extract80, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %84 = load ptr, ptr %10, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %84, 0
  %86 = load ptr, ptr %.fca.1.gep, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %85, ptr %86, 1
  %88 = load ptr, ptr %.fca.2.gep, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %88, 2
  %90 = load i32, ptr %.fca.3.gep, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, i32 %90, 3
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %84)
  %94 = sext i32 %90 to i64
  %95 = getelementptr ptr, ptr %84, i64 %94
  %96 = getelementptr i8, ptr %95, i64 8
  %97 = load ptr, ptr %96, align 8
  %98 = call ptr @behavior_wrapper(ptr %97, { ptr, ptr, ptr, i32 } %91, ptr noundef nonnull align 8 %4)
  %99 = call { ptr, ptr, ptr, i32 } %98({ ptr, ptr, ptr, i32 } %91, { ptr, ptr, ptr, i32 } %91, ptr nonnull %4)
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %99, 0
  %.fca.1.extract70 = extractvalue { ptr, ptr, ptr, i32 } %99, 1
  %.fca.2.extract71 = extractvalue { ptr, ptr, ptr, i32 } %99, 2
  %100 = call i32 @get_offset(ptr %.fca.0.extract69, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %101 = call i32 @get_offset(ptr %.fca.0.extract69, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %103 = load ptr, ptr %20, align 8
  %104 = getelementptr i8, ptr %103, i64 8
  %105 = load ptr, ptr %104, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract69, 0
  %107 = insertvalue { ptr, ptr, ptr, i32 } %106, ptr %.fca.1.extract70, 1
  %108 = insertvalue { ptr, ptr, ptr, i32 } %107, ptr %.fca.2.extract71, 2
  %109 = insertvalue { ptr, ptr, ptr, i32 } %108, i32 %101, 3
  call void %105(ptr %.fca.1.extract48, { ptr, ptr, ptr, i32 } %109) #30
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %111 = load ptr, ptr %15, align 8
  %112 = load ptr, ptr %111, align 8
  %113 = call { ptr, i160 } %112(ptr %.fca.1.extract48) #31
  %.fca.0.extract55 = extractvalue { ptr, i160 } %113, 0
  %.fca.1.extract56 = extractvalue { ptr, i160 } %113, 1
  br label %114

114:                                              ; preds = %55, %29, %24
  %.reg2mem14.0.off0 = phi i1 [ false, %29 ], [ true, %55 ], [ false, %24 ]
  %.reg2mem16.0 = phi i1 [ true, %29 ], [ false, %55 ], [ false, %24 ]
  %.sroa.0110.1 = phi ptr [ %.fca.0.extract106, %29 ], [ %.fca.0.extract106, %55 ], [ %.sroa.0110.0, %24 ]
  %.sroa.3112.1 = phi i160 [ %.fca.1.extract108, %29 ], [ %.fca.1.extract108, %55 ], [ %.sroa.3112.0, %24 ]
  %.1130 = phi ptr [ %.0, %29 ], [ %.0, %55 ], [ %.0129, %24 ]
  %.1128 = phi i160 [ %.0124, %29 ], [ %.0124, %55 ], [ %.0127, %24 ]
  %.2126 = phi i160 [ %.0124, %29 ], [ %.fca.1.extract56, %55 ], [ %.0124, %24 ]
  %.2 = phi ptr [ %.0, %29 ], [ %.fca.0.extract55, %55 ], [ %.0, %24 ]
  br i1 %.reg2mem14.0.off0, label %24, label %115

115:                                              ; preds = %114
  br i1 %.reg2mem16.0, label %116, label %150

116:                                              ; preds = %115
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %118 = load ptr, ptr %14, align 8
  %119 = call ptr @typegetter_wrapper(ptr %118, ptr %.fca.1.extract48)
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %121 = getelementptr i8, ptr %14, i64 8
  %122 = load ptr, ptr %121, align 8
  %123 = call ptr @typegetter_wrapper(ptr %122, ptr %.fca.1.extract48)
  store ptr @Pair, ptr %6, align 8
  %124 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %119, ptr %124, align 8
  %125 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %123, ptr %125, align 8
  %126 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Pair, ptr noundef nonnull align 8 dereferenceable(24) %6)
  %127 = extractvalue { i64, i64 } %126, 0
  %128 = call ptr @bump_malloc(i64 %127)
  store ptr %119, ptr %128, align 8
  %129 = getelementptr i8, ptr %128, i64 8
  store ptr %123, ptr %129, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %128)
  %131 = insertvalue { ptr, i160 } undef, ptr %.1130, 0
  %132 = insertvalue { ptr, i160 } %131, i160 %.1128, 1
  %133 = insertvalue { ptr, i160 } undef, ptr %.sroa.0110.1, 0
  %134 = insertvalue { ptr, i160 } %133, i160 %.sroa.3112.1, 1
  %135 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %128, 1
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, ptr undef, 2
  %137 = insertvalue { ptr, ptr, ptr, i32 } %136, i32 10, 3
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %139 = load ptr, ptr %14, align 8
  %140 = call ptr @typegetter_wrapper(ptr %139, ptr %.fca.1.extract48)
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract47)
  %142 = load ptr, ptr %121, align 8
  %143 = call ptr @typegetter_wrapper(ptr %142, ptr %.fca.1.extract48)
  store ptr %140, ptr %7, align 8
  %144 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %143, ptr %144, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Pair)
  store ptr %.1130, ptr %8, align 8
  %147 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.sroa.0110.1, ptr %147, align 8
  %148 = call ptr @behavior_wrapper(ptr noundef nonnull @Pair_B_init_firstT_secondU, { ptr, ptr, ptr, i32 } %137, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %148({ ptr, ptr, ptr, i32 } %137, { ptr, ptr, ptr, i32 } %137, ptr nonnull %7, { ptr, i160 } %132, { ptr, i160 } %134)
  %149 = ptrtoint ptr %128 to i64
  %.sroa.3.8.insert.ext = zext i64 %149 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %150

150:                                              ; preds = %116, %115
  %.reg2mem12.sroa.0.0 = phi ptr [ @Pair, %116 ], [ @nil_typ, %115 ]
  %.reg2mem12.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %116 ], [ undef, %115 ]
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem12.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.reg2mem12.sroa.3.0, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator_getter_current_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 8
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_current_first(ptr nocapture nofree writeonly align 8 %0, { ptr, i160 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_first_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_first_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 240
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 280
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 30, i64 29
  %8 = getelementptr [124 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 32, %21 ], [ 32, %14 ], [ 33, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 35, %21 ], [ 35, %14 ], [ 34, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ProductCollection_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 37, %21 ], [ 37, %14 ], [ 36, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ProductCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 39, %21 ], [ 39, %14 ], [ 38, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define void @ProductCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(1072) @ProductCollection)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 32
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define i32 @ProductCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(1072) @ProductCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract17)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract17, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract19) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract3, ptr %13, align 8
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep6 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract5, ptr %.fca.1.gep6, align 8
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep8 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract7, ptr %.fca.2.gep8, align 8
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep10 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract9, ptr %.fca.3.gep10, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep6, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep8, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep10, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract17)
  %31 = getelementptr i8, ptr %8, i64 32
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract19) #31
  %35 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  store ptr %.fca.0.extract, ptr %35, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %35, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %35, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %35, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %35, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %.fca.1.gep, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = load ptr, ptr %.fca.2.gep, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %40, 2
  %42 = load i32, ptr %.fca.3.gep, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %42, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %36)
  %46 = sext i32 %42 to i64
  %47 = getelementptr ptr, ptr %36, i64 %46
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @behavior_wrapper(ptr %49, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 %4)
  %51 = call i32 %50({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull %4)
  %52 = mul i32 %51, %29
  ret i32 %52
}

define { ptr, ptr, ptr, i32 } @ProductCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract103 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract105 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract103, ptr noundef nonnull align 16 dereferenceable(1072) @ProductCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract103, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract105) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract64, ptr %13, align 8
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep67 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract66, ptr %.fca.1.gep67, align 8
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep69 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract68, ptr %.fca.2.gep69, align 8
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep71 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract70, ptr %.fca.3.gep71, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep67, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep69, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep71, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract52, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %32 = getelementptr i8, ptr %8, i64 32
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract105) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract43, ptr %36, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %38 = load ptr, ptr %8, align 8
  %39 = call ptr @typegetter_wrapper(ptr %38, ptr %.fca.1.extract105)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %41 = getelementptr i8, ptr %8, i64 8
  %42 = load ptr, ptr %41, align 8
  %43 = call ptr @typegetter_wrapper(ptr %42, ptr %.fca.1.extract105)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %45 = load ptr, ptr %8, align 8
  %46 = call ptr @typegetter_wrapper(ptr %45, ptr %.fca.1.extract105)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %48 = load ptr, ptr %41, align 8
  %49 = call ptr @typegetter_wrapper(ptr %48, ptr %.fca.1.extract105)
  %50 = call ptr @bump_malloc(i64 noundef 32)
  %51 = getelementptr i8, ptr %50, i64 16
  store ptr %49, ptr %51, align 8
  %52 = getelementptr i8, ptr %50, i64 8
  store ptr %46, ptr %52, align 8
  %53 = getelementptr i8, ptr %50, i64 24
  store ptr null, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %50)
  store ptr @Pair, ptr %50, align 8
  %55 = alloca [4 x ptr], align 8
  store ptr @ProductIterator, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %55, i64 8
  store ptr %39, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %55, i64 16
  store ptr %43, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %55, i64 24
  store ptr %50, ptr %58, align 8
  %59 = load ptr, ptr getelementptr (i8, ptr @ProductIterator, i64 48), align 8
  %60 = call { i64, i64 } @size_wrapper(ptr %59, ptr noundef nonnull align 8 dereferenceable(32) %55)
  %61 = extractvalue { i64, i64 } %60, 0
  %62 = call ptr @bump_malloc(i64 %61)
  store ptr %39, ptr %62, align 8
  %63 = getelementptr i8, ptr %62, i64 8
  store ptr %43, ptr %63, align 8
  %64 = getelementptr i8, ptr %62, i64 16
  store ptr %50, ptr %64, align 8
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %62)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %67 = load ptr, ptr %9, align 8
  %68 = load ptr, ptr %67, align 8
  %69 = call { ptr, ptr, ptr, i32 } %68(ptr %.fca.1.extract105) #31
  %70 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %69, 0
  store ptr %.fca.0.extract27, ptr %70, align 8
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %69, 1
  %.fca.1.gep30 = getelementptr inbounds i8, ptr %70, i64 8
  store ptr %.fca.1.extract29, ptr %.fca.1.gep30, align 8
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %69, 2
  %.fca.2.gep32 = getelementptr inbounds i8, ptr %70, i64 16
  store ptr %.fca.2.extract31, ptr %.fca.2.gep32, align 8
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %69, 3
  %.fca.3.gep34 = getelementptr inbounds i8, ptr %70, i64 24
  store i32 %.fca.3.extract33, ptr %.fca.3.gep34, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %70, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %71 = load ptr, ptr %70, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %71, 0
  %73 = load ptr, ptr %.fca.1.gep30, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 1
  %75 = load ptr, ptr %.fca.2.gep32, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %75, 2
  %77 = load i32, ptr %.fca.3.gep34, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %77, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %71)
  %81 = sext i32 %77 to i64
  %82 = getelementptr ptr, ptr %71, i64 %81
  %83 = getelementptr i8, ptr %82, i64 24
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr @behavior_wrapper(ptr %84, { ptr, ptr, ptr, i32 } %78, ptr noundef nonnull align 8 %4)
  %86 = call { ptr, ptr, ptr, i32 } %85({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull %4)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %86, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %86, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %86, 2
  %87 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull @Iterator)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %89 = load ptr, ptr %32, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = call { ptr, ptr, ptr, i32 } %90(ptr %.fca.1.extract105) #31
  %92 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %91, 0
  store ptr %.fca.0.extract, ptr %92, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %91, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %92, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %91, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %92, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %91, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %92, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %92, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %93 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull @Iterator)
  %94 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %.fca.1.extract21, 1
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, ptr %.fca.2.extract23, 2
  %97 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %93, 3
  %98 = load ptr, ptr %92, align 8
  %99 = load ptr, ptr %.fca.1.gep, align 8
  %100 = load ptr, ptr %.fca.2.gep, align 8
  %101 = call i32 @get_offset(ptr %98, ptr noundef nonnull @Iterable)
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %98, 0
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %99, 1
  %104 = insertvalue { ptr, ptr, ptr, i32 } %103, ptr %100, 2
  %105 = insertvalue { ptr, ptr, ptr, i32 } %104, i32 %101, 3
  %106 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %62, 1
  %107 = insertvalue { ptr, ptr, ptr, i32 } %106, ptr undef, 2
  %108 = insertvalue { ptr, ptr, ptr, i32 } %107, i32 10, 3
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %110 = load ptr, ptr %8, align 8
  %111 = call ptr @typegetter_wrapper(ptr %110, ptr %.fca.1.extract105)
  %112 = call ptr @bump_malloc(i64 noundef 24)
  %113 = getelementptr i8, ptr %112, i64 8
  store ptr %111, ptr %113, align 8
  %114 = getelementptr i8, ptr %112, i64 16
  store ptr null, ptr %114, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %112)
  store ptr @Iterator, ptr %112, align 8
  %116 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract103)
  %117 = load ptr, ptr %41, align 8
  %118 = call ptr @typegetter_wrapper(ptr %117, ptr %.fca.1.extract105)
  %119 = call ptr @bump_malloc(i64 noundef 24)
  %120 = getelementptr i8, ptr %119, i64 8
  store ptr %118, ptr %120, align 8
  %121 = getelementptr i8, ptr %119, i64 16
  store ptr null, ptr %121, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %119)
  store ptr @Collection, ptr %119, align 8
  %123 = alloca [2 x ptr], align 8
  store ptr %112, ptr %123, align 8
  %124 = getelementptr inbounds i8, ptr %123, i64 8
  store ptr %119, ptr %124, align 8
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %123)
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator)
  %127 = load ptr, ptr getelementptr (i8, ptr @ProductIterator, i64 136), align 8
  %128 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract19, ptr %128, align 8
  %129 = getelementptr inbounds i8, ptr %128, i64 8
  store ptr %98, ptr %129, align 8
  %130 = call ptr @behavior_wrapper(ptr %127, { ptr, ptr, ptr, i32 } %108, ptr noundef nonnull align 8 dereferenceable(16) %128)
  call void %130({ ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %108, ptr nonnull %123, { ptr, ptr, ptr, i32 } %97, { ptr, ptr, ptr, i32 } %105)
  %131 = call i32 @get_offset(ptr noundef nonnull @ProductIterator, ptr noundef nonnull @Iterator)
  %132 = insertvalue { ptr, ptr, ptr, i32 } %107, i32 %131, 3
  ret { ptr, ptr, ptr, i32 } %132
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

define { ptr, i160 } @_box_function_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_function_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_function_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_function_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Collection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ZipIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 224
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 9197944775169318296, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 248
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZipIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ZipIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ZipIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 312
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ZipIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 320
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @ZipIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(528) @ZipIterable)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 32
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @ZipIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract129 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract131 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract129, ptr noundef nonnull align 16 dereferenceable(528) @ZipIterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract129, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract131) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract90, ptr %13, align 8
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep93 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract92, ptr %.fca.1.gep93, align 8
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep95 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract94, ptr %.fca.2.gep95, align 8
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep97 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract96, ptr %.fca.3.gep97, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep93, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep95, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep97, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract78 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract78, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %32 = getelementptr i8, ptr %8, i64 32
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract131) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract69, ptr %36, align 8
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep72 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract71, ptr %.fca.1.gep72, align 8
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep74 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract73, ptr %.fca.2.gep74, align 8
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep76 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract75, ptr %.fca.3.gep76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep72, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep74, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep76, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %4)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %53 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %55 = load ptr, ptr %8, align 8
  %56 = call ptr @typegetter_wrapper(ptr %55, ptr %.fca.1.extract131)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %58 = getelementptr i8, ptr %8, i64 8
  %59 = load ptr, ptr %58, align 8
  %60 = call ptr @typegetter_wrapper(ptr %59, ptr %.fca.1.extract131)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %62 = load ptr, ptr %8, align 8
  %63 = call ptr @typegetter_wrapper(ptr %62, ptr %.fca.1.extract131)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %65 = load ptr, ptr %58, align 8
  %66 = call ptr @typegetter_wrapper(ptr %65, ptr %.fca.1.extract131)
  %67 = call ptr @bump_malloc(i64 noundef 32)
  %68 = getelementptr i8, ptr %67, i64 16
  store ptr %66, ptr %68, align 8
  %69 = getelementptr i8, ptr %67, i64 8
  store ptr %63, ptr %69, align 8
  %70 = getelementptr i8, ptr %67, i64 24
  store ptr null, ptr %70, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %67)
  store ptr @Pair, ptr %67, align 8
  %72 = alloca [4 x ptr], align 8
  store ptr @ZipIterator, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %72, i64 8
  store ptr %56, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %72, i64 16
  store ptr %60, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %72, i64 24
  store ptr %67, ptr %75, align 8
  %76 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ZipIterator, ptr noundef nonnull align 8 dereferenceable(32) %72)
  %77 = extractvalue { i64, i64 } %76, 0
  %78 = call ptr @bump_malloc(i64 %77)
  store ptr %56, ptr %78, align 8
  %79 = getelementptr i8, ptr %78, i64 8
  store ptr %60, ptr %79, align 8
  %80 = getelementptr i8, ptr %78, i64 16
  store ptr %67, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %78)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %83 = load ptr, ptr %9, align 8
  %84 = load ptr, ptr %83, align 8
  %85 = call { ptr, ptr, ptr, i32 } %84(ptr %.fca.1.extract131) #31
  %86 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  store ptr %.fca.0.extract40, ptr %86, align 8
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.1.gep43 = getelementptr inbounds i8, ptr %86, i64 8
  store ptr %.fca.1.extract42, ptr %.fca.1.gep43, align 8
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %.fca.2.gep45 = getelementptr inbounds i8, ptr %86, i64 16
  store ptr %.fca.2.extract44, ptr %.fca.2.gep45, align 8
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %85, 3
  %.fca.3.gep47 = getelementptr inbounds i8, ptr %86, i64 24
  store i32 %.fca.3.extract46, ptr %.fca.3.gep47, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %86, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %87 = load ptr, ptr %86, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %87, 0
  %89 = load ptr, ptr %.fca.1.gep43, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, ptr %89, 1
  %91 = load ptr, ptr %.fca.2.gep45, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %91, 2
  %93 = load i32, ptr %.fca.3.gep47, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, i32 %93, 3
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %87)
  %97 = sext i32 %93 to i64
  %98 = getelementptr ptr, ptr %87, i64 %97
  %99 = getelementptr i8, ptr %98, i64 8
  %100 = load ptr, ptr %99, align 8
  %101 = call ptr @behavior_wrapper(ptr %100, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 %4)
  %102 = call { ptr, ptr, ptr, i32 } %101({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %102, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %102, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %102, 2
  %103 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %105 = load ptr, ptr %32, align 8
  %106 = load ptr, ptr %105, align 8
  %107 = call { ptr, ptr, ptr, i32 } %106(ptr %.fca.1.extract131) #31
  %108 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %107, 0
  store ptr %.fca.0.extract19, ptr %108, align 8
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %107, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %108, i64 8
  store ptr %.fca.1.extract20, ptr %.fca.1.gep, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %107, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %108, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep, align 8
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %107, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %108, i64 24
  store i32 %.fca.3.extract22, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %108, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %109 = load ptr, ptr %108, align 8
  %110 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %109, 0
  %111 = load ptr, ptr %.fca.1.gep, align 8
  %112 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %111, 1
  %113 = load ptr, ptr %.fca.2.gep, align 8
  %114 = insertvalue { ptr, ptr, ptr, i32 } %112, ptr %113, 2
  %115 = load i32, ptr %.fca.3.gep, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %114, i32 %115, 3
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %109)
  %119 = sext i32 %115 to i64
  %120 = getelementptr ptr, ptr %109, i64 %119
  %121 = getelementptr i8, ptr %120, i64 8
  %122 = load ptr, ptr %121, align 8
  %123 = call ptr @behavior_wrapper(ptr %122, { ptr, ptr, ptr, i32 } %116, ptr noundef nonnull align 8 %4)
  %124 = call { ptr, ptr, ptr, i32 } %123({ ptr, ptr, ptr, i32 } %116, { ptr, ptr, ptr, i32 } %116, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %124, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %124, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %124, 2
  %125 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %126 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %127 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, ptr %.fca.1.extract30, 1
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %.fca.2.extract32, 2
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 %126, 3
  %131 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %132 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %133 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %.fca.1.extract, 1
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %.fca.2.extract, 2
  %135 = insertvalue { ptr, ptr, ptr, i32 } %134, i32 %131, 3
  %136 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %78, 1
  %137 = insertvalue { ptr, ptr, ptr, i32 } %136, ptr undef, 2
  %138 = insertvalue { ptr, ptr, ptr, i32 } %137, i32 10, 3
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %140 = load ptr, ptr %8, align 8
  %141 = call ptr @typegetter_wrapper(ptr %140, ptr %.fca.1.extract131)
  %142 = call ptr @bump_malloc(i64 noundef 24)
  %143 = getelementptr i8, ptr %142, i64 8
  store ptr %141, ptr %143, align 8
  %144 = getelementptr i8, ptr %142, i64 16
  store ptr null, ptr %144, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %142)
  store ptr @Iterator, ptr %142, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %.fca.0.extract129)
  %147 = load ptr, ptr %58, align 8
  %148 = call ptr @typegetter_wrapper(ptr %147, ptr %.fca.1.extract131)
  %149 = call ptr @bump_malloc(i64 noundef 24)
  %150 = getelementptr i8, ptr %149, i64 8
  store ptr %148, ptr %150, align 8
  %151 = getelementptr i8, ptr %149, i64 16
  store ptr null, ptr %151, align 8
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %149)
  store ptr @Iterator, ptr %149, align 8
  %153 = alloca [2 x ptr], align 8
  store ptr %142, ptr %153, align 8
  %154 = getelementptr inbounds i8, ptr %153, i64 8
  store ptr %149, ptr %154, align 8
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %153)
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator)
  %157 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract28, ptr %157, align 8
  %158 = getelementptr inbounds i8, ptr %157, i64 8
  store ptr %.fca.0.extract, ptr %158, align 8
  %159 = call ptr @behavior_wrapper(ptr noundef nonnull @ZipIterator_B_init_firstIteratorT_secondIteratorU, { ptr, ptr, ptr, i32 } %138, ptr noundef nonnull align 8 dereferenceable(16) %157)
  call void %159({ ptr, ptr, ptr, i32 } %138, { ptr, ptr, ptr, i32 } %138, ptr nonnull %153, { ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %135)
  %160 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(176) @ZipIterator, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %161 = insertvalue { ptr, ptr, ptr, i32 } %137, i32 %160, 3
  ret { ptr, ptr, ptr, i32 } %161
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 136
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ZipIterator_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(176) @ZipIterator)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 32
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define { ptr, i160 } @ZipIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %8 = call i32 @get_offset(ptr %.fca.0.extract46, ptr noundef nonnull align 16 dereferenceable(176) @ZipIterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract46)
  %10 = sext i32 %8 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract46, i64 %10
  %12 = getelementptr i8, ptr %11, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call { ptr, ptr, ptr, i32 } %14(ptr %.fca.1.extract48) #31
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  store ptr %.fca.0.extract12, ptr %16, align 8
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.1.gep15 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %.fca.1.extract14, ptr %.fca.1.gep15, align 8
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %.fca.2.gep17 = getelementptr inbounds i8, ptr %16, i64 16
  store ptr %.fca.2.extract16, ptr %.fca.2.gep17, align 8
  %.fca.3.extract18 = extractvalue { ptr, ptr, ptr, i32 } %15, 3
  %.fca.3.gep19 = getelementptr inbounds i8, ptr %16, i64 24
  store i32 %.fca.3.extract18, ptr %.fca.3.gep19, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %16, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %17 = load ptr, ptr %16, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %17, 0
  %19 = load ptr, ptr %.fca.1.gep15, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %19, 1
  %21 = load ptr, ptr %.fca.2.gep17, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 2
  %23 = load i32, ptr %.fca.3.gep19, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %23, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %17)
  %27 = sext i32 %23 to i64
  %28 = getelementptr ptr, ptr %17, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %24, ptr noundef nonnull align 8 %4)
  %32 = call { ptr, i160 } %31({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %4)
  %.fca.0.extract5 = extractvalue { ptr, i160 } %32, 0
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract46)
  %34 = getelementptr i8, ptr %11, i64 32
  %35 = load ptr, ptr %34, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call { ptr, ptr, ptr, i32 } %36(ptr %.fca.1.extract48) #31
  %38 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %37, 0
  store ptr %.fca.0.extract3, ptr %38, align 8
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %37, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %38, i64 8
  store ptr %.fca.1.extract4, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %37, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %38, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %37, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %38, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %38, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %39 = load ptr, ptr %38, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %39, 0
  %41 = load ptr, ptr %.fca.1.gep, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 1
  %43 = load ptr, ptr %.fca.2.gep, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %43, 2
  %45 = load i32, ptr %.fca.3.gep, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %45, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %39)
  %49 = sext i32 %45 to i64
  %50 = getelementptr ptr, ptr %39, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %53 = call ptr @behavior_wrapper(ptr %52, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 %4)
  %54 = call { ptr, i160 } %53({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %54, 0
  %55 = icmp eq ptr %.fca.0.extract5, @nil_typ
  %56 = icmp eq ptr %.fca.0.extract5, null
  %57 = or i1 %55, %56
  br i1 %57, label %.critedge, label %58

58:                                               ; preds = %3
  %59 = icmp eq ptr %.fca.0.extract, @nil_typ
  %60 = icmp eq ptr %.fca.0.extract, null
  %61 = or i1 %59, %60
  br i1 %61, label %.critedge, label %62

62:                                               ; preds = %58
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract46)
  %64 = load ptr, ptr %11, align 8
  %65 = call ptr @typegetter_wrapper(ptr %64, ptr %.fca.1.extract48)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract46)
  %67 = getelementptr i8, ptr %11, i64 8
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %.fca.1.extract48)
  store ptr @Pair, ptr %5, align 8
  %70 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %65, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %69, ptr %71, align 8
  %72 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Pair, ptr noundef nonnull align 8 dereferenceable(24) %5)
  %73 = extractvalue { i64, i64 } %72, 0
  %74 = call ptr @bump_malloc(i64 %73)
  store ptr %65, ptr %74, align 8
  %75 = getelementptr i8, ptr %74, i64 8
  store ptr %69, ptr %75, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %74)
  %77 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %74, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr undef, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 10, 3
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract46)
  %81 = load ptr, ptr %11, align 8
  %82 = call ptr @typegetter_wrapper(ptr %81, ptr %.fca.1.extract48)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract46)
  %84 = load ptr, ptr %67, align 8
  %85 = call ptr @typegetter_wrapper(ptr %84, ptr %.fca.1.extract48)
  store ptr %82, ptr %6, align 8
  %86 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %85, ptr %86, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Pair)
  store ptr %.fca.0.extract5, ptr %7, align 8
  %89 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.0.extract, ptr %89, align 8
  %90 = call ptr @behavior_wrapper(ptr noundef nonnull @Pair_B_init_firstT_secondU, { ptr, ptr, ptr, i32 } %79, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %90({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %6, { ptr, i160 } %32, { ptr, i160 } %54)
  %91 = ptrtoint ptr %74 to i64
  %.sroa.361.8.insert.ext = zext i64 %91 to i160
  %.sroa.361.8.insert.insert = or disjoint i160 %.sroa.361.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.critedge

.critedge:                                        ; preds = %62, %58, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @Pair, %62 ], [ @nil_typ, %58 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.361.8.insert.insert, %62 ], [ undef, %58 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZippedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 240
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 280
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 30, i64 29
  %8 = getelementptr [124 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 32, %21 ], [ 32, %14 ], [ 33, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 35, %21 ], [ 35, %14 ], [ 34, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ZippedCollection_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 37, %21 ], [ 37, %14 ], [ 36, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ZippedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 39, %21 ], [ 39, %14 ], [ 38, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [124 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define void @ZippedCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(1072) @ZippedCollection)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 32
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define i32 @ZippedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract20, ptr noundef nonnull align 16 dereferenceable(1072) @ZippedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract20)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract20, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract22) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract5, ptr %13, align 8
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep8 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract7, ptr %.fca.1.gep8, align 8
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep10 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract9, ptr %.fca.2.gep10, align 8
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep12 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract11, ptr %.fca.3.gep12, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep8, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep10, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep12, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract20)
  %31 = getelementptr i8, ptr %8, i64 32
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract22) #31
  %35 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  store ptr %.fca.0.extract, ptr %35, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %35, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %35, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %35, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %35, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %.fca.1.gep, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = load ptr, ptr %.fca.2.gep, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %40, 2
  %42 = load i32, ptr %.fca.3.gep, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %42, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %36)
  %46 = sext i32 %42 to i64
  %47 = getelementptr ptr, ptr %36, i64 %46
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @behavior_wrapper(ptr %49, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 %4)
  %51 = call i32 %50({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull %4)
  %.sroa.speculated = call i32 @llvm.smin.i32(i32 %29, i32 %51)
  ret i32 %.sroa.speculated
}

define { ptr, ptr, ptr, i32 } @ZippedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract129 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract131 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract129, ptr noundef nonnull align 16 dereferenceable(1072) @ZippedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract129, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract131) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract90, ptr %13, align 8
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep93 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract92, ptr %.fca.1.gep93, align 8
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep95 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract94, ptr %.fca.2.gep95, align 8
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep97 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract96, ptr %.fca.3.gep97, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep93, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep95, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep97, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract78 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract78, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %32 = getelementptr i8, ptr %8, i64 32
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract131) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract69, ptr %36, align 8
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep72 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract71, ptr %.fca.1.gep72, align 8
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep74 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract73, ptr %.fca.2.gep74, align 8
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep76 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract75, ptr %.fca.3.gep76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep72, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep74, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep76, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 24
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %4)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %53 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull @Iterator)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %55 = load ptr, ptr %8, align 8
  %56 = call ptr @typegetter_wrapper(ptr %55, ptr %.fca.1.extract131)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %58 = getelementptr i8, ptr %8, i64 8
  %59 = load ptr, ptr %58, align 8
  %60 = call ptr @typegetter_wrapper(ptr %59, ptr %.fca.1.extract131)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %62 = load ptr, ptr %8, align 8
  %63 = call ptr @typegetter_wrapper(ptr %62, ptr %.fca.1.extract131)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %65 = load ptr, ptr %58, align 8
  %66 = call ptr @typegetter_wrapper(ptr %65, ptr %.fca.1.extract131)
  %67 = call ptr @bump_malloc(i64 noundef 32)
  %68 = getelementptr i8, ptr %67, i64 16
  store ptr %66, ptr %68, align 8
  %69 = getelementptr i8, ptr %67, i64 8
  store ptr %63, ptr %69, align 8
  %70 = getelementptr i8, ptr %67, i64 24
  store ptr null, ptr %70, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %67)
  store ptr @Pair, ptr %67, align 8
  %72 = alloca [4 x ptr], align 8
  store ptr @ZipIterator, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %72, i64 8
  store ptr %56, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %72, i64 16
  store ptr %60, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %72, i64 24
  store ptr %67, ptr %75, align 8
  %76 = load ptr, ptr getelementptr (i8, ptr @ZipIterator, i64 48), align 8
  %77 = call { i64, i64 } @size_wrapper(ptr %76, ptr noundef nonnull align 8 dereferenceable(32) %72)
  %78 = extractvalue { i64, i64 } %77, 0
  %79 = call ptr @bump_malloc(i64 %78)
  store ptr %56, ptr %79, align 8
  %80 = getelementptr i8, ptr %79, i64 8
  store ptr %60, ptr %80, align 8
  %81 = getelementptr i8, ptr %79, i64 16
  store ptr %67, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %79)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %84 = load ptr, ptr %9, align 8
  %85 = load ptr, ptr %84, align 8
  %86 = call { ptr, ptr, ptr, i32 } %85(ptr %.fca.1.extract131) #31
  %87 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %86, 0
  store ptr %.fca.0.extract40, ptr %87, align 8
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %86, 1
  %.fca.1.gep43 = getelementptr inbounds i8, ptr %87, i64 8
  store ptr %.fca.1.extract42, ptr %.fca.1.gep43, align 8
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %86, 2
  %.fca.2.gep45 = getelementptr inbounds i8, ptr %87, i64 16
  store ptr %.fca.2.extract44, ptr %.fca.2.gep45, align 8
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %86, 3
  %.fca.3.gep47 = getelementptr inbounds i8, ptr %87, i64 24
  store i32 %.fca.3.extract46, ptr %.fca.3.gep47, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %87, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %88 = load ptr, ptr %87, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %88, 0
  %90 = load ptr, ptr %.fca.1.gep43, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, ptr %90, 1
  %92 = load ptr, ptr %.fca.2.gep45, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %92, 2
  %94 = load i32, ptr %.fca.3.gep47, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 %94, 3
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %88)
  %98 = sext i32 %94 to i64
  %99 = getelementptr ptr, ptr %88, i64 %98
  %100 = getelementptr i8, ptr %99, i64 24
  %101 = load ptr, ptr %100, align 8
  %102 = call ptr @behavior_wrapper(ptr %101, { ptr, ptr, ptr, i32 } %95, ptr noundef nonnull align 8 %4)
  %103 = call { ptr, ptr, ptr, i32 } %102({ ptr, ptr, ptr, i32 } %95, { ptr, ptr, ptr, i32 } %95, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %103, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %103, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %103, 2
  %104 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull @Iterator)
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %106 = load ptr, ptr %32, align 8
  %107 = load ptr, ptr %106, align 8
  %108 = call { ptr, ptr, ptr, i32 } %107(ptr %.fca.1.extract131) #31
  %109 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %108, 0
  store ptr %.fca.0.extract19, ptr %109, align 8
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %108, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %109, i64 8
  store ptr %.fca.1.extract20, ptr %.fca.1.gep, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %108, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %109, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep, align 8
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %108, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %109, i64 24
  store i32 %.fca.3.extract22, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %109, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %110 = load ptr, ptr %109, align 8
  %111 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %110, 0
  %112 = load ptr, ptr %.fca.1.gep, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } %111, ptr %112, 1
  %114 = load ptr, ptr %.fca.2.gep, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %114, 2
  %116 = load i32, ptr %.fca.3.gep, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 %116, 3
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %110)
  %120 = sext i32 %116 to i64
  %121 = getelementptr ptr, ptr %110, i64 %120
  %122 = getelementptr i8, ptr %121, i64 24
  %123 = load ptr, ptr %122, align 8
  %124 = call ptr @behavior_wrapper(ptr %123, { ptr, ptr, ptr, i32 } %117, ptr noundef nonnull align 8 %4)
  %125 = call { ptr, ptr, ptr, i32 } %124({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %125, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %125, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %125, 2
  %126 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %127 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull @Iterator)
  %128 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %.fca.1.extract30, 1
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, ptr %.fca.2.extract32, 2
  %131 = insertvalue { ptr, ptr, ptr, i32 } %130, i32 %127, 3
  %132 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %.fca.1.extract, 1
  %135 = insertvalue { ptr, ptr, ptr, i32 } %134, ptr %.fca.2.extract, 2
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, i32 %132, 3
  %137 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %79, 1
  %138 = insertvalue { ptr, ptr, ptr, i32 } %137, ptr undef, 2
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, i32 10, 3
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %141 = load ptr, ptr %8, align 8
  %142 = call ptr @typegetter_wrapper(ptr %141, ptr %.fca.1.extract131)
  %143 = call ptr @bump_malloc(i64 noundef 24)
  %144 = getelementptr i8, ptr %143, i64 8
  store ptr %142, ptr %144, align 8
  %145 = getelementptr i8, ptr %143, i64 16
  store ptr null, ptr %145, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %143)
  store ptr @Iterator, ptr %143, align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 992, ptr nocapture nofree noundef %.fca.0.extract129)
  %148 = load ptr, ptr %58, align 8
  %149 = call ptr @typegetter_wrapper(ptr %148, ptr %.fca.1.extract131)
  %150 = call ptr @bump_malloc(i64 noundef 24)
  %151 = getelementptr i8, ptr %150, i64 8
  store ptr %149, ptr %151, align 8
  %152 = getelementptr i8, ptr %150, i64 16
  store ptr null, ptr %152, align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %150)
  store ptr @Iterator, ptr %150, align 8
  %154 = alloca [2 x ptr], align 8
  store ptr %143, ptr %154, align 8
  %155 = getelementptr inbounds i8, ptr %154, i64 8
  store ptr %150, ptr %155, align 8
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %154)
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull @ZipIterator)
  %158 = load ptr, ptr getelementptr (i8, ptr @ZipIterator, i64 120), align 8
  %159 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract28, ptr %159, align 8
  %160 = getelementptr inbounds i8, ptr %159, i64 8
  store ptr %.fca.0.extract, ptr %160, align 8
  %161 = call ptr @behavior_wrapper(ptr %158, { ptr, ptr, ptr, i32 } %139, ptr noundef nonnull align 8 dereferenceable(16) %159)
  call void %161({ ptr, ptr, ptr, i32 } %139, { ptr, ptr, ptr, i32 } %139, ptr nonnull %154, { ptr, ptr, ptr, i32 } %131, { ptr, ptr, ptr, i32 } %136)
  %162 = call i32 @get_offset(ptr noundef nonnull @ZipIterator, ptr noundef nonnull @Iterator)
  %163 = insertvalue { ptr, ptr, ptr, i32 } %138, i32 %162, 3
  ret { ptr, ptr, ptr, i32 } %163
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #5

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 208
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable_field_InterleaveIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 232
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleaveIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @InterleaveIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @InterleaveIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @InterleaveIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @InterleaveIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(512) @InterleaveIterable)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @InterleaveIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract120, ptr noundef nonnull align 16 dereferenceable(512) @InterleaveIterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract120, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract122) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract90, ptr %13, align 8
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep93 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract92, ptr %.fca.1.gep93, align 8
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep95 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract94, ptr %.fca.2.gep95, align 8
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep97 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract96, ptr %.fca.3.gep97, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep93, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep95, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep97, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract78 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract78, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %32 = getelementptr i8, ptr %8, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract122) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract69, ptr %36, align 8
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep72 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract71, ptr %.fca.1.gep72, align 8
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep74 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract73, ptr %.fca.2.gep74, align 8
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep76 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract75, ptr %.fca.3.gep76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep72, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep74, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep76, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %4)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %53 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %55 = load ptr, ptr %8, align 8
  %56 = call ptr @typegetter_wrapper(ptr %55, ptr %.fca.1.extract122)
  %57 = alloca [2 x ptr], align 8
  store ptr @InterleaveIterator, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %57, i64 8
  store ptr %56, ptr %58, align 8
  %59 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_InterleaveIterator, ptr noundef nonnull align 8 dereferenceable(16) %57)
  %60 = extractvalue { i64, i64 } %59, 0
  %61 = call ptr @bump_malloc(i64 %60)
  store ptr %56, ptr %61, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %64, align 8
  %66 = call { ptr, ptr, ptr, i32 } %65(ptr %.fca.1.extract122) #31
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  store ptr %.fca.0.extract40, ptr %67, align 8
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.1.gep43 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract42, ptr %.fca.1.gep43, align 8
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.2.gep45 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract44, ptr %.fca.2.gep45, align 8
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %.fca.3.gep47 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract46, ptr %.fca.3.gep47, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %68 = load ptr, ptr %67, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %68, 0
  %70 = load ptr, ptr %.fca.1.gep43, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %70, 1
  %72 = load ptr, ptr %.fca.2.gep45, align 8
  %73 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %72, 2
  %74 = load i32, ptr %.fca.3.gep47, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 %74, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %68)
  %78 = sext i32 %74 to i64
  %79 = getelementptr ptr, ptr %68, i64 %78
  %80 = getelementptr i8, ptr %79, i64 8
  %81 = load ptr, ptr %80, align 8
  %82 = call ptr @behavior_wrapper(ptr %81, { ptr, ptr, ptr, i32 } %75, ptr noundef nonnull align 8 %4)
  %83 = call { ptr, ptr, ptr, i32 } %82({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %83, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %83, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %83, 2
  %84 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %86 = load ptr, ptr %32, align 8
  %87 = load ptr, ptr %86, align 8
  %88 = call { ptr, ptr, ptr, i32 } %87(ptr %.fca.1.extract122) #31
  %89 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %88, 0
  store ptr %.fca.0.extract19, ptr %89, align 8
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %88, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %89, i64 8
  store ptr %.fca.1.extract20, ptr %.fca.1.gep, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %88, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %89, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep, align 8
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %88, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %89, i64 24
  store i32 %.fca.3.extract22, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %89, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %90 = load ptr, ptr %89, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %90, 0
  %92 = load ptr, ptr %.fca.1.gep, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %92, 1
  %94 = load ptr, ptr %.fca.2.gep, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %94, 2
  %96 = load i32, ptr %.fca.3.gep, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %96, 3
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %90)
  %100 = sext i32 %96 to i64
  %101 = getelementptr ptr, ptr %90, i64 %100
  %102 = getelementptr i8, ptr %101, i64 8
  %103 = load ptr, ptr %102, align 8
  %104 = call ptr @behavior_wrapper(ptr %103, { ptr, ptr, ptr, i32 } %97, ptr noundef nonnull align 8 %4)
  %105 = call { ptr, ptr, ptr, i32 } %104({ ptr, ptr, ptr, i32 } %97, { ptr, ptr, ptr, i32 } %97, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %105, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %105, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %105, 2
  %106 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %107 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %108 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %109 = insertvalue { ptr, ptr, ptr, i32 } %108, ptr %.fca.1.extract30, 1
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %.fca.2.extract32, 2
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, i32 %107, 3
  %112 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %113 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %114 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %.fca.1.extract, 1
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %.fca.2.extract, 2
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 %112, 3
  %117 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %61, 1
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr undef, 2
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 10, 3
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %121 = load ptr, ptr %8, align 8
  %122 = call ptr @typegetter_wrapper(ptr %121, ptr %.fca.1.extract122)
  %123 = call ptr @bump_malloc(i64 noundef 24)
  %124 = getelementptr i8, ptr %123, i64 8
  store ptr %122, ptr %124, align 8
  %125 = getelementptr i8, ptr %123, i64 16
  store ptr null, ptr %125, align 8
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %123)
  store ptr @Iterator, ptr %123, align 8
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %128 = load ptr, ptr %8, align 8
  %129 = call ptr @typegetter_wrapper(ptr %128, ptr %.fca.1.extract122)
  %130 = call ptr @bump_malloc(i64 noundef 24)
  %131 = getelementptr i8, ptr %130, i64 8
  store ptr %129, ptr %131, align 8
  %132 = getelementptr i8, ptr %130, i64 16
  store ptr null, ptr %132, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %130)
  store ptr @Iterator, ptr %130, align 8
  %134 = alloca [2 x ptr], align 8
  store ptr %123, ptr %134, align 8
  %135 = getelementptr inbounds i8, ptr %134, i64 8
  store ptr %130, ptr %135, align 8
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %134)
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator)
  %138 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract28, ptr %138, align 8
  %139 = getelementptr inbounds i8, ptr %138, i64 8
  store ptr %.fca.0.extract, ptr %139, align 8
  %140 = call ptr @behavior_wrapper(ptr noundef nonnull @InterleaveIterator_B_init_firstIteratorT_secondIteratorT, { ptr, ptr, ptr, i32 } %119, ptr noundef nonnull align 8 dereferenceable(16) %138)
  call void %140({ ptr, ptr, ptr, i32 } %119, { ptr, ptr, ptr, i32 } %119, ptr nonnull %134, { ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %116)
  %141 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(168) @InterleaveIterator, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %142 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 %141, 3
  ret { ptr, ptr, ptr, i32 } %142
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

define ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 128
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator_field_InterleaveIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @InterleaveIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract38, ptr noundef nonnull align 16 dereferenceable(168) @InterleaveIterator)
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract20, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %8 = call i32 @get_offset(ptr %.fca.0.extract20, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract38)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract38, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract21, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract22, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract38)
  %23 = getelementptr i8, ptr %11, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %30) #30
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract38)
  %32 = getelementptr i8, ptr %11, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  call void %35(ptr %.fca.1.extract39, i1 true) #30
  ret void
}

define { ptr, i160 } @InterleaveIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %9 = call i32 @get_offset(ptr %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(168) @InterleaveIterator)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract32)
  %11 = sext i32 %9 to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract32, i64 %11
  %13 = getelementptr i8, ptr %12, i64 24
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i1 %15(ptr %.fca.1.extract33) #31
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract32)
  %18 = getelementptr i8, ptr %14, i64 8
  %19 = load ptr, ptr %18, align 8
  br i1 %16, label %20, label %47

20:                                               ; preds = %3
  %.sink140.sroa.gep151 = getelementptr inbounds i8, ptr %6, i64 24
  %.sink140.sroa.gep148 = getelementptr inbounds i8, ptr %6, i64 16
  %.sink140.sroa.gep = getelementptr inbounds i8, ptr %6, i64 8
  call void %19(ptr %.fca.1.extract33, i1 false) #30
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract32)
  %22 = getelementptr i8, ptr %12, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call { ptr, ptr, ptr, i32 } %24(ptr %.fca.1.extract33) #31
  %.fca.0.extract101 = extractvalue { ptr, ptr, ptr, i32 } %25, 0
  store ptr %.fca.0.extract101, ptr %5, align 8
  %.fca.1.extract103 = extractvalue { ptr, ptr, ptr, i32 } %25, 1
  %.fca.1.gep104 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract103, ptr %.fca.1.gep104, align 8
  %.fca.2.extract105 = extractvalue { ptr, ptr, ptr, i32 } %25, 2
  %.fca.2.gep106 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract105, ptr %.fca.2.gep106, align 8
  %.fca.3.extract107 = extractvalue { ptr, ptr, ptr, i32 } %25, 3
  %.fca.3.gep108 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract107, ptr %.fca.3.gep108, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %26 = load ptr, ptr %5, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %26, 0
  %28 = load ptr, ptr %.fca.1.gep104, align 8
  %29 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %28, 1
  %30 = load ptr, ptr %.fca.2.gep106, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %30, 2
  %32 = load i32, ptr %.fca.3.gep108, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %32, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %26)
  %36 = sext i32 %32 to i64
  %37 = getelementptr ptr, ptr %26, i64 %36
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 %4)
  %41 = call { ptr, i160 } %40({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull align 8 %4)
  %.fca.0.extract95 = extractvalue { ptr, i160 } %41, 0
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract32)
  %43 = load ptr, ptr %12, align 8
  %44 = call ptr @typegetter_wrapper(ptr %43, ptr %.fca.1.extract33)
  %45 = icmp eq ptr %.fca.0.extract95, @nil_typ
  %46 = icmp eq ptr %.fca.0.extract95, null
  %.not114.not = or i1 %45, %46
  br i1 %.not114.not, label %.sink.split, label %95

47:                                               ; preds = %3
  %.sink140.sroa.gep152 = getelementptr inbounds i8, ptr %8, i64 24
  %.sink140.sroa.gep149 = getelementptr inbounds i8, ptr %8, i64 16
  %.sink140.sroa.gep146 = getelementptr inbounds i8, ptr %8, i64 8
  call void %19(ptr %.fca.1.extract33, i1 true) #30
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract32)
  %49 = getelementptr i8, ptr %12, i64 16
  %50 = load ptr, ptr %49, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = call { ptr, ptr, ptr, i32 } %51(ptr %.fca.1.extract33) #31
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  store ptr %.fca.0.extract69, ptr %7, align 8
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %52, 1
  %.fca.1.gep72 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract71, ptr %.fca.1.gep72, align 8
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %52, 2
  %.fca.2.gep74 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract73, ptr %.fca.2.gep74, align 8
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %52, 3
  %.fca.3.gep76 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract75, ptr %.fca.3.gep76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %53 = load ptr, ptr %7, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %53, 0
  %55 = load ptr, ptr %.fca.1.gep72, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 1
  %57 = load ptr, ptr %.fca.2.gep74, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 2
  %59 = load i32, ptr %.fca.3.gep76, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %59, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %53)
  %63 = sext i32 %59 to i64
  %64 = getelementptr ptr, ptr %53, i64 %63
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %67 = call ptr @behavior_wrapper(ptr %66, { ptr, ptr, ptr, i32 } %60, ptr noundef nonnull align 8 %4)
  %68 = call { ptr, i160 } %67({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %4)
  %.fca.0.extract54 = extractvalue { ptr, i160 } %68, 0
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract32)
  %70 = load ptr, ptr %12, align 8
  %71 = call ptr @typegetter_wrapper(ptr %70, ptr %.fca.1.extract33)
  %72 = icmp eq ptr %.fca.0.extract54, @nil_typ
  %73 = icmp eq ptr %.fca.0.extract54, null
  %.not111.not = or i1 %72, %73
  br i1 %.not111.not, label %.sink.split, label %95

.sink.split:                                      ; preds = %47, %20
  %.sink145 = phi i64 [ 16, %20 ], [ 8, %47 ]
  %.sink140.sroa.phi = phi ptr [ %.sink140.sroa.gep, %20 ], [ %.sink140.sroa.gep146, %47 ]
  %.sink140.sroa.phi147 = phi ptr [ %.sink140.sroa.gep148, %20 ], [ %.sink140.sroa.gep149, %47 ]
  %.sink140.sroa.phi150 = phi ptr [ %.sink140.sroa.gep151, %20 ], [ %.sink140.sroa.gep152, %47 ]
  %.sink140 = phi ptr [ %6, %20 ], [ %8, %47 ]
  %.pn.ph = phi { ptr, i160 } [ %41, %20 ], [ %68, %47 ]
  %.sroa.speculated68.ph = phi ptr [ %.fca.0.extract95, %20 ], [ %.fca.0.extract54, %47 ]
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract32)
  %75 = getelementptr i8, ptr %12, i64 %.sink145
  %76 = load ptr, ptr %75, align 8
  %77 = load ptr, ptr %76, align 8
  %78 = call { ptr, ptr, ptr, i32 } %77(ptr %.fca.1.extract33) #31
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %78, 0
  store ptr %.fca.0.extract38, ptr %.sink140, align 8
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %78, 1
  store ptr %.fca.1.extract39, ptr %.sink140.sroa.phi, align 8
  %.fca.2.extract40 = extractvalue { ptr, ptr, ptr, i32 } %78, 2
  store ptr %.fca.2.extract40, ptr %.sink140.sroa.phi147, align 8
  %.fca.3.extract41 = extractvalue { ptr, ptr, ptr, i32 } %78, 3
  store i32 %.fca.3.extract41, ptr %.sink140.sroa.phi150, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %.sink140, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %79 = load ptr, ptr %.sink140, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %79, 0
  %81 = load ptr, ptr %.sink140.sroa.phi, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 1
  %83 = load ptr, ptr %.sink140.sroa.phi147, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %83, 2
  %85 = load i32, ptr %.sink140.sroa.phi150, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %85, 3
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %79)
  %89 = sext i32 %85 to i64
  %90 = getelementptr ptr, ptr %79, i64 %89
  %91 = getelementptr i8, ptr %90, i64 8
  %92 = load ptr, ptr %91, align 8
  %93 = call ptr @behavior_wrapper(ptr %92, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 %4)
  %94 = call { ptr, i160 } %93({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %4)
  %.fca.0.extract34 = extractvalue { ptr, i160 } %94, 0
  %.fca.1.extract35 = extractvalue { ptr, i160 } %94, 1
  br label %95

95:                                               ; preds = %.sink.split, %47, %20
  %.pn = phi { ptr, i160 } [ %41, %20 ], [ %68, %47 ], [ %.pn.ph, %.sink.split ]
  %.sroa.speculated68 = phi ptr [ %.fca.0.extract95, %20 ], [ %.fca.0.extract54, %47 ], [ %.sroa.speculated68.ph, %.sink.split ]
  %.reg2mem23.0.in = phi i1 [ false, %20 ], [ false, %47 ], [ true, %.sink.split ]
  %.reg2mem25.sroa.3.0 = phi i160 [ poison, %20 ], [ poison, %47 ], [ %.fca.1.extract35, %.sink.split ]
  %.reg2mem25.sroa.0.0 = phi ptr [ poison, %20 ], [ poison, %47 ], [ %.fca.0.extract34, %.sink.split ]
  %.sroa.3100.0..sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reg2mem21.sroa.3.0 = select i1 %.reg2mem23.0.in, i160 %.reg2mem25.sroa.3.0, i160 %.sroa.3100.0..sroa.3.0
  %.reg2mem21.sroa.0.0 = select i1 %.reg2mem23.0.in, ptr %.reg2mem25.sroa.0.0, ptr %.sroa.speculated68
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem21.sroa.0.0, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %.reg2mem21.sroa.3.0, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator_getter_on_first(ptr nocapture nofree readonly %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleavedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 224
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleavedCollection_field_InterleavedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 264
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 30, %21 ], [ 30, %14 ], [ 31, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 33, %21 ], [ 33, %14 ], [ 32, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @InterleavedCollection_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 35, %21 ], [ 35, %14 ], [ 34, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @InterleavedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 37, %21 ], [ 37, %14 ], [ 36, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define void @InterleavedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define i32 @InterleavedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract17)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract17, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract19) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract3, ptr %13, align 8
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep6 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract5, ptr %.fca.1.gep6, align 8
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep8 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract7, ptr %.fca.2.gep8, align 8
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep10 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract9, ptr %.fca.3.gep10, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep6, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep8, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep10, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract17)
  %31 = getelementptr i8, ptr %8, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract19) #31
  %35 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  store ptr %.fca.0.extract, ptr %35, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %35, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %35, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %35, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %35, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %.fca.1.gep, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = load ptr, ptr %.fca.2.gep, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %40, 2
  %42 = load i32, ptr %.fca.3.gep, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %42, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %36)
  %46 = sext i32 %42 to i64
  %47 = getelementptr ptr, ptr %36, i64 %46
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @behavior_wrapper(ptr %49, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 %4)
  %51 = call i32 %50({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull %4)
  %52 = add i32 %51, %29
  ret i32 %52
}

define { ptr, ptr, ptr, i32 } @InterleavedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract120, ptr noundef nonnull align 16 dereferenceable(1056) @InterleavedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract120, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract122) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract90, ptr %13, align 8
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep93 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract92, ptr %.fca.1.gep93, align 8
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep95 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract94, ptr %.fca.2.gep95, align 8
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep97 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract96, ptr %.fca.3.gep97, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep93, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep95, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep97, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract78 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract78, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %32 = getelementptr i8, ptr %8, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract122) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract69, ptr %36, align 8
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep72 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract71, ptr %.fca.1.gep72, align 8
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep74 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract73, ptr %.fca.2.gep74, align 8
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep76 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract75, ptr %.fca.3.gep76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep72, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep74, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep76, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 24
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %4)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %53 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull @Iterator)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %55 = load ptr, ptr %8, align 8
  %56 = call ptr @typegetter_wrapper(ptr %55, ptr %.fca.1.extract122)
  %57 = alloca [2 x ptr], align 8
  store ptr @InterleaveIterator, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %57, i64 8
  store ptr %56, ptr %58, align 8
  %59 = load ptr, ptr getelementptr (i8, ptr @InterleaveIterator, i64 48), align 8
  %60 = call { i64, i64 } @size_wrapper(ptr %59, ptr noundef nonnull align 8 dereferenceable(16) %57)
  %61 = extractvalue { i64, i64 } %60, 0
  %62 = call ptr @bump_malloc(i64 %61)
  store ptr %56, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %65 = load ptr, ptr %9, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr, ptr, ptr, i32 } %66(ptr %.fca.1.extract122) #31
  %68 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  store ptr %.fca.0.extract40, ptr %68, align 8
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.1.gep43 = getelementptr inbounds i8, ptr %68, i64 8
  store ptr %.fca.1.extract42, ptr %.fca.1.gep43, align 8
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %.fca.2.gep45 = getelementptr inbounds i8, ptr %68, i64 16
  store ptr %.fca.2.extract44, ptr %.fca.2.gep45, align 8
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %67, 3
  %.fca.3.gep47 = getelementptr inbounds i8, ptr %68, i64 24
  store i32 %.fca.3.extract46, ptr %.fca.3.gep47, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %68, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %69 = load ptr, ptr %68, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %69, 0
  %71 = load ptr, ptr %.fca.1.gep43, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %71, 1
  %73 = load ptr, ptr %.fca.2.gep45, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 2
  %75 = load i32, ptr %.fca.3.gep47, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %75, 3
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %69)
  %79 = sext i32 %75 to i64
  %80 = getelementptr ptr, ptr %69, i64 %79
  %81 = getelementptr i8, ptr %80, i64 24
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @behavior_wrapper(ptr %82, { ptr, ptr, ptr, i32 } %76, ptr noundef nonnull align 8 %4)
  %84 = call { ptr, ptr, ptr, i32 } %83({ ptr, ptr, ptr, i32 } %76, { ptr, ptr, ptr, i32 } %76, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %84, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %84, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %84, 2
  %85 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull @Iterator)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %87 = load ptr, ptr %32, align 8
  %88 = load ptr, ptr %87, align 8
  %89 = call { ptr, ptr, ptr, i32 } %88(ptr %.fca.1.extract122) #31
  %90 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %89, 0
  store ptr %.fca.0.extract19, ptr %90, align 8
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %89, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %.fca.1.extract20, ptr %.fca.1.gep, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %89, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %90, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep, align 8
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %89, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %90, i64 24
  store i32 %.fca.3.extract22, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %90, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %91 = load ptr, ptr %90, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %.fca.1.gep, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %.fca.2.gep, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %.fca.3.gep, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 24
  %104 = load ptr, ptr %103, align 8
  %105 = call ptr @behavior_wrapper(ptr %104, { ptr, ptr, ptr, i32 } %98, ptr noundef nonnull align 8 %4)
  %106 = call { ptr, ptr, ptr, i32 } %105({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %106, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %106, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %106, 2
  %107 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %108 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull @Iterator)
  %109 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %.fca.1.extract30, 1
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %.fca.2.extract32, 2
  %112 = insertvalue { ptr, ptr, ptr, i32 } %111, i32 %108, 3
  %113 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %114 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %.fca.1.extract, 1
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %.fca.2.extract, 2
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 %113, 3
  %118 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %62, 1
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr undef, 2
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 10, 3
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %122 = load ptr, ptr %8, align 8
  %123 = call ptr @typegetter_wrapper(ptr %122, ptr %.fca.1.extract122)
  %124 = call ptr @bump_malloc(i64 noundef 24)
  %125 = getelementptr i8, ptr %124, i64 8
  store ptr %123, ptr %125, align 8
  %126 = getelementptr i8, ptr %124, i64 16
  store ptr null, ptr %126, align 8
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %124)
  store ptr @Iterator, ptr %124, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %129 = load ptr, ptr %8, align 8
  %130 = call ptr @typegetter_wrapper(ptr %129, ptr %.fca.1.extract122)
  %131 = call ptr @bump_malloc(i64 noundef 24)
  %132 = getelementptr i8, ptr %131, i64 8
  store ptr %130, ptr %132, align 8
  %133 = getelementptr i8, ptr %131, i64 16
  store ptr null, ptr %133, align 8
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %131)
  store ptr @Iterator, ptr %131, align 8
  %135 = alloca [2 x ptr], align 8
  store ptr %124, ptr %135, align 8
  %136 = getelementptr inbounds i8, ptr %135, i64 8
  store ptr %131, ptr %136, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %135)
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @InterleaveIterator)
  %139 = load ptr, ptr getelementptr (i8, ptr @InterleaveIterator, i64 112), align 8
  %140 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract28, ptr %140, align 8
  %141 = getelementptr inbounds i8, ptr %140, i64 8
  store ptr %.fca.0.extract, ptr %141, align 8
  %142 = call ptr @behavior_wrapper(ptr %139, { ptr, ptr, ptr, i32 } %120, ptr noundef nonnull align 8 dereferenceable(16) %140)
  call void %142({ ptr, ptr, ptr, i32 } %120, { ptr, ptr, ptr, i32 } %120, ptr nonnull %135, { ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %117)
  %143 = call i32 @get_offset(ptr noundef nonnull @InterleaveIterator, ptr noundef nonnull @Iterator)
  %144 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 %143, 3
  ret { ptr, ptr, ptr, i32 } %144
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 224
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainedCollection_field_ChainedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 264
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 30, %21 ], [ 30, %14 ], [ 31, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 33, %21 ], [ 33, %14 ], [ 32, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ChainedCollection_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 35, %21 ], [ 35, %14 ], [ 34, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ChainedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 37, %21 ], [ 37, %14 ], [ 36, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define void @ChainedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(1056) @ChainedCollection)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define i32 @ChainedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(1056) @ChainedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract17)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract17, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract19) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract3, ptr %13, align 8
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep6 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract5, ptr %.fca.1.gep6, align 8
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep8 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract7, ptr %.fca.2.gep8, align 8
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep10 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract9, ptr %.fca.3.gep10, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep6, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep8, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep10, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract17)
  %31 = getelementptr i8, ptr %8, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract19) #31
  %35 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  store ptr %.fca.0.extract, ptr %35, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %35, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %35, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %35, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %35, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %.fca.1.gep, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = load ptr, ptr %.fca.2.gep, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %40, 2
  %42 = load i32, ptr %.fca.3.gep, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %42, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %36)
  %46 = sext i32 %42 to i64
  %47 = getelementptr ptr, ptr %36, i64 %46
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @behavior_wrapper(ptr %49, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 %4)
  %51 = call i32 %50({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull %4)
  %52 = add i32 %51, %29
  ret i32 %52
}

define { ptr, ptr, ptr, i32 } @ChainedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract120, ptr noundef nonnull align 16 dereferenceable(1056) @ChainedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract120, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract122) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract90, ptr %13, align 8
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep93 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract92, ptr %.fca.1.gep93, align 8
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep95 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract94, ptr %.fca.2.gep95, align 8
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep97 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract96, ptr %.fca.3.gep97, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep93, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep95, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep97, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract78 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract78, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %32 = getelementptr i8, ptr %8, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract122) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract69, ptr %36, align 8
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep72 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract71, ptr %.fca.1.gep72, align 8
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep74 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract73, ptr %.fca.2.gep74, align 8
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep76 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract75, ptr %.fca.3.gep76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep72, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep74, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep76, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 24
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %4)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %53 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull @Iterator)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %55 = load ptr, ptr %8, align 8
  %56 = call ptr @typegetter_wrapper(ptr %55, ptr %.fca.1.extract122)
  %57 = alloca [2 x ptr], align 8
  store ptr @ChainIterator, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %57, i64 8
  store ptr %56, ptr %58, align 8
  %59 = load ptr, ptr getelementptr (i8, ptr @ChainIterator, i64 48), align 8
  %60 = call { i64, i64 } @size_wrapper(ptr %59, ptr noundef nonnull align 8 dereferenceable(16) %57)
  %61 = extractvalue { i64, i64 } %60, 0
  %62 = call ptr @bump_malloc(i64 %61)
  store ptr %56, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %65 = load ptr, ptr %9, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr, ptr, ptr, i32 } %66(ptr %.fca.1.extract122) #31
  %68 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %67, 0
  store ptr %.fca.0.extract40, ptr %68, align 8
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %67, 1
  %.fca.1.gep43 = getelementptr inbounds i8, ptr %68, i64 8
  store ptr %.fca.1.extract42, ptr %.fca.1.gep43, align 8
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %67, 2
  %.fca.2.gep45 = getelementptr inbounds i8, ptr %68, i64 16
  store ptr %.fca.2.extract44, ptr %.fca.2.gep45, align 8
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %67, 3
  %.fca.3.gep47 = getelementptr inbounds i8, ptr %68, i64 24
  store i32 %.fca.3.extract46, ptr %.fca.3.gep47, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %68, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %69 = load ptr, ptr %68, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %69, 0
  %71 = load ptr, ptr %.fca.1.gep43, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %71, 1
  %73 = load ptr, ptr %.fca.2.gep45, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 2
  %75 = load i32, ptr %.fca.3.gep47, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %75, 3
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %69)
  %79 = sext i32 %75 to i64
  %80 = getelementptr ptr, ptr %69, i64 %79
  %81 = getelementptr i8, ptr %80, i64 24
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @behavior_wrapper(ptr %82, { ptr, ptr, ptr, i32 } %76, ptr noundef nonnull align 8 %4)
  %84 = call { ptr, ptr, ptr, i32 } %83({ ptr, ptr, ptr, i32 } %76, { ptr, ptr, ptr, i32 } %76, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %84, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %84, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %84, 2
  %85 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull @Iterator)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %87 = load ptr, ptr %32, align 8
  %88 = load ptr, ptr %87, align 8
  %89 = call { ptr, ptr, ptr, i32 } %88(ptr %.fca.1.extract122) #31
  %90 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %89, 0
  store ptr %.fca.0.extract19, ptr %90, align 8
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %89, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %.fca.1.extract20, ptr %.fca.1.gep, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %89, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %90, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep, align 8
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %89, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %90, i64 24
  store i32 %.fca.3.extract22, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %90, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %91 = load ptr, ptr %90, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %.fca.1.gep, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %.fca.2.gep, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %.fca.3.gep, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %91)
  %101 = sext i32 %97 to i64
  %102 = getelementptr ptr, ptr %91, i64 %101
  %103 = getelementptr i8, ptr %102, i64 24
  %104 = load ptr, ptr %103, align 8
  %105 = call ptr @behavior_wrapper(ptr %104, { ptr, ptr, ptr, i32 } %98, ptr noundef nonnull align 8 %4)
  %106 = call { ptr, ptr, ptr, i32 } %105({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %106, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %106, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %106, 2
  %107 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %108 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull @Iterator)
  %109 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %.fca.1.extract30, 1
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %.fca.2.extract32, 2
  %112 = insertvalue { ptr, ptr, ptr, i32 } %111, i32 %108, 3
  %113 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %114 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %.fca.1.extract, 1
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %.fca.2.extract, 2
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 %113, 3
  %118 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %62, 1
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr undef, 2
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 10, 3
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %122 = load ptr, ptr %8, align 8
  %123 = call ptr @typegetter_wrapper(ptr %122, ptr %.fca.1.extract122)
  %124 = call ptr @bump_malloc(i64 noundef 24)
  %125 = getelementptr i8, ptr %124, i64 8
  store ptr %123, ptr %125, align 8
  %126 = getelementptr i8, ptr %124, i64 16
  store ptr null, ptr %126, align 8
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %124)
  store ptr @Iterator, ptr %124, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract120)
  %129 = load ptr, ptr %8, align 8
  %130 = call ptr @typegetter_wrapper(ptr %129, ptr %.fca.1.extract122)
  %131 = call ptr @bump_malloc(i64 noundef 24)
  %132 = getelementptr i8, ptr %131, i64 8
  store ptr %130, ptr %132, align 8
  %133 = getelementptr i8, ptr %131, i64 16
  store ptr null, ptr %133, align 8
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %131)
  store ptr @Iterator, ptr %131, align 8
  %135 = alloca [2 x ptr], align 8
  store ptr %124, ptr %135, align 8
  %136 = getelementptr inbounds i8, ptr %135, i64 8
  store ptr %131, ptr %136, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %135)
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @ChainIterator)
  %139 = load ptr, ptr getelementptr (i8, ptr @ChainIterator, i64 112), align 8
  %140 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract28, ptr %140, align 8
  %141 = getelementptr inbounds i8, ptr %140, i64 8
  store ptr %.fca.0.extract, ptr %141, align 8
  %142 = call ptr @behavior_wrapper(ptr %139, { ptr, ptr, ptr, i32 } %120, ptr noundef nonnull align 8 dereferenceable(16) %140)
  call void %142({ ptr, ptr, ptr, i32 } %120, { ptr, ptr, ptr, i32 } %120, ptr nonnull %135, { ptr, ptr, ptr, i32 } %112, { ptr, ptr, ptr, i32 } %117)
  %143 = call i32 @get_offset(ptr noundef nonnull @ChainIterator, ptr noundef nonnull @Iterator)
  %144 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 %143, 3
  ret { ptr, ptr, ptr, i32 } %144
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator_field_ChainIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 128
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ChainIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract38, ptr noundef nonnull align 16 dereferenceable(168) @ChainIterator)
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract20, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %8 = call i32 @get_offset(ptr %.fca.0.extract20, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract38)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract38, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract21, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract22, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract38)
  %23 = getelementptr i8, ptr %11, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract39, { ptr, ptr, ptr, i32 } %30) #30
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract38)
  %32 = getelementptr i8, ptr %11, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  call void %35(ptr %.fca.1.extract39, i1 true) #30
  ret void
}

define { ptr, i160 } @ChainIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(168) @ChainIterator)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract18)
  %9 = sext i32 %7 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract18, i64 %9
  %11 = getelementptr i8, ptr %10, i64 24
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i1 %13(ptr %.fca.1.extract19) #31
  br i1 %14, label %15, label %47

15:                                               ; preds = %3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract18)
  %17 = getelementptr i8, ptr %10, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr, ptr, ptr, i32 } %19(ptr %.fca.1.extract19) #31
  %.fca.0.extract38 = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  store ptr %.fca.0.extract38, ptr %5, align 8
  %.fca.1.extract40 = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.1.gep41 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract40, ptr %.fca.1.gep41, align 8
  %.fca.2.extract42 = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %.fca.2.gep43 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract42, ptr %.fca.2.gep43, align 8
  %.fca.3.extract44 = extractvalue { ptr, ptr, ptr, i32 } %20, 3
  %.fca.3.gep45 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract44, ptr %.fca.3.gep45, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %21 = load ptr, ptr %5, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = load ptr, ptr %.fca.1.gep41, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 1
  %25 = load ptr, ptr %.fca.2.gep43, align 8
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %25, 2
  %27 = load i32, ptr %.fca.3.gep45, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %27, 3
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %21)
  %31 = sext i32 %27 to i64
  %32 = getelementptr ptr, ptr %21, i64 %31
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = call ptr @behavior_wrapper(ptr %34, { ptr, ptr, ptr, i32 } %28, ptr noundef nonnull align 8 %4)
  %36 = call { ptr, i160 } %35({ ptr, ptr, ptr, i32 } %28, { ptr, ptr, ptr, i32 } %28, ptr nonnull %4)
  %.fca.0.extract32 = extractvalue { ptr, i160 } %36, 0
  %.fca.1.extract34 = extractvalue { ptr, i160 } %36, 1
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract18)
  %38 = load ptr, ptr %10, align 8
  %39 = call ptr @typegetter_wrapper(ptr %38, ptr %.fca.1.extract19)
  %40 = icmp ne ptr %.fca.0.extract32, @nil_typ
  %41 = icmp ne ptr %.fca.0.extract32, null
  %.not47.not.not = and i1 %40, %41
  br i1 %.not47.not.not, label %47, label %42

42:                                               ; preds = %15
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract18)
  %44 = load ptr, ptr %11, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  call void %46(ptr %.fca.1.extract19, i1 false) #30
  br label %47

47:                                               ; preds = %42, %15, %3
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract32, %15 ], [ %.fca.0.extract32, %42 ], [ poison, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract34, %15 ], [ %.fca.1.extract34, %42 ], [ poison, %3 ]
  %.reg2mem13.0 = phi i1 [ true, %15 ], [ false, %42 ], [ false, %3 ]
  br i1 %.reg2mem13.0, label %70, label %48

48:                                               ; preds = %47
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract18)
  %50 = getelementptr i8, ptr %10, i64 16
  %51 = load ptr, ptr %50, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr, ptr, ptr, i32 } %52(ptr %.fca.1.extract19) #31
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %53, 0
  store ptr %.fca.0.extract24, ptr %6, align 8
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %53, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract25, ptr %.fca.1.gep, align 8
  %.fca.2.extract26 = extractvalue { ptr, ptr, ptr, i32 } %53, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract26, ptr %.fca.2.gep, align 8
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %53, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract27, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %54 = load ptr, ptr %6, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %54, 0
  %56 = load ptr, ptr %.fca.1.gep, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %56, 1
  %58 = load ptr, ptr %.fca.2.gep, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 2
  %60 = load i32, ptr %.fca.3.gep, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %60, 3
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %54)
  %64 = sext i32 %60 to i64
  %65 = getelementptr ptr, ptr %54, i64 %64
  %66 = getelementptr i8, ptr %65, i64 8
  %67 = load ptr, ptr %66, align 8
  %68 = call ptr @behavior_wrapper(ptr %67, { ptr, ptr, ptr, i32 } %61, ptr noundef nonnull align 8 %4)
  %69 = call { ptr, i160 } %68({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull %4)
  %.fca.0.extract20 = extractvalue { ptr, i160 } %69, 0
  %.fca.1.extract21 = extractvalue { ptr, i160 } %69, 1
  br label %70

70:                                               ; preds = %48, %47
  %.reg2mem11.sroa.0.0 = phi ptr [ %.fca.0.extract20, %48 ], [ %.reg2mem15.sroa.0.0, %47 ]
  %.reg2mem11.sroa.3.0 = phi i160 [ %.fca.1.extract21, %48 ], [ %.reg2mem15.sroa.3.0, %47 ]
  %.reload12.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem11.sroa.0.0, 0
  %.reload12.fca.1.insert = insertvalue { ptr, i160 } %.reload12.fca.0.insert, i160 %.reg2mem11.sroa.3.0, 1
  ret { ptr, i160 } %.reload12.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator_getter_on_first(ptr nocapture nofree readonly %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @ChainIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 208
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable_field_ChainIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 232
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ChainIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ChainIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ChainIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @ChainIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(512) @ChainIterable)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract34)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract34, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract20, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract21, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %19) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %21 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract34)
  %23 = getelementptr i8, ptr %11, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %21, 3
  call void %26(ptr %.fca.1.extract35, { ptr, ptr, ptr, i32 } %30) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @ChainIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract120 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract122 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract120, ptr noundef nonnull align 16 dereferenceable(512) @ChainIterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract120, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract122) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract90 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract90, ptr %13, align 8
  %.fca.1.extract92 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep93 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract92, ptr %.fca.1.gep93, align 8
  %.fca.2.extract94 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep95 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract94, ptr %.fca.2.gep95, align 8
  %.fca.3.extract96 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep97 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract96, ptr %.fca.3.gep97, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep93, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep95, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep97, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract78 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract78, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %32 = getelementptr i8, ptr %8, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract122) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract69 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract69, ptr %36, align 8
  %.fca.1.extract71 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep72 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract71, ptr %.fca.1.gep72, align 8
  %.fca.2.extract73 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep74 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract73, ptr %.fca.2.gep74, align 8
  %.fca.3.extract75 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep76 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract75, ptr %.fca.3.gep76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep72, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep74, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep76, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %4)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4)
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %53 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %55 = load ptr, ptr %8, align 8
  %56 = call ptr @typegetter_wrapper(ptr %55, ptr %.fca.1.extract122)
  %57 = alloca [2 x ptr], align 8
  store ptr @ChainIterator, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %57, i64 8
  store ptr %56, ptr %58, align 8
  %59 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ChainIterator, ptr noundef nonnull align 8 dereferenceable(16) %57)
  %60 = extractvalue { i64, i64 } %59, 0
  %61 = call ptr @bump_malloc(i64 %60)
  store ptr %56, ptr %61, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %61)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %64, align 8
  %66 = call { ptr, ptr, ptr, i32 } %65(ptr %.fca.1.extract122) #31
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  store ptr %.fca.0.extract40, ptr %67, align 8
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.1.gep43 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract42, ptr %.fca.1.gep43, align 8
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.2.gep45 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract44, ptr %.fca.2.gep45, align 8
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %.fca.3.gep47 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract46, ptr %.fca.3.gep47, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %68 = load ptr, ptr %67, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %68, 0
  %70 = load ptr, ptr %.fca.1.gep43, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %70, 1
  %72 = load ptr, ptr %.fca.2.gep45, align 8
  %73 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %72, 2
  %74 = load i32, ptr %.fca.3.gep47, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 %74, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %68)
  %78 = sext i32 %74 to i64
  %79 = getelementptr ptr, ptr %68, i64 %78
  %80 = getelementptr i8, ptr %79, i64 8
  %81 = load ptr, ptr %80, align 8
  %82 = call ptr @behavior_wrapper(ptr %81, { ptr, ptr, ptr, i32 } %75, ptr noundef nonnull align 8 %4)
  %83 = call { ptr, ptr, ptr, i32 } %82({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull align 8 %4)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %83, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %83, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %83, 2
  %84 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %86 = load ptr, ptr %32, align 8
  %87 = load ptr, ptr %86, align 8
  %88 = call { ptr, ptr, ptr, i32 } %87(ptr %.fca.1.extract122) #31
  %89 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %88, 0
  store ptr %.fca.0.extract19, ptr %89, align 8
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %88, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %89, i64 8
  store ptr %.fca.1.extract20, ptr %.fca.1.gep, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %88, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %89, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep, align 8
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %88, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %89, i64 24
  store i32 %.fca.3.extract22, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %89, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %90 = load ptr, ptr %89, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %90, 0
  %92 = load ptr, ptr %.fca.1.gep, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %92, 1
  %94 = load ptr, ptr %.fca.2.gep, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %94, 2
  %96 = load i32, ptr %.fca.3.gep, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %96, 3
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %90)
  %100 = sext i32 %96 to i64
  %101 = getelementptr ptr, ptr %90, i64 %100
  %102 = getelementptr i8, ptr %101, i64 8
  %103 = load ptr, ptr %102, align 8
  %104 = call ptr @behavior_wrapper(ptr %103, { ptr, ptr, ptr, i32 } %97, ptr noundef nonnull align 8 %4)
  %105 = call { ptr, ptr, ptr, i32 } %104({ ptr, ptr, ptr, i32 } %97, { ptr, ptr, ptr, i32 } %97, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %105, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %105, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %105, 2
  %106 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %107 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %108 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %109 = insertvalue { ptr, ptr, ptr, i32 } %108, ptr %.fca.1.extract30, 1
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %.fca.2.extract32, 2
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, i32 %107, 3
  %112 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %113 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %114 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %.fca.1.extract, 1
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %.fca.2.extract, 2
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 %112, 3
  %117 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %61, 1
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr undef, 2
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 10, 3
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %121 = load ptr, ptr %8, align 8
  %122 = call ptr @typegetter_wrapper(ptr %121, ptr %.fca.1.extract122)
  %123 = call ptr @bump_malloc(i64 noundef 24)
  %124 = getelementptr i8, ptr %123, i64 8
  store ptr %122, ptr %124, align 8
  %125 = getelementptr i8, ptr %123, i64 16
  store ptr null, ptr %125, align 8
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %123)
  store ptr @Iterator, ptr %123, align 8
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract120)
  %128 = load ptr, ptr %8, align 8
  %129 = call ptr @typegetter_wrapper(ptr %128, ptr %.fca.1.extract122)
  %130 = call ptr @bump_malloc(i64 noundef 24)
  %131 = getelementptr i8, ptr %130, i64 8
  store ptr %129, ptr %131, align 8
  %132 = getelementptr i8, ptr %130, i64 16
  store ptr null, ptr %132, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %130)
  store ptr @Iterator, ptr %130, align 8
  %134 = alloca [2 x ptr], align 8
  store ptr %123, ptr %134, align 8
  %135 = getelementptr inbounds i8, ptr %134, i64 8
  store ptr %130, ptr %135, align 8
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %134)
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator)
  %138 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract28, ptr %138, align 8
  %139 = getelementptr inbounds i8, ptr %138, i64 8
  store ptr %.fca.0.extract, ptr %139, align 8
  %140 = call ptr @behavior_wrapper(ptr noundef nonnull @ChainIterator_B_init_firstIteratorT_secondIteratorT, { ptr, ptr, ptr, i32 } %119, ptr noundef nonnull align 8 dereferenceable(16) %138)
  call void %140({ ptr, ptr, ptr, i32 } %119, { ptr, ptr, ptr, i32 } %119, ptr nonnull %134, { ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %116)
  %141 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(168) @ChainIterator, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %142 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 %141, 3
  ret { ptr, ptr, ptr, i32 } %142
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 208
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable_field_FilterIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 232
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @FilterIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @FilterIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @FilterIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @FilterIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(512) @FilterIterable)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract18)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract18, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %19) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract18)
  %21 = getelementptr i8, ptr %11, i64 16
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract19, { ptr } %4) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @FilterIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract73, ptr noundef nonnull align 16 dereferenceable(512) @FilterIterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract73)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract73, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract75) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract43, ptr %13, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep46, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep48, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep50, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract31, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract73)
  %32 = getelementptr i8, ptr %8, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract75) #31
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract73)
  %37 = load ptr, ptr %8, align 8
  %38 = call ptr @typegetter_wrapper(ptr %37, ptr %.fca.1.extract75)
  %39 = alloca [2 x ptr], align 8
  store ptr @FilterIterator, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr %38, ptr %40, align 8
  %41 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_FilterIterator, ptr noundef nonnull align 8 dereferenceable(16) %39)
  %42 = extractvalue { i64, i64 } %41, 0
  %43 = call ptr @bump_malloc(i64 %42)
  store ptr %38, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract73)
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr, ptr, ptr, i32 } %47(ptr %.fca.1.extract75) #31
  %49 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %48, 0
  store ptr %.fca.0.extract16, ptr %49, align 8
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %48, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %49, i64 8
  store ptr %.fca.1.extract17, ptr %.fca.1.gep, align 8
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %48, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %49, i64 16
  store ptr %.fca.2.extract18, ptr %.fca.2.gep, align 8
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %48, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %49, i64 24
  store i32 %.fca.3.extract19, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %49, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %50 = load ptr, ptr %49, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %50, 0
  %52 = load ptr, ptr %.fca.1.gep, align 8
  %53 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %52, 1
  %54 = load ptr, ptr %.fca.2.gep, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %54, 2
  %56 = load i32, ptr %.fca.3.gep, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 %56, 3
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %50)
  %60 = sext i32 %56 to i64
  %61 = getelementptr ptr, ptr %50, i64 %60
  %62 = getelementptr i8, ptr %61, i64 8
  %63 = load ptr, ptr %62, align 8
  %64 = call ptr @behavior_wrapper(ptr %63, { ptr, ptr, ptr, i32 } %57, ptr noundef nonnull align 8 %4)
  %65 = call { ptr, ptr, ptr, i32 } %64({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %65, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %65, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %65, 2
  %66 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract73)
  %68 = load ptr, ptr %32, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = call { ptr } %69(ptr %.fca.1.extract75) #31
  %71 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract15, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.1.extract, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %.fca.2.extract, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %71, 3
  %76 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterator, ptr undef, ptr undef, i32 undef }, ptr %43, 1
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr undef, 2
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, i32 10, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract73)
  %80 = load ptr, ptr %8, align 8
  %81 = call ptr @typegetter_wrapper(ptr %80, ptr %.fca.1.extract75)
  %82 = call ptr @bump_malloc(i64 noundef 24)
  %83 = getelementptr i8, ptr %82, i64 8
  store ptr %81, ptr %83, align 8
  %84 = getelementptr i8, ptr %82, i64 16
  store ptr null, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  store ptr @Iterator, ptr %82, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %.fca.0.extract73)
  %87 = load ptr, ptr %8, align 8
  %88 = call ptr @typegetter_wrapper(ptr %87, ptr %.fca.1.extract75)
  %89 = call ptr @bump_malloc(i64 noundef 32)
  %90 = getelementptr i8, ptr %89, i64 16
  store ptr %88, ptr %90, align 8
  %91 = getelementptr i8, ptr %89, i64 8
  store ptr @_parameterization_Bool, ptr %91, align 8
  %92 = getelementptr i8, ptr %89, i64 24
  store ptr null, ptr %92, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %89)
  store ptr @function_typ, ptr %89, align 8
  %94 = alloca [2 x ptr], align 8
  store ptr %82, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %94, i64 8
  store ptr %89, ptr %95, align 8
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %94)
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @FilterIterator)
  %98 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract15, ptr %98, align 8
  %99 = getelementptr inbounds i8, ptr %98, i64 8
  store ptr @function_typ, ptr %99, align 8
  %100 = call ptr @behavior_wrapper(ptr noundef nonnull @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool, { ptr, ptr, ptr, i32 } %78, ptr noundef nonnull align 8 dereferenceable(16) %98)
  call void %100({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull %94, { ptr, ptr, ptr, i32 } %75, { ptr } %70)
  %101 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(160) @FilterIterator, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %102 = insertvalue { ptr, ptr, ptr, i32 } %77, i32 %101, 3
  ret { ptr, ptr, ptr, i32 } %102
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 120
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator_field_FilterIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(160) @FilterIterator)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %8 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract18)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract18, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %19) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract18)
  %21 = getelementptr i8, ptr %11, i64 16
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract19, { ptr } %4) #30
  ret void
}

define { ptr, i160 } @FilterIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract25, ptr noundef nonnull align 16 dereferenceable(160) @FilterIterator)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract25)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract25, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call { ptr, ptr, ptr, i32 } %12(ptr %.fca.1.extract27) #31
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %13, 0
  store ptr %.fca.0.extract1, ptr %14, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %13, 1
  %.fca.1.gep4 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep4, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %14, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %14, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = load ptr, ptr %.fca.1.gep4, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %17, 1
  %19 = load ptr, ptr %.fca.2.gep, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %19, 2
  %21 = load i32, ptr %.fca.3.gep, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %21, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %15)
  %25 = sext i32 %21 to i64
  %26 = getelementptr ptr, ptr %15, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr @behavior_wrapper(ptr %28, { ptr, ptr, ptr, i32 } %22, ptr noundef nonnull align 8 %4)
  %30 = call { ptr, i160 } %29({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %30, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %30, 1
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract25)
  %32 = getelementptr i8, ptr %9, i64 16
  %.fca.1.gep44 = getelementptr inbounds i8, ptr %5, i64 8
  %.fca.2.gep46 = getelementptr inbounds i8, ptr %5, i64 16
  %.fca.3.gep48 = getelementptr inbounds i8, ptr %5, i64 24
  br label %33

33:                                               ; preds = %68, %3
  %.sroa.3.0 = phi i160 [ %.fca.1.extract, %3 ], [ %.sroa.3.1, %68 ]
  %.sroa.0.0 = phi ptr [ %.fca.0.extract, %3 ], [ %.sroa.0.1, %68 ]
  %.0 = phi i160 [ undef, %3 ], [ %.1, %68 ]
  %34 = load ptr, ptr %9, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %.fca.1.extract27)
  %36 = icmp ne ptr %.sroa.0.0, @nil_typ
  %37 = icmp ne ptr %.sroa.0.0, null
  %.not63 = and i1 %36, %37
  br i1 %.not63, label %38, label %68

38:                                               ; preds = %33
  %39 = insertvalue { ptr, i160 } undef, ptr %.sroa.0.0, 0
  %40 = insertvalue { ptr, i160 } %39, i160 %.sroa.3.0, 1
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract25)
  %42 = load ptr, ptr %32, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract27) #31
  %.fca.0.extract50 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract50({ ptr, i160 } %40)
  %46 = xor i1 %45, true
  br i1 %45, label %68, label %47

47:                                               ; preds = %38
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract25)
  %49 = load ptr, ptr %10, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = call { ptr, ptr, ptr, i32 } %50(ptr %.fca.1.extract27) #31
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %51, 0
  store ptr %.fca.0.extract41, ptr %5, align 8
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %51, 1
  store ptr %.fca.1.extract43, ptr %.fca.1.gep44, align 8
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %51, 2
  store ptr %.fca.2.extract45, ptr %.fca.2.gep46, align 8
  %.fca.3.extract47 = extractvalue { ptr, ptr, ptr, i32 } %51, 3
  store i32 %.fca.3.extract47, ptr %.fca.3.gep48, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %52 = load ptr, ptr %5, align 8
  %53 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %52, 0
  %54 = load ptr, ptr %.fca.1.gep44, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %54, 1
  %56 = load ptr, ptr %.fca.2.gep46, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %56, 2
  %58 = load i32, ptr %.fca.3.gep48, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %58, 3
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %52)
  %62 = sext i32 %58 to i64
  %63 = getelementptr ptr, ptr %52, i64 %62
  %64 = getelementptr i8, ptr %63, i64 8
  %65 = load ptr, ptr %64, align 8
  %66 = call ptr @behavior_wrapper(ptr %65, { ptr, ptr, ptr, i32 } %59, ptr noundef nonnull align 8 %4)
  %67 = call { ptr, i160 } %66({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull %4)
  %.fca.0.extract35 = extractvalue { ptr, i160 } %67, 0
  %.fca.1.extract37 = extractvalue { ptr, i160 } %67, 1
  br label %68

68:                                               ; preds = %47, %38, %33
  %.sroa.3.1 = phi i160 [ %.sroa.3.0, %38 ], [ %.fca.1.extract37, %47 ], [ %.sroa.3.0, %33 ]
  %.sroa.0.1 = phi ptr [ %.sroa.0.0, %38 ], [ %.fca.0.extract35, %47 ], [ %.sroa.0.0, %33 ]
  %.reg2mem20.0.off0 = phi i1 [ %46, %38 ], [ %46, %47 ], [ false, %33 ]
  %.reg2mem22.0 = phi ptr [ %.sroa.0.0, %38 ], [ @nil_typ, %47 ], [ @nil_typ, %33 ]
  %.1 = phi i160 [ %.sroa.3.0, %38 ], [ %.sroa.3.0, %47 ], [ %.0, %33 ]
  br i1 %.reg2mem20.0.off0, label %33, label %69

69:                                               ; preds = %68
  %.reload19.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem22.0, 0
  %.reload19.fca.1.insert = insertvalue { ptr, i160 } %.reload19.fca.0.insert, i160 %.1, 1
  ret { ptr, i160 } %.reload19.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 216
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 240
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @MapIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @MapIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @MapIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 312
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @MapIterable_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(520) @MapIterable)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract18)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract18, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %19) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract18)
  %21 = getelementptr i8, ptr %11, i64 24
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract19, { ptr } %4) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @MapIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract79 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract81 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract79, ptr noundef nonnull align 16 dereferenceable(520) @MapIterable)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract79, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract81) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract43, ptr %13, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep46, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep48, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep50, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract31, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %32 = getelementptr i8, ptr %8, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract81) #31
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %37 = load ptr, ptr %8, align 8
  %38 = call ptr @typegetter_wrapper(ptr %37, ptr %.fca.1.extract81)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %40 = getelementptr i8, ptr %8, i64 8
  %41 = load ptr, ptr %40, align 8
  %42 = call ptr @typegetter_wrapper(ptr %41, ptr %.fca.1.extract81)
  %43 = alloca [3 x ptr], align 8
  store ptr @MapIterator, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %43, i64 8
  store ptr %38, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 16
  store ptr %42, ptr %45, align 8
  %46 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapIterator, ptr noundef nonnull align 8 dereferenceable(24) %43)
  %47 = extractvalue { i64, i64 } %46, 0
  %48 = call ptr @bump_malloc(i64 %47)
  store ptr %38, ptr %48, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  store ptr %42, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %48)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %52 = load ptr, ptr %9, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract81) #31
  %55 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  store ptr %.fca.0.extract16, ptr %55, align 8
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %55, i64 8
  store ptr %.fca.1.extract17, ptr %.fca.1.gep, align 8
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %55, i64 16
  store ptr %.fca.2.extract18, ptr %.fca.2.gep, align 8
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %55, i64 24
  store i32 %.fca.3.extract19, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %55, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %56 = load ptr, ptr %55, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %56, 0
  %58 = load ptr, ptr %.fca.1.gep, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 1
  %60 = load ptr, ptr %.fca.2.gep, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %60, 2
  %62 = load i32, ptr %.fca.3.gep, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %62, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %56)
  %66 = sext i32 %62 to i64
  %67 = getelementptr ptr, ptr %56, i64 %66
  %68 = getelementptr i8, ptr %67, i64 8
  %69 = load ptr, ptr %68, align 8
  %70 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %63, ptr noundef nonnull align 8 %4)
  %71 = call { ptr, ptr, ptr, i32 } %70({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %72 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %74 = load ptr, ptr %32, align 8
  %75 = load ptr, ptr %74, align 8
  %76 = call { ptr } %75(ptr %.fca.1.extract81) #31
  %77 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %78 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract15, 0
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %.fca.1.extract, 1
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %.fca.2.extract, 2
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, i32 %77, 3
  %82 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %48, 1
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr undef, 2
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 10, 3
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %86 = load ptr, ptr %8, align 8
  %87 = call ptr @typegetter_wrapper(ptr %86, ptr %.fca.1.extract81)
  %88 = call ptr @bump_malloc(i64 noundef 24)
  %89 = getelementptr i8, ptr %88, i64 8
  store ptr %87, ptr %89, align 8
  %90 = getelementptr i8, ptr %88, i64 16
  store ptr null, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %88)
  store ptr @Iterator, ptr %88, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %93 = load ptr, ptr %40, align 8
  %94 = call ptr @typegetter_wrapper(ptr %93, ptr %.fca.1.extract81)
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract79)
  %96 = load ptr, ptr %8, align 8
  %97 = call ptr @typegetter_wrapper(ptr %96, ptr %.fca.1.extract81)
  %98 = call ptr @bump_malloc(i64 noundef 32)
  %99 = getelementptr i8, ptr %98, i64 16
  store ptr %97, ptr %99, align 8
  %100 = getelementptr i8, ptr %98, i64 8
  store ptr %94, ptr %100, align 8
  %101 = getelementptr i8, ptr %98, i64 24
  store ptr null, ptr %101, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %98)
  store ptr @function_typ, ptr %98, align 8
  %103 = alloca [2 x ptr], align 8
  store ptr %88, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %103, i64 8
  store ptr %98, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %103)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @MapIterator)
  %107 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract15, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %107, i64 8
  store ptr @function_typ, ptr %108, align 8
  %109 = call ptr @behavior_wrapper(ptr noundef nonnull @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U, { ptr, ptr, ptr, i32 } %84, ptr noundef nonnull align 8 dereferenceable(16) %107)
  call void %109({ ptr, ptr, ptr, i32 } %84, { ptr, ptr, ptr, i32 } %84, ptr nonnull %103, { ptr, ptr, ptr, i32 } %81, { ptr } %76)
  %110 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(168) @MapIterator, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %111 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %110, 3
  ret { ptr, ptr, ptr, i32 } %111
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 128
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @MapIterator_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(168) @MapIterator)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %8 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract18)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract18, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %19) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract18)
  %21 = getelementptr i8, ptr %11, i64 24
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract19, { ptr } %4) #30
  ret void
}

define { ptr, i160 } @MapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract21, ptr noundef nonnull align 16 dereferenceable(168) @MapIterator)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract21)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract21, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract23) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract2, ptr %13, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, i160 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %29, 0
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract21)
  %31 = load ptr, ptr %8, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %.fca.1.extract23)
  %33 = icmp ne ptr %.fca.0.extract, @nil_typ
  %34 = icmp ne ptr %.fca.0.extract, null
  %.not46 = and i1 %33, %34
  br i1 %.not46, label %35, label %42

35:                                               ; preds = %3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract21)
  %37 = getelementptr i8, ptr %8, i64 24
  %38 = load ptr, ptr %37, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr } %39(ptr %.fca.1.extract23) #31
  %.fca.0.extract38 = extractvalue { ptr } %40, 0
  %41 = call { ptr, i160 } %.fca.0.extract38({ ptr, i160 } %29)
  %.fca.0.extract32 = extractvalue { ptr, i160 } %41, 0
  %.fca.1.extract34 = extractvalue { ptr, i160 } %41, 1
  br label %42

42:                                               ; preds = %35, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract32, %35 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract34, %35 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MappedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 232
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 272
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 28, i64 29
  %8 = getelementptr [123 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 31, %21 ], [ 31, %14 ], [ 32, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [123 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 34, %21 ], [ 34, %14 ], [ 33, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [123 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @MappedCollection_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 36, %21 ], [ 36, %14 ], [ 35, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [123 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @MappedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 38, %21 ], [ 38, %14 ], [ 37, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [123 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define void @MappedCollection_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract18, ptr noundef nonnull align 16 dereferenceable(1064) @MappedCollection)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %8 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract18)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract18, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract19, { ptr, ptr, ptr, i32 } %19) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract18)
  %21 = getelementptr i8, ptr %11, i64 24
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract19, { ptr } %4) #30
  ret void
}

define i32 @MappedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract4, ptr noundef nonnull align 16 dereferenceable(1064) @MappedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract4)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract4, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract6) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract, ptr %13, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  ret i32 %29
}

define { ptr, ptr, ptr, i32 } @MappedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract79 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract81 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract79, ptr noundef nonnull align 16 dereferenceable(1064) @MappedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract79, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract81) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract43, ptr %13, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep46, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep48, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep50, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract31, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %32 = getelementptr i8, ptr %8, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract81) #31
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %37 = load ptr, ptr %8, align 8
  %38 = call ptr @typegetter_wrapper(ptr %37, ptr %.fca.1.extract81)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %40 = getelementptr i8, ptr %8, i64 8
  %41 = load ptr, ptr %40, align 8
  %42 = call ptr @typegetter_wrapper(ptr %41, ptr %.fca.1.extract81)
  %43 = alloca [3 x ptr], align 8
  store ptr @MapIterator, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %43, i64 8
  store ptr %38, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 16
  store ptr %42, ptr %45, align 8
  %46 = load ptr, ptr getelementptr (i8, ptr @MapIterator, i64 48), align 8
  %47 = call { i64, i64 } @size_wrapper(ptr %46, ptr noundef nonnull align 8 dereferenceable(24) %43)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = call ptr @bump_malloc(i64 %48)
  store ptr %38, ptr %49, align 8
  %50 = getelementptr i8, ptr %49, i64 8
  store ptr %42, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %49)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %53 = load ptr, ptr %9, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr, ptr, ptr, i32 } %54(ptr %.fca.1.extract81) #31
  %56 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %55, 0
  store ptr %.fca.0.extract16, ptr %56, align 8
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %55, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %56, i64 8
  store ptr %.fca.1.extract17, ptr %.fca.1.gep, align 8
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %55, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %56, i64 16
  store ptr %.fca.2.extract18, ptr %.fca.2.gep, align 8
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %55, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %56, i64 24
  store i32 %.fca.3.extract19, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %56, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %57 = load ptr, ptr %56, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %57, 0
  %59 = load ptr, ptr %.fca.1.gep, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 1
  %61 = load ptr, ptr %.fca.2.gep, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %61, 2
  %63 = load i32, ptr %.fca.3.gep, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %63, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %57)
  %67 = sext i32 %63 to i64
  %68 = getelementptr ptr, ptr %57, i64 %67
  %69 = getelementptr i8, ptr %68, i64 24
  %70 = load ptr, ptr %69, align 8
  %71 = call ptr @behavior_wrapper(ptr %70, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 %4)
  %72 = call { ptr, ptr, ptr, i32 } %71({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %4)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %72, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %72, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %72, 2
  %73 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull @Iterator)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %75 = load ptr, ptr %32, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = call { ptr } %76(ptr %.fca.1.extract81) #31
  %78 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull @Iterator)
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract15, 0
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %.fca.1.extract, 1
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %.fca.2.extract, 2
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %78, 3
  %83 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %49, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr undef, 2
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 10, 3
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %87 = load ptr, ptr %8, align 8
  %88 = call ptr @typegetter_wrapper(ptr %87, ptr %.fca.1.extract81)
  %89 = call ptr @bump_malloc(i64 noundef 24)
  %90 = getelementptr i8, ptr %89, i64 8
  store ptr %88, ptr %90, align 8
  %91 = getelementptr i8, ptr %89, i64 16
  store ptr null, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %89)
  store ptr @Iterator, ptr %89, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %94 = load ptr, ptr %40, align 8
  %95 = call ptr @typegetter_wrapper(ptr %94, ptr %.fca.1.extract81)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 984, ptr nocapture nofree noundef %.fca.0.extract79)
  %97 = load ptr, ptr %8, align 8
  %98 = call ptr @typegetter_wrapper(ptr %97, ptr %.fca.1.extract81)
  %99 = call ptr @bump_malloc(i64 noundef 32)
  %100 = getelementptr i8, ptr %99, i64 16
  store ptr %98, ptr %100, align 8
  %101 = getelementptr i8, ptr %99, i64 8
  store ptr %95, ptr %101, align 8
  %102 = getelementptr i8, ptr %99, i64 24
  store ptr null, ptr %102, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %99)
  store ptr @function_typ, ptr %99, align 8
  %104 = alloca [2 x ptr], align 8
  store ptr %89, ptr %104, align 8
  %105 = getelementptr inbounds i8, ptr %104, i64 8
  store ptr %99, ptr %105, align 8
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %104)
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @MapIterator)
  %108 = load ptr, ptr getelementptr (i8, ptr @MapIterator, i64 112), align 8
  %109 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract15, ptr %109, align 8
  %110 = getelementptr inbounds i8, ptr %109, i64 8
  store ptr @function_typ, ptr %110, align 8
  %111 = call ptr @behavior_wrapper(ptr %108, { ptr, ptr, ptr, i32 } %85, ptr noundef nonnull align 8 dereferenceable(16) %109)
  call void %111({ ptr, ptr, ptr, i32 } %85, { ptr, ptr, ptr, i32 } %85, ptr nonnull %104, { ptr, ptr, ptr, i32 } %82, { ptr } %77)
  %112 = call i32 @get_offset(ptr noundef nonnull @MapIterator, ptr noundef nonnull @Iterator)
  %113 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %112, 3
  ret { ptr, ptr, ptr, i32 } %113
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MappedCollection_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MappedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_EnumeratedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @EnumeratedCollection_B_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 224
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 264
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 30, %21 ], [ 30, %14 ], [ 31, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 33, %21 ], [ 33, %14 ], [ 32, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @EnumeratedCollection_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 35, %21 ], [ 35, %14 ], [ 34, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @EnumeratedCollection_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 37, %21 ], [ 37, %14 ], [ 36, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [122 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define void @EnumeratedCollection_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull align 16 dereferenceable(1056) @EnumeratedCollection)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract13)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract13, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %18) #30
  ret void
}

define i32 @EnumeratedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract4, ptr noundef nonnull align 16 dereferenceable(1056) @EnumeratedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract4)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract4, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract6) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract, ptr %13, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  ret i32 %29
}

define { ptr, ptr, ptr, i32 } @EnumeratedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract63, ptr noundef nonnull align 16 dereferenceable(1056) @EnumeratedCollection)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract63)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract63, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract65) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract39, ptr %13, align 8
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep42 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract41, ptr %.fca.1.gep42, align 8
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep44 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract43, ptr %.fca.2.gep44, align 8
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep46 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract45, ptr %.fca.3.gep46, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep42, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep44, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep46, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract27, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract63)
  %32 = load ptr, ptr %8, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract65)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract63)
  %35 = load ptr, ptr %8, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract65)
  %37 = call ptr @bump_malloc(i64 noundef 32)
  %38 = getelementptr i8, ptr %37, i64 16
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 8
  store ptr @_parameterization_i32, ptr %39, align 8
  %40 = getelementptr i8, ptr %37, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %37)
  store ptr @Pair, ptr %37, align 8
  %42 = alloca [3 x ptr], align 8
  store ptr @Enumerator, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %42, i64 8
  store ptr %33, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  store ptr %37, ptr %44, align 8
  %45 = load ptr, ptr getelementptr (i8, ptr @Enumerator, i64 48), align 8
  %46 = call { i64, i64 } @size_wrapper(ptr %45, ptr noundef nonnull align 8 dereferenceable(24) %42)
  %47 = extractvalue { i64, i64 } %46, 0
  %48 = call ptr @bump_malloc(i64 %47)
  store ptr %33, ptr %48, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  store ptr %37, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %48)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract63)
  %52 = load ptr, ptr %9, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract65) #31
  %55 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  store ptr %.fca.0.extract14, ptr %55, align 8
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %55, i64 8
  store ptr %.fca.1.extract15, ptr %.fca.1.gep, align 8
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %55, i64 16
  store ptr %.fca.2.extract16, ptr %.fca.2.gep, align 8
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %55, i64 24
  store i32 %.fca.3.extract17, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %55, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %56 = load ptr, ptr %55, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %56, 0
  %58 = load ptr, ptr %.fca.1.gep, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 1
  %60 = load ptr, ptr %.fca.2.gep, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %60, 2
  %62 = load i32, ptr %.fca.3.gep, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %62, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %56)
  %66 = sext i32 %62 to i64
  %67 = getelementptr ptr, ptr %56, i64 %66
  %68 = getelementptr i8, ptr %67, i64 24
  %69 = load ptr, ptr %68, align 8
  %70 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %63, ptr noundef nonnull align 8 %4)
  %71 = call { ptr, ptr, ptr, i32 } %70({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %72 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %73 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %74 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %.fca.1.extract, 1
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %.fca.2.extract, 2
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %73, 3
  %78 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %48, 1
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr undef, 2
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 10, 3
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract63)
  %82 = load ptr, ptr %8, align 8
  %83 = call ptr @typegetter_wrapper(ptr %82, ptr %.fca.1.extract65)
  %84 = call ptr @bump_malloc(i64 noundef 24)
  %85 = getelementptr i8, ptr %84, i64 8
  store ptr %83, ptr %85, align 8
  %86 = getelementptr i8, ptr %84, i64 16
  store ptr null, ptr %86, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %84)
  store ptr @Iterator, ptr %84, align 8
  %88 = alloca [1 x ptr], align 8
  store ptr %84, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %88)
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @Enumerator)
  %91 = load ptr, ptr getelementptr (i8, ptr @Enumerator, i64 112), align 8
  %92 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %92, align 8
  %93 = call ptr @behavior_wrapper(ptr %91, { ptr, ptr, ptr, i32 } %80, ptr noundef nonnull align 8 dereferenceable(8) %92)
  call void %93({ ptr, ptr, ptr, i32 } %80, { ptr, ptr, ptr, i32 } %80, ptr nonnull %88, { ptr, ptr, ptr, i32 } %77)
  %94 = call i32 @get_offset(ptr noundef nonnull @Enumerator, ptr noundef nonnull @Iterator)
  %95 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 %94, 3
  ret { ptr, ptr, ptr, i32 } %95
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @EnumeratedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @EnumeratedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_buffer_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_buffer_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4, i32 %5) #3 {
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract21, ptr noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract21)
  %9 = sext i32 %7 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract21, i64 %9
  %11 = getelementptr i8, ptr %10, i64 24
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  call void %14(ptr %.fca.1.extract, { ptr } %3) #30
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract21)
  %16 = getelementptr i8, ptr %10, i64 32
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract, { ptr } %4) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract21)
  %21 = getelementptr i8, ptr %10, i64 40
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract, i32 %5) #30
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract21)
  %26 = getelementptr i8, ptr %10, i64 48
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %.fca.1.extract, i32 0) #30
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract21)
  %31 = getelementptr i8, ptr %10, i64 56
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %.fca.1.extract, i1 false) #30
  ret void
}

define { ptr, i160 } @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract20, ptr noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract20)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract20, i64 %8
  %10 = getelementptr i8, ptr %9, i64 48
  %11 = getelementptr i8, ptr %9, i64 40
  br label %12

12:                                               ; preds = %39, %4
  %.0 = phi ptr [ undef, %4 ], [ %.1, %39 ]
  %.sroa.048.0 = phi i64 [ undef, %4 ], [ %.sroa.048.1, %39 ]
  %.sroa.249.0 = phi i64 [ undef, %4 ], [ %.sroa.249.1, %39 ]
  %13 = load ptr, ptr %10, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract21) #31
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract20)
  %17 = load ptr, ptr %11, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract21) #31
  %20 = icmp slt i32 %15, %19
  br i1 %20, label %21, label %39

21:                                               ; preds = %12
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract20)
  %23 = call i32 %14(ptr %.fca.1.extract21) #31
  %24 = sext i32 %23 to i64
  %25 = shl nsw i64 %24, 5
  %26 = getelementptr i8, ptr %.fca.0.extract, i64 %25
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %26, i64 8
  %29 = load i160, ptr %28, align 4
  %.sroa.048.0.extract.trunc = trunc i160 %29 to i64
  %.sroa.249.0.extract.shift = lshr i160 %29, 64
  %.sroa.249.0.extract.trunc = trunc i160 %.sroa.249.0.extract.shift to i64
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract20)
  %31 = call i32 %14(ptr %.fca.1.extract21) #31
  %32 = add i32 %31, 1
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract20)
  %34 = getelementptr i8, ptr %13, i64 8
  %35 = load ptr, ptr %34, align 8
  call void %35(ptr %.fca.1.extract21, i32 %32) #30
  %36 = icmp ne ptr %27, @nil_typ
  %37 = icmp ne ptr %27, null
  %.not57 = and i1 %36, %37
  %38 = xor i1 %.not57, true
  br label %39

39:                                               ; preds = %21, %12
  %.reg2mem14.0.off0 = phi i1 [ %38, %21 ], [ false, %12 ]
  %.reg2mem16.0 = phi i1 [ %.not57, %21 ], [ false, %12 ]
  %.1 = phi ptr [ %27, %21 ], [ %.0, %12 ]
  %.sroa.048.1 = phi i64 [ %.sroa.048.0.extract.trunc, %21 ], [ %.sroa.048.0, %12 ]
  %.sroa.249.1 = phi i64 [ %.sroa.249.0.extract.trunc, %21 ], [ %.sroa.249.0, %12 ]
  br i1 %.reg2mem14.0.off0, label %12, label %40

40:                                               ; preds = %39
  br i1 %.reg2mem16.0, label %41, label %60

41:                                               ; preds = %40
  %42 = inttoptr i64 %.sroa.048.1 to ptr
  %43 = inttoptr i64 %.sroa.249.1 to ptr
  %44 = call i32 @get_offset(ptr %.1, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.1, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %42, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %43, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %44, 3
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.1)
  %51 = sext i32 %44 to i64
  %52 = getelementptr ptr, ptr %.1, i64 %51
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8
  %55 = call ptr @behavior_wrapper(ptr %54, { ptr, ptr, ptr, i32 } %48, ptr noundef nonnull align 8 %5)
  %56 = call { ptr, ptr, ptr, i32 } %55({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull %5)
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract29 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %57 = call i32 @get_offset(ptr %.fca.0.extract27, ptr noundef nonnull @Pair)
  %58 = ptrtoint ptr %.fca.1.extract28 to i64
  %59 = ptrtoint ptr %.fca.2.extract29 to i64
  %.sroa.626.8.insert.ext = zext i32 %57 to i160
  %.sroa.626.8.insert.shift = shl nuw i160 %.sroa.626.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %59 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.shift, %.sroa.626.8.insert.shift
  %.sroa.3.8.insert.ext = zext i64 %58 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext
  br label %60

60:                                               ; preds = %41, %40
  %.reg2mem12.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %41 ], [ undef, %40 ]
  %.reg2mem12.sroa.0.0 = phi ptr [ %.fca.0.extract27, %41 ], [ @nil_typ, %40 ]
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem12.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.reg2mem12.sroa.3.0, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

define { ptr, i160 } @CuckooMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %8 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract28)
  %10 = sext i32 %8 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract28, i64 %10
  %12 = getelementptr i8, ptr %11, i64 56
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i1 %14(ptr %.fca.1.extract29) #31
  br i1 %15, label %49, label %16

16:                                               ; preds = %3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract28)
  %18 = getelementptr i8, ptr %11, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call { ptr } %20(ptr %.fca.1.extract29) #31
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract29, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %8, 3
  %26 = call ptr @bump_malloc(i64 noundef 16)
  %27 = getelementptr i8, ptr %26, i64 8
  store ptr null, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %26)
  store ptr @buffer_typ, ptr %26, align 8
  store ptr %26, ptr %4, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract28)
  %31 = getelementptr i8, ptr %11, i64 72
  %32 = load ptr, ptr %31, align 8
  store ptr @buffer_typ, ptr %5, align 8
  %33 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %25, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %34 = call { ptr, i160 } %33({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %4, { ptr } %21)
  %.fca.0.extract41 = extractvalue { ptr, i160 } %34, 0
  %35 = icmp ne ptr %.fca.0.extract41, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract41, null
  %.not48.not.not = and i1 %35, %36
  br i1 %.not48.not.not, label %37, label %39

37:                                               ; preds = %16
  %.fca.1.extract42 = extractvalue { ptr, i160 } %34, 1
  %38 = call i32 @get_offset(ptr nonnull %.fca.0.extract41, ptr noundef nonnull @Pair)
  %.sroa.5.8.insert.ext = zext i32 %38 to i160
  %.sroa.5.8.insert.shift = shl nuw i160 %.sroa.5.8.insert.ext, 128
  %.sroa.3.8.insert.ext = and i160 %.fca.1.extract42, 340282366920938463463374607431768211455
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.shift, %.sroa.3.8.insert.ext
  br label %49

39:                                               ; preds = %16
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract28)
  %41 = getelementptr i8, ptr %11, i64 48
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %.fca.1.extract29, i32 0) #30
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract28)
  %46 = load ptr, ptr %12, align 8
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  call void %48(ptr %.fca.1.extract29, i1 true) #30
  br label %49

49:                                               ; preds = %39, %37, %3
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract41, %37 ], [ poison, %39 ], [ poison, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %37 ], [ poison, %39 ], [ poison, %3 ]
  %.reg2mem13.0 = phi i1 [ true, %37 ], [ false, %39 ], [ false, %3 ]
  br i1 %.reg2mem13.0, label %69, label %50

50:                                               ; preds = %49
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract28)
  %52 = getelementptr i8, ptr %11, i64 32
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr } %54(ptr %.fca.1.extract29) #31
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.1.extract29, 1
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.2.extract, 2
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %8, 3
  %60 = call ptr @bump_malloc(i64 noundef 16)
  %61 = getelementptr i8, ptr %60, i64 8
  store ptr null, ptr %61, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %60)
  store ptr @buffer_typ, ptr %60, align 8
  store ptr %60, ptr %6, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract28)
  %65 = getelementptr i8, ptr %11, i64 72
  %66 = load ptr, ptr %65, align 8
  store ptr @buffer_typ, ptr %7, align 8
  %67 = call ptr @behavior_wrapper(ptr %66, { ptr, ptr, ptr, i32 } %59, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %68 = call { ptr, i160 } %67({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull %6, { ptr } %55)
  %.fca.0.extract30 = extractvalue { ptr, i160 } %68, 0
  %.fca.1.extract31 = extractvalue { ptr, i160 } %68, 1
  br label %69

69:                                               ; preds = %50, %49
  %.reg2mem11.sroa.0.0 = phi ptr [ %.fca.0.extract30, %50 ], [ %.reg2mem15.sroa.0.0, %49 ]
  %.reg2mem11.sroa.3.0 = phi i160 [ %.fca.1.extract31, %50 ], [ %.reg2mem15.sroa.3.0, %49 ]
  %.reload12.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem11.sroa.0.0, 0
  %.reload12.fca.1.insert = insertvalue { ptr, i160 } %.reload12.fca.0.insert, i160 %.reg2mem11.sroa.3.0, 1
  ret { ptr, i160 } %.reload12.fca.1.insert
}

define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #3 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 20, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 20
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = extractvalue { i64, i64 } %21, 1
  %24 = call i64 @llvm.umax.i64(i64 %9, i64 %23)
  %25 = call i64 @llvm.umax.i64(i64 %24, i64 noundef 8), !range !1
  %26 = urem i64 %15, %23
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %23, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %22, %15
  %31 = add i64 %30, %29
  %32 = urem i64 %31, %25
  %33 = icmp eq i64 %32, 0
  %34 = sub i64 %25, %32
  %35 = select i1 %33, i64 0, i64 %34
  %36 = add i64 %31, %35
  %37 = insertvalue { i64, i64 } undef, i64 %36, 0
  %38 = insertvalue { i64, i64 } %37, i64 %25, 1
  ret { i64, i64 } %38
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @Entry_B_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 160
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_primary_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_to_pair_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Entry_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #3 {
  %.fca.0.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract22, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract22)
  %9 = sext i32 %7 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract22, i64 %9
  %11 = getelementptr i8, ptr %10, i64 24
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  call void %14(ptr %.fca.1.extract23, { ptr, i160 } %3) #30
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract22)
  %16 = getelementptr i8, ptr %10, i64 32
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract23, { ptr, i160 } %4) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract22)
  %21 = getelementptr i8, ptr %10, i64 16
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract23, i32 %5) #30
  ret void
}

define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract7)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract8) #31
  ret { ptr, i160 } %11
}

define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract7)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = getelementptr i8, ptr %7, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract8) #31
  ret { ptr, i160 } %11
}

define i32 @Entry_primary_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  ret i32 %11
}

define { ptr, ptr, ptr, i32 } @Entry_to_pair_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract57, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr, i160 } %10(ptr %.fca.1.extract58) #31
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %13 = getelementptr i8, ptr %7, i64 32
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call { ptr, i160 } %15(ptr %.fca.1.extract58) #31
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %18 = load ptr, ptr %7, align 8
  %19 = call ptr @typegetter_wrapper(ptr %18, ptr %.fca.1.extract58)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %21 = getelementptr i8, ptr %7, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = call ptr @typegetter_wrapper(ptr %22, ptr %.fca.1.extract58)
  %24 = alloca [3 x ptr], align 8
  store ptr @Pair, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %24, i64 8
  store ptr %19, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %24, i64 16
  store ptr %23, ptr %26, align 8
  %27 = load ptr, ptr getelementptr (i8, ptr @Pair, i64 48), align 8
  %28 = call { i64, i64 } @size_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(24) %24)
  %29 = extractvalue { i64, i64 } %28, 0
  %30 = call ptr @bump_malloc(i64 %29)
  store ptr %19, ptr %30, align 8
  %31 = getelementptr i8, ptr %30, i64 8
  store ptr %23, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %30)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %34 = load ptr, ptr %8, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr, i160 } %35(ptr %.fca.1.extract58) #31
  %.fca.0.extract12 = extractvalue { ptr, i160 } %36, 0
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %38 = load ptr, ptr %13, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, i160 } %39(ptr %.fca.1.extract58) #31
  %.fca.0.extract = extractvalue { ptr, i160 } %40, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %30, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr undef, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 10, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %45 = load ptr, ptr %7, align 8
  %46 = call ptr @typegetter_wrapper(ptr %45, ptr %.fca.1.extract58)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract57)
  %48 = load ptr, ptr %21, align 8
  %49 = call ptr @typegetter_wrapper(ptr %48, ptr %.fca.1.extract58)
  %50 = alloca [2 x ptr], align 8
  store ptr %46, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %49, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %50)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Pair)
  %54 = load ptr, ptr getelementptr (i8, ptr @Pair, i64 144), align 8
  %55 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract12, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %55, i64 8
  store ptr %.fca.0.extract, ptr %56, align 8
  %57 = call ptr @behavior_wrapper(ptr %54, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 dereferenceable(16) %55)
  call void %57({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull %50, { ptr, i160 } %36, { ptr, i160 } %40)
  %58 = call i32 @get_offset(ptr noundef nonnull @Pair, ptr noundef nonnull @Pair)
  %59 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %58, 3
  ret { ptr, ptr, ptr, i32 } %59
}

define { ptr, i160 } @Entry_getter_value(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = extractvalue { i64, i64 } %6, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %20 = call { i64, i64 } @size_wrapper(ptr %19, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %21 = extractvalue { i64, i64 } %20, 1
  %22 = urem i64 %14, %21
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 %21, %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = getelementptr i8, ptr %0, i64 %14
  %27 = getelementptr i8, ptr %26, i64 %25
  %28 = load ptr, ptr %15, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = call { ptr, i160 } @box_wrapper(ptr %31, ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %28)
  ret { ptr, i160 } %32
}

define void @Entry_setter_value(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 20, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 20
  %15 = add i64 %14, %13
  %16 = getelementptr inbounds i8, ptr %0, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 1
  %23 = urem i64 %15, %22
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %22, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = getelementptr i8, ptr %0, i64 %15
  %28 = getelementptr i8, ptr %27, i64 %26
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  call void @unbox_wrapper(ptr %32, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %29, ptr %28)
  ret void
}

define { ptr, i160 } @Entry_getter_key(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = load ptr, ptr %0, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 56
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } @box_wrapper(ptr %16, ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %13)
  ret { ptr, i160 } %17
}

define void @Entry_setter_key(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %reass.sub = sub i64 %8, %9
  %11 = add i64 %reass.sub, 20
  %12 = select i1 %10, i64 20, i64 %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load ptr, ptr %0, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 64
  %17 = load ptr, ptr %16, align 8
  call void @unbox_wrapper(ptr %17, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %14, ptr %13)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_primary_hash(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_primary_hash(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @CuckooMapIterator_getter_on_second(ptr nocapture nofree readonly %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_on_second(ptr nocapture nofree writeonly %0, i1 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_table_len(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_KeyNotFound(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @String, align 4
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 noundef ptrtoint (ptr @String to i64), ptr %13)
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = getelementptr i8, ptr %16, i64 168
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @String_field_String_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_core.Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_byte_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #29
  ret ptr @String__Self_from_bytes_source_bytesBufferi8_source_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #29
  ret ptr @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  ret ptr @String__Self_from_c_string_c_stringBufferi8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 528
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_empty_(ptr nocapture nofree %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #29
  ret ptr @String__Self_empty_
}

define noundef nonnull ptr @String_B__Self_from_iterable_iterableIterableCharacter(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %12 = load i64, ptr @Iterable, align 4
  %13 = call i1 @subtype_test_wrapper(ptr %10, i64 %9, i64 %8, i64 %12, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %11)
  ret ptr @String__Self_from_iterable_iterableIterableCharacter
}

define ptr @String_B_append_charCharacter({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6681222582356018452, i64 noundef ptrtoint (ptr @Character to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 584
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_last_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B_extend_otherIterableT_extend_otherCollectionCharacter_extend_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Collection, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Collection to i64), ptr %18)
  br i1 %20, label %21, label %.critedge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %25)
  br i1 %26, label %.critedge, label %._crit_edge

.critedge:                                        ; preds = %21, %14
  %27 = load i64, ptr %5, align 4
  %28 = load i64, ptr %6, align 4
  %29 = load ptr, ptr %7, align 8
  %30 = load ptr, ptr %8, align 8
  %31 = load i64, ptr @Iterable, align 4
  %32 = call i1 @subtype_test_wrapper(ptr %29, i64 %28, i64 %27, i64 %31, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %30)
  br i1 %32, label %33, label %._crit_edge

33:                                               ; preds = %.critedge
  %34 = load i64, ptr %5, align 4
  %35 = load i64, ptr %6, align 4
  %36 = load ptr, ptr %7, align 8
  %37 = load ptr, ptr %8, align 8
  %38 = call i1 @subtype_test_wrapper(ptr %36, i64 %35, i64 %34, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %37)
  br label %._crit_edge

._crit_edge:                                      ; preds = %33, %.critedge, %21, %2
  %.reg2mem7.0 = phi i32 [ 69, %2 ], [ 67, %.critedge ], [ 67, %33 ], [ 68, %21 ]
  %39 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %40 = zext nneg i32 %.reg2mem7.0 to i64
  %41 = getelementptr [314 x ptr], ptr %39, i64 0, i64 %40
  %42 = getelementptr i8, ptr %41, i64 80
  %43 = load ptr, ptr %42, align 8
  ret ptr %43
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6681222582356018452, i64 noundef ptrtoint (ptr @Character to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 648
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 656
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 664
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 672
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 680
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6681222582356018452, i64 noundef ptrtoint (ptr @Character to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 688
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 696
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 704
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 712
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 81, i64 80
  %8 = getelementptr [314 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 736
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 83, %22 ], [ 83, %15 ], [ 84, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [314 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 86, %22 ], [ 86, %15 ], [ 85, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [314 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @String_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 88, %22 ], [ 88, %15 ], [ 87, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [314 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @String_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 90, %22 ], [ 90, %15 ], [ 89, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [314 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 808
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define i32 @String_byte_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  ret i32 %11
}

define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  ret i32 %11
}

define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca [4 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %13 = alloca [3 x ptr], align 8
  %14 = alloca { ptr, ptr, ptr }, align 8
  %15 = alloca [1 x ptr], align 8
  store ptr @String, ptr %15, align 8
  %16 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %17 = extractvalue { i64, i64 } %16, 0
  %18 = call ptr @bump_malloc(i64 %17)
  %19 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %18, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr undef, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 10, 3
  %22 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %22, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %22)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %25 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %25, align 8
  %26 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_capacityi32, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 dereferenceable(8) %25)
  call void %26({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %22, i32 %2)
  %27 = getelementptr inbounds i8, ptr %5, i64 8
  %28 = getelementptr inbounds i8, ptr %5, i64 16
  %29 = getelementptr inbounds i8, ptr %6, i64 8
  %30 = getelementptr inbounds i8, ptr %6, i64 16
  %31 = getelementptr inbounds i8, ptr %9, i64 8
  %32 = getelementptr inbounds i8, ptr %9, i64 16
  %33 = getelementptr inbounds i8, ptr %9, i64 24
  %34 = getelementptr inbounds i8, ptr %10, i64 8
  %35 = getelementptr inbounds i8, ptr %10, i64 16
  %36 = getelementptr inbounds i8, ptr %10, i64 24
  %37 = getelementptr inbounds i8, ptr %11, i64 8
  %38 = getelementptr inbounds i8, ptr %12, i64 8
  %39 = getelementptr inbounds i8, ptr %13, i64 8
  %40 = getelementptr inbounds i8, ptr %13, i64 16
  %41 = getelementptr inbounds i8, ptr %14, i64 8
  %42 = getelementptr inbounds i8, ptr %14, i64 16
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge, %3
  %.0 = phi i32 [ 0, %3 ], [ %.1, %._crit_edge ]
  %43 = icmp slt i32 %.0, %2
  br i1 %43, label %44, label %._crit_edge

44:                                               ; preds = %._crit_edge3
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %27, align 8
  store ptr @_parameterization_i32, ptr %28, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %5)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  store ptr @buffer_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %29, align 8
  store ptr @i32_typ, ptr %30, align 8
  %47 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr noundef nonnull align 8 dereferenceable(24) %6)
  %48 = call { ptr, i64 } %47(ptr nonnull %5, { ptr } %1, i32 %.0, i32 %2)
  %.fca.0.extract81 = extractvalue { ptr, i64 } %48, 0
  %.fca.1.extract82 = extractvalue { ptr, i64 } %48, 1
  %49 = icmp eq ptr %.fca.0.extract81, @nil_typ
  %50 = icmp eq ptr %.fca.0.extract81, null
  %51 = or i1 %49, %50
  br i1 %51, label %52, label %._crit_edge1

52:                                               ; preds = %44
  store ptr @InvalidUTF8Error, ptr %7, align 8
  %53 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_InvalidUTF8Error, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %54 = extractvalue { i64, i64 } %53, 0
  %55 = call ptr @bump_malloc(i64 %54)
  %56 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InvalidUTF8Error, ptr undef, ptr undef, i32 undef }, ptr %55, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr undef, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 10, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error)
  %61 = call ptr @behavior_wrapper(ptr noundef nonnull @InvalidUTF8Error_B_init_, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  call void %61({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull %4)
  %62 = call ptr @bump_malloc(i64 noundef 56)
  store <55 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 99, i8 111, i8 114, i8 101, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %62, align 1
  store ptr @String, ptr %8, align 8
  %63 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %64 = extractvalue { i64, i64 } %63, 0
  %65 = call ptr @bump_malloc(i64 %64)
  %66 = insertvalue { ptr } undef, ptr %62, 0
  %67 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %65, 1
  %68 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr undef, 2
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %9, align 8
  store ptr @_parameterization_i32, ptr %31, align 8
  store ptr @_parameterization_i32, ptr %32, align 8
  store ptr @_parameterization_i32, ptr %33, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %9)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %10, align 8
  store ptr @i32_typ, ptr %34, align 8
  store ptr @i32_typ, ptr %35, align 8
  store ptr @i32_typ, ptr %36, align 8
  %72 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %69, ptr noundef nonnull align 8 dereferenceable(32) %10)
  call void %72({ ptr, ptr, ptr, i32 } %69, { ptr, ptr, ptr, i32 } %69, ptr nonnull %9, { ptr } %66, i32 55, i32 55, i32 56)
  %73 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %74 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %73, 3
  store ptr @_parameterization_i32, ptr %11, align 8
  store ptr @_parameterization_core.String, ptr %37, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error)
  store ptr @i32_typ, ptr %12, align 8
  store ptr @String, ptr %38, align 8
  %77 = call ptr @behavior_wrapper(ptr noundef nonnull @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 dereferenceable(16) %12)
  call void %77({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull %11, i32 141, { ptr, ptr, ptr, i32 } %74)
  %78 = ptrtoint ptr %55 to i64
  %.sroa.475.8.insert.ext = zext i64 %78 to i160
  %.sroa.475.8.insert.insert = or disjoint i160 %.sroa.475.8.insert.ext, 3402823669209384634633746074317682114560
  %79 = call ptr @get_current_coroutine()
  %80 = getelementptr i8, ptr %79, i64 48
  store ptr @InvalidUTF8Error, ptr %80, align 8
  %81 = getelementptr i8, ptr %79, i64 56
  store i160 %.sroa.475.8.insert.insert, ptr %81, align 4
  call void @coroutine_yield_cold(ptr noundef align 8 %79)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %52, %44
  %.sroa.083.0 = phi ptr [ @nil_typ, %52 ], [ %.fca.0.extract81, %44 ]
  %82 = icmp ne ptr %.sroa.083.0, @nil_typ
  %83 = icmp ne ptr %.sroa.083.0, null
  %.not88 = and i1 %82, %83
  br i1 %.not88, label %84, label %._crit_edge

84:                                               ; preds = %._crit_edge1
  %85 = bitcast i64 %.fca.1.extract82 to <2 x i32>
  %.4.vec.extract = extractelement <2 x i32> %85, i64 1
  store ptr @_parameterization_Bufferi8, ptr %13, align 8
  store ptr @_parameterization_i32, ptr %39, align 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %13)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %14, align 8
  store ptr @i32_typ, ptr %41, align 8
  store ptr @i32_typ, ptr %42, align 8
  %88 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 dereferenceable(24) %14)
  %89 = call { ptr, ptr, ptr, i32 } %88({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %13, { ptr } %1, i32 %.0, i32 %.4.vec.extract)
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %89, 0
  %90 = call i32 @get_offset(ptr %.fca.0.extract33, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %91 = add i32 %.4.vec.extract, %.0
  br label %._crit_edge

._crit_edge:                                      ; preds = %84, %._crit_edge1, %._crit_edge3
  %.1 = phi i32 [ %91, %84 ], [ %.0, %._crit_edge1 ], [ %.0, %._crit_edge3 ]
  br i1 %43, label %._crit_edge3, label %92

92:                                               ; preds = %._crit_edge
  %93 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %94 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %93, 3
  ret { ptr, ptr, ptr, i32 } %94
}

define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr }, align 8
  %7 = alloca [3 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr }, align 8
  %9 = alloca [3 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  store ptr @String, ptr %11, align 8
  %12 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = call ptr @bump_malloc(i64 %13)
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %14, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 10, 3
  %18 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %21 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %21, align 8
  %22 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_capacityi32, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(8) %21)
  call void %22({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %18, i32 %2)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %25 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_replacement_buf_, ptr noundef nonnull align 8 %4)
  %26 = call { ptr } %25(ptr nonnull %4)
  %27 = getelementptr inbounds i8, ptr %5, i64 8
  %28 = getelementptr inbounds i8, ptr %5, i64 16
  %29 = getelementptr inbounds i8, ptr %6, i64 8
  %30 = getelementptr inbounds i8, ptr %6, i64 16
  %31 = getelementptr inbounds i8, ptr %9, i64 8
  %32 = getelementptr inbounds i8, ptr %9, i64 16
  %33 = getelementptr inbounds i8, ptr %10, i64 8
  %34 = getelementptr inbounds i8, ptr %10, i64 16
  %35 = getelementptr inbounds i8, ptr %7, i64 8
  %36 = getelementptr inbounds i8, ptr %7, i64 16
  %37 = getelementptr inbounds i8, ptr %8, i64 8
  %38 = getelementptr inbounds i8, ptr %8, i64 16
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %3
  %.0 = phi i32 [ 0, %3 ], [ %.1, %._crit_edge ]
  %39 = icmp slt i32 %.0, %2
  br i1 %39, label %40, label %._crit_edge

40:                                               ; preds = %._crit_edge1
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %27, align 8
  store ptr @_parameterization_i32, ptr %28, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %5)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  store ptr @buffer_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %29, align 8
  store ptr @i32_typ, ptr %30, align 8
  %43 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr noundef nonnull align 8 dereferenceable(24) %6)
  %44 = call { ptr, i64 } %43(ptr nonnull %5, { ptr } %1, i32 %.0, i32 %2)
  %.fca.0.extract61 = extractvalue { ptr, i64 } %44, 0
  %45 = icmp ne ptr %.fca.0.extract61, @nil_typ
  %46 = icmp ne ptr %.fca.0.extract61, null
  %.not68 = and i1 %45, %46
  br i1 %.not68, label %47, label %55

47:                                               ; preds = %40
  %.fca.1.extract62 = extractvalue { ptr, i64 } %44, 1
  %48 = bitcast i64 %.fca.1.extract62 to <2 x i32>
  %.4.vec.extract = extractelement <2 x i32> %48, i64 1
  store ptr @_parameterization_Bufferi8, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %35, align 8
  store ptr @_parameterization_i32, ptr %36, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %7)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %37, align 8
  store ptr @i32_typ, ptr %38, align 8
  %51 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(24) %8)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %7, { ptr } %1, i32 %.0, i32 %.4.vec.extract)
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %53 = call i32 @get_offset(ptr %.fca.0.extract49, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %54 = add i32 %.4.vec.extract, %.0
  br label %._crit_edge

55:                                               ; preds = %40
  store ptr @_parameterization_Bufferi8, ptr %9, align 8
  store ptr @_parameterization_i32, ptr %31, align 8
  store ptr @_parameterization_i32, ptr %32, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %9)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %10, align 8
  store ptr @i32_typ, ptr %33, align 8
  store ptr @i32_typ, ptr %34, align 8
  %58 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(24) %10)
  %59 = call { ptr, ptr, ptr, i32 } %58({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %9, { ptr } %26, i32 0, i32 3)
  %.fca.0.extract42 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %60 = call i32 @get_offset(ptr %.fca.0.extract42, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %61 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %55, %47, %._crit_edge1
  %.1 = phi i32 [ %54, %47 ], [ %61, %55 ], [ %.0, %._crit_edge1 ]
  br i1 %39, label %._crit_edge1, label %62

62:                                               ; preds = %._crit_edge
  %63 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %64 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %63, 3
  ret { ptr, ptr, ptr, i32 } %64
}

define { ptr, ptr, ptr, i32 } @String__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree readnone %0, { ptr } %1) #3 {
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %2
  %.0 = phi i32 [ 0, %2 ], [ %.1, %._crit_edge ]
  %5 = sext i32 %.0 to i64
  %6 = getelementptr i8, ptr %.fca.0.extract, i64 %5
  %7 = load i8, ptr %6, align 1
  %.not = icmp ne i8 %7, 0
  %8 = zext i1 %.not to i32
  %.1 = add i32 %.0, %8
  br i1 %.not, label %._crit_edge, label %9

9:                                                ; preds = %._crit_edge
  store ptr @_parameterization_Bufferi8, ptr %3, align 8
  %10 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %10, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3) #39
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String) #39
  store ptr @buffer_typ, ptr %4, align 8
  %13 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %13, align 8
  %14 = call ptr @class_behavior_wrapper(ptr noundef nonnull @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr noundef nonnull align 8 dereferenceable(16) %4)
  %15 = call { ptr, ptr, ptr, i32 } %14(ptr nonnull %3, { ptr } %1, i32 %.1)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %16 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %17 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract15, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %17, 3
  ret { ptr, ptr, ptr, i32 } %21
}

define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %5 = call ptr @bump_malloc(i64 noundef 1)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %4 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr } undef, ptr %5, 0
  call void %11(ptr %.fca.1.extract, { ptr } %12) #30
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 1) #30
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = getelementptr i8, ptr %8, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 0) #30
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %24 = getelementptr i8, ptr %8, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  call void %27(ptr %.fca.1.extract, i32 0) #30
  ret void
}

define void @String_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #30
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = load ptr, ptr %9, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #31
  %17 = sext i32 %16 to i64
  %18 = call ptr @bump_malloc(i64 %17)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %20 = load ptr, ptr %8, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr } undef, ptr %18, 0
  call void %22(ptr %.fca.1.extract, { ptr } %23) #30
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %25 = getelementptr i8, ptr %8, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %.fca.1.extract, i32 0) #30
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %30 = getelementptr i8, ptr %8, i64 16
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  call void %33(ptr %.fca.1.extract, i32 0) #30
  ret void
}

define void @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5, i32 %6) #3 {
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %8 = call i32 @get_offset(ptr %.fca.0.extract16, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract16)
  %10 = sext i32 %8 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract16, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  call void %14(ptr %.fca.1.extract, { ptr } %3) #30
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract16)
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract, i32 %4) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract16)
  %21 = getelementptr i8, ptr %11, i64 16
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract, i32 %5) #30
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract16)
  %26 = getelementptr i8, ptr %11, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %.fca.1.extract, i32 %6) #30
  ret void
}

define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract46 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract46, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract46)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract46, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call i32 %11(ptr %.fca.1.extract47) #31
  %13 = add i32 %12, 1
  %14 = sext i32 %13 to i64
  %15 = call ptr @bump_malloc(i64 %14)
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract46)
  %17 = load ptr, ptr %9, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract47) #31
  %20 = alloca [1 x ptr], align 8
  store ptr @Range, ptr %20, align 8
  %21 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %22 = call { i64, i64 } @size_wrapper(ptr %21, ptr noundef nonnull align 8 dereferenceable(8) %20)
  %23 = extractvalue { i64, i64 } %22, 0
  %24 = call ptr @bump_malloc(i64 %23)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract46)
  %26 = load ptr, ptr %9, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract47) #31
  %29 = add i32 %28, -1
  %30 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %24, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr undef, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 10, 3
  %33 = alloca [2 x ptr], align 8
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %33, i64 8
  store ptr @_parameterization_i32, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %33)
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %37 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  %38 = alloca { ptr, ptr }, align 8
  store ptr @i32_typ, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr @i32_typ, ptr %39, align 8
  %40 = call ptr @behavior_wrapper(ptr %37, { ptr, ptr, ptr, i32 } %32, ptr noundef nonnull align 8 dereferenceable(16) %38)
  call void %40({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull %33, i32 0, i32 %29)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %43 = load ptr, ptr getelementptr (i8, ptr @Range, i64 152), align 8
  %44 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %32, ptr noundef nonnull align 8 %4)
  %45 = call { ptr, ptr, ptr, i32 } %44({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %46 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @RangeIterator)
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %46, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %53 = sext i32 %46 to i64
  %54 = getelementptr ptr, ptr %.fca.0.extract, i64 %53
  %55 = getelementptr i8, ptr %54, i64 40
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %3
  %56 = load ptr, ptr %55, align 8
  %57 = call ptr @behavior_wrapper(ptr %56, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 %4)
  %58 = call { ptr, i160 } %57({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %4)
  %.fca.0.extract70 = extractvalue { ptr, i160 } %58, 0
  %59 = icmp ne ptr %.fca.0.extract70, @nil_typ
  %60 = icmp ne ptr %.fca.0.extract70, null
  %.not73 = and i1 %59, %60
  br i1 %.not73, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  %.fca.1.extract71 = extractvalue { ptr, i160 } %58, 1
  %.sroa.0.8.extract.trunc = trunc i160 %.fca.1.extract71 to i32
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract46)
  %62 = load ptr, ptr %8, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call { ptr } %63(ptr %.fca.1.extract47) #31
  %.fca.0.extract62 = extractvalue { ptr } %64, 0
  %65 = sext i32 %.sroa.0.8.extract.trunc to i64
  %66 = getelementptr i8, ptr %.fca.0.extract62, i64 %65
  %67 = load i8, ptr %66, align 1
  %68 = getelementptr i8, ptr %15, i64 %65
  store i8 %67, ptr %68, align 1
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract46)
  %70 = load ptr, ptr %9, align 8
  %71 = load ptr, ptr %70, align 8
  %72 = call i32 %71(ptr %.fca.1.extract47) #31
  %73 = sext i32 %72 to i64
  %74 = getelementptr i8, ptr %15, i64 %73
  store i8 0, ptr %74, align 1
  %75 = insertvalue { ptr } undef, ptr %15, 0
  ret { ptr } %75
}

define { ptr, ptr, ptr, i32 } @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #3 {
  %7 = alloca [0 x ptr], align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %13 = call i32 @get_offset(ptr %.fca.0.extract45, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %15 = sext i32 %13 to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract45, i64 %15
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr %.fca.1.extract) #31
  %21 = add i32 %20, %5
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %23 = getelementptr i8, ptr %16, i64 24
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr %.fca.1.extract) #31
  %.not = icmp slt i32 %21, %26
  br i1 %.not, label %._crit_edge, label %27

27:                                               ; preds = %6
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %29 = call i32 %25(ptr %.fca.1.extract) #31
  %30 = shl i32 %29, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %13, 3
  store ptr @_parameterization_i32, ptr %8, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %37 = getelementptr i8, ptr %16, i64 120
  %38 = load ptr, ptr %37, align 8
  store ptr @i32_typ, ptr %9, align 8
  %39 = call ptr @behavior_wrapper(ptr %38, { ptr, ptr, ptr, i32 } %34, ptr noundef nonnull align 8 dereferenceable(8) %9)
  call void %39({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %8, i32 %30)
  br label %._crit_edge

._crit_edge:                                      ; preds = %27, %6
  store ptr @Range, ptr %10, align 8
  %40 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %41 = call { i64, i64 } @size_wrapper(ptr %40, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %42 = extractvalue { i64, i64 } %41, 0
  %43 = call ptr @bump_malloc(i64 %42)
  %44 = add i32 %5, -1
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %43, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 10, 3
  store ptr @_parameterization_i32, ptr %11, align 8
  %48 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %51 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  store ptr @i32_typ, ptr %12, align 8
  %52 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @i32_typ, ptr %52, align 8
  %53 = call ptr @behavior_wrapper(ptr %51, { ptr, ptr, ptr, i32 } %47, ptr noundef nonnull align 8 dereferenceable(16) %12)
  call void %53({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull %11, i32 0, i32 %44)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %7)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %56 = load ptr, ptr getelementptr (i8, ptr @Range, i64 152), align 8
  %57 = call ptr @behavior_wrapper(ptr %56, { ptr, ptr, ptr, i32 } %47, ptr noundef nonnull align 8 %7)
  %58 = call { ptr, ptr, ptr, i32 } %57({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull align 8 %7)
  %.fca.0.extract83 = extractvalue { ptr, ptr, ptr, i32 } %58, 0
  %.fca.1.extract85 = extractvalue { ptr, ptr, ptr, i32 } %58, 1
  %.fca.2.extract87 = extractvalue { ptr, ptr, ptr, i32 } %58, 2
  %59 = call i32 @get_offset(ptr %.fca.0.extract83, ptr noundef nonnull @RangeIterator)
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract83, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract85, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract87, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %59, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %7)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract83)
  %66 = sext i32 %59 to i64
  %67 = getelementptr ptr, ptr %.fca.0.extract83, i64 %66
  %68 = getelementptr i8, ptr %67, i64 40
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %._crit_edge1, %._crit_edge
  %69 = load ptr, ptr %68, align 8
  %70 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %63, ptr noundef nonnull align 8 %7)
  %71 = call { ptr, i160 } %70({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull %7)
  %.fca.0.extract72 = extractvalue { ptr, i160 } %71, 0
  %72 = icmp ne ptr %.fca.0.extract72, @nil_typ
  %73 = icmp ne ptr %.fca.0.extract72, null
  %.not110 = and i1 %72, %73
  br i1 %.not110, label %._crit_edge1, label %.critedge

._crit_edge1:                                     ; preds = %._crit_edge2
  %.fca.1.extract73 = extractvalue { ptr, i160 } %71, 1
  %.sroa.0.8.extract.trunc = trunc i160 %.fca.1.extract73 to i32
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %75 = load ptr, ptr %17, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = call i32 %76(ptr %.fca.1.extract) #31
  %78 = add i32 %77, %.sroa.0.8.extract.trunc
  %79 = add i32 %4, %.sroa.0.8.extract.trunc
  %80 = sext i32 %79 to i64
  %81 = getelementptr i8, ptr %.fca.0.extract, i64 %80
  %82 = load i8, ptr %81, align 1
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %84 = load ptr, ptr %16, align 8
  %85 = load ptr, ptr %84, align 8
  %86 = call { ptr } %85(ptr %.fca.1.extract) #31
  %.fca.0.extract59 = extractvalue { ptr } %86, 0
  %87 = sext i32 %78 to i64
  %88 = getelementptr i8, ptr %.fca.0.extract59, i64 %87
  store i8 %82, ptr %88, align 1
  br label %._crit_edge2

.critedge:                                        ; preds = %._crit_edge2
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %90 = getelementptr i8, ptr %16, i64 16
  %91 = load ptr, ptr %90, align 8
  %92 = load ptr, ptr %91, align 8
  %93 = call i32 %92(ptr %.fca.1.extract) #31
  %94 = add i32 %93, 1
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %96 = getelementptr i8, ptr %91, i64 8
  %97 = load ptr, ptr %96, align 8
  call void %97(ptr %.fca.1.extract, i32 %94) #30
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %99 = load ptr, ptr %17, align 8
  %100 = load ptr, ptr %99, align 8
  %101 = call i32 %100(ptr %.fca.1.extract) #31
  %102 = add i32 %101, %5
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract45)
  %104 = getelementptr i8, ptr %99, i64 8
  %105 = load ptr, ptr %104, align 8
  call void %105(ptr %.fca.1.extract, i32 %102) #30
  %106 = call i32 @get_offset(ptr noundef %.fca.0.extract45, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %107 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %108 = insertvalue { ptr, ptr, ptr, i32 } %107, ptr %.fca.1.extract, 1
  %109 = insertvalue { ptr, ptr, ptr, i32 } %108, ptr %.fca.2.extract, 2
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, i32 %106, 3
  ret { ptr, ptr, ptr, i32 } %110
}

define void @String_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %9 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %11 = sext i32 %9 to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract, i64 %11
  %13 = getelementptr i8, ptr %12, i64 24
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #31
  %.not = icmp sgt i32 %3, %16
  br i1 %.not, label %17, label %.critedge

17:                                               ; preds = %4
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = getelementptr i8, ptr %14, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %.fca.1.extract, i32 %3) #30
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %22 = load ptr, ptr %12, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = call { ptr } %23(ptr %.fca.1.extract) #31
  %.fca.0.extract80 = extractvalue { ptr } %24, 0
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %26 = load ptr, ptr %13, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract) #31
  %29 = sext i32 %28 to i64
  %30 = call ptr @bump_malloc(i64 %29)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %32 = load ptr, ptr %12, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr } undef, ptr %30, 0
  call void %34(ptr %.fca.1.extract, { ptr } %35) #30
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %37 = getelementptr i8, ptr %12, i64 8
  %38 = load ptr, ptr %37, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call i32 %39(ptr %.fca.1.extract) #31
  store ptr @Range, ptr %6, align 8
  %41 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %42 = call { i64, i64 } @size_wrapper(ptr %41, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %43 = extractvalue { i64, i64 } %42, 0
  %44 = call ptr @bump_malloc(i64 %43)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %46 = load ptr, ptr %37, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call i32 %47(ptr %.fca.1.extract) #31
  %49 = add i32 %48, -1
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %44, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 10, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %53 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %56 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  store ptr @i32_typ, ptr %8, align 8
  %57 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %57, align 8
  %58 = call ptr @behavior_wrapper(ptr %56, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %58({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %7, i32 0, i32 %49)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %61 = load ptr, ptr getelementptr (i8, ptr @Range, i64 152), align 8
  %62 = call ptr @behavior_wrapper(ptr %61, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 %5)
  %63 = call { ptr, ptr, ptr, i32 } %62({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull align 8 %5)
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %63, 0
  %.fca.1.extract54 = extractvalue { ptr, ptr, ptr, i32 } %63, 1
  %.fca.2.extract56 = extractvalue { ptr, ptr, ptr, i32 } %63, 2
  %64 = call i32 @get_offset(ptr %.fca.0.extract52, ptr noundef nonnull @RangeIterator)
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract52, 0
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %.fca.1.extract54, 1
  %67 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %.fca.2.extract56, 2
  %68 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %64, 3
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract52)
  %71 = sext i32 %64 to i64
  %72 = getelementptr ptr, ptr %.fca.0.extract52, i64 %71
  %73 = getelementptr i8, ptr %72, i64 40
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %17
  %74 = load ptr, ptr %73, align 8
  %75 = call ptr @behavior_wrapper(ptr %74, { ptr, ptr, ptr, i32 } %68, ptr noundef nonnull align 8 %5)
  %76 = call { ptr, i160 } %75({ ptr, ptr, ptr, i32 } %68, { ptr, ptr, ptr, i32 } %68, ptr nonnull %5)
  %.fca.0.extract41 = extractvalue { ptr, i160 } %76, 0
  %77 = icmp ne ptr %.fca.0.extract41, @nil_typ
  %78 = icmp ne ptr %.fca.0.extract41, null
  %.not85 = and i1 %77, %78
  br i1 %.not85, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  %.fca.1.extract42 = extractvalue { ptr, i160 } %76, 1
  %.sroa.0.8.extract.trunc = trunc i160 %.fca.1.extract42 to i32
  %79 = sext i32 %.sroa.0.8.extract.trunc to i64
  %80 = getelementptr i8, ptr %.fca.0.extract80, i64 %79
  %81 = load i8, ptr %80, align 1
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %83 = load ptr, ptr %12, align 8
  %84 = load ptr, ptr %83, align 8
  %85 = call { ptr } %84(ptr %.fca.1.extract) #31
  %.fca.0.extract31 = extractvalue { ptr } %85, 0
  %86 = getelementptr i8, ptr %.fca.0.extract31, i64 %79
  store i8 %81, ptr %86, align 1
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1, %4
  ret void
}

define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %11 = call i32 @get_offset(ptr %.fca.0.extract24, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %12 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract24)
  %14 = sext i32 %11 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract24, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract25) #31
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %12, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %26 = sext i32 %12 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 40
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr @behavior_wrapper(ptr %29, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 %5)
  %31 = call i32 %30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull align 8 %5)
  %.not = icmp eq i32 %19, %31
  br i1 %.not, label %32, label %.critedge

32:                                               ; preds = %4
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract24)
  %34 = load ptr, ptr %16, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %.fca.1.extract25) #31
  store ptr @Range, ptr %6, align 8
  %37 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %38 = call { i64, i64 } @size_wrapper(ptr %37, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %39 = extractvalue { i64, i64 } %38, 0
  %40 = call ptr @bump_malloc(i64 %39)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract24)
  %42 = load ptr, ptr %16, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %.fca.1.extract25) #31
  %45 = add i32 %44, -1
  %46 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %40, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr undef, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 10, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %49 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %52 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  store ptr @i32_typ, ptr %8, align 8
  %53 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %53, align 8
  %54 = call ptr @behavior_wrapper(ptr %52, { ptr, ptr, ptr, i32 } %48, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %54({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull %7, i32 0, i32 %45)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %57 = load ptr, ptr getelementptr (i8, ptr @Range, i64 152), align 8
  %58 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %48, ptr noundef nonnull align 8 %5)
  %59 = call { ptr, ptr, ptr, i32 } %58({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 %5)
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  %.fca.2.extract61 = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  %60 = call i32 @get_offset(ptr %.fca.0.extract57, ptr noundef nonnull @RangeIterator)
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract59, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract61, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %60, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract57)
  %67 = sext i32 %60 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract57, i64 %67
  %69 = getelementptr i8, ptr %68, i64 40
  %70 = getelementptr i8, ptr %27, i64 144
  br label %71

71:                                               ; preds = %77, %32
  %72 = load ptr, ptr %69, align 8
  %73 = call ptr @behavior_wrapper(ptr %72, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 %5)
  %74 = call { ptr, i160 } %73({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %5)
  %.fca.0.extract46 = extractvalue { ptr, i160 } %74, 0
  %75 = icmp eq ptr %.fca.0.extract46, @nil_typ
  %76 = icmp eq ptr %.fca.0.extract46, null
  %.not83.not = or i1 %75, %76
  br i1 %.not83.not, label %.critedge, label %77

77:                                               ; preds = %71
  %.fca.1.extract47 = extractvalue { ptr, i160 } %74, 1
  %.sroa.0.8.extract.trunc = trunc i160 %.fca.1.extract47 to i32
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract24)
  %79 = load ptr, ptr %15, align 8
  %80 = load ptr, ptr %79, align 8
  %81 = call { ptr } %80(ptr %.fca.1.extract25) #31
  %.fca.0.extract38 = extractvalue { ptr } %81, 0
  %82 = sext i32 %.sroa.0.8.extract.trunc to i64
  %83 = getelementptr i8, ptr %.fca.0.extract38, i64 %82
  %84 = load i8, ptr %83, align 1
  store ptr @_parameterization_i32, ptr %9, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %87 = load ptr, ptr %70, align 8
  store ptr @i32_typ, ptr %10, align 8
  %88 = call ptr @behavior_wrapper(ptr %87, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %89 = call i8 %88({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %9, i32 %.sroa.0.8.extract.trunc)
  %.not86 = icmp eq i8 %84, %89
  br i1 %.not86, label %71, label %.critedge

.critedge:                                        ; preds = %77, %71, %4
  %.reg2mem20.0 = phi i1 [ false, %4 ], [ %.not83.not, %77 ], [ %.not83.not, %71 ]
  ret i1 %.reg2mem20.0
}

define { ptr, i64 } @String_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract10)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract10, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract11) #31
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract10)
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract11) #31
  %17 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %17)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %22 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %22, i64 8
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %22, i64 16
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr noundef nonnull align 8 dereferenceable(24) %22)
  %26 = call { ptr, i64 } %25(ptr nonnull %17, { ptr } %11, i32 %3, i32 %16)
  ret { ptr, i64 } %26
}

define i8 @String_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract7)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract7, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call { ptr } %10(ptr %.fca.1.extract) #31
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = sext i32 %3 to i64
  %13 = getelementptr i8, ptr %.fca.0.extract, i64 %12
  %14 = load i8, ptr %13, align 1
  ret i8 %14
}

define void @String_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i8 %4) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract7, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract7)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract7, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr %.fca.1.extract) #31
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = sext i32 %3 to i64
  %14 = getelementptr i8, ptr %.fca.0.extract, i64 %13
  store i8 %4, ptr %14, align 1
  ret void
}

define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [4 x ptr], align 8
  %7 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %8 = call i32 @get_offset(ptr %.fca.0.extract58, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %10 = sext i32 %8 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract58, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract59) #31
  %16 = sext i32 %15 to i64
  %17 = call ptr @bump_malloc(i64 %16)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %19 = load ptr, ptr %12, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %.fca.1.extract59) #31
  %22 = alloca [1 x ptr], align 8
  store ptr @Range, ptr %22, align 8
  %23 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %24 = call { i64, i64 } @size_wrapper(ptr %23, ptr noundef nonnull align 8 dereferenceable(8) %22)
  %25 = extractvalue { i64, i64 } %24, 0
  %26 = call ptr @bump_malloc(i64 %25)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %28 = load ptr, ptr %12, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %.fca.1.extract59) #31
  %31 = add i32 %30, -1
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %26, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  %35 = alloca [2 x ptr], align 8
  store ptr @_parameterization_i32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %35, i64 8
  store ptr @_parameterization_i32, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %35)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %39 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  %40 = alloca { ptr, ptr }, align 8
  store ptr @i32_typ, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr @i32_typ, ptr %41, align 8
  %42 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %34, ptr noundef nonnull align 8 dereferenceable(16) %40)
  call void %42({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %35, i32 0, i32 %31)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %45 = load ptr, ptr getelementptr (i8, ptr @Range, i64 152), align 8
  %46 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %34, ptr noundef nonnull align 8 %4)
  %47 = call { ptr, ptr, ptr, i32 } %46({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %47, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %47, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %47, 2
  %48 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @RangeIterator)
  %49 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.1.extract, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %.fca.2.extract, 2
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 %48, 3
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %55 = sext i32 %48 to i64
  %56 = getelementptr ptr, ptr %.fca.0.extract, i64 %55
  %57 = getelementptr i8, ptr %56, i64 40
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %3
  %58 = load ptr, ptr %57, align 8
  %59 = call ptr @behavior_wrapper(ptr %58, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 %4)
  %60 = call { ptr, i160 } %59({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %4)
  %.fca.0.extract95 = extractvalue { ptr, i160 } %60, 0
  %61 = icmp ne ptr %.fca.0.extract95, @nil_typ
  %62 = icmp ne ptr %.fca.0.extract95, null
  %.not98 = and i1 %61, %62
  br i1 %.not98, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  %.fca.1.extract96 = extractvalue { ptr, i160 } %60, 1
  %.sroa.0.8.extract.trunc = trunc i160 %.fca.1.extract96 to i32
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %64 = load ptr, ptr %11, align 8
  %65 = load ptr, ptr %64, align 8
  %66 = call { ptr } %65(ptr %.fca.1.extract59) #31
  %.fca.0.extract87 = extractvalue { ptr } %66, 0
  %67 = sext i32 %.sroa.0.8.extract.trunc to i64
  %68 = getelementptr i8, ptr %.fca.0.extract87, i64 %67
  %69 = load i8, ptr %68, align 1
  %70 = getelementptr i8, ptr %17, i64 %67
  store i8 %69, ptr %70, align 1
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %72 = load ptr, ptr %12, align 8
  %73 = load ptr, ptr %72, align 8
  %74 = call i32 %73(ptr %.fca.1.extract59) #31
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %76 = getelementptr i8, ptr %11, i64 16
  %77 = load ptr, ptr %76, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = call i32 %78(ptr %.fca.1.extract59) #31
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %81 = call i32 %73(ptr %.fca.1.extract59) #31
  store ptr @String, ptr %5, align 8
  %82 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %83 = extractvalue { i64, i64 } %82, 0
  %84 = call ptr @bump_malloc(i64 %83)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %86 = load ptr, ptr %12, align 8
  %87 = load ptr, ptr %86, align 8
  %88 = call i32 %87(ptr %.fca.1.extract59) #31
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %90 = load ptr, ptr %76, align 8
  %91 = load ptr, ptr %90, align 8
  %92 = call i32 %91(ptr %.fca.1.extract59) #31
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract58)
  %94 = call i32 %87(ptr %.fca.1.extract59) #31
  %95 = insertvalue { ptr } undef, ptr %17, 0
  %96 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %84, 1
  %97 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr undef, 2
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %6, align 8
  %99 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @_parameterization_i32, ptr %99, align 8
  %100 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr @_parameterization_i32, ptr %100, align 8
  %101 = getelementptr inbounds i8, ptr %6, i64 24
  store ptr @_parameterization_i32, ptr %101, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %6)
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %7, align 8
  %104 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @i32_typ, ptr %104, align 8
  %105 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @i32_typ, ptr %105, align 8
  %106 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr @i32_typ, ptr %106, align 8
  %107 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %98, ptr noundef nonnull align 8 dereferenceable(32) %7)
  call void %107({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull %6, { ptr } %95, i32 %88, i32 %92, i32 %94)
  %108 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %109 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 %108, 3
  ret { ptr, ptr, ptr, i32 } %109
}

define { ptr, ptr, ptr, i32 } @String__Self_empty_(ptr nocapture nofree readnone %0) #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  store ptr @String, ptr %3, align 8
  %4 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %5 = extractvalue { i64, i64 } %4, 0
  %6 = call ptr @bump_malloc(i64 %5)
  %7 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr undef, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 10, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %12 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 %2)
  call void %12({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %2)
  %13 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull @List)
  %14 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %13, 3
  ret { ptr, ptr, ptr, i32 } %14
}

define { ptr, ptr, ptr, i32 } @String__Self_from_iterable_iterableIterableCharacter(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract25, ptr noundef nonnull @Iterable)
  %5 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract25, 0
  %6 = ptrtoint ptr %.fca.1.extract26 to i64
  %7 = ptrtoint ptr %.fca.2.extract27 to i64
  %.sroa.624.8.insert.ext = zext i32 %4 to i160
  %.sroa.624.8.insert.shift = shl nuw i160 %.sroa.624.8.insert.ext, 128
  %.sroa.523.8.insert.ext = zext i64 %7 to i160
  %.sroa.523.8.insert.shift = shl nuw nsw i160 %.sroa.523.8.insert.ext, 64
  %.sroa.523.8.insert.insert = or disjoint i160 %.sroa.624.8.insert.shift, %.sroa.523.8.insert.shift
  %.sroa.322.8.insert.ext = zext i64 %6 to i160
  %.sroa.322.8.insert.insert = or disjoint i160 %.sroa.523.8.insert.insert, %.sroa.322.8.insert.ext
  %8 = insertvalue { ptr, i160 } %5, i160 %.sroa.322.8.insert.insert, 1
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %11 = call ptr @class_behavior_wrapper(ptr noundef nonnull @String_B__Self_empty_, ptr noundef nonnull align 8 %3)
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr nonnull %3)
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %13 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract15, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract16, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %13, 3
  %18 = alloca [1 x ptr], align 8
  store ptr @_parameterization_iteration.Iterablecore.Character, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract15)
  %21 = sext i32 %13 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract15, i64 %21
  %23 = getelementptr i8, ptr %22, i64 216
  %24 = load ptr, ptr %23, align 8
  %25 = alloca { ptr }, align 8
  store ptr %.fca.0.extract25, ptr %25, align 8
  %26 = call ptr @behavior_wrapper(ptr %24, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(8) %25)
  %27 = call { ptr, i160 } %26({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %18, { ptr, i160 } %8)
  %.fca.0.extract = extractvalue { ptr, i160 } %27, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %27, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %28 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %29 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %30 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %31 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @List)
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %28, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %29, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %31, 3
  ret { ptr, ptr, ptr, i32 } %35
}

define { ptr, ptr, ptr, i32 } @String_append_charCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract40 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract39, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %3, 1
  %.sroa.231.8.extract.trunc = trunc i160 %.fca.1.extract29 to i64
  %.sroa.432.8.extract.shift = lshr i160 %.fca.1.extract29, 64
  %.sroa.432.8.extract.trunc = trunc i160 %.sroa.432.8.extract.shift to i64
  %7 = inttoptr i64 %.sroa.231.8.extract.trunc to ptr
  %8 = inttoptr i64 %.sroa.432.8.extract.trunc to ptr
  %9 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %7, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %8, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %9, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract28)
  %16 = sext i32 %9 to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract28, i64 %16
  %18 = getelementptr i8, ptr %17, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @behavior_wrapper(ptr %19, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 %5)
  %21 = call { ptr, ptr, ptr, i32 } %20({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %5)
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %21, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %21, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %21, 2
  %22 = call i32 @get_offset(ptr %.fca.0.extract14, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %23 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract14, 0
  %24 = ptrtoint ptr %.fca.1.extract15 to i64
  %25 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %22 to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.513.8.insert.ext = zext i64 %25 to i160
  %.sroa.513.8.insert.shift = shl nuw nsw i160 %.sroa.513.8.insert.ext, 64
  %.sroa.513.8.insert.insert = or disjoint i160 %.sroa.513.8.insert.shift, %.sroa.6.8.insert.shift
  %.sroa.312.8.insert.ext = zext i64 %24 to i160
  %.sroa.312.8.insert.insert = or disjoint i160 %.sroa.513.8.insert.insert, %.sroa.312.8.insert.ext
  %26 = insertvalue { ptr, i160 } %23, i160 %.sroa.312.8.insert.insert, 1
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract39, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract40, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract41, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %6, 3
  %31 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract39)
  %34 = sext i32 %6 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract39, i64 %34
  %36 = getelementptr i8, ptr %35, i64 216
  %37 = load ptr, ptr %36, align 8
  %38 = alloca { ptr }, align 8
  store ptr %.fca.0.extract14, ptr %38, align 8
  %39 = call ptr @behavior_wrapper(ptr %37, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 dereferenceable(8) %38)
  %40 = call { ptr, i160 } %39({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %31, { ptr, i160 } %26)
  %.fca.0.extract = extractvalue { ptr, i160 } %40, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %40, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %41 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %42 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %43 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %44 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @List)
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %41, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %42, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %44, 3
  ret { ptr, ptr, ptr, i32 } %48
}

define i32 @List_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @List)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract)
  %12 = sext i32 %5 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 80
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @behavior_wrapper(ptr %15, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 %4)
  %17 = call i32 %16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %4)
  ret i32 %17
}

define { ptr, i160 } @List_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract14, ptr noundef nonnull align 16 dereferenceable(80) @List)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract15, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract14)
  %12 = sext i32 %5 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract14, i64 %12
  %14 = getelementptr i8, ptr %13, i64 88
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @behavior_wrapper(ptr %15, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 %4)
  %17 = call i1 %16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %4)
  br i1 %17, label %41, label %18

18:                                               ; preds = %3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract14)
  %21 = getelementptr i8, ptr %13, i64 96
  %22 = load ptr, ptr %21, align 8
  %23 = call ptr @behavior_wrapper(ptr %22, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 %4)
  %24 = call { ptr, ptr, ptr, i32 } %23({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %4)
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %24, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %24, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %24, 2
  %25 = call i32 @get_offset(ptr %.fca.0.extract32, ptr noundef nonnull @ConstantTimeIterator)
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %.fca.1.extract33, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.2.extract34, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %25, 3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract32)
  %32 = sext i32 %25 to i64
  %33 = getelementptr ptr, ptr %.fca.0.extract32, i64 %32
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  %36 = call ptr @behavior_wrapper(ptr %35, { ptr, ptr, ptr, i32 } %29, ptr noundef nonnull align 8 %4)
  %37 = call { ptr, i160 } %36({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull %4)
  %.fca.0.extract19 = extractvalue { ptr, i160 } %37, 0
  %.fca.1.extract20 = extractvalue { ptr, i160 } %37, 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract14)
  %39 = load ptr, ptr %13, align 8
  %40 = call ptr @typegetter_wrapper(ptr %39, ptr %.fca.1.extract15)
  br label %41

41:                                               ; preds = %18, %3
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract19, %18 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract20, %18 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

define { ptr, i160 } @List_last_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract11, ptr noundef nonnull align 16 dereferenceable(80) @List)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract12, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract11)
  %12 = sext i32 %5 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = getelementptr i8, ptr %13, i64 80
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @behavior_wrapper(ptr %15, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 %4)
  %17 = call i32 %16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %4)
  %18 = add i32 %17, -1
  %19 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract11)
  %22 = getelementptr i8, ptr %13, i64 64
  %23 = load ptr, ptr %22, align 8
  %24 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %9, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call { ptr, i160 } %25({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %19, i32 %18)
  ret { ptr, i160 } %26
}

define { ptr, ptr, ptr, i32 } @List_extend_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract36 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %8 = call i32 @get_offset(ptr %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(80) @List)
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %9 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull @Iterable)
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.1.extract14, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.2.extract15, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %9, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract13)
  %16 = sext i32 %9 to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract13, i64 %16
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @behavior_wrapper(ptr %19, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 %5)
  %21 = call { ptr, ptr, ptr, i32 } %20({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %21, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %21, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %21, 2
  %22 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %22, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract)
  %29 = sext i32 %22 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract, i64 %29
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = sext i32 %8 to i64
  %33 = getelementptr ptr, ptr %.fca.0.extract34, i64 %32
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract35, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract36, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %8, 3
  %38 = getelementptr i8, ptr %33, i64 24
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %39 = load ptr, ptr %31, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %5)
  %41 = call { ptr, i160 } %40({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull %5)
  %.fca.0.extract63 = extractvalue { ptr, i160 } %41, 0
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract34)
  %43 = load ptr, ptr %33, align 8
  %44 = call ptr @typegetter_wrapper(ptr %43, ptr %.fca.1.extract35)
  %45 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %46 = icmp ne ptr %.fca.0.extract63, null
  %.not69 = and i1 %45, %46
  br i1 %.not69, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract34)
  %48 = load ptr, ptr %33, align 8
  %49 = call ptr @typegetter_wrapper(ptr %48, ptr %.fca.1.extract35)
  store ptr %49, ptr %6, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract34)
  %52 = load ptr, ptr %38, align 8
  store ptr %.fca.0.extract63, ptr %7, align 8
  %53 = call ptr @behavior_wrapper(ptr %52, { ptr, ptr, ptr, i32 } %37, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %54 = call { ptr, ptr, ptr, i32 } %53({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull %6, { ptr, i160 } %41)
  %.fca.0.extract48 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  %55 = call i32 @get_offset(ptr %.fca.0.extract48, ptr noundef nonnull align 16 dereferenceable(80) @List)
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  %56 = call i32 @get_offset(ptr noundef %.fca.0.extract34, ptr noundef nonnull align 16 dereferenceable(80) @List)
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract35, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract36, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %56, 3
  ret { ptr, ptr, ptr, i32 } %60
}

define { ptr, i160 } @String_extend_otherCollectionCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %10 = call i32 @get_offset(ptr %.fca.0.extract14, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %.fca.0.extract10 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract11 = extractvalue { ptr, i160 } %3, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract11 to i64
  %11 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.6.8.extract.shift = lshr i160 %.fca.1.extract11, 64
  %.sroa.6.8.extract.trunc = trunc i160 %.sroa.6.8.extract.shift to i64
  %12 = inttoptr i64 %.sroa.6.8.extract.trunc to ptr
  %13 = call i32 @get_offset(ptr %.fca.0.extract10, ptr noundef nonnull @Collection)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %11, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %12, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %13, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract10)
  %20 = sext i32 %13 to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract10, i64 %20
  %22 = getelementptr i8, ptr %21, i64 24
  %23 = load ptr, ptr %22, align 8
  %24 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %25 = call { ptr, ptr, ptr, i32 } %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 2
  %26 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %26, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract)
  %33 = sext i32 %26 to i64
  %34 = getelementptr ptr, ptr %.fca.0.extract, i64 %33
  %35 = getelementptr i8, ptr %34, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %.0 = phi i32 [ 0, %4 ], [ %.1, %._crit_edge ]
  %36 = load ptr, ptr %35, align 8
  %37 = call ptr @behavior_wrapper(ptr %36, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 %5)
  %38 = call { ptr, i160 } %37({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 %5)
  %.fca.0.extract89 = extractvalue { ptr, i160 } %38, 0
  %39 = icmp ne ptr %.fca.0.extract89, @nil_typ
  %40 = icmp ne ptr %.fca.0.extract89, null
  %.not97 = and i1 %39, %40
  br i1 %.not97, label %41, label %._crit_edge

41:                                               ; preds = %._crit_edge1
  %.fca.1.extract90 = extractvalue { ptr, i160 } %38, 1
  %.sroa.794.8.extract.shift = lshr i160 %.fca.1.extract90, 64
  %.sroa.794.8.extract.trunc = trunc i160 %.sroa.794.8.extract.shift to i64
  %.sroa.493.8.extract.trunc = trunc i160 %.fca.1.extract90 to i64
  %42 = inttoptr i64 %.sroa.493.8.extract.trunc to ptr
  %43 = inttoptr i64 %.sroa.794.8.extract.trunc to ptr
  %44 = call i32 @get_offset(ptr nonnull %.fca.0.extract89, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract89, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %42, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %43, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %44, 3
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract89)
  %51 = sext i32 %44 to i64
  %52 = getelementptr ptr, ptr %.fca.0.extract89, i64 %51
  %53 = getelementptr i8, ptr %52, i64 40
  %54 = load ptr, ptr %53, align 8
  %55 = call ptr @behavior_wrapper(ptr %54, { ptr, ptr, ptr, i32 } %48, ptr noundef nonnull align 8 %5)
  %56 = call i32 %55({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull %5)
  %57 = add i32 %56, %.0
  br label %._crit_edge

._crit_edge:                                      ; preds = %41, %._crit_edge1
  %.1 = phi i32 [ %57, %41 ], [ %.0, %._crit_edge1 ]
  br i1 %.not97, label %._crit_edge1, label %58

58:                                               ; preds = %._crit_edge
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract14)
  %60 = sext i32 %10 to i64
  %61 = getelementptr ptr, ptr %.fca.0.extract14, i64 %60
  %62 = getelementptr i8, ptr %61, i64 8
  %63 = load ptr, ptr %62, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = call i32 %64(ptr %.fca.1.extract15) #31
  %66 = add i32 %65, %.1
  %67 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %68 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr %.fca.1.extract15, 1
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %.fca.2.extract16, 2
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, i32 %10, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract14)
  %73 = getelementptr i8, ptr %61, i64 120
  %74 = load ptr, ptr %73, align 8
  store ptr @i32_typ, ptr %7, align 8
  %75 = call ptr @behavior_wrapper(ptr %74, { ptr, ptr, ptr, i32 } %70, ptr noundef nonnull align 8 dereferenceable(8) %7)
  call void %75({ ptr, ptr, ptr, i32 } %70, { ptr, ptr, ptr, i32 } %70, ptr nonnull %6, i32 %66)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract10)
  %78 = load ptr, ptr %22, align 8
  %79 = call ptr @behavior_wrapper(ptr %78, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %80 = call { ptr, ptr, ptr, i32 } %79({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %5)
  %.fca.0.extract62 = extractvalue { ptr, ptr, ptr, i32 } %80, 0
  %.fca.1.extract63 = extractvalue { ptr, ptr, ptr, i32 } %80, 1
  %.fca.2.extract64 = extractvalue { ptr, ptr, ptr, i32 } %80, 2
  %81 = call i32 @get_offset(ptr %.fca.0.extract62, ptr noundef nonnull @Iterator)
  %82 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract62, 0
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %.fca.1.extract63, 1
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %.fca.2.extract64, 2
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %81, 3
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract62)
  %88 = sext i32 %81 to i64
  %89 = getelementptr ptr, ptr %.fca.0.extract62, i64 %88
  %90 = getelementptr i8, ptr %89, i64 8
  %91 = getelementptr i8, ptr %61, i64 184
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge2, %58
  %92 = load ptr, ptr %90, align 8
  %93 = call ptr @behavior_wrapper(ptr %92, { ptr, ptr, ptr, i32 } %85, ptr noundef nonnull align 8 %5)
  %94 = call { ptr, i160 } %93({ ptr, ptr, ptr, i32 } %85, { ptr, ptr, ptr, i32 } %85, ptr nonnull %5)
  %.fca.0.extract47 = extractvalue { ptr, i160 } %94, 0
  %95 = icmp ne ptr %.fca.0.extract47, @nil_typ
  %96 = icmp ne ptr %.fca.0.extract47, null
  %.not99 = and i1 %95, %96
  br i1 %.not99, label %._crit_edge2, label %.critedge

._crit_edge2:                                     ; preds = %._crit_edge3
  %.fca.1.extract48 = extractvalue { ptr, i160 } %94, 1
  %97 = call i32 @get_offset(ptr nonnull %.fca.0.extract47, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %98 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract47, 0
  %.sroa.3.0.insert.ext = zext i32 %97 to i160
  %.sroa.3.0.insert.shift = shl nuw i160 %.sroa.3.0.insert.ext, 128
  %99 = and i160 %.fca.1.extract48, 340282366920938463463374607431768211455
  %.sroa.032.0.insert.insert = or disjoint i160 %.sroa.3.0.insert.shift, %99
  %100 = insertvalue { ptr, i160 } %98, i160 %.sroa.032.0.insert.insert, 1
  store ptr @_parameterization_core.Character, ptr %8, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract14)
  %103 = load ptr, ptr %91, align 8
  store ptr %.fca.0.extract47, ptr %9, align 8
  %104 = call ptr @behavior_wrapper(ptr %103, { ptr, ptr, ptr, i32 } %70, ptr noundef nonnull align 8 dereferenceable(8) %9)
  %105 = call { ptr, ptr, ptr, i32 } %104({ ptr, ptr, ptr, i32 } %70, { ptr, ptr, ptr, i32 } %70, ptr nonnull %8, { ptr, i160 } %100)
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %105, 0
  %106 = call i32 @get_offset(ptr %.fca.0.extract23, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  br label %._crit_edge3

.critedge:                                        ; preds = %._crit_edge3
  %107 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract14, 0
  %108 = ptrtoint ptr %.fca.1.extract15 to i64
  %109 = ptrtoint ptr %.fca.2.extract16 to i64
  %.sroa.13.8.insert.ext = zext i32 %10 to i160
  %.sroa.13.8.insert.shift = shl nuw i160 %.sroa.13.8.insert.ext, 128
  %.sroa.10.8.insert.ext = zext i64 %109 to i160
  %.sroa.10.8.insert.shift = shl nuw nsw i160 %.sroa.10.8.insert.ext, 64
  %.sroa.10.8.insert.insert = or disjoint i160 %.sroa.13.8.insert.shift, %.sroa.10.8.insert.shift
  %.sroa.5.8.insert.ext = zext i64 %108 to i160
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.10.8.insert.insert, %.sroa.5.8.insert.ext
  %110 = insertvalue { ptr, i160 } %107, i160 %.sroa.5.8.insert.insert, 1
  ret { ptr, i160 } %110
}

define { ptr, i160 } @String_extend_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %10 = call i32 @get_offset(ptr %.fca.0.extract32, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %3, 1
  %.sroa.4.8.extract.trunc = trunc i160 %.fca.1.extract29 to i64
  %11 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %.sroa.8.8.extract.shift = lshr i160 %.fca.1.extract29, 64
  %.sroa.8.8.extract.trunc = trunc i160 %.sroa.8.8.extract.shift to i64
  %12 = inttoptr i64 %.sroa.8.8.extract.trunc to ptr
  %13 = call i32 @get_offset(ptr %.fca.0.extract28, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %11, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %12, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %13, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract28)
  %20 = sext i32 %13 to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract28, i64 %20
  %22 = getelementptr i8, ptr %21, i64 40
  %23 = load ptr, ptr %22, align 8
  %24 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %25 = call i32 %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %5)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract32)
  %27 = sext i32 %10 to i64
  %28 = getelementptr ptr, ptr %.fca.0.extract32, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = call i32 %31(ptr %.fca.1.extract33) #31
  %33 = add i32 %32, %25
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract33, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract34, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %10, 3
  %38 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract32)
  %41 = getelementptr i8, ptr %28, i64 120
  %42 = load ptr, ptr %41, align 8
  %43 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %43, align 8
  %44 = call ptr @behavior_wrapper(ptr %42, { ptr, ptr, ptr, i32 } %37, ptr noundef nonnull align 8 dereferenceable(8) %43)
  call void %44({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull %38, i32 %33)
  %45 = alloca [1 x ptr], align 8
  store ptr @Range, ptr %45, align 8
  %46 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %47 = call { i64, i64 } @size_wrapper(ptr %46, ptr noundef nonnull align 8 dereferenceable(8) %45)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = call ptr @bump_malloc(i64 %48)
  %50 = add i32 %25, -1
  %51 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %49, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr undef, 2
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 10, 3
  %54 = alloca [2 x ptr], align 8
  store ptr @_parameterization_i32, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  store ptr @_parameterization_i32, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %54)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %58 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  %59 = alloca { ptr, ptr }, align 8
  store ptr @i32_typ, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %59, i64 8
  store ptr @i32_typ, ptr %60, align 8
  %61 = call ptr @behavior_wrapper(ptr %58, { ptr, ptr, ptr, i32 } %53, ptr noundef nonnull align 8 dereferenceable(16) %59)
  call void %61({ ptr, ptr, ptr, i32 } %53, { ptr, ptr, ptr, i32 } %53, ptr nonnull %54, i32 0, i32 %50)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %64 = load ptr, ptr getelementptr (i8, ptr @Range, i64 152), align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %53, ptr noundef nonnull align 8 %5)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %53, { ptr, ptr, ptr, i32 } %53, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %67 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @RangeIterator)
  %68 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %.fca.1.extract, 1
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.2.extract, 2
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %67, 3
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %74 = sext i32 %67 to i64
  %75 = getelementptr ptr, ptr %.fca.0.extract, i64 %74
  %76 = getelementptr i8, ptr %75, i64 40
  %77 = getelementptr i8, ptr %21, i64 144
  %78 = getelementptr inbounds i8, ptr %8, i64 8
  %79 = getelementptr i8, ptr %28, i64 152
  %80 = getelementptr inbounds i8, ptr %9, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %81 = load ptr, ptr %76, align 8
  %82 = call ptr @behavior_wrapper(ptr %81, { ptr, ptr, ptr, i32 } %71, ptr noundef nonnull align 8 %5)
  %83 = call { ptr, i160 } %82({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull align 8 %5)
  %.fca.0.extract53 = extractvalue { ptr, i160 } %83, 0
  %84 = icmp ne ptr %.fca.0.extract53, @nil_typ
  %85 = icmp ne ptr %.fca.0.extract53, null
  %.not56 = and i1 %84, %85
  br i1 %.not56, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  %.fca.1.extract54 = extractvalue { ptr, i160 } %83, 1
  %.sroa.084.8.extract.trunc = trunc i160 %.fca.1.extract54 to i32
  %86 = add i32 %32, %.sroa.084.8.extract.trunc
  store ptr @_parameterization_i32, ptr %6, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract28)
  %89 = load ptr, ptr %77, align 8
  store ptr @i32_typ, ptr %7, align 8
  %90 = call ptr @behavior_wrapper(ptr %89, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %91 = call i8 %90({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %6, i32 %.sroa.084.8.extract.trunc)
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr @_parameterization_i8, ptr %78, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract32)
  %94 = load ptr, ptr %79, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr @i8_typ, ptr %80, align 8
  %95 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %37, ptr noundef nonnull align 8 dereferenceable(16) %9)
  call void %95({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull %8, i32 %86, i8 %91)
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract32)
  %97 = load ptr, ptr %29, align 8
  %98 = getelementptr i8, ptr %97, i64 8
  %99 = load ptr, ptr %98, align 8
  call void %99(ptr %.fca.1.extract33, i32 %33) #30
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract32)
  %101 = getelementptr i8, ptr %28, i64 16
  %102 = load ptr, ptr %101, align 8
  %103 = load ptr, ptr %102, align 8
  %104 = call i32 %103(ptr %.fca.1.extract33) #31
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract28)
  %107 = getelementptr i8, ptr %21, i64 240
  %108 = load ptr, ptr %107, align 8
  %109 = call ptr @behavior_wrapper(ptr %108, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %110 = call i32 %109({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %5)
  %111 = add i32 %110, %104
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract32)
  %113 = load ptr, ptr %101, align 8
  %114 = getelementptr i8, ptr %113, i64 8
  %115 = load ptr, ptr %114, align 8
  call void %115(ptr %.fca.1.extract33, i32 %111) #30
  %116 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract32, 0
  %117 = ptrtoint ptr %.fca.1.extract33 to i64
  %118 = ptrtoint ptr %.fca.2.extract34 to i64
  %.sroa.19.8.insert.ext = zext i32 %10 to i160
  %.sroa.19.8.insert.shift = shl nuw i160 %.sroa.19.8.insert.ext, 128
  %.sroa.16.8.insert.ext = zext i64 %118 to i160
  %.sroa.16.8.insert.shift = shl nuw nsw i160 %.sroa.16.8.insert.ext, 64
  %.sroa.16.8.insert.insert = or disjoint i160 %.sroa.19.8.insert.shift, %.sroa.16.8.insert.shift
  %.sroa.871.8.insert.ext = zext i64 %117 to i160
  %.sroa.871.8.insert.insert = or disjoint i160 %.sroa.16.8.insert.insert, %.sroa.871.8.insert.ext
  %119 = insertvalue { ptr, i160 } %116, i160 %.sroa.871.8.insert.insert, 1
  ret { ptr, i160 } %119
}

define { ptr, i160 } @List_get_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract16, ptr noundef nonnull align 16 dereferenceable(80) @List)
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract17, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract16)
  %13 = sext i32 %6 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract16, i64 %13
  %15 = getelementptr i8, ptr %14, i64 80
  %16 = load ptr, ptr %15, align 8
  %17 = call ptr @behavior_wrapper(ptr %16, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %5)
  %18 = call i32 %17({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %5)
  %.not = icmp slt i32 %3, %18
  br i1 %.not, label %19, label %88

19:                                               ; preds = %4
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract16)
  %22 = getelementptr i8, ptr %14, i64 136
  %23 = load ptr, ptr %22, align 8
  %24 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %5)
  %25 = call { ptr, ptr, ptr, i32 } %24({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %5)
  %.fca.0.extract56 = extractvalue { ptr, ptr, ptr, i32 } %25, 0
  %.fca.1.extract58 = extractvalue { ptr, ptr, ptr, i32 } %25, 1
  %.fca.2.extract60 = extractvalue { ptr, ptr, ptr, i32 } %25, 2
  %26 = call i32 @get_offset(ptr %.fca.0.extract56, ptr noundef nonnull @Collection)
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract56, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract58, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract60, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %26, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract56)
  %33 = sext i32 %26 to i64
  %34 = getelementptr ptr, ptr %.fca.0.extract56, i64 %33
  %35 = getelementptr i8, ptr %34, i64 24
  %36 = load ptr, ptr %35, align 8
  %37 = call ptr @behavior_wrapper(ptr %36, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 %5)
  %38 = call { ptr, ptr, ptr, i32 } %37({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 %5)
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %39 = call i32 @get_offset(ptr %.fca.0.extract41, ptr noundef nonnull @Iterator)
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.1.extract43, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.2.extract45, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %39, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract41)
  %46 = sext i32 %39 to i64
  %47 = getelementptr ptr, ptr %.fca.0.extract41, i64 %46
  %48 = getelementptr i8, ptr %47, i64 8
  br label %49

49:                                               ; preds = %73, %19
  %.sroa.11.0 = phi i32 [ undef, %19 ], [ %.sroa.11.1, %73 ]
  %.sroa.7.0 = phi ptr [ undef, %19 ], [ %.sroa.7.1, %73 ]
  %.sroa.3.0 = phi ptr [ undef, %19 ], [ %.sroa.3.1, %73 ]
  %.sroa.0.0 = phi ptr [ undef, %19 ], [ %.sroa.0.1, %73 ]
  %50 = load ptr, ptr %48, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 %5)
  %52 = call { ptr, i160 } %51({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %5)
  %.fca.0.extract30 = extractvalue { ptr, i160 } %52, 0
  %53 = icmp ne ptr %.fca.0.extract30, @nil_typ
  %54 = icmp ne ptr %.fca.0.extract30, null
  %.not70 = and i1 %53, %54
  br i1 %.not70, label %55, label %73

55:                                               ; preds = %49
  %.fca.1.extract31 = extractvalue { ptr, i160 } %52, 1
  %.sroa.382.8.extract.shift = lshr i160 %.fca.1.extract31, 64
  %.sroa.382.8.extract.trunc = trunc i160 %.sroa.382.8.extract.shift to i64
  %.sroa.081.8.extract.trunc = trunc i160 %.fca.1.extract31 to i64
  %56 = inttoptr i64 %.sroa.081.8.extract.trunc to ptr
  %57 = inttoptr i64 %.sroa.382.8.extract.trunc to ptr
  %58 = call i32 @get_offset(ptr nonnull %.fca.0.extract30, ptr noundef nonnull @Pair)
  %59 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract30, 0
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %56, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %57, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %58, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract30)
  %65 = sext i32 %58 to i64
  %66 = getelementptr ptr, ptr %.fca.0.extract30, i64 %65
  %67 = getelementptr i8, ptr %66, i64 32
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @behavior_wrapper(ptr %68, { ptr, ptr, ptr, i32 } %62, ptr noundef nonnull align 8 %5)
  %70 = call { ptr, i160 } %69({ ptr, ptr, ptr, i32 } %62, { ptr, ptr, ptr, i32 } %62, ptr nonnull %5)
  %.fca.1.extract27 = extractvalue { ptr, i160 } %70, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract27 to i32
  %71 = icmp eq i32 %3, %.sroa.1.8.extract.trunc
  %72 = xor i1 %71, true
  br label %73

73:                                               ; preds = %55, %49
  %.sroa.11.1 = phi i32 [ %.sroa.11.0, %49 ], [ %58, %55 ]
  %.sroa.7.1 = phi ptr [ %.sroa.7.0, %49 ], [ %57, %55 ]
  %.sroa.3.1 = phi ptr [ %.sroa.3.0, %49 ], [ %56, %55 ]
  %.sroa.0.1 = phi ptr [ %.sroa.0.0, %49 ], [ %.fca.0.extract30, %55 ]
  %.reg2mem42.0.off0 = phi i1 [ false, %49 ], [ %72, %55 ]
  %.reg2mem44.0 = phi i1 [ false, %49 ], [ %71, %55 ]
  br i1 %.reg2mem42.0.off0, label %49, label %74

74:                                               ; preds = %73
  br i1 %.reg2mem44.0, label %75, label %88

75:                                               ; preds = %74
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.1, 0
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.sroa.3.1, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.sroa.7.1, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %.sroa.11.1, 3
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.sroa.0.1)
  %82 = sext i32 %.sroa.11.1 to i64
  %83 = getelementptr ptr, ptr %.sroa.0.1, i64 %82
  %84 = getelementptr i8, ptr %83, i64 40
  %85 = load ptr, ptr %84, align 8
  %86 = call ptr @behavior_wrapper(ptr %85, { ptr, ptr, ptr, i32 } %79, ptr noundef nonnull align 8 %5)
  %87 = call { ptr, i160 } %86({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %5)
  %.fca.0.extract20 = extractvalue { ptr, i160 } %87, 0
  %.fca.1.extract21 = extractvalue { ptr, i160 } %87, 1
  br label %88

88:                                               ; preds = %75, %74, %4
  %.reg2mem36.sroa.0.0 = phi ptr [ @nil_typ, %4 ], [ %.fca.0.extract20, %75 ], [ poison, %74 ]
  %.reg2mem36.sroa.3.0 = phi i160 [ undef, %4 ], [ %.fca.1.extract21, %75 ], [ undef, %74 ]
  %.reload37.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem36.sroa.0.0, 0
  %.reload37.fca.1.insert = insertvalue { ptr, i160 } %.reload37.fca.0.insert, i160 %.reg2mem36.sroa.3.0, 1
  ret { ptr, i160 } %.reload37.fca.1.insert
}

define { ptr, i32 } @List_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract19, ptr noundef nonnull align 16 dereferenceable(80) @List)
  %.fca.0.extract = extractvalue { ptr } %4, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract20, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %7, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract19)
  %14 = sext i32 %7 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract19, i64 %14
  %16 = getelementptr i8, ptr %15, i64 88
  %17 = load ptr, ptr %16, align 8
  %18 = call ptr @behavior_wrapper(ptr %17, { ptr, ptr, ptr, i32 } %11, ptr noundef nonnull align 8 %6)
  %19 = call i1 %18({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 %6)
  br i1 %19, label %89, label %20

20:                                               ; preds = %5
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1088, ptr nocapture nofree noundef %.fca.0.extract19)
  %23 = getelementptr i8, ptr %15, i64 136
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @behavior_wrapper(ptr %24, { ptr, ptr, ptr, i32 } %11, ptr noundef nonnull align 8 %6)
  %26 = call { ptr, ptr, ptr, i32 } %25({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 %6)
  %.fca.0.extract67 = extractvalue { ptr, ptr, ptr, i32 } %26, 0
  %.fca.1.extract69 = extractvalue { ptr, ptr, ptr, i32 } %26, 1
  %.fca.2.extract71 = extractvalue { ptr, ptr, ptr, i32 } %26, 2
  %27 = call i32 @get_offset(ptr %.fca.0.extract67, ptr noundef nonnull @Collection)
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract67, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract69, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract71, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %27, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract67)
  %34 = sext i32 %27 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract67, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = call ptr @behavior_wrapper(ptr %37, { ptr, ptr, ptr, i32 } %31, ptr noundef nonnull align 8 %6)
  %39 = call { ptr, ptr, ptr, i32 } %38({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %6)
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %39, 0
  %.fca.1.extract54 = extractvalue { ptr, ptr, ptr, i32 } %39, 1
  %.fca.2.extract56 = extractvalue { ptr, ptr, ptr, i32 } %39, 2
  %40 = call i32 @get_offset(ptr %.fca.0.extract52, ptr noundef nonnull @Iterator)
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract52, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract54, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract56, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %40, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract52)
  %47 = sext i32 %40 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract52, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  br label %50

50:                                               ; preds = %74, %20
  %.sroa.11.0 = phi i32 [ undef, %20 ], [ %.sroa.11.1, %74 ]
  %.sroa.7.0 = phi ptr [ undef, %20 ], [ %.sroa.7.1, %74 ]
  %.sroa.3.0 = phi ptr [ undef, %20 ], [ %.sroa.3.1, %74 ]
  %.sroa.0.0 = phi ptr [ undef, %20 ], [ %.sroa.0.1, %74 ]
  %51 = load ptr, ptr %49, align 8
  %52 = call ptr @behavior_wrapper(ptr %51, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %6)
  %53 = call { ptr, i160 } %52({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %6)
  %.fca.0.extract41 = extractvalue { ptr, i160 } %53, 0
  %54 = icmp ne ptr %.fca.0.extract41, @nil_typ
  %55 = icmp ne ptr %.fca.0.extract41, null
  %.not84 = and i1 %54, %55
  br i1 %.not84, label %56, label %74

56:                                               ; preds = %50
  %.fca.1.extract42 = extractvalue { ptr, i160 } %53, 1
  %.sroa.396.8.extract.shift = lshr i160 %.fca.1.extract42, 64
  %.sroa.396.8.extract.trunc = trunc i160 %.sroa.396.8.extract.shift to i64
  %.sroa.095.8.extract.trunc = trunc i160 %.fca.1.extract42 to i64
  %57 = inttoptr i64 %.sroa.095.8.extract.trunc to ptr
  %58 = inttoptr i64 %.sroa.396.8.extract.trunc to ptr
  %59 = call i32 @get_offset(ptr nonnull %.fca.0.extract41, ptr noundef nonnull @Pair)
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %57, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %58, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %59, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract41)
  %66 = sext i32 %59 to i64
  %67 = getelementptr ptr, ptr %.fca.0.extract41, i64 %66
  %68 = getelementptr i8, ptr %67, i64 40
  %69 = load ptr, ptr %68, align 8
  %70 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %63, ptr noundef nonnull align 8 %6)
  %71 = call { ptr, i160 } %70({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull %6)
  %72 = call i1 %.fca.0.extract({ ptr, i160 } %71, { ptr, i160 } %3)
  %73 = xor i1 %72, true
  br label %74

74:                                               ; preds = %56, %50
  %.sroa.11.1 = phi i32 [ %.sroa.11.0, %50 ], [ %59, %56 ]
  %.sroa.7.1 = phi ptr [ %.sroa.7.0, %50 ], [ %58, %56 ]
  %.sroa.3.1 = phi ptr [ %.sroa.3.0, %50 ], [ %57, %56 ]
  %.sroa.0.1 = phi ptr [ %.sroa.0.0, %50 ], [ %.fca.0.extract41, %56 ]
  %.reg2mem60.0.off0 = phi i1 [ false, %50 ], [ %73, %56 ]
  %.reg2mem62.0 = phi i1 [ false, %50 ], [ %72, %56 ]
  br i1 %.reg2mem60.0.off0, label %50, label %75

75:                                               ; preds = %74
  br i1 %.reg2mem62.0, label %76, label %89

76:                                               ; preds = %75
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.1, 0
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.sroa.3.1, 1
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %.sroa.7.1, 2
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 %.sroa.11.1, 3
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.sroa.0.1)
  %83 = sext i32 %.sroa.11.1 to i64
  %84 = getelementptr ptr, ptr %.sroa.0.1, i64 %83
  %85 = getelementptr i8, ptr %84, i64 32
  %86 = load ptr, ptr %85, align 8
  %87 = call ptr @behavior_wrapper(ptr %86, { ptr, ptr, ptr, i32 } %80, ptr noundef nonnull align 8 %6)
  %88 = call { ptr, i160 } %87({ ptr, ptr, ptr, i32 } %80, { ptr, ptr, ptr, i32 } %80, ptr nonnull %6)
  %.fca.1.extract27 = extractvalue { ptr, i160 } %88, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract27 to i32
  br label %89

89:                                               ; preds = %76, %75, %5
  %.reg2mem46.sroa.3.0 = phi i32 [ poison, %5 ], [ %.sroa.1.8.extract.trunc, %76 ], [ poison, %75 ]
  %.reg2mem44.0 = phi ptr [ @nil_typ, %5 ], [ @i32_typ, %76 ], [ @nil_typ, %75 ]
  %.reload43.fca.0.insert = insertvalue { ptr, i32 } poison, ptr %.reg2mem44.0, 0
  %.reload43.fca.1.insert = insertvalue { ptr, i32 } %.reload43.fca.0.insert, i32 %.reg2mem46.sroa.3.0, 1
  ret { ptr, i32 } %.reload43.fca.1.insert
}

define i32 @String_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  ret i32 %11
}

define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %5 = alloca [1 x ptr], align 8
  store ptr @StringIterator, ptr %5, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_StringIterator, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = call ptr @bump_malloc(i64 %7)
  %9 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.1.extract, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.2.extract, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %9, 3
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %8, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 10, 3
  %17 = alloca [1 x ptr], align 8
  store ptr @_parameterization_core.String, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 16 dereferenceable(208) @StringIterator)
  %20 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = call ptr @behavior_wrapper(ptr noundef nonnull @StringIterator_B_init_strString, { ptr, ptr, ptr, i32 } %16, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %21({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %17, { ptr, ptr, ptr, i32 } %13)
  %22 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(208) @StringIterator, ptr noundef nonnull @Iterator)
  %23 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %22, 3
  ret { ptr, ptr, ptr, i32 } %23
}

define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  ret { ptr, ptr, ptr, i32 } %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 40, i64 8 }
}

define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 120
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @StringIterator_field_StringIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_core.Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(208) @StringIterator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract17)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract17, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %7, 3
  call void %13(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %17) #30
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract17)
  %19 = getelementptr i8, ptr %10, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract18, i32 0) #30
  ret void
}

define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %11 = call i32 @get_offset(ptr %.fca.0.extract33, ptr noundef nonnull align 16 dereferenceable(208) @StringIterator)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract33)
  %13 = sext i32 %11 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract33, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %.fca.1.extract35) #31
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract33)
  %20 = load ptr, ptr %14, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call { ptr, ptr, ptr, i32 } %21(ptr %.fca.1.extract35) #31
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  store ptr %.fca.0.extract, ptr %23, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %23, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %23, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %23, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %23, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %24, 0
  %26 = load ptr, ptr %.fca.1.gep, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %26, 1
  %28 = load ptr, ptr %.fca.2.gep, align 8
  %29 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %28, 2
  %30 = load i32, ptr %.fca.3.gep, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %30, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %24)
  %34 = sext i32 %30 to i64
  %35 = getelementptr ptr, ptr %24, i64 %34
  %36 = getelementptr i8, ptr %35, i64 40
  %37 = load ptr, ptr %36, align 8
  %38 = call ptr @behavior_wrapper(ptr %37, { ptr, ptr, ptr, i32 } %31, ptr noundef nonnull align 8 %4)
  %39 = call i32 %38({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull %4)
  %.not = icmp slt i32 %18, %39
  br i1 %.not, label %40, label %87

40:                                               ; preds = %3
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract33)
  %42 = load ptr, ptr %15, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %.fca.1.extract35) #31
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract33)
  %46 = load ptr, ptr %14, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr, ptr, ptr, i32 } %47(ptr %.fca.1.extract35) #31
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %48, 0
  store ptr %.fca.0.extract57, ptr %5, align 8
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %48, 1
  %.fca.1.gep60 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract59, ptr %.fca.1.gep60, align 8
  %.fca.2.extract61 = extractvalue { ptr, ptr, ptr, i32 } %48, 2
  %.fca.2.gep62 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract61, ptr %.fca.2.gep62, align 8
  %.fca.3.extract63 = extractvalue { ptr, ptr, ptr, i32 } %48, 3
  %.fca.3.gep64 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract63, ptr %.fca.3.gep64, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %49 = load ptr, ptr %5, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %49, 0
  %51 = load ptr, ptr %.fca.1.gep60, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 1
  %53 = load ptr, ptr %.fca.2.gep62, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 2
  %55 = load i32, ptr %.fca.3.gep64, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %55, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %49)
  %59 = sext i32 %55 to i64
  %60 = getelementptr ptr, ptr %49, i64 %59
  %61 = getelementptr i8, ptr %60, i64 136
  %62 = load ptr, ptr %61, align 8
  store ptr @i32_typ, ptr %7, align 8
  %63 = call ptr @behavior_wrapper(ptr %62, { ptr, ptr, ptr, i32 } %56, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %64 = call { ptr, i64 } %63({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull %6, i32 %44)
  %.fca.0.extract51 = extractvalue { ptr, i64 } %64, 0
  %65 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %66 = icmp ne ptr %.fca.0.extract51, null
  %.not70 = and i1 %65, %66
  br i1 %.not70, label %67, label %87

67:                                               ; preds = %40
  %.fca.1.extract53 = extractvalue { ptr, i64 } %64, 1
  %68 = bitcast i64 %.fca.1.extract53 to <2 x i32>
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract33)
  %70 = load ptr, ptr %15, align 8
  %71 = load ptr, ptr %70, align 8
  %72 = call i32 %71(ptr %.fca.1.extract35) #31
  %.4.vec.extract = extractelement <2 x i32> %68, i64 1
  %73 = add i32 %72, %.4.vec.extract
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract33)
  %75 = getelementptr i8, ptr %70, i64 8
  %76 = load ptr, ptr %75, align 8
  call void %76(ptr %.fca.1.extract35, i32 %73) #30
  store ptr @Character, ptr %8, align 8
  %77 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Character, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %78 = extractvalue { i64, i64 } %77, 0
  %79 = call ptr @bump_malloc(i64 %78)
  %.0.vec.extract = trunc i64 %.fca.1.extract53 to i32
  %80 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Character, ptr undef, ptr undef, i32 undef }, ptr %79, 1
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr undef, 2
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 10, 3
  store ptr @_parameterization_i32, ptr %9, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Character)
  store ptr @i32_typ, ptr %10, align 8
  %85 = call ptr @behavior_wrapper(ptr noundef nonnull @Character_B_init_codepointi32, { ptr, ptr, ptr, i32 } %82, ptr noundef nonnull align 8 dereferenceable(8) %10)
  call void %85({ ptr, ptr, ptr, i32 } %82, { ptr, ptr, ptr, i32 } %82, ptr nonnull %9, i32 %.0.vec.extract)
  %86 = ptrtoint ptr %79 to i64
  %.sroa.3.8.insert.ext = zext i64 %86 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %87

87:                                               ; preds = %67, %40, %3
  %.reg2mem9.sroa.0.0 = phi ptr [ @nil_typ, %3 ], [ @Character, %67 ], [ @nil_typ, %40 ]
  %.reg2mem9.sroa.3.0 = phi i160 [ undef, %3 ], [ %.sroa.3.8.insert.insert, %67 ], [ undef, %40 ]
  %.reload10.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem9.sroa.0.0, 0
  %.reload10.fca.1.insert = insertvalue { ptr, i160 } %.reload10.fca.0.insert, i160 %.reg2mem9.sroa.3.0, 1
  ret { ptr, i160 } %.reload10.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_codepointi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_codepoint_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_to_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Character_B__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6681222582356018452, i64 noundef ptrtoint (ptr @Character to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 152
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_n_bytes_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define i32 @Character_codepoint_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #31
  ret i32 %10
}

define void @Character_init_codepointi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 %3) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @Character_to_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract14, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract14)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract15) #31
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %14 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %14, align 8
  %15 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_encode_one_cpi32, ptr noundef nonnull align 8 dereferenceable(8) %14)
  %16 = call { ptr, ptr, ptr, i32 } %15(ptr nonnull %11, i32 %10)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %17 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %18 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %22
}

define i1 @Character__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract11, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract11)
  %9 = sext i32 %6 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract11, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call i32 %12(ptr %.fca.1.extract12) #31
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %7, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %20 = sext i32 %7 to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %25 = call i32 %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %5)
  %26 = icmp eq i32 %13, %25
  ret i1 %26
}

define noundef range(i32 1, 5) i32 @Character_n_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(168) @Character)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #31
  %11 = icmp slt i32 %10, 128
  %12 = icmp slt i32 %10, 2048
  %13 = icmp slt i32 %10, 1114112
  %14 = select i1 %13, i32 4, i32 3
  %.reg2mem22.0 = select i1 %12, i32 2, i32 %14
  %.reg2mem18.0 = select i1 %11, i32 1, i32 %.reg2mem22.0
  ret i32 %.reg2mem18.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_encode_one_cpi32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  ret ptr @Unicode__Self_encode_one_cpi32
}

define { ptr, ptr, ptr, i32 } @Unicode__Self_encode_one_cpi32(ptr nocapture nofree readnone %0, i32 %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %4 = alloca [1 x ptr], align 8
  %5 = alloca [4 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca [4 x ptr], align 8
  %12 = alloca { ptr, ptr, ptr, ptr }, align 8
  %13 = call ptr @bump_malloc(i64 noundef 4)
  %14 = icmp slt i32 %1, 128
  br i1 %14, label %15, label %34

15:                                               ; preds = %2
  %16 = trunc i32 %1 to i8
  store i8 %16, ptr %13, align 1
  store ptr @String, ptr %4, align 8
  %17 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %18 = extractvalue { i64, i64 } %17, 0
  %19 = call ptr @bump_malloc(i64 %18)
  %20 = insertvalue { ptr } undef, ptr %13, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %19, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  %24 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr @_parameterization_i32, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @_parameterization_i32, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %6, align 8
  %29 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr @i32_typ, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %6, i64 24
  store ptr @i32_typ, ptr %31, align 8
  %32 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 dereferenceable(32) %6)
  call void %32({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %5, { ptr } %20, i32 1, i32 1, i32 4)
  %33 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  br label %105

34:                                               ; preds = %2
  %35 = icmp slt i32 %1, 2048
  br i1 %35, label %36, label %61

36:                                               ; preds = %34
  %37 = lshr i32 %1, 6
  %38 = trunc i32 %37 to i8
  %39 = or i8 %38, -64
  store i8 %39, ptr %13, align 1
  %40 = trunc i32 %1 to i8
  %41 = and i8 %40, 63
  %42 = or disjoint i8 %41, -128
  %43 = getelementptr i8, ptr %13, i64 1
  store i8 %42, ptr %43, align 1
  store ptr @String, ptr %7, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  %47 = insertvalue { ptr } undef, ptr %13, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %46, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr undef, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %8, align 8
  %51 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @_parameterization_i32, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %9, align 8
  %56 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @i32_typ, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @i32_typ, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @i32_typ, ptr %58, align 8
  %59 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(32) %9)
  call void %59({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %8, { ptr } %47, i32 2, i32 1, i32 4)
  %60 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  br label %105

61:                                               ; preds = %34
  %62 = icmp slt i32 %1, 1114112
  br i1 %62, label %63, label %98

63:                                               ; preds = %61
  %64 = lshr i32 %1, 18
  %65 = trunc i32 %64 to i8
  %66 = or i8 %65, -16
  store i8 %66, ptr %13, align 1
  %67 = lshr i32 %1, 12
  %68 = trunc i32 %67 to i8
  %69 = and i8 %68, 63
  %70 = or disjoint i8 %69, -128
  %71 = getelementptr i8, ptr %13, i64 1
  store i8 %70, ptr %71, align 1
  %72 = lshr i32 %1, 6
  %73 = trunc i32 %72 to i8
  %74 = and i8 %73, 63
  %75 = or disjoint i8 %74, -128
  %76 = getelementptr i8, ptr %13, i64 2
  store i8 %75, ptr %76, align 1
  %77 = trunc i32 %1 to i8
  %78 = and i8 %77, 63
  %79 = or disjoint i8 %78, -128
  %80 = getelementptr i8, ptr %13, i64 3
  store i8 %79, ptr %80, align 1
  store ptr @String, ptr %10, align 8
  %81 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %82 = extractvalue { i64, i64 } %81, 0
  %83 = call ptr @bump_malloc(i64 %82)
  %84 = insertvalue { ptr } undef, ptr %13, 0
  %85 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %83, 1
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, ptr undef, 2
  %87 = insertvalue { ptr, ptr, ptr, i32 } %86, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %11, align 8
  %88 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_i32, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @_parameterization_i32, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %11, i64 24
  store ptr @_parameterization_i32, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %11)
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  store ptr @buffer_typ, ptr %12, align 8
  %93 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @i32_typ, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @i32_typ, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %12, i64 24
  store ptr @i32_typ, ptr %95, align 8
  %96 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %87, ptr noundef nonnull align 8 dereferenceable(32) %12)
  call void %96({ ptr, ptr, ptr, i32 } %87, { ptr, ptr, ptr, i32 } %87, ptr nonnull %11, { ptr } %84, i32 4, i32 1, i32 4)
  %97 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  br label %105

98:                                               ; preds = %61
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %101 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_replacement_str_, ptr noundef nonnull align 8 %3)
  %102 = call { ptr, ptr, ptr, i32 } %101(ptr nonnull %3)
  %.fca.0.extract62 = extractvalue { ptr, ptr, ptr, i32 } %102, 0
  %103 = call i32 @get_offset(ptr %.fca.0.extract62, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %104 = call i32 @get_offset(ptr %.fca.0.extract62, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %.reload8.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %102, 1
  %.reload8.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %102, 2
  br label %105

105:                                              ; preds = %98, %63, %36, %15
  %.reg2mem17.sroa.0.0 = phi ptr [ @String, %15 ], [ @String, %36 ], [ @String, %63 ], [ %.fca.0.extract62, %98 ]
  %.reg2mem17.sroa.3.0 = phi ptr [ %19, %15 ], [ %46, %36 ], [ %83, %63 ], [ %.reload8.fca.1.extract, %98 ]
  %.reg2mem17.sroa.6.0 = phi ptr [ undef, %15 ], [ undef, %36 ], [ undef, %63 ], [ %.reload8.fca.2.extract, %98 ]
  %.reg2mem17.sroa.9.0 = phi i32 [ %33, %15 ], [ %60, %36 ], [ %97, %63 ], [ %104, %98 ]
  %.reload18.fca.0.insert = insertvalue { ptr, ptr, ptr, i32 } poison, ptr %.reg2mem17.sroa.0.0, 0
  %.reload18.fca.1.insert = insertvalue { ptr, ptr, ptr, i32 } %.reload18.fca.0.insert, ptr %.reg2mem17.sroa.3.0, 1
  %.reload18.fca.2.insert = insertvalue { ptr, ptr, ptr, i32 } %.reload18.fca.1.insert, ptr %.reg2mem17.sroa.6.0, 2
  %.reload18.fca.3.insert = insertvalue { ptr, ptr, ptr, i32 } %.reload18.fca.2.insert, i32 %.reg2mem17.sroa.9.0, 3
  ret { ptr, ptr, ptr, i32 } %.reload18.fca.3.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_str_(ptr nocapture nofree %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #29
  ret ptr @Unicode__Self_replacement_str_
}

define { ptr, ptr, ptr, i32 } @Unicode__Self_replacement_str_(ptr nocapture nofree readnone %0) #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #29
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode) #29
  %5 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_replacement_buf_, ptr noundef nonnull align 8 %2)
  %6 = call { ptr } %5(ptr nonnull align 8 %2)
  %7 = alloca [1 x ptr], align 8
  store ptr @String, ptr %7, align 8
  %8 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %9 = extractvalue { i64, i64 } %8, 0
  %10 = call ptr @bump_malloc(i64 %9)
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Unicode)
  %13 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Unicode_B__Self_replacement_buf_, ptr noundef nonnull align 8 %2)
  %14 = call { ptr } %13(ptr nonnull %2)
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %10, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 10, 3
  %18 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @_parameterization_i32, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %18, i64 24
  store ptr @_parameterization_i32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %18)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %24 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %24, i64 8
  store ptr @i32_typ, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %24, i64 16
  store ptr @i32_typ, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %24, i64 24
  store ptr @i32_typ, ptr %27, align 8
  %28 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(32) %24)
  call void %28({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %18, { ptr } %14, i32 3, i32 1, i32 4)
  %29 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %30 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %29, 3
  ret { ptr, ptr, ptr, i32 } %30
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_buf_(ptr nocapture nofree %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #29
  ret ptr @Unicode__Self_replacement_buf_
}

define { ptr } @Unicode__Self_replacement_buf_(ptr nocapture nofree readnone %0) #3 {
  %2 = call ptr @bump_malloc(i64 noundef 3)
  store i8 -17, ptr %2, align 1
  %3 = getelementptr i8, ptr %2, i64 1
  store i8 -65, ptr %3, align 1
  %4 = getelementptr i8, ptr %2, i64 2
  store i8 -67, ptr %4, align 1
  %5 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Unicode(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_replacement_codepoint_(ptr nocapture nofree %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #29
  ret ptr @Unicode__Self_replacement_codepoint_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #29
  ret ptr @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @Unicode__Self_replacement_codepoint_(ptr nocapture nofree readnone %0) #1 {
  ret i32 -3
}

define { ptr, i64 } @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr nocapture nofree readnone %0, { ptr } %1, i32 %2, i32 %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr } %1, 0
  %.not = icmp slt i32 %2, %3
  br i1 %.not, label %._crit_edge, label %85

._crit_edge:                                      ; preds = %4
  %9 = sext i32 %2 to i64
  %10 = getelementptr i8, ptr %.fca.0.extract10, i64 %9
  %11 = load i8, ptr %10, align 1
  %12 = sext i8 %11 to i32
  %13 = icmp sgt i8 %11, -1
  %spec.select = zext i1 %13 to i32
  %14 = and i32 %12, -32
  %15 = icmp eq i32 %14, -64
  %.1149 = select i1 %15, i32 2, i32 %spec.select
  %16 = and i32 %12, -16
  %17 = icmp eq i32 %16, -32
  %.2150 = select i1 %17, i32 3, i32 %.1149
  %18 = and i32 %12, -8
  %19 = icmp eq i32 %18, -16
  %.3151 = select i1 %19, i32 4, i32 %.2150
  %20 = icmp eq i32 %.3151, 0
  %21 = add i32 %.3151, %2
  %22 = icmp sgt i32 %21, %3
  %.0152 = or i1 %20, %22
  br i1 %.0152, label %85, label %23

23:                                               ; preds = %._crit_edge
  %24 = and i32 %12, 7
  %25 = and i32 %12, 15
  %26 = and i32 %12, 31
  %spec.select171 = select i1 %13, i32 %12, i32 0
  %.1 = select i1 %15, i32 %26, i32 %spec.select171
  %.2 = select i1 %17, i32 %25, i32 %.1
  %.3 = select i1 %19, i32 %24, i32 %.2
  store ptr @Range, ptr %6, align 8
  %27 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %28 = call { i64, i64 } @size_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %29 = extractvalue { i64, i64 } %28, 0
  %30 = call ptr @bump_malloc(i64 %29)
  %31 = add nsw i32 %.3151, -1
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %30, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 10, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %35 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7) #39
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range) #39
  %38 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  store ptr @i32_typ, ptr %8, align 8
  %39 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %39, align 8
  %40 = call ptr @behavior_wrapper(ptr %38, { ptr, ptr, ptr, i32 } %34, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %40({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %7, i32 1, i32 %31)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #39
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range) #39
  %43 = load ptr, ptr getelementptr (i8, ptr @Range, i64 152), align 8
  %44 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %34, ptr noundef nonnull align 8 %5)
  %45 = call { ptr, ptr, ptr, i32 } %44({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %5)
  %.fca.0.extract75 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract77 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %46 = call i32 @get_offset(ptr %.fca.0.extract75, ptr noundef nonnull @RangeIterator)
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract75, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract77, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %46, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract75)
  %53 = sext i32 %46 to i64
  %54 = getelementptr ptr, ptr %.fca.0.extract75, i64 %53
  %55 = getelementptr i8, ptr %54, i64 40
  br label %56

56:                                               ; preds = %74, %23
  %.4 = phi i32 [ %.3, %23 ], [ %.6, %74 ]
  %57 = load ptr, ptr %55, align 8
  %58 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 %5)
  %59 = call { ptr, i160 } %58({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %5)
  %.fca.0.extract64 = extractvalue { ptr, i160 } %59, 0
  %60 = icmp ne ptr %.fca.0.extract64, @nil_typ
  %61 = icmp ne ptr %.fca.0.extract64, null
  %.not170 = and i1 %60, %61
  br i1 %.not170, label %62, label %74

62:                                               ; preds = %56
  %.fca.1.extract65 = extractvalue { ptr, i160 } %59, 1
  %.sroa.0.8.extract.trunc = trunc i160 %.fca.1.extract65 to i32
  %63 = add i32 %2, %.sroa.0.8.extract.trunc
  %64 = sext i32 %63 to i64
  %65 = getelementptr i8, ptr %.fca.0.extract10, i64 %64
  %66 = load i8, ptr %65, align 1
  %67 = sext i8 %66 to i32
  %68 = and i32 %67, -64
  %69 = icmp ne i32 %68, -128
  %70 = xor i1 %69, true
  %71 = shl i32 %.4, 6
  %72 = and i32 %67, 63
  %73 = or disjoint i32 %72, %71
  %.5 = select i1 %69, i32 %.4, i32 %73
  br label %74

74:                                               ; preds = %62, %56
  %.reg2mem81.0.off0 = phi i1 [ %70, %62 ], [ false, %56 ]
  %.reg2mem83.0 = phi i1 [ %69, %62 ], [ false, %56 ]
  %.6 = phi i32 [ %.5, %62 ], [ %.4, %56 ]
  br i1 %.reg2mem81.0.off0, label %56, label %75

75:                                               ; preds = %74
  br i1 %.reg2mem83.0, label %85, label %._crit_edge4

._crit_edge4:                                     ; preds = %75
  %76 = icmp eq i32 %.3151, 2
  %77 = icmp slt i32 %.6, -128
  %spec.select172 = select i1 %76, i1 %77, i1 false
  br i1 %spec.select172, label %.critedge175, label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge4
  %not. = xor i1 %19, true
  %78 = and i1 %17, %not.
  %79 = icmp slt i32 %.6, 2048
  %spec.select173 = select i1 %78, i1 %79, i1 false
  %80 = icmp slt i32 %.6, 65536
  %spec.select174 = select i1 %19, i1 %80, i1 false
  %or.cond = select i1 %spec.select173, i1 true, i1 %spec.select174
  br i1 %or.cond, label %.critedge175, label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5
  %81 = and i32 %.6, -2048
  %spec.select176 = icmp eq i32 %81, -10240
  br label %.critedge175

.critedge175:                                     ; preds = %._crit_edge7, %._crit_edge5, %._crit_edge4
  %.0158 = phi i1 [ %spec.select176, %._crit_edge7 ], [ true, %._crit_edge4 ], [ true, %._crit_edge5 ]
  %82 = icmp sgt i32 %.6, 1114111
  %spec.select177 = select i1 %.0158, i1 true, i1 %82
  %.0.vec.insert = insertelement <2 x i32> poison, i32 %.6, i64 0
  %.4.vec.insert = insertelement <2 x i32> %.0.vec.insert, i32 %.3151, i64 1
  %83 = bitcast <2 x i32> %.4.vec.insert to i64
  %84 = select i1 %spec.select177, ptr @nil_typ, ptr @tuple_typ
  br label %85

85:                                               ; preds = %.critedge175, %75, %._crit_edge, %4
  %.reg2mem55.0 = phi ptr [ @nil_typ, %4 ], [ @nil_typ, %._crit_edge ], [ %84, %.critedge175 ], [ @nil_typ, %75 ]
  %.reg2mem57.sroa.3.0 = phi i64 [ poison, %4 ], [ poison, %._crit_edge ], [ %83, %.critedge175 ], [ poison, %75 ]
  %.reload54.fca.0.insert = insertvalue { ptr, i64 } poison, ptr %.reg2mem55.0, 0
  %.reload54.fca.1.insert = insertvalue { ptr, i64 } %.reload54.fca.0.insert, i64 %.reg2mem57.sroa.3.0, 1
  ret { ptr, i64 } %.reload54.fca.1.insert
}

define { ptr, i160 } @_box_tuple_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_tuple_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @tuple_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_tuple_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_tuple_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_RangeIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @RangeIterator_field_RangeIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @RangeIterator_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4, i32 %5) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(168) @RangeIterator)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %9 = sext i32 %7 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract, i64 %9
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  call void %13(ptr %.fca.1.extract, i32 %3) #30
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %15 = getelementptr i8, ptr %10, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %.fca.1.extract, i32 %4) #30
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract)
  %20 = getelementptr i8, ptr %10, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract, i32 %5) #30
  ret void
}

define { ptr, i160 } @RangeIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract23, ptr noundef nonnull align 16 dereferenceable(168) @RangeIterator)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract23)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract23, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract24) #31
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract23)
  %12 = getelementptr i8, ptr %7, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract24) #31
  %16 = icmp sgt i32 %10, %15
  br i1 %16, label %31, label %17

17:                                               ; preds = %3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract23)
  %19 = call i32 %9(ptr %.fca.1.extract24) #31
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract23)
  %21 = call i32 %9(ptr %.fca.1.extract24) #31
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract23)
  %23 = getelementptr i8, ptr %7, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr %.fca.1.extract24) #31
  %27 = add i32 %26, %21
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract23)
  %29 = getelementptr i8, ptr %8, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %.fca.1.extract24, i32 %27) #30
  %.sroa.026.0.insert.ext = zext i32 %19 to i160
  br label %31

31:                                               ; preds = %17, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ @i32_typ, %17 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.sroa.026.0.insert.ext, %17 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_step(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_step(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_end(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_end(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_counter(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_counter(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Range(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @Range_field_Range_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_endi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_step_stepi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 33, i64 32
  %8 = getelementptr [127 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Range_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 35, %22 ], [ 35, %15 ], [ 36, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [127 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 38, %22 ], [ 38, %15 ], [ 37, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [127 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Range_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 40, %22 ], [ 40, %15 ], [ 39, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [127 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Range_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 42, %22 ], [ 42, %15 ], [ 41, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [127 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define void @Range_init_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(1096) @Range)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #30
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = load ptr, ptr %8, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 0) #30
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  call void %21(ptr %.fca.1.extract, i32 1) #30
  ret void
}

define void @Range_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(1096) @Range)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #30
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 %4) #30
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i32 1) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @Range_step_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(1096) @Range)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #30
  %13 = call i32 @get_offset(ptr noundef %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(1096) @Range)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %13, 3
  ret { ptr, ptr, ptr, i32 } %17
}

define i32 @Range_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(1096) @Range)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  %12 = icmp eq i32 %11, 1
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %.fca.1.extract) #31
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %.fca.1.extract) #31
  %22 = sub i32 %17, %21
  br i1 %12, label %27, label %23

23:                                               ; preds = %3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %25 = call i32 %10(ptr %.fca.1.extract) #31
  %26 = sdiv i32 %22, %25
  br label %27

27:                                               ; preds = %23, %3
  %.reg2mem5.0.in = phi i32 [ %26, %23 ], [ %22, %3 ]
  %.reg2mem5.0 = add i32 %.reg2mem5.0.in, 1
  ret i32 %.reg2mem5.0
}

define { ptr, ptr, ptr, i32 } @Range_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(1096) @Range)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call i32 %9(ptr %.fca.1.extract) #31
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %12 = getelementptr i8, ptr %7, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract) #31
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr %.fca.1.extract) #31
  %21 = alloca [1 x ptr], align 8
  store ptr @RangeIterator, ptr %21, align 8
  %22 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_RangeIterator, ptr noundef nonnull align 8 dereferenceable(8) %21)
  %23 = extractvalue { i64, i64 } %22, 0
  %24 = call ptr @bump_malloc(i64 %23)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %26 = load ptr, ptr %7, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract) #31
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %30 = load ptr, ptr %12, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = call i32 %31(ptr %.fca.1.extract) #31
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = load ptr, ptr %17, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %.fca.1.extract) #31
  %37 = insertvalue { ptr, ptr, ptr, i32 } { ptr @RangeIterator, ptr undef, ptr undef, i32 undef }, ptr %24, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr undef, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 10, 3
  %40 = alloca [3 x ptr], align 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %40)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @RangeIterator)
  %45 = alloca { ptr, ptr, ptr }, align 8
  store ptr @i32_typ, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr @i32_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %45, i64 16
  store ptr @i32_typ, ptr %47, align 8
  %48 = call ptr @behavior_wrapper(ptr noundef nonnull @RangeIterator_B_init_counteri32_endi32_stepi32, { ptr, ptr, ptr, i32 } %39, ptr noundef nonnull align 8 dereferenceable(24) %45)
  call void %48({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull %40, i32 %28, i32 %32, i32 %36)
  %49 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(168) @RangeIterator, ptr noundef nonnull @Iterator)
  %50 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %49, 3
  ret { ptr, ptr, ptr, i32 } %50
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_step(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_step(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_end(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_end(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_start(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_start(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Character_getter_codepoint(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_codepoint(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_byte_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_byte_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ConstantTimeIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_List(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i8_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_i8_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i8_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InvalidUTF8Error(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %13)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 168
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @InvalidUTF8Error_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 152
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InvalidUTF8Error_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract56 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract56, ptr noundef nonnull align 16 dereferenceable(192) @Exception)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %8 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract56)
  %10 = sext i32 %6 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract56, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %8, 3
  call void %15(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %19) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract56)
  %21 = load ptr, ptr %11, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract57, i32 0) #30
  %24 = call ptr @bump_malloc(i64 noundef 1)
  %25 = alloca [1 x ptr], align 8
  store ptr @String, ptr %25, align 8
  %26 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %25)
  %27 = extractvalue { i64, i64 } %26, 0
  %28 = call ptr @bump_malloc(i64 %27)
  %29 = insertvalue { ptr } undef, ptr %24, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %28, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr undef, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 10, 3
  %33 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %33, i64 8
  store ptr @_parameterization_i32, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %33, i64 16
  store ptr @_parameterization_i32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %33, i64 24
  store ptr @_parameterization_i32, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %33)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %39 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @i32_typ, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @i32_typ, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr @i32_typ, ptr %42, align 8
  %43 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %32, ptr noundef nonnull align 8 dereferenceable(32) %39)
  call void %43({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull %33, { ptr } %29, i32 0, i32 0, i32 1)
  %44 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract56)
  %46 = getelementptr i8, ptr %11, i64 8
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %44, 3
  call void %49(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %50) #30
  %51 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %51, align 8
  %52 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Stacktrace, ptr noundef nonnull align 8 dereferenceable(8) %51)
  %53 = extractvalue { i64, i64 } %52, 0
  %54 = call ptr @bump_malloc(i64 %53)
  %55 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %54, 1
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr undef, 2
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 10, 3
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %60 = call ptr @behavior_wrapper(ptr noundef nonnull @Stacktrace_B_init_, { ptr, ptr, ptr, i32 } %57, ptr noundef nonnull align 8 %5)
  call void %60({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull %5)
  %61 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace, ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract56)
  %63 = getelementptr i8, ptr %11, i64 24
  %64 = load ptr, ptr %63, align 8
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %61, 3
  call void %66(ptr %.fca.1.extract57, { ptr, ptr, ptr, i32 } %67) #30
  ret void
}

define void @InvalidUTF8Error_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(304) @InvalidUTF8Error)
  %6 = call ptr @bump_malloc(i64 noundef 61)
  store <60 x i8> <i8 73, i8 110, i8 118, i8 97, i8 108, i8 105, i8 100, i8 32, i8 85, i8 84, i8 70, i8 45, i8 56, i8 32, i8 115, i8 101, i8 113, i8 117, i8 101, i8 110, i8 99, i8 101, i8 32, i8 101, i8 110, i8 99, i8 111, i8 117, i8 110, i8 116, i8 101, i8 114, i8 101, i8 100, i8 32, i8 100, i8 117, i8 114, i8 105, i8 110, i8 103, i8 32, i8 115, i8 116, i8 114, i8 105, i8 110, i8 103, i8 32, i8 99, i8 111, i8 110, i8 118, i8 101, i8 114, i8 115, i8 105, i8 111, i8 110, i8 46>, ptr %6, align 1
  %7 = alloca [1 x ptr], align 8
  store ptr @String, ptr %7, align 8
  %8 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %9 = extractvalue { i64, i64 } %8, 0
  %10 = call ptr @bump_malloc(i64 %9)
  %11 = insertvalue { ptr } undef, ptr %6, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %10, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr undef, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 10, 3
  %15 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %15)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %21 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr @i32_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %14, ptr noundef nonnull align 8 dereferenceable(32) %21)
  call void %25({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull %15, { ptr } %11, i32 60, i32 60, i32 61)
  %26 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef %.fca.0.extract)
  %28 = sext i32 %5 to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract, i64 %28
  %30 = getelementptr i8, ptr %29, i64 16
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %26, 3
  call void %33(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %34) #30
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef %.fca.0.extract)
  %36 = load ptr, ptr %29, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract, i32 0) #30
  %39 = call ptr @bump_malloc(i64 noundef 1)
  %40 = alloca [1 x ptr], align 8
  store ptr @String, ptr %40, align 8
  %41 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %40)
  %42 = extractvalue { i64, i64 } %41, 0
  %43 = call ptr @bump_malloc(i64 %42)
  %44 = insertvalue { ptr } undef, ptr %39, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %43, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 10, 3
  %48 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %48, i64 8
  store ptr @_parameterization_i32, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %48, i64 16
  store ptr @_parameterization_i32, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %48, i64 24
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %48)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %54 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %54, i64 16
  store ptr @i32_typ, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %54, i64 24
  store ptr @i32_typ, ptr %57, align 8
  %58 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %47, ptr noundef nonnull align 8 dereferenceable(32) %54)
  call void %58({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull %48, { ptr } %44, i32 0, i32 0, i32 1)
  %59 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef %.fca.0.extract)
  %61 = getelementptr i8, ptr %29, i64 8
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %59, 3
  call void %64(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %65) #30
  %66 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %66, align 8
  %67 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Stacktrace, ptr noundef nonnull align 8 dereferenceable(8) %66)
  %68 = extractvalue { i64, i64 } %67, 0
  %69 = call ptr @bump_malloc(i64 %68)
  %70 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %69, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr undef, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 10, 3
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %75 = call ptr @behavior_wrapper(ptr noundef nonnull @Stacktrace_B_init_, { ptr, ptr, ptr, i32 } %72, ptr noundef nonnull align 8 %4)
  call void %75({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull %4)
  %76 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace, ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 224, ptr nocapture nofree noundef %.fca.0.extract)
  %78 = getelementptr i8, ptr %29, i64 24
  %79 = load ptr, ptr %78, align 8
  %80 = getelementptr i8, ptr %79, i64 8
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %76, 3
  call void %81(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %82) #30
  ret void
}

define void @Exception_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(192) @Exception)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract17)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract17, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract18, i32 %3) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %13 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %14 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract17)
  %16 = getelementptr i8, ptr %9, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %14, 3
  call void %19(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %23) #30
  ret void
}

define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract180 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract182 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract184 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %5 = call i32 @get_offset(ptr %.fca.0.extract180, ptr noundef nonnull align 16 dereferenceable(192) @Exception)
  %6 = call ptr @bump_malloc(i64 noundef 10)
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %6, align 1
  %7 = alloca [1 x ptr], align 8
  store ptr @String, ptr %7, align 8
  %8 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %9 = extractvalue { i64, i64 } %8, 0
  %10 = call ptr @bump_malloc(i64 %9)
  %11 = insertvalue { ptr } undef, ptr %6, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %10, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr undef, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 10, 3
  %15 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %15)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %21 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr @i32_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %14, ptr noundef nonnull align 8 dereferenceable(32) %21)
  call void %25({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull %15, { ptr } %11, i32 9, i32 9, i32 10)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %28 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %14, ptr noundef nonnull align 8 %4)
  %29 = call { ptr } %28({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull align 8 %4)
  %.fca.0.extract139 = extractvalue { ptr } %29, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract139) #40
  %30 = call ptr @bump_malloc(i64 noundef 27)
  store <26 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110, i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105, i8 108, i8 101>, ptr %30, align 1
  %31 = alloca [1 x ptr], align 8
  store ptr @String, ptr %31, align 8
  %32 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %33 = extractvalue { i64, i64 } %32, 0
  %34 = call ptr @bump_malloc(i64 %33)
  %35 = insertvalue { ptr } undef, ptr %30, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %34, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr undef, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 10, 3
  %39 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @_parameterization_i32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %39, i64 24
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %39)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %45 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr @i32_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %45, i64 16
  store ptr @i32_typ, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %45, i64 24
  store ptr @i32_typ, ptr %48, align 8
  %49 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %38, ptr noundef nonnull align 8 dereferenceable(32) %45)
  call void %49({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull %39, { ptr } %35, i32 26, i32 26, i32 27)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %52 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %38, ptr noundef nonnull align 8 %4)
  %53 = call { ptr } %52({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4)
  %.fca.0.extract112 = extractvalue { ptr } %53, 0
  %puts189 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract112) #40
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract180)
  %55 = sext i32 %5 to i64
  %56 = getelementptr ptr, ptr %.fca.0.extract180, i64 %55
  %57 = getelementptr i8, ptr %56, i64 8
  %58 = load ptr, ptr %57, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract182) #31
  %61 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract104 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  store ptr %.fca.0.extract104, ptr %61, align 8
  %.fca.1.extract106 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.1.gep107 = getelementptr inbounds i8, ptr %61, i64 8
  store ptr %.fca.1.extract106, ptr %.fca.1.gep107, align 8
  %.fca.2.extract108 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.2.gep109 = getelementptr inbounds i8, ptr %61, i64 16
  store ptr %.fca.2.extract108, ptr %.fca.2.gep109, align 8
  %.fca.3.extract110 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %.fca.3.gep111 = getelementptr inbounds i8, ptr %61, i64 24
  store i32 %.fca.3.extract110, ptr %.fca.3.gep111, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %61, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %62 = load ptr, ptr %61, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %.fca.1.gep107, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %.fca.2.gep109, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %.fca.3.gep111, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %62)
  %72 = sext i32 %68 to i64
  %73 = getelementptr ptr, ptr %62, i64 %72
  %74 = getelementptr i8, ptr %73, i64 104
  %75 = load ptr, ptr %74, align 8
  %76 = call ptr @behavior_wrapper(ptr %75, { ptr, ptr, ptr, i32 } %69, ptr noundef nonnull align 8 %4)
  %77 = call { ptr } %76({ ptr, ptr, ptr, i32 } %69, { ptr, ptr, ptr, i32 } %69, ptr nonnull align 8 %4)
  %.fca.0.extract101 = extractvalue { ptr } %77, 0
  %puts190 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract101) #40
  %78 = call ptr @bump_malloc(i64 noundef 8)
  store <7 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101>, ptr %78, align 1
  %79 = alloca [1 x ptr], align 8
  store ptr @String, ptr %79, align 8
  %80 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %79)
  %81 = extractvalue { i64, i64 } %80, 0
  %82 = call ptr @bump_malloc(i64 %81)
  %83 = insertvalue { ptr } undef, ptr %78, 0
  %84 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %82, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr undef, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 10, 3
  %87 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %87, i64 8
  store ptr @_parameterization_i32, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %87, i64 16
  store ptr @_parameterization_i32, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %87, i64 24
  store ptr @_parameterization_i32, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %87)
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %93 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %93, i64 8
  store ptr @i32_typ, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %93, i64 16
  store ptr @i32_typ, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %93, i64 24
  store ptr @i32_typ, ptr %96, align 8
  %97 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(32) %93)
  call void %97({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %87, { ptr } %83, i32 7, i32 7, i32 8)
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %100 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 %4)
  %101 = call { ptr } %100({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull align 8 %4)
  %.fca.0.extract74 = extractvalue { ptr } %101, 0
  %puts191 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract74) #40
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract180)
  %103 = load ptr, ptr %56, align 8
  %104 = load ptr, ptr %103, align 8
  %105 = call i32 %104(ptr %.fca.1.extract182) #31
  %106 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %105) #40
  %107 = call ptr @bump_malloc(i64 noundef 13)
  store <12 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115, i8 115, i8 97, i8 103, i8 101>, ptr %107, align 1
  %108 = alloca [1 x ptr], align 8
  store ptr @String, ptr %108, align 8
  %109 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %108)
  %110 = extractvalue { i64, i64 } %109, 0
  %111 = call ptr @bump_malloc(i64 %110)
  %112 = insertvalue { ptr } undef, ptr %107, 0
  %113 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %111, 1
  %114 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr undef, 2
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, i32 10, 3
  %116 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %116, align 8
  %117 = getelementptr inbounds i8, ptr %116, i64 8
  store ptr @_parameterization_i32, ptr %117, align 8
  %118 = getelementptr inbounds i8, ptr %116, i64 16
  store ptr @_parameterization_i32, ptr %118, align 8
  %119 = getelementptr inbounds i8, ptr %116, i64 24
  store ptr @_parameterization_i32, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %116)
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %122 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %122, align 8
  %123 = getelementptr inbounds i8, ptr %122, i64 8
  store ptr @i32_typ, ptr %123, align 8
  %124 = getelementptr inbounds i8, ptr %122, i64 16
  store ptr @i32_typ, ptr %124, align 8
  %125 = getelementptr inbounds i8, ptr %122, i64 24
  store ptr @i32_typ, ptr %125, align 8
  %126 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %115, ptr noundef nonnull align 8 dereferenceable(32) %122)
  call void %126({ ptr, ptr, ptr, i32 } %115, { ptr, ptr, ptr, i32 } %115, ptr nonnull %116, { ptr } %112, i32 12, i32 12, i32 13)
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %129 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %115, ptr noundef nonnull align 8 %4)
  %130 = call { ptr } %129({ ptr, ptr, ptr, i32 } %115, { ptr, ptr, ptr, i32 } %115, ptr nonnull align 8 %4)
  %.fca.0.extract46 = extractvalue { ptr } %130, 0
  %puts192 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract46) #40
  %131 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract180, 0
  %132 = insertvalue { ptr, ptr, ptr, i32 } %131, ptr %.fca.1.extract182, 1
  %133 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %.fca.2.extract184, 2
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, i32 %5, 3
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract180)
  %137 = getelementptr i8, ptr %56, i64 64
  %138 = load ptr, ptr %137, align 8
  %139 = call ptr @behavior_wrapper(ptr %138, { ptr, ptr, ptr, i32 } %134, ptr noundef nonnull align 8 %4)
  call void %139({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr nonnull align 8 %4)
  %140 = call ptr @bump_malloc(i64 noundef 13)
  store <12 x i8> <i8 83, i8 116, i8 97, i8 99, i8 107, i8 32, i8 116, i8 114, i8 97, i8 99, i8 101, i8 58>, ptr %140, align 1
  %141 = alloca [1 x ptr], align 8
  store ptr @String, ptr %141, align 8
  %142 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %141)
  %143 = extractvalue { i64, i64 } %142, 0
  %144 = call ptr @bump_malloc(i64 %143)
  %145 = insertvalue { ptr } undef, ptr %140, 0
  %146 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %144, 1
  %147 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr undef, 2
  %148 = insertvalue { ptr, ptr, ptr, i32 } %147, i32 10, 3
  %149 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %149, align 8
  %150 = getelementptr inbounds i8, ptr %149, i64 8
  store ptr @_parameterization_i32, ptr %150, align 8
  %151 = getelementptr inbounds i8, ptr %149, i64 16
  store ptr @_parameterization_i32, ptr %151, align 8
  %152 = getelementptr inbounds i8, ptr %149, i64 24
  store ptr @_parameterization_i32, ptr %152, align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %149)
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %155 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %155, align 8
  %156 = getelementptr inbounds i8, ptr %155, i64 8
  store ptr @i32_typ, ptr %156, align 8
  %157 = getelementptr inbounds i8, ptr %155, i64 16
  store ptr @i32_typ, ptr %157, align 8
  %158 = getelementptr inbounds i8, ptr %155, i64 24
  store ptr @i32_typ, ptr %158, align 8
  %159 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %148, ptr noundef nonnull align 8 dereferenceable(32) %155)
  call void %159({ ptr, ptr, ptr, i32 } %148, { ptr, ptr, ptr, i32 } %148, ptr nonnull %149, { ptr } %145, i32 12, i32 12, i32 13)
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %162 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %148, ptr noundef nonnull align 8 %4)
  %163 = call { ptr } %162({ ptr, ptr, ptr, i32 } %148, { ptr, ptr, ptr, i32 } %148, ptr nonnull align 8 %4)
  %.fca.0.extract19 = extractvalue { ptr } %163, 0
  %puts193 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract19) #40
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract180)
  %165 = getelementptr i8, ptr %56, i64 24
  %166 = load ptr, ptr %165, align 8
  %167 = load ptr, ptr %166, align 8
  %168 = call { ptr, ptr, ptr, i32 } %167(ptr %.fca.1.extract182) #31
  %169 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %168, 0
  store ptr %.fca.0.extract18, ptr %169, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %168, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %169, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %168, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %169, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %168, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %169, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %169, ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %170 = load ptr, ptr %169, align 8
  %171 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %170, 0
  %172 = load ptr, ptr %.fca.1.gep, align 8
  %173 = insertvalue { ptr, ptr, ptr, i32 } %171, ptr %172, 1
  %174 = load ptr, ptr %.fca.2.gep, align 8
  %175 = insertvalue { ptr, ptr, ptr, i32 } %173, ptr %174, 2
  %176 = load i32, ptr %.fca.3.gep, align 8
  %177 = insertvalue { ptr, ptr, ptr, i32 } %175, i32 %176, 3
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %170)
  %180 = sext i32 %176 to i64
  %181 = getelementptr ptr, ptr %170, i64 %180
  %182 = getelementptr i8, ptr %181, i64 24
  %183 = load ptr, ptr %182, align 8
  %184 = call ptr @behavior_wrapper(ptr %183, { ptr, ptr, ptr, i32 } %177, ptr noundef nonnull align 8 %4)
  call void %184({ ptr, ptr, ptr, i32 } %177, { ptr, ptr, ptr, i32 } %177, ptr nonnull align 8 %4)
  %185 = call ptr @bump_malloc(i64 noundef 10)
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %185, align 1
  %186 = alloca [1 x ptr], align 8
  store ptr @String, ptr %186, align 8
  %187 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %186)
  %188 = extractvalue { i64, i64 } %187, 0
  %189 = call ptr @bump_malloc(i64 %188)
  %190 = insertvalue { ptr } undef, ptr %185, 0
  %191 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %189, 1
  %192 = insertvalue { ptr, ptr, ptr, i32 } %191, ptr undef, 2
  %193 = insertvalue { ptr, ptr, ptr, i32 } %192, i32 10, 3
  %194 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %194, align 8
  %195 = getelementptr inbounds i8, ptr %194, i64 8
  store ptr @_parameterization_i32, ptr %195, align 8
  %196 = getelementptr inbounds i8, ptr %194, i64 16
  store ptr @_parameterization_i32, ptr %196, align 8
  %197 = getelementptr inbounds i8, ptr %194, i64 24
  store ptr @_parameterization_i32, ptr %197, align 8
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %194)
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %200 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %200, align 8
  %201 = getelementptr inbounds i8, ptr %200, i64 8
  store ptr @i32_typ, ptr %201, align 8
  %202 = getelementptr inbounds i8, ptr %200, i64 16
  store ptr @i32_typ, ptr %202, align 8
  %203 = getelementptr inbounds i8, ptr %200, i64 24
  store ptr @i32_typ, ptr %203, align 8
  %204 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %193, ptr noundef nonnull align 8 dereferenceable(32) %200)
  call void %204({ ptr, ptr, ptr, i32 } %193, { ptr, ptr, ptr, i32 } %193, ptr nonnull %194, { ptr } %190, i32 9, i32 9, i32 10)
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %207 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %193, ptr noundef nonnull align 8 %4)
  %208 = call { ptr } %207({ ptr, ptr, ptr, i32 } %193, { ptr, ptr, ptr, i32 } %193, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr } %208, 0
  %puts194 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #40
  ret void
}

define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract5, ptr noundef nonnull align 16 dereferenceable(192) @Exception)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract5)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract5, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract7) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract1, ptr %13, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 104
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr } %29, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #40
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #27

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 104, i64 8 }
}

define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 152
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Exception_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %13)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 168
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(192) @Exception)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  call void %11(ptr %.fca.1.extract, i32 0) #30
  %12 = call ptr @bump_malloc(i64 noundef 7)
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %12, align 1
  %13 = alloca [1 x ptr], align 8
  store ptr @String, ptr %13, align 8
  %14 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %13)
  %15 = extractvalue { i64, i64 } %14, 0
  %16 = call ptr @bump_malloc(i64 %15)
  %17 = insertvalue { ptr } undef, ptr %12, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %16, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr undef, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 10, 3
  %21 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr @_parameterization_i32, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr @_parameterization_i32, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store ptr @_parameterization_i32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %21)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %27 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %27, i64 8
  store ptr @i32_typ, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %27, i64 16
  store ptr @i32_typ, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %27, i64 24
  store ptr @i32_typ, ptr %30, align 8
  %31 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(32) %27)
  call void %31({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %21, { ptr } %17, i32 6, i32 6, i32 7)
  %32 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract)
  %34 = getelementptr i8, ptr %8, i64 16
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %32, 3
  call void %37(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %38) #30
  %39 = call ptr @bump_malloc(i64 noundef 1)
  %40 = alloca [1 x ptr], align 8
  store ptr @String, ptr %40, align 8
  %41 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %40)
  %42 = extractvalue { i64, i64 } %41, 0
  %43 = call ptr @bump_malloc(i64 %42)
  %44 = insertvalue { ptr } undef, ptr %39, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %43, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 10, 3
  %48 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %48, i64 8
  store ptr @_parameterization_i32, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %48, i64 16
  store ptr @_parameterization_i32, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %48, i64 24
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %48)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %54 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %54, i64 16
  store ptr @i32_typ, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %54, i64 24
  store ptr @i32_typ, ptr %57, align 8
  %58 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %47, ptr noundef nonnull align 8 dereferenceable(32) %54)
  call void %58({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull %48, { ptr } %44, i32 0, i32 0, i32 1)
  %59 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract)
  %61 = getelementptr i8, ptr %8, i64 8
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %59, 3
  call void %64(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %65) #30
  %66 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %66, align 8
  %67 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Stacktrace, ptr noundef nonnull align 8 dereferenceable(8) %66)
  %68 = extractvalue { i64, i64 } %67, 0
  %69 = call ptr @bump_malloc(i64 %68)
  %70 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %69, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr undef, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 10, 3
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %75 = call ptr @behavior_wrapper(ptr noundef nonnull @Stacktrace_B_init_, { ptr, ptr, ptr, i32 } %72, ptr noundef nonnull align 8 %4)
  call void %75({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull %4)
  %76 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace, ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract)
  %78 = getelementptr i8, ptr %8, i64 24
  %79 = load ptr, ptr %78, align 8
  %80 = getelementptr i8, ptr %79, i64 8
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %76, 3
  call void %81(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %82) #30
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Stacktrace(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Stacktrace_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Stacktrace_B_print_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Stacktrace_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %5 = call ptr @bump_malloc(i64 noundef 800)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract15)
  %7 = sext i32 %4 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract15, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr } undef, ptr %5, 0
  call void %11(ptr %.fca.1.extract, { ptr } %12) #30
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract15)
  %14 = load ptr, ptr %8, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call { ptr } %15(ptr %.fca.1.extract) #31
  %17 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %16)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract15)
  %19 = getelementptr i8, ptr %8, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %.fca.1.extract, i64 %17) #30
  ret void
}

define void @Stacktrace_print_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract8, ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract8)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = call { ptr } %9(ptr %.fca.1.extract) #31
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract8)
  %12 = getelementptr i8, ptr %7, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i64 %14(ptr %.fca.1.extract) #31
  call void @print_backtrace({ ptr } %10, i64 %15)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @Stacktrace_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Stacktrace_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Stacktrace_getter_stacktrace(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Stacktrace_setter_stacktrace(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #7 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_message(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_file_name(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @InvalidUTF8Error_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InvalidUTF8Error_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_char_length(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_char_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_byte_length(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_byte_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #7 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(96) @Representable)
  %5 = call ptr @bump_malloc(i64 noundef 7)
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %5, align 1
  %6 = alloca [1 x ptr], align 8
  store ptr @String, ptr %6, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = call ptr @bump_malloc(i64 %8)
  %10 = insertvalue { ptr } undef, ptr %5, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %9, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr undef, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 10, 3
  %14 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_i32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %14, i64 24
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %14)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %20 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @i32_typ, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr @i32_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %20, i64 24
  store ptr @i32_typ, ptr %23, align 8
  %24 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(32) %20)
  call void %24({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %14, { ptr } %10, i32 6, i32 6, i32 7)
  %25 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %26 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %25, 3
  ret { ptr, ptr, ptr, i32 } %26
}

define ptr @KeyNotFound_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @String, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 152
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_message(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_file_name(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @KeyNotFound_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Map(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IndexableCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Indexable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapValues(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @MapValues_B_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef -5249855671126779970, i64 noundef ptrtoint (ptr @Map to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 224
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValues_field_MapValues_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValues_field_MapValues_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapValues_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 264
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValues_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapValues_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 30, %22 ], [ 30, %15 ], [ 31, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @MapValues_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 33, %22 ], [ 33, %15 ], [ 32, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @MapValues_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 35, %22 ], [ 35, %15 ], [ 34, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @MapValues_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 37, %22 ], [ 37, %15 ], [ 36, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define void @MapValues_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull align 16 dereferenceable(1056) @MapValues)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract13)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract13, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %18) #30
  ret void
}

define i32 @MapValues_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract4, ptr noundef nonnull align 16 dereferenceable(1056) @MapValues)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract4)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract4, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract6) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract, ptr %13, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 96
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  ret i32 %29
}

define { ptr, ptr, ptr, i32 } @MapValues_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract66, ptr noundef nonnull align 16 dereferenceable(1056) @MapValues)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract66, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract68) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract39, ptr %13, align 8
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep42 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract41, ptr %.fca.1.gep42, align 8
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep44 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract43, ptr %.fca.2.gep44, align 8
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep46 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract45, ptr %.fca.3.gep46, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep42, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep44, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep46, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 112
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract27, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %32 = load ptr, ptr %8, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract68)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %35 = getelementptr i8, ptr %8, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = call ptr @typegetter_wrapper(ptr %36, ptr %.fca.1.extract68)
  %38 = alloca [3 x ptr], align 8
  store ptr @MapValueIterator, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr %33, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %38, i64 16
  store ptr %37, ptr %40, align 8
  %41 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapValueIterator, ptr noundef nonnull align 8 dereferenceable(24) %38)
  %42 = extractvalue { i64, i64 } %41, 0
  %43 = call ptr @bump_malloc(i64 %42)
  store ptr %33, ptr %43, align 8
  %44 = getelementptr i8, ptr %43, i64 8
  store ptr %37, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %43)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %47 = load ptr, ptr %9, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %.fca.1.extract68) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract14, ptr %50, align 8
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract15, ptr %.fca.1.gep, align 8
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract16, ptr %.fca.2.gep, align 8
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract17, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 112
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %67 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %68 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.1.extract, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %.fca.2.extract, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %68, 3
  %73 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapValueIterator, ptr undef, ptr undef, i32 undef }, ptr %43, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr undef, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 10, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %77 = load ptr, ptr %8, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %.fca.1.extract68)
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %80 = load ptr, ptr %35, align 8
  %81 = call ptr @typegetter_wrapper(ptr %80, ptr %.fca.1.extract68)
  %82 = call ptr @bump_malloc(i64 noundef 24)
  %83 = call ptr @bump_malloc(i64 noundef 32)
  %84 = getelementptr i8, ptr %83, i64 16
  store ptr %81, ptr %84, align 8
  %85 = getelementptr i8, ptr %83, i64 8
  store ptr %78, ptr %85, align 8
  %86 = getelementptr i8, ptr %83, i64 24
  store ptr null, ptr %86, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %83)
  store ptr @Pair, ptr %83, align 8
  %88 = getelementptr i8, ptr %82, i64 8
  store ptr %83, ptr %88, align 8
  %89 = getelementptr i8, ptr %82, i64 16
  store ptr null, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  store ptr @Iterator, ptr %82, align 8
  %91 = alloca [1 x ptr], align 8
  store ptr %82, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %91)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @MapValueIterator)
  %94 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %94, align 8
  %95 = call ptr @behavior_wrapper(ptr noundef nonnull @MapValueIterator_B_init_map_iteratorIteratorPairK._V, { ptr, ptr, ptr, i32 } %75, ptr noundef nonnull align 8 dereferenceable(8) %94)
  call void %95({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull %91, { ptr, ptr, ptr, i32 } %72)
  %96 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(160) @MapValueIterator, ptr noundef nonnull @Iterator)
  %97 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %96, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapValueIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @MapValueIterator_B_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterator, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 120
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValueIterator_field_MapValueIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapValueIterator_field_MapValueIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapValueIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @MapValueIterator_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull align 16 dereferenceable(160) @MapValueIterator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract13)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract13, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %18) #30
  ret void
}

define { ptr, i160 } @MapValueIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(160) @MapValueIterator)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract15)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract15, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract17) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract2, ptr %13, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull @Iterator)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, i160 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %29, 0
  %30 = icmp ne ptr %.fca.0.extract, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %30, %31
  br i1 %.not43, label %32, label %48

32:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %29, 1
  %.sroa.3.sroa.2.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.sroa.2.0.extract.trunc = trunc i160 %.sroa.3.sroa.2.0.extract.shift to i64
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %33 = inttoptr i64 %.sroa.3.sroa.0.0.extract.trunc to ptr
  %34 = inttoptr i64 %.sroa.3.sroa.2.0.extract.trunc to ptr
  %35 = call i32 @get_offset(ptr nonnull %.fca.0.extract, ptr noundef nonnull @Pair)
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %33, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %34, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %35, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %42 = sext i32 %35 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract, i64 %42
  %44 = getelementptr i8, ptr %43, i64 40
  %45 = load ptr, ptr %44, align 8
  %46 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %39, ptr noundef nonnull align 8 %4)
  %47 = call { ptr, i160 } %46({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull %4)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %47, 0
  %.fca.1.extract30 = extractvalue { ptr, i160 } %47, 1
  br label %48

48:                                               ; preds = %32, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract28, %32 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract30, %32 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapValueIterator_getter_map_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapValueIterator_setter_map_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapValues_getter_map(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapValues_setter_map(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapKeys(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @MapKeys_B_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef -5249855671126779970, i64 noundef ptrtoint (ptr @Map to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 224
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeys_field_MapKeys_1(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeys_field_MapKeys_0(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapKeys_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 264
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [122 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeys_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapKeys_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 30, %22 ], [ 30, %15 ], [ 31, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @MapKeys_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 33, %22 ], [ 33, %15 ], [ 32, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @MapKeys_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 35, %22 ], [ 35, %15 ], [ 34, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @MapKeys_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 37, %22 ], [ 37, %15 ], [ 36, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [122 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define void @MapKeys_init_mapMapK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull align 16 dereferenceable(1056) @MapKeys)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract13)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract13, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %18) #30
  ret void
}

define i32 @MapKeys_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract4, ptr noundef nonnull align 16 dereferenceable(1056) @MapKeys)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract4)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract4, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract6) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract, ptr %13, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 96
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call i32 %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  ret i32 %29
}

define { ptr, ptr, ptr, i32 } @MapKeys_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract66 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract68 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract66, ptr noundef nonnull align 16 dereferenceable(1056) @MapKeys)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract66, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract68) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract39, ptr %13, align 8
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep42 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract41, ptr %.fca.1.gep42, align 8
  %.fca.2.extract43 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep44 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract43, ptr %.fca.2.gep44, align 8
  %.fca.3.extract45 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep46 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract45, ptr %.fca.3.gep46, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep42, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep44, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep46, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 112
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, ptr, ptr, i32 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %29, 0
  %30 = call i32 @get_offset(ptr %.fca.0.extract27, ptr noundef nonnull @Iterator)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %32 = load ptr, ptr %8, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %.fca.1.extract68)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %35 = getelementptr i8, ptr %8, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = call ptr @typegetter_wrapper(ptr %36, ptr %.fca.1.extract68)
  %38 = alloca [3 x ptr], align 8
  store ptr @MapKeyIterator, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr %33, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %38, i64 16
  store ptr %37, ptr %40, align 8
  %41 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapKeyIterator, ptr noundef nonnull align 8 dereferenceable(24) %38)
  %42 = extractvalue { i64, i64 } %41, 0
  %43 = call ptr @bump_malloc(i64 %42)
  store ptr %33, ptr %43, align 8
  %44 = getelementptr i8, ptr %43, i64 8
  store ptr %37, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %43)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %47 = load ptr, ptr %9, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %.fca.1.extract68) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract14, ptr %50, align 8
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract15, ptr %.fca.1.gep, align 8
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract16, ptr %.fca.2.gep, align 8
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract17, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 2224, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 112
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %67 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %68 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.1.extract, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %.fca.2.extract, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %68, 3
  %73 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapKeyIterator, ptr undef, ptr undef, i32 undef }, ptr %43, 1
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr undef, 2
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 10, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %77 = load ptr, ptr %35, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %.fca.1.extract68)
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 976, ptr nocapture nofree noundef %.fca.0.extract66)
  %80 = load ptr, ptr %8, align 8
  %81 = call ptr @typegetter_wrapper(ptr %80, ptr %.fca.1.extract68)
  %82 = call ptr @bump_malloc(i64 noundef 24)
  %83 = call ptr @bump_malloc(i64 noundef 32)
  %84 = getelementptr i8, ptr %83, i64 16
  store ptr %81, ptr %84, align 8
  %85 = getelementptr i8, ptr %83, i64 8
  store ptr %78, ptr %85, align 8
  %86 = getelementptr i8, ptr %83, i64 24
  store ptr null, ptr %86, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %83)
  store ptr @Pair, ptr %83, align 8
  %88 = getelementptr i8, ptr %82, i64 8
  store ptr %83, ptr %88, align 8
  %89 = getelementptr i8, ptr %82, i64 16
  store ptr null, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  store ptr @Iterator, ptr %82, align 8
  %91 = alloca [1 x ptr], align 8
  store ptr %82, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %91)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @MapKeyIterator)
  %94 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %94, align 8
  %95 = call ptr @behavior_wrapper(ptr noundef nonnull @MapKeyIterator_B_init_map_iteratorIteratorPairK._V, { ptr, ptr, ptr, i32 } %75, ptr noundef nonnull align 8 dereferenceable(8) %94)
  call void %95({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull %91, { ptr, ptr, ptr, i32 } %72)
  %96 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(160) @MapKeyIterator, ptr noundef nonnull @Iterator)
  %97 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %96, 3
  ret { ptr, ptr, ptr, i32 } %97
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapKeyIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @MapKeyIterator_B_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterator, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 120
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeyIterator_field_MapKeyIterator_1(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapKeyIterator_field_MapKeyIterator_0(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapKeyIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @MapKeyIterator_init_map_iteratorIteratorPairK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract13, ptr noundef nonnull align 16 dereferenceable(160) @MapKeyIterator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract13)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract13, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %18) #30
  ret void
}

define { ptr, i160 } @MapKeyIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract15, ptr noundef nonnull align 16 dereferenceable(160) @MapKeyIterator)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract15)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract15, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract17) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract2, ptr %13, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull @Iterator)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr, i160 } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %29, 0
  %30 = icmp ne ptr %.fca.0.extract, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %30, %31
  br i1 %.not43, label %32, label %48

32:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %29, 1
  %.sroa.3.sroa.2.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.sroa.2.0.extract.trunc = trunc i160 %.sroa.3.sroa.2.0.extract.shift to i64
  %.sroa.3.sroa.0.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %33 = inttoptr i64 %.sroa.3.sroa.0.0.extract.trunc to ptr
  %34 = inttoptr i64 %.sroa.3.sroa.2.0.extract.trunc to ptr
  %35 = call i32 @get_offset(ptr nonnull %.fca.0.extract, ptr noundef nonnull @Pair)
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %33, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %34, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %35, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %42 = sext i32 %35 to i64
  %43 = getelementptr ptr, ptr %.fca.0.extract, i64 %42
  %44 = getelementptr i8, ptr %43, i64 32
  %45 = load ptr, ptr %44, align 8
  %46 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %39, ptr noundef nonnull align 8 %4)
  %47 = call { ptr, i160 } %46({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull %4)
  %.fca.0.extract28 = extractvalue { ptr, i160 } %47, 0
  %.fca.1.extract30 = extractvalue { ptr, i160 } %47, 1
  br label %48

48:                                               ; preds = %32, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract28, %32 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract30, %32 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapKeyIterator_getter_map_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapKeyIterator_setter_map_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapKeys_getter_map(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapKeys_setter_map(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #1 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_eq(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_eq(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_hasher(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_hasher(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_size(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_size(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_table_len(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_bool_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_bool_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_bool_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

define ptr @IO_B__Self_print_xNil__Self_print_xi32__Self_print_xRepresentable__Self_print_xCharacter__Self_print_xi8__Self_print_xBool__Self_print_xi64__Self_print_xString__Self_print_xf64(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  %3 = load ptr, ptr %0, align 8
  %4 = icmp eq ptr %3, @nil_typ
  %5 = icmp eq ptr %3, null
  %6 = or i1 %4, %5
  br i1 %6, label %._crit_edge, label %7

7:                                                ; preds = %1
  %8 = icmp eq ptr %3, @bool_typ
  br i1 %8, label %._crit_edge, label %9

9:                                                ; preds = %7
  %10 = icmp eq ptr %3, @i8_typ
  br i1 %10, label %._crit_edge, label %11

11:                                               ; preds = %9
  %12 = icmp eq ptr %3, @i32_typ
  br i1 %12, label %._crit_edge, label %13

13:                                               ; preds = %11
  %14 = icmp eq ptr %3, @i64_typ
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %13
  %16 = icmp eq ptr %3, @f64_typ
  br i1 %16, label %._crit_edge, label %17

17:                                               ; preds = %15
  %18 = getelementptr i8, ptr %3, i64 8
  %19 = getelementptr i8, ptr %3, i64 16
  %20 = getelementptr i8, ptr %3, i64 24
  %21 = getelementptr i8, ptr %3, i64 32
  %22 = load i64, ptr %18, align 4
  %23 = load i64, ptr %19, align 4
  %24 = load ptr, ptr %20, align 8
  %25 = load ptr, ptr %21, align 8
  %26 = load i64, ptr @String, align 4
  %27 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 %26, i64 noundef ptrtoint (ptr @String to i64), ptr %25)
  br i1 %27, label %28, label %.critedge

28:                                               ; preds = %17
  %29 = load i64, ptr %18, align 4
  %30 = load i64, ptr %19, align 4
  %31 = load ptr, ptr %20, align 8
  %32 = load ptr, ptr %21, align 8
  %33 = load i64, ptr @Character, align 4
  %34 = call i1 @subtype_test_wrapper(ptr %31, i64 %30, i64 %29, i64 %33, i64 noundef ptrtoint (ptr @Character to i64), ptr %32)
  br i1 %34, label %.critedge, label %._crit_edge

.critedge:                                        ; preds = %28, %17
  %35 = load i64, ptr %18, align 4
  %36 = load i64, ptr %19, align 4
  %37 = load ptr, ptr %20, align 8
  %38 = load ptr, ptr %21, align 8
  %39 = load i64, ptr @Representable, align 4
  %40 = call i1 @subtype_test_wrapper(ptr %37, i64 %36, i64 %35, i64 %39, i64 noundef ptrtoint (ptr @Representable to i64), ptr %38)
  br i1 %40, label %41, label %.critedge14

41:                                               ; preds = %.critedge
  %42 = load i64, ptr %18, align 4
  %43 = load i64, ptr %19, align 4
  %44 = load ptr, ptr %20, align 8
  %45 = load ptr, ptr %21, align 8
  %46 = load i64, ptr @Character, align 4
  %47 = call i1 @subtype_test_wrapper(ptr %44, i64 %43, i64 %42, i64 %46, i64 noundef ptrtoint (ptr @Character to i64), ptr %45)
  br i1 %47, label %.critedge14, label %48

48:                                               ; preds = %41
  %49 = load i64, ptr %18, align 4
  %50 = load i64, ptr %19, align 4
  %51 = load ptr, ptr %20, align 8
  %52 = load ptr, ptr %21, align 8
  %53 = call i1 @subtype_test_wrapper(ptr %51, i64 %50, i64 %49, i64 %26, i64 noundef ptrtoint (ptr @String to i64), ptr %52)
  br i1 %53, label %.critedge14, label %._crit_edge

.critedge14:                                      ; preds = %48, %41, %.critedge
  %54 = load i64, ptr %18, align 4
  %55 = load i64, ptr %19, align 4
  %56 = load ptr, ptr %20, align 8
  %57 = load ptr, ptr %21, align 8
  %58 = load i64, ptr @Character, align 4
  %59 = call i1 @subtype_test_wrapper(ptr %56, i64 %55, i64 %54, i64 %58, i64 noundef ptrtoint (ptr @Character to i64), ptr %57)
  br i1 %59, label %60, label %._crit_edge

60:                                               ; preds = %.critedge14
  %61 = load i64, ptr %18, align 4
  %62 = load i64, ptr %19, align 4
  %63 = load ptr, ptr %20, align 8
  %64 = load ptr, ptr %21, align 8
  %65 = call i1 @subtype_test_wrapper(ptr %63, i64 %62, i64 %61, i64 %26, i64 noundef ptrtoint (ptr @String to i64), ptr %64)
  br label %._crit_edge

._crit_edge:                                      ; preds = %60, %.critedge14, %48, %28, %15, %13, %11, %9, %7, %1
  %.reg2mem25.0 = phi i32 [ 1, %1 ], [ 6, %7 ], [ 5, %9 ], [ 2, %11 ], [ 7, %13 ], [ 9, %15 ], [ 4, %.critedge14 ], [ 4, %60 ], [ 3, %48 ], [ 8, %28 ]
  %66 = zext nneg i32 %.reg2mem25.0 to i64
  %67 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %66
  %68 = getelementptr i8, ptr %67, i64 80
  %69 = load ptr, ptr %68, align 8
  ret ptr %69
}

define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %4 = call ptr @bump_malloc(i64 noundef 4)
  store <3 x i8> <i8 110, i8 105, i8 108>, ptr %4, align 1
  %5 = alloca [1 x ptr], align 8
  store ptr @String, ptr %5, align 8
  %6 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = call ptr @bump_malloc(i64 %8)
  %10 = insertvalue { ptr } undef, ptr %4, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %9, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr undef, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 10, 3
  %14 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_i32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %14, i64 24
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %14)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %20 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  %21 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr @i32_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr %20, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(32) %21)
  call void %25({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %14, { ptr } %10, i32 3, i32 3, i32 4)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %28 = load ptr, ptr getelementptr (i8, ptr @String, i64 184), align 8
  %29 = call ptr @behavior_wrapper(ptr %28, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 %3)
  %30 = call { ptr } %29({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %3)
  %.fca.0.extract = extractvalue { ptr } %30, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #40
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #28 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #27
  ret void
}

define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract12 = extractvalue { ptr, i160 } %1, 1
  %.sroa.214.8.extract.trunc = trunc i160 %.fca.1.extract12 to i64
  %.sroa.415.8.extract.shift = lshr i160 %.fca.1.extract12, 64
  %.sroa.415.8.extract.trunc = trunc i160 %.sroa.415.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.214.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.415.8.extract.trunc to ptr
  %6 = call i32 @get_offset(ptr %.fca.0.extract11, ptr noundef nonnull @Representable)
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %4, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %5, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef %.fca.0.extract11)
  %13 = sext i32 %6 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract11, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @behavior_wrapper(ptr %15, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %3)
  %17 = call { ptr, ptr, ptr, i32 } %16({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %3)
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %18 = call i32 @get_offset(ptr %.fca.0.extract5, ptr noundef nonnull @String)
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %18, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract5)
  %25 = sext i32 %18 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract5, i64 %25
  %27 = getelementptr i8, ptr %26, i64 104
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr @behavior_wrapper(ptr %28, { ptr, ptr, ptr, i32 } %22, ptr noundef nonnull align 8 %3)
  %30 = call { ptr } %29({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull %3)
  %.fca.0.extract = extractvalue { ptr } %30, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #40
  ret void
}

define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract12 = extractvalue { ptr, i160 } %1, 1
  %.sroa.214.8.extract.trunc = trunc i160 %.fca.1.extract12 to i64
  %.sroa.415.8.extract.shift = lshr i160 %.fca.1.extract12, 64
  %.sroa.415.8.extract.trunc = trunc i160 %.sroa.415.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.214.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.415.8.extract.trunc to ptr
  %6 = call i32 @get_offset(ptr %.fca.0.extract11, ptr noundef nonnull @Character)
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %4, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %5, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract11)
  %13 = sext i32 %6 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract11, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = call ptr @behavior_wrapper(ptr %16, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %3)
  %18 = call { ptr, ptr, ptr, i32 } %17({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %3)
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %19 = call i32 @get_offset(ptr %.fca.0.extract5, ptr noundef nonnull @String)
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %19, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract5)
  %26 = sext i32 %19 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract5, i64 %26
  %28 = getelementptr i8, ptr %27, i64 104
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr @behavior_wrapper(ptr %29, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 %3)
  %31 = call { ptr } %30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %3)
  %.fca.0.extract = extractvalue { ptr } %31, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #40
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #28 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  %3 = sext i8 %.sroa.1.8.extract.trunc to i32
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #27
  ret void
}

define void @IO__Self_print_xBool(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %4 = alloca [1 x ptr], align 8
  %5 = alloca [4 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [4 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.sroa.1.sroa.0 = alloca i8, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %.sroa.1.sroa.0, align 8
  %.sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.8. = load i1, ptr %.sroa.1.sroa.0, align 8
  br i1 %.sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.8., label %10, label %35

10:                                               ; preds = %2
  %11 = call ptr @bump_malloc(i64 noundef 5)
  store <4 x i8> <i8 116, i8 114, i8 117, i8 101>, ptr %11, align 1
  store ptr @String, ptr %4, align 8
  %12 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %13 = call { i64, i64 } @size_wrapper(ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = call ptr @bump_malloc(i64 %14)
  %16 = insertvalue { ptr } undef, ptr %11, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %15, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr undef, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  %20 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr @_parameterization_i32, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @_parameterization_i32, ptr %22, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %5)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %25 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %6, align 8
  %26 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr @i32_typ, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %6, i64 24
  store ptr @i32_typ, ptr %28, align 8
  %29 = call ptr @behavior_wrapper(ptr %25, { ptr, ptr, ptr, i32 } %19, ptr noundef nonnull align 8 dereferenceable(32) %6)
  call void %29({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %5, { ptr } %16, i32 4, i32 4, i32 5)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %32 = load ptr, ptr getelementptr (i8, ptr @String, i64 184), align 8
  %33 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %19, ptr noundef nonnull align 8 %3)
  %34 = call { ptr } %33({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %3)
  br label %60

35:                                               ; preds = %2
  %36 = call ptr @bump_malloc(i64 noundef 6)
  store <5 x i8> <i8 102, i8 97, i8 108, i8 115, i8 101>, ptr %36, align 1
  store ptr @String, ptr %7, align 8
  %37 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %38 = call { i64, i64 } @size_wrapper(ptr %37, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %39 = extractvalue { i64, i64 } %38, 0
  %40 = call ptr @bump_malloc(i64 %39)
  %41 = insertvalue { ptr } undef, ptr %36, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %40, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr undef, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %8, align 8
  %45 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @_parameterization_i32, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @_parameterization_i32, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %8)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %50 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %9, align 8
  %51 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @i32_typ, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @i32_typ, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @i32_typ, ptr %53, align 8
  %54 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 dereferenceable(32) %9)
  call void %54({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull %8, { ptr } %41, i32 5, i32 5, i32 6)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %57 = load ptr, ptr getelementptr (i8, ptr @String, i64 184), align 8
  %58 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %3)
  %59 = call { ptr } %58({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull %3)
  br label %60

60:                                               ; preds = %35, %10
  %.sink = phi { ptr } [ %59, %35 ], [ %34, %10 ]
  %.fca.0.extract1 = extractvalue { ptr } %.sink, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract1) #40
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #28 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #27
  ret void
}

define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %.sroa.4.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.4.8.extract.trunc = trunc i160 %.sroa.4.8.extract.shift to i64
  %4 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %5 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %6 = call i32 @get_offset(ptr %.fca.0.extract5, ptr noundef nonnull @String)
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %4, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %5, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %6, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %.fca.0.extract5)
  %13 = sext i32 %6 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract5, i64 %13
  %15 = getelementptr i8, ptr %14, i64 104
  %16 = load ptr, ptr %15, align 8
  %17 = call ptr @behavior_wrapper(ptr %16, { ptr, ptr, ptr, i32 } %10, ptr noundef nonnull align 8 %3)
  %18 = call { ptr } %17({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull %3)
  %.fca.0.extract = extractvalue { ptr } %18, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #40
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #28 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #27
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_f64_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_f64_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_f64_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i64_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_i64_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i64_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @Array_field_Array_2(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_i32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_bounds_check_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_unchecked_insert_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @any_typ, align 4
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %13)
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = getelementptr i8, ptr %16, i64 464
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_empty_(ptr nocapture nofree %0) #26 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #29
  ret ptr @Array__Self_empty_
}

define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterableT(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %12 = load i64, ptr @Iterable, align 4
  %13 = call i1 @subtype_test_wrapper(ptr %10, i64 %9, i64 %8, i64 %12, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %11)
  ret ptr @Array__Self_from_iterable_iterableIterableT
}

define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 488
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_last_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_extend_otherIterableT_extend_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 55, %22 ], [ 55, %15 ], [ 56, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [529 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 544
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_indices_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_values_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B__set_index_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @any_typ, align 4
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %13)
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = getelementptr i8, ptr %16, i64 576
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 616
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 624
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 632
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 640
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 71, i64 72
  %8 = getelementptr [529 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 664
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 74, %22 ], [ 74, %15 ], [ 75, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [529 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 77, %22 ], [ 77, %15 ], [ 76, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [529 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Array_B_zip_otherCollectionU_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 79, %22 ], [ 79, %15 ], [ 78, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [529 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Array_B_product_otherCollectionU_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 4
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 4
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 81, %22 ], [ 81, %15 ], [ 80, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [529 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 736
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  ret i32 %11
}

define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = call ptr @typegetter_wrapper(ptr %8, ptr %.fca.1.extract)
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 72
  %12 = load ptr, ptr %11, align 8
  %13 = call { i64, i64 } @size_wrapper(ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %9)
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = call ptr @bump_malloc(i64 %14)
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr } undef, ptr %15, 0
  call void %20(ptr %.fca.1.extract, { ptr } %21) #30
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %23 = getelementptr i8, ptr %7, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  call void %26(ptr %.fca.1.extract, i32 0) #30
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr %.fca.1.extract, i32 1) #30
  ret void
}

define void @Array_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #30
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = load ptr, ptr %9, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract) #31
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %18 = load ptr, ptr %8, align 8
  %19 = call ptr @typegetter_wrapper(ptr %18, ptr %.fca.1.extract)
  %20 = sext i32 %16 to i64
  %21 = load ptr, ptr %19, align 8
  %22 = getelementptr i8, ptr %21, i64 72
  %23 = load ptr, ptr %22, align 8
  %24 = call { i64, i64 } @size_wrapper(ptr %23, ptr noundef nonnull align 8 dereferenceable(8) %19)
  %25 = extractvalue { i64, i64 } %24, 0
  %26 = mul i64 %25, %20
  %27 = call ptr @bump_malloc(i64 %26)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %29 = getelementptr i8, ptr %8, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = insertvalue { ptr } undef, ptr %27, 0
  call void %32(ptr %.fca.1.extract, { ptr } %33) #30
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %35 = getelementptr i8, ptr %8, i64 16
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract, i32 0) #30
  ret void
}

define void @Array_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #3 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract12, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract12)
  %9 = sext i32 %7 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract12, i64 %9
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  call void %14(ptr %.fca.1.extract, { ptr } %3) #30
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract12)
  %16 = getelementptr i8, ptr %10, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %.fca.1.extract, i32 %4) #30
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract12)
  %21 = getelementptr i8, ptr %10, i64 24
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  call void %24(ptr %.fca.1.extract, i32 %5) #30
  ret void
}

define void @Array_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call i32 %11(ptr %.fca.1.extract) #31
  %.not = icmp sgt i32 %3, %12
  br i1 %.not, label %13, label %.loopexit

13:                                               ; preds = %4
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %15 = getelementptr i8, ptr %10, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %.fca.1.extract, i32 %3) #30
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %18 = getelementptr i8, ptr %8, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call { ptr } %20(ptr %.fca.1.extract) #31
  %.fca.0.extract56 = extractvalue { ptr } %21, 0
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %23 = load ptr, ptr %9, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call i32 %24(ptr %.fca.1.extract) #31
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %27 = load ptr, ptr %8, align 8
  %28 = call ptr @typegetter_wrapper(ptr %27, ptr %.fca.1.extract)
  %29 = sext i32 %25 to i64
  %30 = load ptr, ptr %28, align 8
  %31 = getelementptr i8, ptr %30, i64 72
  %32 = load ptr, ptr %31, align 8
  %33 = call { i64, i64 } @size_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %28)
  %34 = extractvalue { i64, i64 } %33, 0
  %35 = mul i64 %34, %29
  %36 = call ptr @bump_malloc(i64 %35)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %38 = load ptr, ptr %18, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %41 = insertvalue { ptr } undef, ptr %36, 0
  call void %40(ptr %.fca.1.extract, { ptr } %41) #30
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %43 = getelementptr i8, ptr %8, i64 16
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %13
  %.0 = phi i32 [ 0, %13 ], [ %.1, %._crit_edge ]
  %44 = load ptr, ptr %43, align 8
  %45 = load ptr, ptr %44, align 8
  %46 = call i32 %45(ptr %.fca.1.extract) #31
  %47 = icmp slt i32 %.0, %46
  br i1 %47, label %48, label %._crit_edge

48:                                               ; preds = %._crit_edge1
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %50 = load ptr, ptr %8, align 8
  %51 = call ptr @typegetter_wrapper(ptr %50, ptr %.fca.1.extract)
  %52 = sext i32 %.0 to i64
  %53 = load ptr, ptr %51, align 8
  %54 = getelementptr i8, ptr %53, i64 72
  %55 = load ptr, ptr %54, align 8
  %56 = call { i64, i64 } @size_wrapper(ptr %55, ptr noundef nonnull align 8 dereferenceable(8) %51)
  %57 = extractvalue { i64, i64 } %56, 0
  %58 = mul i64 %57, %52
  %59 = getelementptr i8, ptr %.fca.0.extract56, i64 %58
  %60 = load ptr, ptr %51, align 8
  %61 = getelementptr i8, ptr %60, i64 56
  %62 = load ptr, ptr %61, align 8
  %63 = call { ptr, i160 } @box_wrapper(ptr %62, ptr %59, ptr noundef nonnull align 8 dereferenceable(8) %51)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %65 = load ptr, ptr %18, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr } %66(ptr %.fca.1.extract) #31
  %.fca.0.extract39 = extractvalue { ptr } %67, 0
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %69 = load ptr, ptr %8, align 8
  %70 = call ptr @typegetter_wrapper(ptr %69, ptr %.fca.1.extract)
  %71 = load ptr, ptr %70, align 8
  %72 = getelementptr i8, ptr %71, i64 72
  %73 = load ptr, ptr %72, align 8
  %74 = call { i64, i64 } @size_wrapper(ptr %73, ptr noundef nonnull align 8 dereferenceable(8) %70)
  %75 = extractvalue { i64, i64 } %74, 0
  %76 = mul i64 %75, %52
  %77 = getelementptr i8, ptr %.fca.0.extract39, i64 %76
  %78 = load ptr, ptr %70, align 8
  %79 = getelementptr i8, ptr %78, i64 64
  %80 = load ptr, ptr %79, align 8
  call void @unbox_wrapper(ptr %80, { ptr, i160 } %63, ptr noundef nonnull align 8 dereferenceable(8) %70, ptr %77)
  %81 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %48, %._crit_edge1
  %.1 = phi i32 [ %81, %48 ], [ %.0, %._crit_edge1 ]
  br i1 %47, label %._crit_edge1, label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %4
  ret void
}

define void @Array_bounds_check_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca [4 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %13 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %15 = sext i32 %13 to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract, i64 %15
  %17 = getelementptr i8, ptr %16, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr %.fca.1.extract) #31
  %21 = add i32 %20, -1
  %22 = icmp sgt i32 %3, %21
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %24 = call i32 %19(ptr %.fca.1.extract) #31
  %25 = add i32 %24, %3
  %26 = icmp slt i32 %25, 0
  %.0 = select i1 %22, i1 true, i1 %26
  br i1 %.0, label %27, label %._crit_edge

27:                                               ; preds = %4
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %29 = call i32 %19(ptr %.fca.1.extract) #31
  store ptr @OutOfBounds, ptr %5, align 8
  %30 = load ptr, ptr getelementptr (i8, ptr @OutOfBounds, i64 48), align 8
  %31 = call { i64, i64 } @size_wrapper(ptr %30, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %32 = extractvalue { i64, i64 } %31, 0
  %33 = call ptr @bump_malloc(i64 %32)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %35 = load ptr, ptr %17, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %.fca.1.extract) #31
  %38 = insertvalue { ptr, ptr, ptr, i32 } { ptr @OutOfBounds, ptr undef, ptr undef, i32 undef }, ptr %33, 1
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr undef, 2
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 10, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %41 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef nonnull @OutOfBounds)
  %44 = load ptr, ptr getelementptr (i8, ptr @OutOfBounds, i64 120), align 8
  store ptr @i32_typ, ptr %7, align 8
  %45 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @i32_typ, ptr %45, align 8
  %46 = call ptr @behavior_wrapper(ptr %44, { ptr, ptr, ptr, i32 } %40, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %46({ ptr, ptr, ptr, i32 } %40, { ptr, ptr, ptr, i32 } %40, ptr nonnull %6, i32 %37, i32 %3)
  %47 = call ptr @bump_malloc(i64 noundef 57)
  store <56 x i8> <i8 67, i8 58, i8 47, i8 85, i8 115, i8 101, i8 114, i8 115, i8 47, i8 80, i8 97, i8 117, i8 108, i8 75, i8 47, i8 79, i8 110, i8 101, i8 68, i8 114, i8 105, i8 118, i8 101, i8 47, i8 68, i8 111, i8 99, i8 117, i8 109, i8 101, i8 110, i8 116, i8 115, i8 47, i8 80, i8 76, i8 47, i8 80, i8 121, i8 80, i8 76, i8 47, i8 108, i8 105, i8 98, i8 47, i8 97, i8 114, i8 114, i8 97, i8 121, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %47, align 1
  store ptr @String, ptr %8, align 8
  %48 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %49 = call { i64, i64 } @size_wrapper(ptr %48, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %50 = extractvalue { i64, i64 } %49, 0
  %51 = call ptr @bump_malloc(i64 %50)
  %52 = insertvalue { ptr } undef, ptr %47, 0
  %53 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %51, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr undef, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %9, align 8
  %56 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @_parameterization_i32, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_i32, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @_parameterization_i32, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %9)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %61 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  store ptr @buffer_typ, ptr %10, align 8
  %62 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr @i32_typ, ptr %62, align 8
  %63 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %10, i64 24
  store ptr @i32_typ, ptr %64, align 8
  %65 = call ptr @behavior_wrapper(ptr %61, { ptr, ptr, ptr, i32 } %55, ptr noundef nonnull align 8 dereferenceable(32) %10)
  call void %65({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull %9, { ptr } %52, i32 56, i32 56, i32 57)
  %66 = call i32 @get_offset(ptr noundef nonnull @String, ptr noundef nonnull @String)
  %67 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %66, 3
  store ptr @_parameterization_i32, ptr %11, align 8
  %68 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_core.String, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef nonnull @OutOfBounds)
  %71 = load ptr, ptr getelementptr (i8, ptr @OutOfBounds, i64 144), align 8
  store ptr @i32_typ, ptr %12, align 8
  %72 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @String, ptr %72, align 8
  %73 = call ptr @behavior_wrapper(ptr %71, { ptr, ptr, ptr, i32 } %40, ptr noundef nonnull align 8 dereferenceable(16) %12)
  call void %73({ ptr, ptr, ptr, i32 } %40, { ptr, ptr, ptr, i32 } %40, ptr nonnull %11, i32 99, { ptr, ptr, ptr, i32 } %67)
  %74 = ptrtoint ptr %33 to i64
  %.sroa.460.8.insert.ext = zext i64 %74 to i160
  %.sroa.460.8.insert.insert = or disjoint i160 %.sroa.460.8.insert.ext, 3402823669209384634633746074317682114560
  %75 = call ptr @get_current_coroutine()
  %76 = getelementptr i8, ptr %75, i64 48
  store ptr @OutOfBounds, ptr %76, align 8
  %77 = getelementptr i8, ptr %75, i64 56
  store i160 %.sroa.460.8.insert.insert, ptr %77, align 4
  call void @coroutine_yield_cold(ptr noundef align 8 %75)
  br label %._crit_edge

._crit_edge:                                      ; preds = %27, %4
  ret void
}

define { ptr, i160 } @Array_unchecked_index_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract12, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract12)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract12, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr } %11(ptr %.fca.1.extract13) #31
  %.fca.0.extract2 = extractvalue { ptr } %12, 0
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract12)
  %14 = load ptr, ptr %8, align 8
  %15 = call ptr @typegetter_wrapper(ptr %14, ptr %.fca.1.extract13)
  %16 = sext i32 %3 to i64
  %17 = load ptr, ptr %15, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %20 = call { i64, i64 } @size_wrapper(ptr %19, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %21 = extractvalue { i64, i64 } %20, 0
  %22 = mul i64 %21, %16
  %23 = getelementptr i8, ptr %.fca.0.extract2, i64 %22
  %24 = load ptr, ptr %15, align 8
  %25 = getelementptr i8, ptr %24, i64 56
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, i160 } @box_wrapper(ptr %26, ptr %23, ptr noundef nonnull align 8 dereferenceable(8) %15)
  ret { ptr, i160 } %27
}

define void @Array_unchecked_insert_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract14, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract14)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract14, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = call { ptr } %12(ptr %.fca.1.extract15) #31
  %.fca.0.extract = extractvalue { ptr } %13, 0
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract14)
  %15 = load ptr, ptr %9, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %.fca.1.extract15)
  %17 = sext i32 %3 to i64
  %18 = load ptr, ptr %16, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = mul i64 %22, %17
  %24 = getelementptr i8, ptr %.fca.0.extract, i64 %23
  %25 = load ptr, ptr %16, align 8
  %26 = getelementptr i8, ptr %25, i64 64
  %27 = load ptr, ptr %26, align 8
  call void @unbox_wrapper(ptr %27, { ptr, i160 } %4, ptr noundef nonnull align 8 dereferenceable(8) %16, ptr %24)
  ret void
}

define { ptr, ptr, ptr, i32 } @Array__Self_empty_(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = load ptr, ptr %0, align 8
  %4 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %3, ptr %5, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Array, ptr noundef nonnull align 8 dereferenceable(16) %4)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = call ptr @bump_malloc(i64 %7)
  store ptr %3, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %8, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array)
  %15 = call ptr @behavior_wrapper(ptr noundef nonnull @Array_B_init_, { ptr, ptr, ptr, i32 } %12, ptr noundef nonnull align 8 %2)
  call void %15({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull %2)
  %16 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(4312) @Array, ptr noundef nonnull @List)
  %17 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %16, 3
  ret { ptr, ptr, ptr, i32 } %17
}

define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterableT(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = alloca {}, align 8
  %.fca.0.extract47 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract48 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract47, ptr noundef nonnull @Iterable)
  %5 = call i32 @get_offset(ptr %.fca.0.extract47, ptr noundef nonnull @Iterable)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract47, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract48, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract49, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract47)
  %11 = sext i32 %.fca.3.extract32 to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract47, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = call ptr @typegetter_wrapper(ptr %13, ptr %.fca.1.extract48)
  %15 = alloca [1 x ptr], align 8
  store ptr %14, ptr %15, align 8
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef nonnull align 16 dereferenceable(4312) @Array)
  %18 = call ptr @class_behavior_wrapper(ptr noundef nonnull @Array_B__Self_empty_, ptr noundef nonnull align 8 %3)
  %19 = call { ptr, ptr, ptr, i32 } %18(ptr nonnull %15)
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %20 = call i32 @get_offset(ptr %.fca.0.extract21, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract22, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract23, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %20, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract47)
  %26 = load ptr, ptr %12, align 8
  %27 = call ptr @typegetter_wrapper(ptr %26, ptr %.fca.1.extract48)
  %28 = call ptr @bump_malloc(i64 noundef 24)
  %29 = getelementptr i8, ptr %28, i64 8
  store ptr %27, ptr %29, align 8
  %30 = getelementptr i8, ptr %28, i64 16
  store ptr null, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %28)
  store ptr @Iterable, ptr %28, align 8
  %32 = alloca [1 x ptr], align 8
  store ptr %28, ptr %32, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract21)
  %35 = sext i32 %20 to i64
  %36 = getelementptr ptr, ptr %.fca.0.extract21, i64 %35
  %37 = getelementptr i8, ptr %36, i64 152
  %38 = load ptr, ptr %37, align 8
  %39 = alloca { ptr }, align 8
  store ptr %.fca.0.extract47, ptr %39, align 8
  %40 = call ptr @behavior_wrapper(ptr %38, { ptr, ptr, ptr, i32 } %24, ptr noundef nonnull align 8 dereferenceable(8) %39)
  %41 = call { ptr, ptr, ptr, i32 } %40({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull %32, { ptr, ptr, ptr, i32 } %9)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %42 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %43 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @List)
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.1.extract, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.2.extract, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %43, 3
  ret { ptr, ptr, ptr, i32 } %47
}

define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract38 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract37, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %9 = sext i32 %7 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract37, i64 %9
  %11 = getelementptr i8, ptr %10, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = call i32 %13(ptr %.fca.1.extract38) #31
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %16 = getelementptr i8, ptr %10, i64 24
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call i32 %18(ptr %.fca.1.extract38) #31
  %.not = icmp slt i32 %14, %19
  br i1 %.not, label %._crit_edge, label %20

20:                                               ; preds = %4
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %22 = call i32 %18(ptr %.fca.1.extract38) #31
  %23 = shl i32 %22, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract37, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract38, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %7, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %30 = getelementptr i8, ptr %10, i64 72
  %31 = load ptr, ptr %30, align 8
  store ptr @i32_typ, ptr %6, align 8
  %32 = call ptr @behavior_wrapper(ptr %31, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 dereferenceable(8) %6)
  call void %32({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull %5, i32 %23)
  br label %._crit_edge

._crit_edge:                                      ; preds = %20, %4
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %34 = load ptr, ptr %11, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %.fca.1.extract38) #31
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %38 = getelementptr i8, ptr %10, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call { ptr } %40(ptr %.fca.1.extract38) #31
  %.fca.0.extract52 = extractvalue { ptr } %41, 0
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %43 = load ptr, ptr %10, align 8
  %44 = call ptr @typegetter_wrapper(ptr %43, ptr %.fca.1.extract38)
  %45 = sext i32 %36 to i64
  %46 = load ptr, ptr %44, align 8
  %47 = getelementptr i8, ptr %46, i64 72
  %48 = load ptr, ptr %47, align 8
  %49 = call { i64, i64 } @size_wrapper(ptr %48, ptr noundef nonnull align 8 dereferenceable(8) %44)
  %50 = extractvalue { i64, i64 } %49, 0
  %51 = mul i64 %50, %45
  %52 = getelementptr i8, ptr %.fca.0.extract52, i64 %51
  %53 = load ptr, ptr %44, align 8
  %54 = getelementptr i8, ptr %53, i64 64
  %55 = load ptr, ptr %54, align 8
  call void @unbox_wrapper(ptr %55, { ptr, i160 } %3, ptr noundef nonnull align 8 dereferenceable(8) %44, ptr %52)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %57 = load ptr, ptr %11, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call i32 %58(ptr %.fca.1.extract38) #31
  %60 = add i32 %59, 1
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract37)
  %62 = getelementptr i8, ptr %57, i64 8
  %63 = load ptr, ptr %62, align 8
  call void %63(ptr %.fca.1.extract38, i32 %60) #30
  %64 = call i32 @get_offset(ptr noundef %.fca.0.extract37, ptr noundef nonnull @List)
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract37, 0
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %.fca.1.extract38, 1
  %67 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %.fca.2.extract, 2
  %68 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %64, 3
  ret { ptr, ptr, ptr, i32 } %68
}

define { ptr, ptr, ptr, i32 } @Array_extend_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract58 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract60 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %8 = call i32 @get_offset(ptr %.fca.0.extract58, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %9 = call i32 @get_offset(ptr %.fca.0.extract25, ptr noundef nonnull @Collection)
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract58)
  %11 = sext i32 %8 to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract58, i64 %11
  %13 = getelementptr i8, ptr %12, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %.fca.1.extract59) #31
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract25, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract26, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract27, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %9, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract25)
  %23 = sext i32 %9 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract25, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = call ptr @behavior_wrapper(ptr %26, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 %5)
  %28 = call i32 %27({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %29 = add i32 %28, %16
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract58, 0
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.1.extract59, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.2.extract60, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %8, 3
  %34 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract58)
  %37 = getelementptr i8, ptr %12, i64 72
  %38 = load ptr, ptr %37, align 8
  %39 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %39, align 8
  %40 = call ptr @behavior_wrapper(ptr %38, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 dereferenceable(8) %39)
  call void %40({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull %34, i32 %29)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 472, ptr nocapture nofree noundef %.fca.0.extract25)
  %43 = getelementptr i8, ptr %24, i64 24
  %44 = load ptr, ptr %43, align 8
  %45 = call ptr @behavior_wrapper(ptr %44, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 %5)
  %46 = call { ptr, ptr, ptr, i32 } %45({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %46, 2
  %47 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Iterator)
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.1.extract, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.2.extract, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %47, 3
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract)
  %54 = sext i32 %47 to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract, i64 %54
  %56 = getelementptr i8, ptr %55, i64 8
  %57 = getelementptr inbounds i8, ptr %6, i64 8
  %58 = getelementptr i8, ptr %12, i64 96
  %59 = getelementptr inbounds i8, ptr %7, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %.0 = phi i32 [ 0, %4 ], [ %.1, %._crit_edge ]
  %60 = load ptr, ptr %56, align 8
  %61 = call ptr @behavior_wrapper(ptr %60, { ptr, ptr, ptr, i32 } %51, ptr noundef nonnull align 8 %5)
  %62 = call { ptr, i160 } %61({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull %5)
  %.fca.0.extract81 = extractvalue { ptr, i160 } %62, 0
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract58)
  %64 = load ptr, ptr %12, align 8
  %65 = call ptr @typegetter_wrapper(ptr %64, ptr %.fca.1.extract59)
  %66 = icmp ne ptr %.fca.0.extract81, @nil_typ
  %67 = icmp ne ptr %.fca.0.extract81, null
  %.not87 = and i1 %66, %67
  br i1 %.not87, label %68, label %._crit_edge

68:                                               ; preds = %._crit_edge1
  %69 = add i32 %.0, %16
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract58)
  %71 = load ptr, ptr %12, align 8
  %72 = call ptr @typegetter_wrapper(ptr %71, ptr %.fca.1.extract59)
  store ptr @_parameterization_i32, ptr %6, align 8
  store ptr %72, ptr %57, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract58)
  %75 = load ptr, ptr %58, align 8
  store ptr @i32_typ, ptr %7, align 8
  store ptr %.fca.0.extract81, ptr %59, align 8
  %76 = call ptr @behavior_wrapper(ptr %75, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %76({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull %6, i32 %69, { ptr, i160 } %62)
  %77 = add i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %68, %._crit_edge1
  %.1 = phi i32 [ %77, %68 ], [ %.0, %._crit_edge1 ]
  br i1 %.not87, label %._crit_edge1, label %78

78:                                               ; preds = %._crit_edge
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract58)
  %80 = load ptr, ptr %13, align 8
  %81 = getelementptr i8, ptr %80, i64 8
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %.fca.1.extract59, i32 %29) #30
  %83 = call i32 @get_offset(ptr noundef %.fca.0.extract58, ptr noundef nonnull @List)
  %84 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %83, 3
  ret { ptr, ptr, ptr, i32 } %84
}

define { ptr, ptr, ptr, i32 } @Array_indices_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  %12 = alloca [1 x ptr], align 8
  store ptr @Range, ptr %12, align 8
  %13 = load ptr, ptr getelementptr (i8, ptr @Range, i64 48), align 8
  %14 = call { i64, i64 } @size_wrapper(ptr %13, ptr noundef nonnull align 8 dereferenceable(8) %12)
  %15 = extractvalue { i64, i64 } %14, 0
  %16 = call ptr @bump_malloc(i64 %15)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %18 = load ptr, ptr %8, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i32 %19(ptr %.fca.1.extract) #31
  %21 = add i32 %20, -1
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Range, ptr undef, ptr undef, i32 undef }, ptr %16, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 10, 3
  %25 = alloca [2 x ptr], align 8
  store ptr @_parameterization_i32, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %25, i64 8
  store ptr @_parameterization_i32, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %25)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1016, ptr nocapture nofree noundef nonnull @Range)
  %29 = load ptr, ptr getelementptr (i8, ptr @Range, i64 120), align 8
  %30 = alloca { ptr, ptr }, align 8
  store ptr @i32_typ, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %30, i64 8
  store ptr @i32_typ, ptr %31, align 8
  %32 = call ptr @behavior_wrapper(ptr %29, { ptr, ptr, ptr, i32 } %24, ptr noundef nonnull align 8 dereferenceable(16) %30)
  call void %32({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull %25, i32 0, i32 %21)
  %33 = call i32 @get_offset(ptr noundef nonnull @Range, ptr noundef nonnull @Collection)
  %34 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %33, 3
  ret { ptr, ptr, ptr, i32 } %34
}

define { ptr, ptr, ptr, i32 } @Array_values_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %5 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull @Collection)
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %5, 3
  ret { ptr, ptr, ptr, i32 } %9
}

define { ptr, i160 } @Array__index_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %7 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %.fca.1.extract = extractvalue { ptr, i160 } %3, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract18, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %7, 3
  %12 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract17)
  %15 = sext i32 %7 to i64
  %16 = getelementptr ptr, ptr %.fca.0.extract17, i64 %15
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  %19 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %19, align 8
  %20 = call ptr @behavior_wrapper(ptr %18, { ptr, ptr, ptr, i32 } %11, ptr noundef nonnull align 8 dereferenceable(8) %19)
  call void %20({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull %12, i32 %.sroa.1.8.extract.trunc)
  %21 = icmp slt i32 %.sroa.1.8.extract.trunc, 0
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %4
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract17)
  %24 = getelementptr i8, ptr %16, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract18) #31
  %28 = add i32 %27, %.sroa.1.8.extract.trunc
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %4
  %.0 = phi i32 [ %28, %22 ], [ %.sroa.1.8.extract.trunc, %4 ]
  store ptr @_parameterization_i32, ptr %5, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract17)
  %31 = getelementptr i8, ptr %16, i64 88
  %32 = load ptr, ptr %31, align 8
  store ptr @i32_typ, ptr %6, align 8
  %33 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %11, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %34 = call { ptr, i160 } %33({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull %5, i32 %.0)
  ret { ptr, i160 } %34
}

define void @Array__set_index_indexi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #3 {
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %8 = call i32 @get_offset(ptr %.fca.0.extract25, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %.fca.1.extract8 = extractvalue { ptr, i160 } %3, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract8 to i32
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract25, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract26, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %8, 3
  %13 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract25)
  %16 = sext i32 %8 to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract25, i64 %16
  %18 = getelementptr i8, ptr %17, i64 80
  %19 = load ptr, ptr %18, align 8
  %20 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %20, align 8
  %21 = call ptr @behavior_wrapper(ptr %19, { ptr, ptr, ptr, i32 } %12, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %21({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull %13, i32 %.sroa.1.8.extract.trunc)
  %22 = icmp slt i32 %.sroa.1.8.extract.trunc, 0
  br i1 %22, label %23, label %._crit_edge

23:                                               ; preds = %5
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract25)
  %25 = getelementptr i8, ptr %17, i64 16
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract26) #31
  %29 = add i32 %28, %.sroa.1.8.extract.trunc
  br label %._crit_edge

._crit_edge:                                      ; preds = %23, %5
  %.0 = phi i32 [ %29, %23 ], [ %.sroa.1.8.extract.trunc, %5 ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract25)
  %31 = load ptr, ptr %17, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %.fca.1.extract26)
  store ptr @_parameterization_i32, ptr %6, align 8
  %33 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %32, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract25)
  %36 = getelementptr i8, ptr %17, i64 96
  %37 = load ptr, ptr %36, align 8
  store ptr @i32_typ, ptr %7, align 8
  %38 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.0.extract, ptr %38, align 8
  %39 = call ptr @behavior_wrapper(ptr %37, { ptr, ptr, ptr, i32 } %12, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %39({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull %6, i32 %.0, { ptr, i160 } %4)
  ret void
}

define i32 @Array_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = call i32 %10(ptr %.fca.1.extract) #31
  ret i32 %11
}

define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %6 = sext i32 %4 to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = call ptr @typegetter_wrapper(ptr %8, ptr %.fca.1.extract)
  %10 = alloca [2 x ptr], align 8
  store ptr @ArrayIterator, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %9, ptr %11, align 8
  %12 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ArrayIterator, ptr noundef nonnull align 8 dereferenceable(16) %10)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = call ptr @bump_malloc(i64 %13)
  store ptr %9, ptr %14, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %16 = call i32 @get_offset(ptr noundef %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %16, 3
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %14, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %.fca.0.extract)
  %25 = load ptr, ptr %7, align 8
  %26 = call ptr @typegetter_wrapper(ptr %25, ptr %.fca.1.extract)
  %27 = call ptr @bump_malloc(i64 noundef 24)
  %28 = getelementptr i8, ptr %27, i64 8
  store ptr %26, ptr %28, align 8
  %29 = getelementptr i8, ptr %27, i64 16
  store ptr null, ptr %29, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %27)
  store ptr @Array, ptr %27, align 8
  %31 = alloca [1 x ptr], align 8
  store ptr %27, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef nonnull align 16 dereferenceable(208) @ArrayIterator)
  %34 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %34, align 8
  %35 = call ptr @behavior_wrapper(ptr noundef nonnull @ArrayIterator_B_init_arrayArrayT, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 dereferenceable(8) %34)
  call void %35({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %31, { ptr, ptr, ptr, i32 } %20)
  %36 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(208) @ArrayIterator, ptr noundef nonnull @Iterator)
  %37 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define { ptr, ptr, ptr, i32 } @Array_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %4 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %5 = call ptr @bump_malloc(i64 noundef 6)
  store <5 x i8> <i8 65, i8 114, i8 114, i8 97, i8 121>, ptr %5, align 1
  %6 = alloca [1 x ptr], align 8
  store ptr @String, ptr %6, align 8
  %7 = load ptr, ptr getelementptr (i8, ptr @String, i64 48), align 8
  %8 = call { i64, i64 } @size_wrapper(ptr %7, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %9 = extractvalue { i64, i64 } %8, 0
  %10 = call ptr @bump_malloc(i64 %9)
  %11 = insertvalue { ptr } undef, ptr %5, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %10, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr undef, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 10, 3
  %15 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %15)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull @String)
  %21 = load ptr, ptr getelementptr (i8, ptr @String, i64 176), align 8
  %22 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %22, i64 8
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %22, i64 16
  store ptr @i32_typ, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %22, i64 24
  store ptr @i32_typ, ptr %25, align 8
  %26 = call ptr @behavior_wrapper(ptr %21, { ptr, ptr, ptr, i32 } %14, ptr noundef nonnull align 8 dereferenceable(32) %22)
  call void %26({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull %15, { ptr } %11, i32 5, i32 5, i32 6)
  %27 = call i32 @get_offset(ptr noundef nonnull @String, ptr noundef nonnull @String)
  %28 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %27, 3
  ret { ptr, ptr, ptr, i32 } %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef -5261542750394134544, i64 noundef ptrtoint (ptr @Array to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 120
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract17, ptr noundef nonnull align 16 dereferenceable(208) @ArrayIterator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract17)
  %9 = sext i32 %5 to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract17, i64 %9
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %7, 3
  call void %14(ptr %.fca.1.extract18, { ptr, ptr, ptr, i32 } %18) #30
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract17)
  %20 = getelementptr i8, ptr %10, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  call void %23(ptr %.fca.1.extract18, i32 0) #30
  ret void
}

define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %8 = call i32 @get_offset(ptr %.fca.0.extract29, ptr noundef nonnull align 16 dereferenceable(208) @ArrayIterator)
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract29)
  %10 = sext i32 %8 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract29, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = call i32 %14(ptr %.fca.1.extract31) #31
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract29)
  %17 = getelementptr i8, ptr %11, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr, ptr, ptr, i32 } %19(ptr %.fca.1.extract31) #31
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  store ptr %.fca.0.extract, ptr %21, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %21, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %21, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %21, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %22, 0
  %24 = load ptr, ptr %.fca.1.gep, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 1
  %26 = load ptr, ptr %.fca.2.gep, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %26, 2
  %28 = load i32, ptr %.fca.3.gep, align 8
  %29 = insertvalue { ptr, ptr, ptr, i32 } %27, i32 %28, 3
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %22)
  %32 = sext i32 %28 to i64
  %33 = getelementptr ptr, ptr %22, i64 %32
  %34 = getelementptr i8, ptr %33, i64 128
  %35 = load ptr, ptr %34, align 8
  %36 = call ptr @behavior_wrapper(ptr %35, { ptr, ptr, ptr, i32 } %29, ptr noundef nonnull align 8 %4)
  %37 = call i32 %36({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull %4)
  %.not = icmp slt i32 %15, %37
  br i1 %.not, label %38, label %69

38:                                               ; preds = %3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract29)
  %40 = load ptr, ptr %12, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr %.fca.1.extract31) #31
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract29)
  %44 = call i32 %41(ptr %.fca.1.extract31) #31
  %45 = add i32 %44, 1
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract29)
  %47 = getelementptr i8, ptr %40, i64 8
  %48 = load ptr, ptr %47, align 8
  call void %48(ptr %.fca.1.extract31, i32 %45) #30
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 128, ptr nocapture nofree noundef %.fca.0.extract29)
  %50 = load ptr, ptr %17, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = call { ptr, ptr, ptr, i32 } %51(ptr %.fca.1.extract31) #31
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  store ptr %.fca.0.extract45, ptr %5, align 8
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %52, 1
  %.fca.1.gep48 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract47, ptr %.fca.1.gep48, align 8
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %52, 2
  %.fca.2.gep50 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract49, ptr %.fca.2.gep50, align 8
  %.fca.3.extract51 = extractvalue { ptr, ptr, ptr, i32 } %52, 3
  %.fca.3.gep52 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract51, ptr %.fca.3.gep52, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(4312) @Array)
  %53 = load ptr, ptr %5, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %53, 0
  %55 = load ptr, ptr %.fca.1.gep48, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 1
  %57 = load ptr, ptr %.fca.2.gep50, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 2
  %59 = load i32, ptr %.fca.3.gep52, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %59, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 4232, ptr nocapture nofree noundef %53)
  %63 = sext i32 %59 to i64
  %64 = getelementptr ptr, ptr %53, i64 %63
  %65 = getelementptr i8, ptr %64, i64 88
  %66 = load ptr, ptr %65, align 8
  store ptr @i32_typ, ptr %7, align 8
  %67 = call ptr @behavior_wrapper(ptr %66, { ptr, ptr, ptr, i32 } %60, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %68 = call { ptr, i160 } %67({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull %6, i32 %42)
  %.fca.0.extract39 = extractvalue { ptr, i160 } %68, 0
  %.fca.1.extract41 = extractvalue { ptr, i160 } %68, 1
  br label %69

69:                                               ; preds = %38, %3
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract39, %38 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract41, %38 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBounds(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 136, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @OutOfBounds_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 176
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %13)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 192
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @OutOfBounds_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %7 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(328) @OutOfBounds)
  %8 = alloca [1 x ptr], align 8
  store ptr @OutOfBoundsDetails, ptr %8, align 8
  %9 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_OutOfBoundsDetails, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = call ptr @bump_malloc(i64 %10)
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @OutOfBoundsDetails, ptr undef, ptr undef, i32 undef }, ptr %11, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr undef, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 10, 3
  %15 = alloca [2 x ptr], align 8
  store ptr @_parameterization_i32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %15)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %19 = alloca { ptr, ptr }, align 8
  store ptr @i32_typ, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr @i32_typ, ptr %20, align 8
  %21 = call ptr @behavior_wrapper(ptr noundef nonnull @OutOfBoundsDetails_B_init_boundsi32_indexi32, { ptr, ptr, ptr, i32 } %14, ptr noundef nonnull align 8 dereferenceable(16) %19)
  call void %21({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull %15, i32 %3, i32 %4)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef %.fca.0.extract)
  %23 = sext i32 %7 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = ptrtoint ptr %11 to i64
  %.sroa.3.8.insert.ext = zext i64 %28 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %29 = insertvalue { ptr, i160 } { ptr @OutOfBoundsDetails, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  call void %27(ptr %.fca.1.extract, { ptr, i160 } %29) #30
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef %.fca.0.extract)
  %31 = getelementptr i8, ptr %24, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %.fca.1.extract, i32 0) #30
  %35 = call ptr @bump_malloc(i64 noundef 1)
  %36 = alloca [1 x ptr], align 8
  store ptr @String, ptr %36, align 8
  %37 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %36)
  %38 = extractvalue { i64, i64 } %37, 0
  %39 = call ptr @bump_malloc(i64 %38)
  %40 = insertvalue { ptr } undef, ptr %35, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %39, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr undef, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 10, 3
  %44 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %44, i64 8
  store ptr @_parameterization_i32, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 16
  store ptr @_parameterization_i32, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %44, i64 24
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %44)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %50 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %50, align 8
  %51 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr @i32_typ, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr @i32_typ, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %50, i64 24
  store ptr @i32_typ, ptr %53, align 8
  %54 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 dereferenceable(32) %50)
  call void %54({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull %44, { ptr } %40, i32 0, i32 0, i32 1)
  %55 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef %.fca.0.extract)
  %57 = getelementptr i8, ptr %24, i64 16
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %55, 3
  call void %60(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %61) #30
  %62 = call ptr @bump_malloc(i64 noundef 66)
  store <65 x i8> <i8 65, i8 110, i8 32, i8 111, i8 117, i8 116, i8 45, i8 111, i8 102, i8 45, i8 98, i8 111, i8 117, i8 110, i8 100, i8 115, i8 32, i8 101, i8 114, i8 114, i8 111, i8 114, i8 32, i8 111, i8 99, i8 99, i8 117, i8 114, i8 114, i8 101, i8 100, i8 32, i8 119, i8 104, i8 105, i8 108, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 116, i8 111, i8 32, i8 97, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 46>, ptr %62, align 1
  %63 = alloca [1 x ptr], align 8
  store ptr @String, ptr %63, align 8
  %64 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %63)
  %65 = extractvalue { i64, i64 } %64, 0
  %66 = call ptr @bump_malloc(i64 %65)
  %67 = insertvalue { ptr } undef, ptr %62, 0
  %68 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %66, 1
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr undef, 2
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, i32 10, 3
  %71 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %71, i64 8
  store ptr @_parameterization_i32, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %71, i64 16
  store ptr @_parameterization_i32, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %71, i64 24
  store ptr @_parameterization_i32, ptr %74, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %77 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %77, i64 8
  store ptr @i32_typ, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %77, i64 16
  store ptr @i32_typ, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %77, i64 24
  store ptr @i32_typ, ptr %80, align 8
  %81 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %70, ptr noundef nonnull align 8 dereferenceable(32) %77)
  call void %81({ ptr, ptr, ptr, i32 } %70, { ptr, ptr, ptr, i32 } %70, ptr nonnull %71, { ptr } %67, i32 65, i32 65, i32 66)
  %82 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(2592) @String, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef %.fca.0.extract)
  %84 = getelementptr i8, ptr %24, i64 24
  %85 = load ptr, ptr %84, align 8
  %86 = getelementptr i8, ptr %85, i64 8
  %87 = load ptr, ptr %86, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %69, i32 %82, 3
  call void %87(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %88) #30
  %89 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %89, align 8
  %90 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Stacktrace, ptr noundef nonnull align 8 dereferenceable(8) %89)
  %91 = extractvalue { i64, i64 } %90, 0
  %92 = call ptr @bump_malloc(i64 %91)
  %93 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Stacktrace, ptr undef, ptr undef, i32 undef }, ptr %92, 1
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr undef, 2
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, i32 10, 3
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %98 = call ptr @behavior_wrapper(ptr noundef nonnull @Stacktrace_B_init_, { ptr, ptr, ptr, i32 } %95, ptr noundef nonnull align 8 %6)
  call void %98({ ptr, ptr, ptr, i32 } %95, { ptr, ptr, ptr, i32 } %95, ptr nonnull %6)
  %99 = call i32 @get_offset(ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace, ptr noundef nonnull align 16 dereferenceable(128) @Stacktrace)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef %.fca.0.extract)
  %101 = getelementptr i8, ptr %24, i64 32
  %102 = load ptr, ptr %101, align 8
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %105 = insertvalue { ptr, ptr, ptr, i32 } %94, i32 %99, 3
  call void %104(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %105) #30
  ret void
}

define void @OutOfBounds_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract14, ptr noundef nonnull align 16 dereferenceable(328) @OutOfBounds)
  %6 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef %.fca.0.extract14)
  %7 = sext i32 %5 to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract14, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract16) #31
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  store ptr %.fca.0.extract5, ptr %13, align 8
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract6, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(2592) @String)
  %14 = load ptr, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %16 = load ptr, ptr %.fca.1.gep, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %16, 1
  %18 = load ptr, ptr %.fca.2.gep, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 2
  %20 = load i32, ptr %.fca.3.gep, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %20, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef %14)
  %24 = sext i32 %20 to i64
  %25 = getelementptr ptr, ptr %14, i64 %24
  %26 = getelementptr i8, ptr %25, i64 104
  %27 = load ptr, ptr %26, align 8
  %28 = call ptr @behavior_wrapper(ptr %27, { ptr, ptr, ptr, i32 } %21, ptr noundef nonnull align 8 %4)
  %29 = call { ptr } %28({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4)
  %.fca.0.extract3 = extractvalue { ptr } %29, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract3) #40
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 248, ptr nocapture nofree noundef %.fca.0.extract14)
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, i160 } %32(ptr %.fca.1.extract16) #31
  %.fca.0.extract = extractvalue { ptr, i160 } %33, 0
  %34 = icmp ne ptr %.fca.0.extract, @nil_typ
  %35 = icmp ne ptr %.fca.0.extract, null
  %.not41 = and i1 %34, %35
  br i1 %.not41, label %36, label %._crit_edge

36:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %33, 1
  %.sroa.3.0.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.3.0.extract.trunc = trunc i160 %.sroa.3.0.extract.shift to i64
  %.sroa.039.0.extract.trunc = trunc i160 %.fca.1.extract to i64
  %37 = inttoptr i64 %.sroa.039.0.extract.trunc to ptr
  %38 = inttoptr i64 %.sroa.3.0.extract.trunc to ptr
  %39 = call i32 @get_offset(ptr nonnull %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %37, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %38, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %39, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %46 = sext i32 %39 to i64
  %47 = getelementptr ptr, ptr %.fca.0.extract, i64 %46
  %48 = getelementptr i8, ptr %47, i64 24
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @behavior_wrapper(ptr %49, { ptr, ptr, ptr, i32 } %43, ptr noundef nonnull align 8 %4)
  call void %50({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull %4)
  br label %._crit_edge

._crit_edge:                                      ; preds = %36, %3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBoundsDetails(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @OutOfBoundsDetails_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %6 = call i32 @get_offset(ptr %.fca.0.extract, ptr noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract)
  %8 = sext i32 %6 to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  call void %12(ptr %.fca.1.extract, i32 %3) #30
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %.fca.1.extract, i32 %4) #30
  ret void
}

define void @OutOfBoundsDetails_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %5 = call i32 @get_offset(ptr %.fca.0.extract49, ptr noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %6 = call ptr @bump_malloc(i64 noundef 45)
  store <44 x i8> <i8 84, i8 104, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 32, i8 111, i8 102, i8 32, i8 116, i8 104, i8 101, i8 32, i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 32, i8 98, i8 101, i8 105, i8 110, i8 103, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 101, i8 100, i8 32, i8 119, i8 97, i8 115>, ptr %6, align 1
  %7 = alloca [1 x ptr], align 8
  store ptr @String, ptr %7, align 8
  %8 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %9 = extractvalue { i64, i64 } %8, 0
  %10 = call ptr @bump_malloc(i64 %9)
  %11 = insertvalue { ptr } undef, ptr %6, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %10, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr undef, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 10, 3
  %15 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %15)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %21 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr @i32_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %14, ptr noundef nonnull align 8 dereferenceable(32) %21)
  call void %25({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull %15, { ptr } %11, i32 44, i32 44, i32 45)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %28 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %14, ptr noundef nonnull align 8 %4)
  %29 = call { ptr } %28({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull align 8 %4)
  %.fca.0.extract20 = extractvalue { ptr } %29, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract20) #40
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract49)
  %31 = sext i32 %5 to i64
  %32 = getelementptr ptr, ptr %.fca.0.extract49, i64 %31
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call i32 %34(ptr %.fca.1.extract) #31
  %36 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %35) #40
  %37 = call ptr @bump_malloc(i64 noundef 26)
  store <25 x i8> <i8 84, i8 104, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 97, i8 114, i8 103, i8 117, i8 109, i8 101, i8 110, i8 116, i8 32, i8 119, i8 97, i8 115>, ptr %37, align 1
  %38 = alloca [1 x ptr], align 8
  store ptr @String, ptr %38, align 8
  %39 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %38)
  %40 = extractvalue { i64, i64 } %39, 0
  %41 = call ptr @bump_malloc(i64 %40)
  %42 = insertvalue { ptr } undef, ptr %37, 0
  %43 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %41, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr undef, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 10, 3
  %46 = alloca [4 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr @_parameterization_i32, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %46)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %52 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @i32_typ, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 16
  store ptr @i32_typ, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %52, i64 24
  store ptr @i32_typ, ptr %55, align 8
  %56 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %45, ptr noundef nonnull align 8 dereferenceable(32) %52)
  call void %56({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull %46, { ptr } %42, i32 25, i32 25, i32 26)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2512, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2592) @String)
  %59 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %45, ptr noundef nonnull align 8 %4)
  %60 = call { ptr } %59({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr } %60, 0
  %puts51 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #40
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract49)
  %62 = getelementptr i8, ptr %32, i64 8
  %63 = load ptr, ptr %62, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = call i32 %64(ptr %.fca.1.extract) #31
  %66 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %65) #40
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_bounds(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_bounds(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 104
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 112
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 120
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 128
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 104
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 112
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 120
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 128
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_message(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_file_name(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBounds_getter_line_number(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_line_number(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @OutOfBounds_getter_details(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, i160 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load i160, ptr %4, align 8
  %6 = insertvalue { ptr, i160 } %3, i160 %5, 1
  ret { ptr, i160 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_details(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, i160 } %1) #7 {
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store i160 %.fca.1.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

define void @report_exception({ ptr } %0) #3 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %.fca.0.extract2, i64 56
  %6 = load i160, ptr %5, align 4
  %7 = getelementptr i8, ptr %4, i64 8
  %8 = getelementptr i8, ptr %4, i64 16
  %9 = getelementptr i8, ptr %4, i64 24
  %10 = getelementptr i8, ptr %4, i64 32
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 noundef 9027164862567808692, i64 noundef ptrtoint (ptr @Exception to i64), ptr %14)
  br i1 %15, label %16, label %._crit_edge

16:                                               ; preds = %1
  %.sroa.4.sroa.3.0.extract.shift = lshr i160 %6, 64
  %.sroa.4.sroa.3.0.extract.trunc = trunc i160 %.sroa.4.sroa.3.0.extract.shift to i64
  %.sroa.4.sroa.0.0.extract.trunc = trunc i160 %6 to i64
  %17 = inttoptr i64 %.sroa.4.sroa.0.0.extract.trunc to ptr
  %18 = inttoptr i64 %.sroa.4.sroa.3.0.extract.trunc to ptr
  %19 = call i32 @get_offset(ptr noundef align 8 %4, ptr noundef nonnull align 16 dereferenceable(192) @Exception)
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %4, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %17, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %18, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %19, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef align 8 %4)
  %26 = sext i32 %19 to i64
  %27 = getelementptr ptr, ptr %4, i64 %26
  %28 = getelementptr i8, ptr %27, i64 56
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr @behavior_wrapper(ptr %29, { ptr, ptr, ptr, i32 } %23, ptr noundef nonnull align 8 %2)
  call void %30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %2)
  br label %._crit_edge

._crit_edge:                                      ; preds = %16, %1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #1 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "disable-tail-calls"="true" }
attributes #2 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #3 = { "disable-tail-calls"="true" }
attributes #4 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #7 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "disable-tail-calls"="true" }
attributes #8 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #9 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #10 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) }
attributes #11 = { alwaysinline }
attributes #12 = { nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #13 = { alwaysinline mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #14 = { mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #15 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #16 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #17 = { noinline }
attributes #18 = { noreturn nounwind }
attributes #19 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #20 = { nocallback nofree nosync nounwind willreturn }
attributes #21 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #22 = { noinline nounwind memory(readwrite) }
attributes #23 = { cold noinline }
attributes #24 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #25 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #26 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #27 = { nofree nounwind }
attributes #28 = { nofree nounwind "disable-tail-calls"="true" }
attributes #29 = { nofree willreturn }
attributes #30 = { nounwind willreturn memory(argmem: readwrite) }
attributes #31 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #32 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #33 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #34 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #35 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #36 = { mustprogress nofree nosync nounwind willreturn }
attributes #37 = { mustprogress nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #38 = { nounwind memory(readwrite) }
attributes #39 = { nofree }
attributes #40 = { nounwind }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i64 8, i64 0}
